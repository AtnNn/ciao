<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 10 November 2000 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - Low-level concurrency/multithreading primitives</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_81.html">previous</A>, <A HREF="ciao_83.html">next</A>, <A HREF="ciao_175.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC340" HREF="ciao_toc.html#TOC340">Low-level concurrency/multithreading primitives</A></H1>
<P>
<A NAME="IDX3907"></A>


<P>
<STRONG>Author(s):</STRONG> Manuel Carro.


<P>
<STRONG>Version:</STRONG> 1.5#171 (2000/7/7, 16:10:17 CEST)


<P>
<STRONG>Version of last change:</STRONG> 1.5#145 (2000/5/18, 16:13:40 CEST)


<P>
This module provides basic mechanisms for using concurrency and implementing multi-goal applications.
<A NAME="IDX3908"></A>
<A NAME="IDX3909"></A>
It provides a means for arbitrary goals to be specified to be run in a separate stack set; in that case, they are assigned a goal identifier with which further accesses (e.g., asking for more solutions) to the goal can be made. Additionally, in some architectures, these goals can be assigned an O.S. thread, separate from the one which made the initial call, thus providing concurrency and, in multiprocessors, parallelism capabilities. 


<P>
As for now, the memory space of the threads (c.f., stack sets) is separate in the sense that goals are copied to the new stack set, and bindings of variables are not seen among stack sets which allows forward and backward execution to proceed independently in each stack set, at the cost of the initial goal copy. However, the program space (including, specially, the 
<A NAME="IDX3910"></A>
concurrent predicates) are shared and seen by all the goals and threads, and should be used as the primary means of communication and synchronization. Higer level libraries can be built using these basic blocks. 


<P>
Additionally, a small set of lock primitives are provided. Locks are associated with atom names. Whereas the concurrent database facilities are enough to implement locks, semaphores, messages, etc., the predicates implementing atom-based locks are faster than the ones accessing the concurrent database (but they are less powerful). 



<UL>
<LI><A HREF="ciao_82.html#SEC341">Usage and interface (concurrency)</A>
<LI><A HREF="ciao_82.html#SEC342">Documentation on exports (concurrency)</A>
<LI><A HREF="ciao_82.html#SEC343">Known bugs and planned improvements (concurrency)</A>
</UL>



<H2><A NAME="SEC341" HREF="ciao_toc.html#TOC341">Usage and interface (<CODE>concurrency</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

These predicates are builtin in Ciao, so nothing special has to be done to use them.

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX3911"></A>
<CODE>eng_call/4</CODE>, 
<A NAME="IDX3912"></A>
<CODE>eng_call/3</CODE>, 
<A NAME="IDX3913"></A>
<CODE>eng_backtrack/2</CODE>, 
<A NAME="IDX3914"></A>
<CODE>eng_cut/1</CODE>, 
<A NAME="IDX3915"></A>
<CODE>eng_release/1</CODE>, 
<A NAME="IDX3916"></A>
<CODE>eng_wait/1</CODE>, 
<A NAME="IDX3917"></A>
<CODE>eng_kill/1</CODE>, 
<A NAME="IDX3918"></A>
<CODE>eng_killothers/0</CODE>, 
<A NAME="IDX3919"></A>
<CODE>eng_self/1</CODE>, 
<A NAME="IDX3920"></A>
<CODE>eng_status/0</CODE>, 
<A NAME="IDX3921"></A>
<CODE>lock_atom/1</CODE>, 
<A NAME="IDX3922"></A>
<CODE>unlock_atom/1</CODE>, 
<A NAME="IDX3923"></A>
<CODE>atom_lock_state/2</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC342" HREF="ciao_toc.html#TOC342">Documentation on exports (<CODE>concurrency</CODE>)</A></H2>
<P>
<A NAME="IDX3924"></A>
<A NAME="IDX3925"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>eng_call/4:</B>
<DD><A NAME="IDX3926"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>eng_call(goal,?,?,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>eng_call(+Goal,+EngineCreation,+ThreadCreation,-GoalId)</CODE>

<UL>
<LI><EM>Description:</EM> Calls <CODE>Goal</CODE> in a new engine (stack set), possibly using a new thread, and returns a <CODE>GoalId</CODE> to designate this new goal henceforth. <CODE>EngineCreation</CODE> can be either <CODE>wait</CODE> or <CODE>create</CODE>; the distinction is not yet meaningful. <CODE>ThreadCreation</CODE> can be one of <CODE>self</CODE>, <CODE>wait</CODE>, or <CODE>create</CODE>. In the first case the creating thread is used to execute <CODE>Goal</CODE>, and thus it has to wait until its first result or failure. The call will fail if <CODE>Goal</CODE> fails, and succeed otherwise. However, the call will always suceed when a remote thread is started. The space and identifiers reclaimed for the thread must be explicitly deallocated by calling

<A NAME="IDX3927"></A>
<CODE>eng_release/1</CODE>. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>+Goal</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)

<CODE>+EngineCreation</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+ThreadCreation</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>-GoalId</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3928"></A>
<A NAME="IDX3929"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>eng_call/3:</B>
<DD><A NAME="IDX3930"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>eng_call(goal,?,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>eng_call(+Goal,+EngineCreation,+ThreadCreation)</CODE>

<UL>
<LI><EM>Description:</EM> Similar to

<A NAME="IDX3931"></A>
<CODE>eng_call/4</CODE>, but the thread (if created) and stack areas are automatically released upon success or failure of the goal. No <CODE>GoalId</CODE> is provided for further interaction with the goal. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>+Goal</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)

<CODE>+EngineCreation</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+ThreadCreation</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3932"></A>
<A NAME="IDX3933"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>eng_backtrack/2:</B>
<DD><A NAME="IDX3934"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>eng_backtrack(+GoalId,+ThreadCreation)</CODE>

<UL>
<LI><EM>Description:</EM> Performs backtracking on the goal designed by <CODE>GoalId</CODE>. A new thread can be used to perform backtracking, according to <CODE>ThreadCreation</CODE> (same as in

<A NAME="IDX3935"></A>
<CODE>eng_call/4</CODE>). Fails if the goal is backtracked over by the local thread, and there are no more solutions. Always succeeds if executed by a remote thread. The engine is <STRONG>not</STRONG> automatically released up upon failure: 
<A NAME="IDX3936"></A>
<CODE>eng_release/1</CODE> must be called to that end. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>+GoalId</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)

<CODE>+ThreadCreation</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3937"></A>
<A NAME="IDX3938"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>eng_cut/1:</B>
<DD><A NAME="IDX3939"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>eng_cut(+GoalId)</CODE>

<UL>
<LI><EM>Description:</EM> Performs a <EM>cut</EM> in the execution of the goal <CODE>GoalId</CODE>. The next call to

<A NAME="IDX3940"></A>
<CODE>eng_backtrack/2</CODE> will therefore backtrack all the way and fail. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>+GoalId</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3941"></A>
<A NAME="IDX3942"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>eng_release/1:</B>
<DD><A NAME="IDX3943"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>eng_release(+GoalId)</CODE>

<UL>
<LI><EM>Description:</EM> Cleans up and releases the engine executing the goal designed by <CODE>GoalId</CODE>. The engine must be idle, i.e., currently not exedcuting any goal.

<A NAME="IDX3944"></A>
<CODE>eng_wait/1</CODE> can be used to ensure this. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>+GoalId</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3945"></A>
<A NAME="IDX3946"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>eng_wait/1:</B>
<DD><A NAME="IDX3947"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>eng_wait(+GoalId)</CODE>

<UL>
<LI><EM>Description:</EM> Waits for the engine executing the goal denoted by <CODE>GoalId</CODE> to finish the computation (i.e., it has finished searching for a solution, either with success or failure).

<LI><EM>The following properties should hold at call time:</EM>

<CODE>+GoalId</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3948"></A>
<A NAME="IDX3949"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>eng_kill/1:</B>
<DD><A NAME="IDX3950"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>eng_kill(+GoalId)</CODE>

<UL>
<LI><EM>Description:</EM> Kills the thread executing <CODE>GoalId</CODE> (if any), and frees the memory used up by the stack set. Usually one should wait (

<A NAME="IDX3951"></A>
<CODE>eng_wait/1</CODE>) for a goal, and then release it, but killing the thread explicitly allows recovering from error states. A goal cannot kill itself. This feature should be used with caution, because there are situations where killing a thread might render the system in an unstable state. Threads should cooperate in their killing, but if the killed thread is blocked in a I/O operation, or inside an internal critical region, this cooperation is not possible and the system, although stopped, might very well end up in a incosistent state. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>+GoalId</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3952"></A>
<A NAME="IDX3953"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>eng_killothers/0:</B>
<DD><A NAME="IDX3954"></A>


<P>
<STRONG>Usage:</STRONG> 

<UL>
<LI><EM>Description:</EM> Kills threads and releases stack sets of all active goals, but the one calling

<A NAME="IDX3955"></A>
<CODE>eng_killothers</CODE>. Again, a safety measure. The same cautions as with 
<A NAME="IDX3956"></A>
<CODE>eng_kill/1</CODE> should be taken. 
</UL>

</DL>

<P>
<A NAME="IDX3957"></A>
<A NAME="IDX3958"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>eng_self/1:</B>
<DD><A NAME="IDX3959"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>eng_self(?GoalId)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>GoalId</CODE> is unified with the identifier of the goal within which

<A NAME="IDX3960"></A>
<CODE>eng_self/1</CODE> is executed. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>?GoalId</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3961"></A>
<A NAME="IDX3962"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>eng_status/0:</B>
<DD><A NAME="IDX3963"></A>


<P>
<STRONG>Usage:</STRONG> 

<UL>
<LI><EM>Description:</EM> Prints to standard output the current status of the stack sets.

</UL>

</DL>

<P>
<A NAME="IDX3964"></A>
<A NAME="IDX3965"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>lock_atom/1:</B>
<DD><A NAME="IDX3966"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>lock_atom(+Atom)</CODE>

<UL>
<LI><EM>Description:</EM> The

<A NAME="IDX3967"></A>
semaphore associated to <CODE>Atom</CODE> is accessed; if its value is nonzero, it is atomically decremented and the execution of this thread proceeds. Otherwise, the goal waits until a nonzero value is reached. The semaphore is then atomically decremented and the execution of this thread proceeds. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>+Atom</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3968"></A>
<A NAME="IDX3969"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>unlock_atom/1:</B>
<DD><A NAME="IDX3970"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>unlock_atom(+Atom)</CODE>

<UL>
<LI><EM>Description:</EM> The

<A NAME="IDX3971"></A>
semaphore associated to <CODE>Atom</CODE> is atomically incremented. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>+Atom</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3972"></A>
<A NAME="IDX3973"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>atom_lock_state/2:</B>
<DD><A NAME="IDX3974"></A>


<P>
<STRONG>Usage 1:</STRONG> <CODE>atom_lock_state(+Atom,+Value)</CODE>

<UL>
<LI><EM>Description:</EM> Sets the semaphore associated to <CODE>Atom</CODE> to <CODE>Value</CODE>. This is usually done at the beginning of the execution, but can be executed at any time. If not called, semaphore associated to atoms are by default inited to 1. It should be used with caution: arbitrary use can transform programs using locks in a mess of internal relations. The change of a semaphore value in a place other than the initialization stage of a program is <STRONG>not</STRONG> among the allowed operations as defined by Dijkstra [Dij65,BA82].

<LI><EM>The following properties should hold at call time:</EM>

<CODE>+Atom</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+Value</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>atom_lock_state(+Atom,-Value)</CODE>

<UL>
<LI><EM>Description:</EM> Consults the <CODE>Value</CODE> of the semaphore associated to <CODE>Atom</CODE>. Use sparingly and mainly as a medium to check state correctness. Not among the operations on semaphore by Djikstra.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>+Atom</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>-Value</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)
</UL>

</DL>



<H2><A NAME="SEC343" HREF="ciao_toc.html#TOC343">Known bugs and planned improvements (<CODE>concurrency</CODE>)</A></H2>


<UL>

<LI>

<STRONG>This library is being rewritten at the moment. The Prolog interface herein described may not correspond exactly with the existing implementation. This note will be removed when the documentation corresponds to the implementation.</STRONG>

<LI>

Available architectures implementing POSIX threads and in Windows 32 environments.

<LI>

Some implementation of threads have a limit on the total number of threads that can be created by a process. Thread creation, in this case, just hangs. A better solution is planned for the future.
</UL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_81.html">previous</A>, <A HREF="ciao_83.html">next</A>, <A HREF="ciao_175.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
