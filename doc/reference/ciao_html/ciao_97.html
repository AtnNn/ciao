<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 26 January 2000 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - Declaring classes and interfaces</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_96.html">previous</A>, <A HREF="ciao_98.html">next</A>, <A HREF="ciao_148.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC335" HREF="ciao_toc.html#TOC335">Declaring classes and interfaces</A></H1>
<P>
<A NAME="IDX3591"></A>


<P>
<STRONG>Author(s):</STRONG> Angel Fernandez Pineda.


<P>
<STRONG>Version:</STRONG> 1.5#9 (1999/12/9, 21:57:42 MET)


<P>
<STRONG>Version of last change:</STRONG> 1.5#3 (1999/11/29, 18:6:27 MET)


<P>
O'CIAO classes are declared in the same way as traditional prolog modules. The general mechanism of <EM>source expansion</EM> will translate object-oriented declarations to normal prolog code. This is done transparently to the user. 


<P>
Abstract 
<A NAME="IDX3592"></A>
<A NAME="IDX3593"></A>
<EM>interfaces</EM> are restricted classes which declare exported predicates with no implementation. The implementation itselt will be provided by some class using an 
<A NAME="IDX3594"></A>
<CODE>implements/1</CODE> declaration. Only 
<A NAME="IDX3595"></A>
<CODE>export/1</CODE> and 
<A NAME="IDX3596"></A>
<CODE>data/1</CODE> declarations are allowed when declaring an interface. Normal classes may treated as interfaces just ignoring all exported predicate implementations. 



<UL>
<LI><A HREF="ciao_97.html#SEC336">Usage and interface (class)</A>
<LI><A HREF="ciao_97.html#SEC337">Documentation on new declarations (class)</A>
<LI><A HREF="ciao_97.html#SEC338">Documentation on exports (class)</A>
<LI><A HREF="ciao_97.html#SEC339">Known bugs and planned improvements (class)</A>
</UL>



<H2><A NAME="SEC336" HREF="ciao_toc.html#TOC336">Usage and interface (<CODE>class</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

To declare a class the compiler must be told to use the <CODE>class</CODE> <EM>source expansion</EM>. To do so, source code must start with a module declaration which loads the class package: 

<PRE>
           :- class(ClassName).
</PRE>

or a 
<A NAME="IDX3597"></A>
<CODE>module/3</CODE> declaration, as follows: 

<PRE>
           :- module(ClassName,[],[class]).
</PRE>


<A NAME="IDX3598"></A>
interfaces are declared in a similar way: 

<PRE>
           :- interface(InterfaceName).
</PRE>

Please, do not use SICStus-like module declaration, with a non-empty export list. In other case, some non-sense errors will be reported by normal CIAO module system. 

Most of the regular CIAO declarations may be used when defining a class, such as 
<A NAME="IDX3599"></A>
<CODE>concurrent/1</CODE>,
<A NAME="IDX3600"></A>
<CODE>dynamic/1</CODE>, 
<A NAME="IDX3601"></A>
<CODE>discontiguous/1</CODE>,
<A NAME="IDX3602"></A>
<CODE>multifile/1</CODE>, and so on. 

However, there are some restrictions wich apply to those declarations: 

<UL>
<LI>

<A NAME="IDX3603"></A>
<CODE>meta_predicate/1</CODE> declaration is not allowed to hold 
<A NAME="IDX3604"></A>
<A NAME="IDX3605"></A>
<EM>addmodule and pred(N) meta-arguments</EM>, except for previously declared multifiles. 
<LI>Attribute and multifile predicates must be declared before any clause of the related predicate.

<LI>There is no sense in declaring an attribute as meta_predicate.

</UL>

It is a good practique to put all your declarations at the very begining of the file, just before the code itself. 

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX3606"></A>
<CODE>inherited/1</CODE>, 
<A NAME="IDX3607"></A>
<CODE>self/1</CODE>, 
<A NAME="IDX3608"></A>
<CODE>constructor/0</CODE>, 
<A NAME="IDX3609"></A>
<CODE>destructor/0</CODE>.

</UL>

<LI><STRONG>New declarations defined:</STRONG>

<A NAME="IDX3610"></A>
<CODE>export/1</CODE>, 
<A NAME="IDX3611"></A>
<CODE>public/1</CODE>, 
<A NAME="IDX3612"></A>
<CODE>inheritable/1</CODE>, 
<A NAME="IDX3613"></A>
<CODE>data/1</CODE>, 
<A NAME="IDX3614"></A>
<CODE>dynamic/1</CODE>, 
<A NAME="IDX3615"></A>
<CODE>concurrent/1</CODE>, 
<A NAME="IDX3616"></A>
<CODE>inherit_class/1</CODE>, 
<A NAME="IDX3617"></A>
<CODE>implements/1</CODE>, 
<A NAME="IDX3618"></A>
<CODE>virtual/1</CODE>.

<LI><STRONG>Other modules used:</STRONG>


<UL>

<LI><EM>System library modules:</EM>

<A NAME="IDX3619"></A>
<CODE>objects/objects_rt</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC337" HREF="ciao_toc.html#TOC337">Documentation on new declarations (<CODE>class</CODE>)</A></H2>
<P>
<A NAME="IDX3620"></A>
<A NAME="IDX3621"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>export/1:</B>
<DD><A NAME="IDX3622"></A>


<P>
Declares a method or attribute to be part of the 
<A NAME="IDX3623"></A>
<A NAME="IDX3624"></A>
<EM>public interface</EM>. 


<P>
The public interface is the set of predicates wich will be accesible from any code establishing an usage relationship with this class (see 
<A NAME="IDX3625"></A>
<CODE>use_class/1</CODE> for further information). 


<P>
Publishing an attribute or method is very similar to <EM>exporting</EM> a predicate in a Prolog module. 


<P>
Whether an inherited and exported predicate is 
<A NAME="IDX3626"></A>
overriden, it must be explicitly exported again. 


<P>
An inherited (but not exported) predicate may become exported, without overriding it by the usage of this declaration. 


<P>
<STRONG>Usage:</STRONG> :- <CODE>export(Spec)</CODE>.

<UL>
<LI><EM>Description:</EM> <CODE>Spec</CODE> will be part of the public (exported) interface.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Spec</CODE> is a method or attribute specification.
 (<CODE>objects_rt:method_spec/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3627"></A>
<A NAME="IDX3628"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>public/1:</B>
<DD><A NAME="IDX3629"></A>


<P>
Just an alias for 
<A NAME="IDX3630"></A>
<CODE>export/1</CODE>.


<P>
<STRONG>Usage:</STRONG> :- <CODE>public(Spec)</CODE>.

<UL>
<LI><EM>Description:</EM> This declaration may be used instead of

<A NAME="IDX3631"></A>
<CODE>export/1</CODE>. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Spec</CODE> is a method or attribute specification.
 (<CODE>objects_rt:method_spec/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3632"></A>
<A NAME="IDX3633"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>inheritable/1:</B>
<DD><A NAME="IDX3634"></A>


<P>
Declares a method or attribute to be inherited by descendant classes. Notice that all <STRONG>public predicates are inheritable by default</STRONG>. There is no need to mark them as inheritable. 


<P>
Traditionaly, object oriented languages makes use of the 
<A NAME="IDX3635"></A>
<A NAME="IDX3636"></A>
<EM>protected</EM> concept. Inheritable/1 may be used as the same concept. 


<P>
The set of inheritable predicates is called the 
<A NAME="IDX3637"></A>
<A NAME="IDX3638"></A>
<EM>inheritable interface</EM>. 


<P>
<STRONG>Usage:</STRONG> :- <CODE>inheritable(MethodSpec)</CODE>.

<UL>
<LI><EM>Description:</EM> <CODE>MethodSpec</CODE> is accessible to descendant classes.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>MethodSpec</CODE> is a method or attribute specification.
 (<CODE>objects_rt:method_spec/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3639"></A>
<A NAME="IDX3640"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>data/1:</B>
<DD><A NAME="IDX3641"></A>


<P>
Declares an 
<A NAME="IDX3642"></A>
<A NAME="IDX3643"></A>
<EM>attribute</EM> at current class. Attributes are used to build the internal state of instances. So, each instance will own a particular copy of those attribute definitions. In this way, one instance may have different state from another. 


<P>
O'CIAO attributes are restricted to hold simple facts. It is not possible to hold a Head :- Body clause at an instance attribute. 


<P>
Notice that attributes are 
<A NAME="IDX3644"></A>
<A NAME="IDX3645"></A>
<EM>multi-evaluated</EM> by nature, and may be manipulated by the habitual <STRONG>assert/retract</STRONG> family of predicates. 


<P>
Attributes may also be initialized. In order to do so, simply put some clauses after the attribute definition. Each time an instance is created, its initial state will be built from those 
<A NAME="IDX3646"></A>
<A NAME="IDX3647"></A>
<EM>initialization clauses</EM>. 


<P>
Note: whether a data/1 declaration appears inside an interface, it will be automatically exported. 


<P>
<STRONG>Usage:</STRONG> :- <CODE>data Spec</CODE>.

<UL>
<LI><EM>Description:</EM> <CODE>Spec</CODE> is an attribute.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Spec</CODE> is a method or attribute specification.
 (<CODE>objects_rt:method_spec/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3648"></A>
<A NAME="IDX3649"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>dynamic/1:</B>
<DD><A NAME="IDX3650"></A>


<P>
Just an alias for 
<A NAME="IDX3651"></A>
<CODE>data/1</CODE>. 


<P>
<STRONG>Usage:</STRONG> :- <CODE>dynamic Spec</CODE>.

<UL>
<LI><EM>Description:</EM> You may use this declaration instead of

<A NAME="IDX3652"></A>
<CODE>data/1</CODE>. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Spec</CODE> is a method or attribute specification.
 (<CODE>objects_rt:method_spec/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3653"></A>
<A NAME="IDX3654"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>concurrent/1:</B>
<DD><A NAME="IDX3655"></A>


<P>
Declares a 
<A NAME="IDX3656"></A>
<A NAME="IDX3657"></A>
<EM>concurrent attribute</EM> at current class. Concurrent attributes are just the same as normal attributes, those declared using 
<A NAME="IDX3658"></A>
<CODE>data/1</CODE>, except for they may freeze the calling thread instead of failing when no more choice points are remaining on the concurrent attribute. 


<P>
In order to get more information about concurrent behavior take a look to the concurrent/1 built-in declaration on CIAO Prolog module system. 


<P>
<STRONG>Usage:</STRONG> :- <CODE>concurrent Spec</CODE>.

<UL>
<LI><EM>Description:</EM> Declares <CODE>Spec</CODE> to be a concurrent attribute.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Spec</CODE> is a method or attribute specification.
 (<CODE>objects_rt:method_spec/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3659"></A>
<A NAME="IDX3660"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>inherit_class/1:</B>
<DD><A NAME="IDX3661"></A>


<P>
Makes any public and/or inheritable predicate at inherited class to become accesible by any instance derived from current class. 


<P>
Inherited class is also called the 
<A NAME="IDX3662"></A>
<A NAME="IDX3663"></A>
<EM>super class</EM>. 


<P>
Only one inherit_class/1 declaration is allowed to be present at current source. 


<P>
Notice that inheritance is 
<A NAME="IDX3664"></A>
public by default. Any public and/or inheritable declaration will remain the same to descendant classes. However, any inherited predicate may be <EM>overriden</EM> (redefined). 


<P>
A predicate is said to be 
<A NAME="IDX3665"></A>
<A NAME="IDX3666"></A>
<EM>overriden</EM> when it has been inherited from super class, but there are clauses (or a 
<A NAME="IDX3667"></A>
<CODE>data/1</CODE> declaration) present at current class for such a predicate. 


<P>
Whether a <STRONG>public</STRONG> predicate is overriden, the local definition must also be exported, otherwise an error is reported. 


<P>
Whether an <STRONG>inheritable</STRONG> predicate (not public) is overriden, the local definition must also be marked as inheritable or exported, otherwise an error is also reported. 


<P>
Note: whether inherit_class/1 appears inside an interface, it will be used as an 
<A NAME="IDX3668"></A>
<CODE>implements/1</CODE> declaration. 


<P>
<STRONG>Usage:</STRONG> :- <CODE>inherit_class(Source)</CODE>.

<UL>
<LI><EM>Description:</EM> Establish an

<A NAME="IDX3669"></A>
<A NAME="IDX3670"></A>
<EM>inheritance relationship</EM> between current class and the class defined at <CODE>Source</CODE> file. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Source</CODE> is a valid path to a prolog file containing a class declaration (without .pl extension).
 (<CODE>objects_rt:class_source/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3671"></A>
<A NAME="IDX3672"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>implements/1:</B>
<DD><A NAME="IDX3673"></A>


<P>
Forces current source to provide an implementation for the given interface file. Such interface file may declare another class or a specific interface. 


<P>
Every public predicate present at given interface file will be automatically declared as public at current source, so you <STRONG>must</STRONG> provide an implementation for such predicates. 


<P>
The effect of this declaration is called 
<A NAME="IDX3674"></A>
<A NAME="IDX3675"></A>
<EM>interface inheritance</EM>,and there is no restriction on the number of implements/1 declarations present at current code. 


<P>
<STRONG>Usage:</STRONG> :- <CODE>implements(Interface)</CODE>.

<UL>
<LI><EM>Description:</EM> Current source is supposed to provide an implementation for <CODE>Interface</CODE>.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Interface</CODE> is a valid path to a prolog file containing a class declaration or an interface declaration (without .pl extension).
 (<CODE>objects_rt:interface_source/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3676"></A>
<A NAME="IDX3677"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>virtual/1:</B>
<DD><A NAME="IDX3678"></A>


<P>
This declaration may be used whenever descendant classes are to implement different versions of a given predicate. 


<P>
<A NAME="IDX3679"></A>
<A NAME="IDX3680"></A>
<EM>virtual</EM> predicates give a chance to handle, in an uniform way, different implementations of the same functionality. 


<P>
Whether a virtual predicate is declared as a method, there must be at least one clause of it present at current source. Whenever no special implementation is needed at current class, a never-fail/allways-fail clause may be defined (depending on your needs). For example: 



<PRE>
   :- virtual([ test1/1 , test2/2 ]).
   test1(_).
   test2(_,_) :- fail.
</PRE>

<P>
This kind of virtual methods are also known as 
<A NAME="IDX3681"></A>
<A NAME="IDX3682"></A>
<EM>abstract methods</EM>, since implementation is fully delegated to descendant classes. 


<P>
An attribute may be also declared as a virtual one, but there is no need to write clauses for it. 


<P>
<STRONG>Usage:</STRONG> :- <CODE>virtual(VirtualMethodSpec)</CODE>.

<UL>
<LI><EM>Description:</EM> All calls to <CODE>VirtualMethodSpec</CODE> predicate in current source will use the most descendant implementation of it.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>VirtualMethodSpec</CODE> is a method specification.
 (<CODE>objects_rt:virtual_method_spec/1</CODE>)
</UL>

</DL>



<H2><A NAME="SEC338" HREF="ciao_toc.html#TOC338">Documentation on exports (<CODE>class</CODE>)</A></H2>
<P>
<A NAME="IDX3683"></A>
<A NAME="IDX3684"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>inherited/1:</B>
<DD><A NAME="IDX3685"></A>


<P>
This predicate qualificator may be used whenever you need to reference an attribute or method on the super class. 


<P>
Since methods and attributes may be 
<A NAME="IDX3686"></A>
redefined, this qualificator is need to distinguish between a locally declared predicate and the inherited one, which has the same name. 


<P>
There is no need to use inherited/1 if a particular inherited predicate has not been redefined at current class. 


<P>
<STRONG>Usage:</STRONG> <CODE>inherited(Goal)</CODE>

<UL>
<LI><EM>Description:</EM> References a given <CODE>Goal</CODE> at the super class

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Goal</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3687"></A>
<A NAME="IDX3688"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>self/1:</B>
<DD><A NAME="IDX3689"></A>


<P>
Determines which instance is currently executing self/1 goal. 


<P>
Predicate will fail if argument is not a free variable. Otherwise, it will allways succeed, retrieving the instance identifier which is executing current code. 


<P>
This functionality is very usefull since an object must have knowledge of other object's identifier in order to send messages to it.For example: 


<P>
:- concurrent ack/0. 


<P>
send_data_to_object(Data,Obj) :- self(X), Obj:take_this(Data,X), current_fact(ack). 


<P>
acknowledge :- asserta_fact(ack). 


<P>
take_this(Data,Sender) :- validate_data(Data), Sender:acknowledge. 


<P>
<STRONG>Usage:</STRONG> <CODE>self(Variable)</CODE>

<UL>
<LI><EM>Description:</EM> Retrieves current instance identifier in <CODE>Variable</CODE>

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Variable</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)
<LI><EM>The following properties should hold upon exit:</EM>

<CODE>Variable</CODE> is an unique term which identifies an object.
 (<CODE>objects_rt:instance_id/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3690"></A>
<A NAME="IDX3691"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>constructor/0:</B>
<DD><A NAME="IDX3692"></A>


<P>
A 
<A NAME="IDX3693"></A>
<A NAME="IDX3694"></A>
<EM>constructor</EM> is a special case of method which complains the following conditions: 



<UL>
<LI>The constructor functor matches the current class name.

<LI>A constructor may hold any number of arguments.

<LI>If an inheritance relationship was defined, an inherited constructor must be manually called (see below).

<LI>When instance creation takes place, any of the declared constructors are implicitly called. The actual constructor called depends on the

<A NAME="IDX3695"></A>
<CODE>new/2</CODE> goal specified by the user. 
</UL>

<P>
This is a simple example of constructor declaration for the foo class: 



<PRE>
           foo :- 
               display('an instance was born').
</PRE>

<P>
Constructor declaration is not mandatory, and there may be more than one constructor declarations (with different arity) at the source code. 


<P>
This functionality is usefull when some computation is needed at instance creation. For example: opening a socket, clearing the screen, etc. 


<P>
Whenever an inheritance relationship is established, and there is any constructor defined at the super class, you must call manually an inherited constructor. Here is an example: 



<PRE>
           :- class(foo).
           :- inherit_class(myclass).

           foo :-
               myclass(0),
               display('an instance was born').

           foo(N) :- myclass(N).
</PRE>

<P>
Consequences may be unpredictable, if you forget to call an inherited constructor. You should also take care not to call an inherited constructor twice. 


<P>
All defined constructors are inheritable by default. A constructor may also be declared as public (by the user), but it is not mandatory. 


<P>
<STRONG>Usage:</STRONG> 

<UL>
<LI><EM>Description:</EM> Constructors are implicitly declared

</UL>

</DL>

<P>
<A NAME="IDX3696"></A>
<A NAME="IDX3697"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>destructor/0:</B>
<DD><A NAME="IDX3698"></A>


<P>
A 
<A NAME="IDX3699"></A>
<A NAME="IDX3700"></A>
<EM>destructor</EM> is a special case of method which will be automatically called when instance destruction takes place. 


<P>
A destructor will never be wanted to be part of the public interface, and there is no need to mark them as inheritable, since all inherited destructors are called by O'CIAO just before yours. 


<P>
This is a simple example of destructor declaration: 



<PRE>
           destructor :- 
               display('goodbye, cruel world!!!').
</PRE>

<P>
Destructor declaration is not mandatory. Failure or sucess of destructors will be ignored by O'CIAO, and they will be called only once. 


<P>
This functionality is usefull when some computation is need at instance destruction. For example: closing an open file. 


<P>
<STRONG>Usage:</STRONG> 

<UL>
<LI><EM>Description:</EM> Destructors are implicitly declared

</UL>

</DL>



<H2><A NAME="SEC339" HREF="ciao_toc.html#TOC339">Known bugs and planned improvements (<CODE>class</CODE>)</A></H2>


<UL>

<LI>

addmodule and pred(N) meta-arguments are not allowed on meta-predicates. 
</UL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_96.html">previous</A>, <A HREF="ciao_98.html">next</A>, <A HREF="ciao_148.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
