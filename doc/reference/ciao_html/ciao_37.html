<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 5 May 2000 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - All solutions predicates</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_36.html">previous</A>, <A HREF="ciao_38.html">next</A>, <A HREF="ciao_158.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC192" HREF="ciao_toc.html#TOC192">All solutions predicates</A></H1>
<P>
<A NAME="IDX2184"></A>


<P>
<STRONG>Author(s):</STRONG> First version by Richard A. O'Keefe and David H.D. Warren. Changes by Mats Carlsson, Daniel Cabeza, and Manuel Hermenegildo.


<P>
<STRONG>Version:</STRONG> 1.5#118 (2000/4/19, 18:13:43 CEST)


<P>
<STRONG>Version of last change:</STRONG> 1.5#115 (2000/4/12, 12:17:22 CEST)


<P>
This module implements the standard solution aggregation predicates. 


<P>
When there are many solutions to a problem, and when all those solutions are required to be collected together, this can be achieved by repeatedly backtracking and gradually building up a list of the solutions. The following built-in predicates are provided to automate this process. 



<UL>
<LI><A HREF="ciao_37.html#SEC193">Usage and interface (aggregates)</A>
<LI><A HREF="ciao_37.html#SEC194">Documentation on exports (aggregates)</A>
</UL>



<H2><A NAME="SEC193" HREF="ciao_toc.html#TOC193">Usage and interface (<CODE>aggregates</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

<CODE>:- use_module(library(aggregates)).</CODE>

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX2185"></A>
<CODE>setof/3</CODE>, 
<A NAME="IDX2186"></A>
<CODE>bagof/3</CODE>, 
<A NAME="IDX2187"></A>
<CODE>findall/3</CODE>, 
<A NAME="IDX2188"></A>
<CODE>findall/4</CODE>, 
<A NAME="IDX2189"></A>
<CODE>findnsols/4</CODE>, 
<A NAME="IDX2190"></A>
<CODE>findnsols/5</CODE>, 
<A NAME="IDX2191"></A>
<CODE>^/2</CODE>.

</UL>

<LI><STRONG>Other modules used:</STRONG>


<UL>

<LI><EM>System library modules:</EM>

<A NAME="IDX2192"></A>
<CODE>sort</CODE>, 
<A NAME="IDX2193"></A>
<CODE>lists</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC194" HREF="ciao_toc.html#TOC194">Documentation on exports (<CODE>aggregates</CODE>)</A></H2>
<P>
<A NAME="IDX2194"></A>
<A NAME="IDX2195"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>setof/3:</B>
<DD><A NAME="IDX2196"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>setof(?,goal,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>setof(@(Template),+Generator,?(Set))</CODE>
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Description:</EM> Finds the <CODE>Set</CODE> of instances of the <CODE>Template</CODE> satisfying <CODE>Generator</CODE>. The set is in ascending order (see section <A HREF="ciao_21.html#SEC141">Comparing terms</A> for a definition of this order) without duplicates, and is non-empty. If there are no solutions, <CODE>setof</CODE> fails. <CODE>setof</CODE> may succeed in more than one way, binding free variables in <CODE>Generator</CODE> to different values. This can be avoided by using existential quantifiers on the free variables in front of <CODE>Generator</CODE>, using

<A NAME="IDX2197"></A>
<CODE>^/2</CODE>. For example, given the clauses: 

<PRE>
father(bill, tom).
father(bill, ann).
father(bill, john).
father(harry, july).
father(harry, daniel).
</PRE>

The following query produces two alternative solutions via backtracking: 

<PRE>
?- setof(X,father(F,X),Sons).

F = bill,
Sons = [ann,john,tom] ? ;

F = harry,
Sons = [daniel,july] ? ;

no
?- 
</PRE>

 
<LI><EM>The following properties should hold upon exit:</EM>

<CODE>Template</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>Generator</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)

<CODE>Set</CODE> is a list.
 (<CODE>basic_props:list/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2198"></A>
<A NAME="IDX2199"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>bagof/3:</B>
<DD><A NAME="IDX2200"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>bagof(?,goal,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>bagof(@(Template),+Generator,?(Bag))</CODE>
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Description:</EM> Finds all the instances of the <CODE>Template</CODE> produced by the <CODE>Generator</CODE>, and returns them in the <CODE>Bag</CODE> in the order in which they were found. If the <CODE>Generator</CODE> contains free variables which are not bound in the <CODE>Template</CODE>, it assumes that this is like any other Prolog question and that you want bindings for those variables. This can be avoided by using existential quantifiers on the free variables in front of the <CODE>Generator</CODE>, using

<A NAME="IDX2201"></A>
<CODE>^/2</CODE>. 
</UL>

</DL>

<P>
<A NAME="IDX2202"></A>
<A NAME="IDX2203"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>findall/3:</B>
<DD><A NAME="IDX2204"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>findall(?,goal,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>findall(?(Template),+Generator,?(List))</CODE>
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Description:</EM> A special case of bagof, where all free variables in the <CODE>Generator</CODE> are taken to be existentially quantified. Faster than the other aggregation predicates.

</UL>

</DL>

<P>
<A NAME="IDX2205"></A>
<A NAME="IDX2206"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>findall/4:</B>
<DD><A NAME="IDX2207"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>findall(?,goal,?,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>findall(?(Template),+Generator,?(List),?(Tail))</CODE>
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Description:</EM> As

<A NAME="IDX2208"></A>
<CODE>findall/3</CODE>, but returning in <CODE>Tail</CODE> the tail of <CODE>List</CODE>. 
</UL>

</DL>

<P>
<A NAME="IDX2209"></A>
<A NAME="IDX2210"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>findnsols/4:</B>
<DD><A NAME="IDX2211"></A>


<P>
<CODE>findnsols(N,Template,Generator,List)</CODE>


<P>
As 
<A NAME="IDX2212"></A>
<CODE>findall/3</CODE>, but generating at most <CODE>N</CODE> solutions of <CODE>Generator</CODE>. Thus, the length of <CODE>List</CODE> will not be greater than <CODE>N</CODE>. If <CODE>N</CODE>=&#60;0, returns directly an empty list. This predicate is especially useful if <CODE>Generator</CODE> may have an infinite number of solutions.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>findnsols(?,?,goal,?)</CODE>.


</DL>

<P>
<A NAME="IDX2213"></A>
<A NAME="IDX2214"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>findnsols/5:</B>
<DD><A NAME="IDX2215"></A>


<P>
<CODE>findnsols(N,Template,Generator,List,Tail)</CODE>


<P>
As 
<A NAME="IDX2216"></A>
<CODE>findnsols/4</CODE>, but returning in <CODE>Tail</CODE> the tail of <CODE>List</CODE>.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>findnsols(?,?,goal,?,?)</CODE>.


</DL>

<P>
<A NAME="IDX2217"></A>
<A NAME="IDX2218"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>^/2:</B>
<DD><A NAME="IDX2219"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>X ^ P</CODE>

<UL>
<LI><EM>Description:</EM> Existential quantification: <CODE>X</CODE> is existentially quantified in <CODE>P</CODE>. E.g., in <CODE>A^p(A,B)</CODE>, <CODE>A</CODE> is existentially quantified. Used only within

<A NAME="IDX2220"></A>
aggregation predicates. In all other contexts, simply, execute the procedure call <CODE>P</CODE>. 
</UL>

</DL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_36.html">previous</A>, <A HREF="ciao_38.html">next</A>, <A HREF="ciao_158.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
