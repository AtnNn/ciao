<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 5 October 2004 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - Dynamic predicates</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_36.html">previous</A>, <A HREF="ciao_38.html">next</A>, <A HREF="ciao_243.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC170" HREF="ciao_toc.html#TOC170">Dynamic predicates</A></H1>
<P>
<A NAME="IDX2482"></A>


<P>
<STRONG>Author(s):</STRONG> The CLIP Group.


<P>
<STRONG>Version:</STRONG> 1.11#222 (2004/5/24, 13:8:7 CEST)


<P>
<STRONG>Version of last change:</STRONG> 1.11#75 (2003/12/19, 17:4:51 CET)


<P>
This module implements the assert/retract family of predicates to manipulate dynamic predicates. 


<P>
The predicates defined in this module allow modification of the program as it is actually running. Clauses can be added to the program (<EM>asserted</EM>) or removed from the program (<EM>retracted</EM>). For these predicates, the argument which corresponds to the clause head must be instantiated to an atom or a compound term. The argument corresponding to the clause must be instantiated either to a term <CODE>Head :- Body</CODE> or, if the body part is empty, to <CODE>Head</CODE>. An empty body part is represented as <CODE>true</CODE>. Note that using this library is very detrimental to global analysis, and that for most uses the predicates listed in section <A HREF="ciao_28.html#SEC141">Fast/concurrent update of facts</A> suffice.



<UL>
<LI><A HREF="ciao_37.html#SEC171">Usage and interface (dynamic)</A>
<LI><A HREF="ciao_37.html#SEC172">Documentation on exports (dynamic)</A>
<LI><A HREF="ciao_37.html#SEC173">Documentation on multifiles (dynamic)</A>
</UL>



<H2><A NAME="SEC171" HREF="ciao_toc.html#TOC171">Usage and interface (<CODE>dynamic</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

<CODE>:- use_module(library(dynamic)).</CODE>

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX2483"></A>
<CODE>asserta/1</CODE>, 
<A NAME="IDX2484"></A>
<CODE>asserta/2</CODE>, 
<A NAME="IDX2485"></A>
<CODE>assertz/1</CODE>, 
<A NAME="IDX2486"></A>
<CODE>assertz/2</CODE>, 
<A NAME="IDX2487"></A>
<CODE>assert/1</CODE>, 
<A NAME="IDX2488"></A>
<CODE>assert/2</CODE>, 
<A NAME="IDX2489"></A>
<CODE>retract/1</CODE>, 
<A NAME="IDX2490"></A>
<CODE>retractall/1</CODE>, 
<A NAME="IDX2491"></A>
<CODE>abolish/1</CODE>, 
<A NAME="IDX2492"></A>
<CODE>clause/2</CODE>, 
<A NAME="IDX2493"></A>
<CODE>clause/3</CODE>, 
<A NAME="IDX2494"></A>
<CODE>current_predicate/1</CODE>, 
<A NAME="IDX2495"></A>
<CODE>current_predicate/2</CODE>, 
<A NAME="IDX2496"></A>
<CODE>dynamic/1</CODE>, 
<A NAME="IDX2497"></A>
<CODE>data/1</CODE>, 
<A NAME="IDX2498"></A>
<CODE>wellformed_body/3</CODE>.

<LI><EM>Multifiles:</EM>

<A NAME="IDX2499"></A>
<CODE>do_on_abolish/1</CODE>.

</UL>

<LI><STRONG>Other modules used:</STRONG>


<UL>

<LI><EM>System library modules:</EM>

<A NAME="IDX2500"></A>
<CODE>prolog_sys</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC172" HREF="ciao_toc.html#TOC172">Documentation on exports (<CODE>dynamic</CODE>)</A></H2>
<P>
<A NAME="IDX2501"></A>
<A NAME="IDX2502"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>asserta/1:</B>
<DD><A NAME="IDX2503"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>asserta(clause)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>asserta(Clause)</CODE>
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Description:</EM> The current instance of <CODE>Clause</CODE> is interpreted as a clause and is added to the current program. The predicate concerned must be dynamic. The new clause becomes the <EM>first</EM> clause for the predicate concerned. Any uninstantiated variables in <CODE>Clause</CODE> will be replaced by new private variables.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Clause</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2504"></A>
<A NAME="IDX2505"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>asserta/2:</B>
<DD><A NAME="IDX2506"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>asserta(clause,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>asserta(Clause, Ref)</CODE>

<UL>
<LI><EM>Description:</EM> Like <CODE>asserta/1</CODE>. <CODE>Ref</CODE> is a unique identifier of the asserted clause.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Clause</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>Ref</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2507"></A>
<A NAME="IDX2508"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>assertz/1:</B>
<DD><A NAME="IDX2509"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>assertz(clause)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>assertz(Clause)</CODE>
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Description:</EM> Like <CODE>asserta/1</CODE>, except that the new clause becomes the <EM>last</EM> clause for the predicate concerned.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Clause</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2510"></A>
<A NAME="IDX2511"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>assertz/2:</B>
<DD><A NAME="IDX2512"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>assertz(clause,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>assertz(Clause, Ref)</CODE>

<UL>
<LI><EM>Description:</EM> Like <CODE>assertz/1</CODE>. <CODE>Ref</CODE> is a unique identifier of the asserted clause.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Clause</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>Ref</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2513"></A>
<A NAME="IDX2514"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>assert/1:</B>
<DD><A NAME="IDX2515"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>assert(clause)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>assert(Clause)</CODE>

<UL>
<LI><EM>Description:</EM> Identical to <CODE>assertz/1</CODE>. Included for compatibility.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Clause</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2516"></A>
<A NAME="IDX2517"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>assert/2:</B>
<DD><A NAME="IDX2518"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>assert(clause,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>assert(Clause, Ref)</CODE>

<UL>
<LI><EM>Description:</EM> Identical to <CODE>assertz/2</CODE>. Included for compatibility.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Clause</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>Ref</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2519"></A>
<A NAME="IDX2520"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>retract/1:</B>
<DD><A NAME="IDX2521"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>retract(clause)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>retract(Clause)</CODE>
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Description:</EM> The first clause in the program that matches <CODE>Clause</CODE> is erased. The predicate concerned must be dynamic.

The predicate <CODE>retract/1</CODE> may be used in a non-determinate fashion, i.e., it will successively retract clauses matching the argument through backtracking. If reactivated by backtracking, invocations of the predicate whose clauses are being retracted will proceed unaffected by the retracts. This is also true for invocations of <CODE>clause</CODE> for the same predicate. The space occupied by a retracted clause will be recovered when instances of the clause are no longer in use. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Clause</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2522"></A>
<A NAME="IDX2523"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>retractall/1:</B>
<DD><A NAME="IDX2524"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>retractall(fact)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>retractall(Head)</CODE>

<UL>
<LI><EM>Description:</EM> Erase all clauses whose head matches <CODE>Head</CODE>, where <CODE>Head</CODE> must be instantiated to an atom or a compound term. The predicate concerned must be dynamic. The predicate definition is retained.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Head</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2525"></A>
<A NAME="IDX2526"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>abolish/1:</B>
<DD><A NAME="IDX2527"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>abolish(spec)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>abolish(Spec)</CODE>
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Description:</EM> Erase all clauses of the predicate specified by the predicate spec <CODE>Spec</CODE>. The predicate definition itself is also erased (the predicate is deemed undefined after execution of the abolish). The predicates concerned must all be user defined.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Spec</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2528"></A>
<A NAME="IDX2529"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>clause/2:</B>
<DD><A NAME="IDX2530"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>clause(fact,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>clause(Head, Body)</CODE>
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Description:</EM> The clause '<CODE>Head</CODE> <CODE>:-</CODE> <CODE>Body</CODE>' exists in the current program. The predicate concerned must be dynamic.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Head</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2531"></A>
<A NAME="IDX2532"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>clause/3:</B>
<DD><A NAME="IDX2533"></A>


<P>
<CODE>clause(Head, Body, Ref)</CODE>


<P>
Like <CODE>clause(Head,Body)</CODE>, plus the clause is uniquely identified by <CODE>Ref</CODE>.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>clause(fact,?,?)</CODE>.


<P>
<STRONG>General properties:</STRONG> 

<UL>
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

<P>
<STRONG>Usage 1:</STRONG> <CODE>clause(Head, Body, Ref)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Head</CODE> must be instantiated to an atom or a compound term.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Head</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>clause(Head, Body, Ref)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Ref</CODE> must be instantiated to a valid identifier.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Ref</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2534"></A>
<A NAME="IDX2535"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>current_predicate/1:</B>
<DD><A NAME="IDX2536"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>current_predicate(Spec)</CODE>
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Description:</EM> A predicate in the current module is named <CODE>Spec</CODE>.

<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2537"></A>
<A NAME="IDX2538"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>current_predicate/2:</B>
<DD><A NAME="IDX2539"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>current_predicate(Spec, Module)</CODE>

<UL>
<LI><EM>Description:</EM> A predicate in <CODE>Module</CODE> is named <CODE>Spec</CODE>. <CODE>Module</CODE> never is an engine module.

<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2540"></A>
<A NAME="IDX2541"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>dynamic/1:</B>
<DD><A NAME="IDX2542"></A>


<P>
<CODE>dynamic Spec</CODE>


<P>
<CODE>Spec</CODE> is of the form <CODE>F</CODE>/<CODE>A</CODE>. The predicate named <CODE>F</CODE> with arity <CODE>A</CODE> is made 
<A NAME="IDX2543"></A>
dynamic in the current module at runtime (useful for predicate names generated on-the-fly). If the predicate functor name <CODE>F</CODE> is uninstatiated, a new, unique, predicate name is generated at runtime.


<P>
<STRONG>Usage:</STRONG> <CODE>dynamic Spec</CODE>

<UL>
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Spec</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2544"></A>
<A NAME="IDX2545"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>data/1:</B>
<DD><A NAME="IDX2546"></A>


<P>
<CODE>data Spec</CODE>


<P>
<CODE>Spec</CODE> is of the form <CODE>F</CODE>/<CODE>A</CODE>. The predicate named <CODE>F</CODE> with arity <CODE>A</CODE> is made 
<A NAME="IDX2547"></A>
data in the current module at runtime (useful for predicate names generated on-the-fly). If the predicate functor name <CODE>F</CODE> is uninstatiated, a new, unique, predicate name is generated at runtime. 


<P>
<STRONG>Usage:</STRONG> <CODE>data Spec</CODE>

<UL>
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Spec</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2548"></A>
<A NAME="IDX2549"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>wellformed_body/3:</B>
<DD><A NAME="IDX2550"></A>


<P>
<CODE>wellformed_body(BodyIn, Env, BodyOut)</CODE>


<P>
<CODE>BodyIn</CODE> is a well-formed clause body. <CODE>BodyOut</CODE> is its counterpart with no single-variable meta-goals (i.e., with <CODE>call(X)</CODE> for <CODE>X</CODE>). <CODE>Env</CODE> denotes if global cuts are admissible in <CODE>BodyIn</CODE> (<CODE>+</CODE> if they are, <CODE>-</CODE> if they are not).


</DL>



<H2><A NAME="SEC173" HREF="ciao_toc.html#TOC173">Documentation on multifiles (<CODE>dynamic</CODE>)</A></H2>
<P>
<A NAME="IDX2551"></A>
<A NAME="IDX2552"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>do_on_abolish/1:</B>
<DD><A NAME="IDX2553"></A>


<P>
<CODE>do_on_abolish(Head)</CODE>


<P>
A hook predicate which will be called when the definition of the predicate of <CODE>Head</CODE> is abolished.


<P>
The predicate is <EM>multifile</EM>.


</DL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_36.html">previous</A>, <A HREF="ciao_38.html">next</A>, <A HREF="ciao_243.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
