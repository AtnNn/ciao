<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 24 April 2004 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - The interactive debugger</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_7.html">previous</A>, <A HREF="ciao_9.html">next</A>, <A HREF="ciao_241.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC72" HREF="ciao_toc.html#TOC72">The interactive debugger</A></H1>

<P>
<STRONG>Author(s):</STRONG> D. Cabeza, Manuel C. Rodriguez, (A. Ciepielewski, M. Carlsson, T. Chikayama, K. Shen).


<P>
<STRONG>Version:</STRONG> 1.9#342 (2004/4/24, 20:30:39 CEST)


<P>
<STRONG>Version of last change:</STRONG> 1.9#188 (2003/12/19, 16:2:3 CET)


<P>
 


<P>
The Ciao program development environment includes a number of advanced 
<A NAME="IDX643"></A>
debugging tools, such as a 
<A NAME="IDX644"></A>
source-level debugger, the 
<A NAME="IDX645"></A>
<CODE>ciaopp</CODE> preprocessor, and some 
<A NAME="IDX646"></A>
execution visualizers. Herein we discuss the interactive debugger available in the standard 
<A NAME="IDX647"></A>
top-level, which allows tracing the control flow of programs, in a similar way to other popular Prolog systems. This is a classical Byrd <EM>box-type</EM> 
<A NAME="IDX648"></A>
<A NAME="IDX649"></A>
<EM>debugger</EM> 
<A NAME="IDX650"></A>
<A NAME="IDX651"></A>
[Byr80,BBP81], with some enhancements, most notably being able to track the execution on the source program. We also discuss the 
<A NAME="IDX652"></A>
embedded debugger, which is a version of the debugger which can be embedded into executables so that an interactive debugging session can be triggered at any time while running that executable without needing the top-level shell. 


<P>
Byrd's 
<A NAME="IDX653"></A>
Procedure Box model of debugging execution provides a simple way of visualising control flow, including backtracking. Control flow is in principle viewed at the predicate level, rather than at the level of individual clauses. The Ciao debugger has the ability to mark selected modules and/or files for debugging (traditional and source debugging), rather than having to exhaustively trace your program. It also allows to selectively set 
<A NAME="IDX654"></A>
spy-points and 
<A NAME="IDX655"></A>
breakpoints. Spy-points allow the programmer to nominate interesting predicates at which program execution is to pause so that the programmer can interact with the debugger. Breakpoints are similar to spy-points, but allow pausing at a specific line in the code, corresponding to a particular literal. There is a wide choice of control and information options available during debugging interaction. 


<P>
<STRONG>Note:</STRONG> While the debugger described herein can be used in a standalone way (i.e., from a operating system shell or terminal window) in the same way as other Prolog debuggers, the most convenient way of debugging Ciao programs is by using the emacs mode (see section <A HREF="ciao_12.html#SEC93">Using Ciao inside GNU emacs</A>), i.e., debugging from within the 
<A NAME="IDX656"></A>
<CODE>emacs</CODE> editor / programming environment. 



<UL>
<LI><A HREF="ciao_8.html#SEC73">Marking modules and files for debugging in the top-level debugger</A>
<LI><A HREF="ciao_8.html#SEC74">The debugging process</A>
<LI><A HREF="ciao_8.html#SEC75">Marking modules and files for debugging with the embedded debugger</A>
<LI><A HREF="ciao_8.html#SEC76">The procedure box control flow model</A>
<LI><A HREF="ciao_8.html#SEC77">Format of debugging messages</A>
<LI><A HREF="ciao_8.html#SEC78">Options available during debugging</A>
<LI><A HREF="ciao_8.html#SEC79">Calling predicates that are not exported by a module</A>
<LI><A HREF="ciao_8.html#SEC80">Acknowledgements</A>
</UL>



<H2><A NAME="SEC73" HREF="ciao_toc.html#TOC73">Marking modules and files for debugging in the top-level debugger</A></H2>

<P>
Usually, when a program is not working properly, the programmer has a feeling of which are the modules where the fault may be. Since full-fledged debugging is only available on <EM>interpreted</EM> (called 
<A NAME="IDX657"></A>
<A NAME="IDX658"></A>
<EM>interpreted mode</EM> in traditional Prolog systems) modules, which are executed much slower than compiled modules, there is the posibility of telling the top level which particular modules are to be loaded in 
<A NAME="IDX659"></A>
<A NAME="IDX660"></A>
<EM>interpreted mode</EM>, with the aim of debugging them. The simplest way of achieving this is by executing in the Ciao shell prompt, for each suspicious module <CODE>Module</CODE> in the program, a command like this: 



<PRE>
?- debug_module(Module).
</PRE>

<P>
An alternative way of loading a module in interpreted mode exists which will instruct the debugger to keep track of the line numbers in the source file and to report them during debugging. This feature can be selected for a suspicious module <CODE>Module</CODE> in the program by executing a command such as: 



<PRE>
?- debug_module_source(Module).
</PRE>

<P>
This is most useful when running the top-level inside the 
<A NAME="IDX661"></A>
<CODE>emacs</CODE> editor since in that case the Ciao 
<A NAME="IDX662"></A>
emacs mode allows performing full 
<A NAME="IDX663"></A>
source-level debugging in each module marked as above, i.e., the source lines being executed will be highlighted dynamically during debugging in a window showing the source code of the module. 


<P>
<A NAME="IDX664"></A>
<A NAME="IDX665"></A>
Note that all files with no module declaration belong to the pseudo-module <CODE>user</CODE>, so the command to be issued for debugging a user file, say <CODE>foo.pl</CODE>, would be <CODE>debug_module(user)</CODE> or <CODE>debug_module_source(user)</CODE>, and not <CODE>debug_module(foo)</CODE>. 


<P>
The two ways of performing 
<A NAME="IDX666"></A>
source-level debugging are fully compatible between them, i.e., Ciao allows having some modules loaded with 
<A NAME="IDX667"></A>
<CODE>debug_module/1</CODE> and others with 
<A NAME="IDX668"></A>
<CODE>debug_module_source/1</CODE>. To change from one interpreted mode to the other mode it suffices to select the module with the new interpreted mode (debugger mode), using the appropiate command, and reload the module. 


<P>
The commands above perform in fact two related actions: first, they let the compiler know that if a file containing a module with this name is loaded, it should be loaded in interpreted mode (source or traditional). In addition, they instruct the debugger to actually prepare for debugging the code belonging to that module. After that, the modules which are to be debugged have to be (re)loaded so that they are compiled or loaded for interpretation in the appropriate way. The nice thing is that, due to the modular behaviour of the compiler/top-level, if the modules are part of a bigger application, it suffices to load the main module of the application, since this will automatically force the dependent modules which have changed to be loaded in the appropriate way, including those whose 
<A NAME="IDX669"></A>
<A NAME="IDX670"></A>
<EM>loading mode</EM> has changed (i.e., changing the loading mode has the effect of forcing the required re-loading of the module at the appropriate time). 


<P>
Later in the debugging process, as the bug location is isolated, typically one will want to restrict more and more the modules where debugging takes place. To this end, and without the need for reloading, one can tell the debugger to not consider a module for debugging issuing a 
<A NAME="IDX671"></A>
<CODE>nodebug_module/1</CODE> command, which counteracts a 
<A NAME="IDX672"></A>
<CODE>debug_module/1</CODE> or 
<A NAME="IDX673"></A>
<CODE>debug_module_source/1</CODE> command with the same module name, and reloading it (or the main file). 


<P>
There are also two top-level commands 
<A NAME="IDX674"></A>
<CODE>set_debug_mode/1</CODE> and 
<A NAME="IDX675"></A>
<CODE>set_nodebug_mode/1</CODE>, which accept as argument a file spec (i.e., <CODE>library(foo)</CODE> or <CODE>foo</CODE>, even if it is a user file) to be able to load a file in interpreted mode without changing the set of modules that the debugger will try to spy. 




<H2><A NAME="SEC74" HREF="ciao_toc.html#TOC74">The debugging process</A></H2>

<P>
Once modules or user files are marked for debugging and reloaded, the traditional debugging shell commands can be used (the documentation of the 
<A NAME="IDX676"></A>
<CODE>debugger</CODE> library following this chapter contains all the commands and their description), with the same meaning as in other classical Prolog systems. The differences in their behavior are: 



<UL>

<LI>Debugging takes place only in the modules in which it was activated,

<LI>

<A NAME="IDX677"></A>
<CODE>nospy/1</CODE> and 
<A NAME="IDX678"></A>
<CODE>spy/1</CODE> accept sequences of predicate specs, and they will search for those predicates only in the modules marked for debugging (traditional or source-level debugging). 

<LI>

<A NAME="IDX679"></A>
<CODE>breakpt/6</CODE> and 
<A NAME="IDX680"></A>
<CODE>nobreakpt/6</CODE> allow setting breakpoints at selected clause literals and will search for those literals only in the modules marked for 
<A NAME="IDX681"></A>
source-level debugging (modules marked with 
<A NAME="IDX682"></A>
<CODE>debug_module_source/1</CODE>). 

</UL>

<P>
In particular, the system is initially in 
<A NAME="IDX683"></A>
nodebug mode, in which no tracing is performed. The system can be put in 
<A NAME="IDX684"></A>
debug mode by a call to 
<A NAME="IDX685"></A>
<CODE>debug/0</CODE> in which execution of queries will proceed until the first <EM>spy-point</EM> or <EM>breakpoint</EM>. Alternatively, the system can be put in 
<A NAME="IDX686"></A>
trace mode by a call to 
<A NAME="IDX687"></A>
<CODE>trace/0</CODE> in which all predicates will be trace. 




<H2><A NAME="SEC75" HREF="ciao_toc.html#TOC75">Marking modules and files for debugging with the embedded debugger</A></H2>

<P>
The embedded debugger, as the interpreted debugger, has three different modes of operation: debug, trace or nodebug. These debuggers modes can be set by adding a package declaration in the module, as follows: 



<PRE>
:- use_package(debug).
:- use_package(trace).
:- use_package(nodebug).
</PRE>

<P>
and recompiling the application. 


<P>
In order to debug, or trace, correctly the complete code these declarations <EM>must</EM> appear the last ones of all 
<A NAME="IDX688"></A>
<CODE>use_package</CODE> declarations used. Also it is possible, as usual, to add the debugging package(s) in the module declaration using the predicate 
<A NAME="IDX689"></A>
<CODE>module/3</CODE> (and they should also be the last ones). 


<P>
The embedded debugger has limitations over the interpreted debugger. The most important is that the "retry" option is not available. But it is possible to add, and remove, 
<A NAME="IDX690"></A>
spy-points and 
<A NAME="IDX691"></A>
breakpoins using the predicates 
<A NAME="IDX692"></A>
<CODE>spy/1</CODE>, 
<A NAME="IDX693"></A>
<CODE>nospy/1</CODE>, 
<A NAME="IDX694"></A>
<CODE>breakpt/6</CODE> and 
<A NAME="IDX695"></A>
<CODE>nobreakpt/6</CODE>, etc. These can be used in a clause declaration or as declarations. Also it is possible to add in the code predicates for issuing the debugger (i.e., use debug mode, and in a clause add the predicate 
<A NAME="IDX696"></A>
<CODE>trace/1</CODE>). 


<P>
The nodebug mode allows keeping the spy-points and breakpoints in the code instead of removing them from the code. 


<P>
Note that there is a particularly interesting way of using the 
<A NAME="IDX697"></A>
embedded debugger: if an <EM>application</EM> is run in a shell buffer which has been set with Ciao inferior mode (<KBD>M-x</KBD> <CODE>ciao-inferior-mode</CODE>) and this application starts emitting output from the embedded debugger (i.e., which contains the embedded debugger and is debugging its code) then the Ciao emacs mode will be able to follow these messages, for example tracking execution in the source level code. This also works if the application is written in a combination of languages, provided the parts written in Ciao are compiled with the embedded debugger package and is thus a covenient way of debugging multi-language applications. The only thing needed is to make sure that the output messages appear in a shell buffer that is in Ciao inferior mode. 


<P>
See the following as a general example of use of the embedded debugger: 

<PRE>
:- module( foo,[main/1],[assertions, debug]).

:- entry main/1.

main(X) :- 
         display(X),
         spy(foo), 
         foo(X), 
         notrace,
         nl.

foo([]).  
foo([X|T]) :-  
        trace,
        bar(X), 
        foo(T).

bar(X) :- 
        display(X).
</PRE>



<H2><A NAME="SEC76" HREF="ciao_toc.html#TOC76">The procedure box control flow model</A></H2>

<P>
During debugging the interpreter prints out a sequence of goals in various states of instantiation in order to show the state that the program has reached in its execution. However, in order to understand what is occurring it is necessary to understand when and why the interpreter prints out goals. As in other programming languages, key points of interest are procedure entry and return, but in Prolog there is the additional complexity of backtracking. One of the major confusions that novice Prolog programmers have to face is the question of what actually happens when a goal fails and the system suddenly starts backtracking. The Procedure Box model of Prolog execution views program control flow in terms of movement about the program text. This model provides a basis for the debugging mechanism in the interpreter, and enables the user to view the behaviour of the program in a consistent way. It also provides the basis for the visualization performed on the source level program when source level program when 
<A NAME="IDX698"></A>
source-level debugging is activated within 
<A NAME="IDX699"></A>
<CODE>emacs</CODE>. 
 
Let us look at an example Prolog procedure: 


<P>
<IMG SRC="autofigbyrdbox.jpg" ALT="Image:autofigbyrdbox.jpg"> 


<P>
The first clause states that <CODE>Y</CODE> is a descendant of <CODE>X</CODE> if <CODE>Y</CODE> is an offspring of <CODE>X</CODE>, and the second clause states that <CODE>Y</CODE> is a descendant of <CODE>X</CODE> if <CODE>Z</CODE> is an offspring of <CODE>X</CODE> and <CODE>Y</CODE> is a descendant of <CODE>Z</CODE>. In the diagram a box has been drawn around the whole procedure and labelled arrows indicate the control flow in and out of this box. There are four such arrows which we shall look at in turn. 



<UL>

<LI><STRONG>Call</STRONG>

This arrow represents initial invocation of the procedure. When a goal of the form <CODE>descendant(X,Y)</CODE> is required to be satisfied, control passes through the Call port of the descendant box with the intention of matching a component clause and then satisfying any subgoals in the body of that clause. Note that this is independent of whether such a match is possible; i.e. first the box is called, and then the attempt to match takes place. Textually we can imagine moving to the code for descendant when meeting a call to descendant in some other part of the code. 

<LI><STRONG>Exit</STRONG>

This arrow represents a successful return from the procedure. This occurs when the initial goal has been unified with one of the component clauses and any subgoals have been satisfied. Control now passes out of the Exit port of the descendant box. Textually we stop following the code for descendant and go back to the place we came from. 

<LI><STRONG>Redo</STRONG>

This arrow indicates that a subsequent goal has failed and that the system is backtracking in an attempt to find alternatives to previous solutions. Control passes through the Redo port of the descendant box. An attempt will now be made to resatisfy one of the component subgoals in the body of the clause that last succeeded; or, if that fails, to completely rematch the original goal with an alternative clause and then try to satisfy any subgoals in the body of this new clause. Textually we follow the code backwards up the way we came looking for new ways of succeeding, possibly dropping down on to another clause and following that if necessary. 

<LI><STRONG>Fail</STRONG>

This arrow represents a failure of the initial goal, which might occur if no clause is matched, or if subgoals are never satisfied, or if any solution produced is always rejected by later processing. Control now passes out of the Fail port of the descendant box and the system continues to backtrack. Textually we move back to the code which called this procedure and keep moving backwards up the code looking for choice points. 
</UL>

<P>
In terms of this model, the information we get about the procedure box is only the control flow through these four ports. This means that at this level we are not concerned with which clause matches, and how any subgoals are satisfied, but rather we only wish to know the initial goal and the final outcome. However, it can be seen that whenever we are trying to satisfy subgoals, what we are actually doing is passing through the ports of <EM>their</EM> respective boxes. If we were following this (e.g., activating 
<A NAME="IDX700"></A>
source-level debugging), then we would have complete information about the control flow inside the procedure box. 


<P>
Note that the box we have drawn around the procedure should really be seen as an invocation box. That is, there will be a different box for each different invocation of the procedure. Obviously, with something like a recursive procedure, there will be many different Calls and Exits in the control flow, but these will be for different invocations. Since this might get confusing each invocation box is given a unique integer identifier in the messages, as described below. 


<P>
Note that not all procedure calls are traced; there are a few basic predicates which have been made invisible since it is more convenient not to trace them. These include debugging directives, basic control structures, and some builtins. This means that messages will never be printed for these predicates during debugging. 




<H2><A NAME="SEC77" HREF="ciao_toc.html#TOC77">Format of debugging messages</A></H2>

<P>
This section explains the two formats of the message output by the debugger at a port. All trace messages are output to the terminal regardless of where the current output stream is directed (which allows tracing programs while they are performing file I/O). The basic format, which will be shown in traditional debug and in source-level debugging within Ciao 
<A NAME="IDX701"></A>
<CODE>emacs</CODE> mode, is as follows: 



<PRE>
S  13  7  Call: T user:descendant(dani,_123) ?
</PRE>

<P>
<CODE>S</CODE> is a spy-point or breakpoint indicator. It is printed as '<CODE>+</CODE>', indicating that there is a spy-point on <CODE>descendant/2</CODE> in module <CODE>user</CODE>, as <CODE>'B'</CODE> denoting a breakpoint, or as ' ', denoting no spy-point or breakpoint. If there is a spy-point and a breakpoint in the same predicate the spy-point indicator takes preference over breakpoint indicator. 


<P>
<CODE>T</CODE> is a subterm trace. This is used in conjunction with the <CODE>^</CODE> command (set subterm), described below. If a subterm has been selected, <CODE>T</CODE> is printed as the sequence of commands used to select the subterm. Normally, however, <CODE>T</CODE> is printed as ' ', indicating that no subterm has been selected. 


<P>
The first number is the unique invocation identifier. It is always nondecreasing (provided that the debugger is switched on) regardless of whether or not the invocations are being actually seen. This number can be used to cross correlate the trace messages for the various ports, since it is unique for every invocation. It will also give an indication of the number of procedure calls made since the start of the execution. The invocation counter starts again for every fresh execution of a command, and it is also reset when retries (see later) are performed. 


<P>
The number following this is the <EM>current depth</EM>; i.e., the number of direct <EM>ancestors</EM> this goal has. The next word specifies the particular port (<CODE>Call</CODE>, <CODE>Exit</CODE>, <CODE>Redo</CODE> or <CODE>Fail</CODE>). The goal is then printed so that its current instantiation state can be inspected. The final <CODE>?</CODE> is the prompt indicating that the debugger is waiting for user interaction. One of the option codes allowed (see below) can be input at this point. 


<P>
The second format, quite similar to the format explained above, is shown when using source-level debugging outside the Ciao 
<A NAME="IDX702"></A>
<CODE>emacs</CODE> mode, and it is as follows: 



<PRE>
	   In /home/mcarlos/ciao/foo.pl (5-9) descendant-1
S  13  7  Call: T user:descendant(dani,_123) ?
</PRE>

<P>
This format is identical to the format above except for the first line, which contains the information for location of the point in the source program text where execution is currently at. The first line contains the name of the source file, the start and end lines where the literal can be found, the substring to search for between those lines and the number of substrings to locate. This information for locating the point on the source file is not shown when executing the source-level debugger from the Ciao 
<A NAME="IDX703"></A>
<CODE>emacs</CODE> mode. 


<P>
Ports can be "unleashed" by calling the 
<A NAME="IDX704"></A>
<CODE>leash/1</CODE> predicate omiting that port in the argument. This means that the debugger will stop but user interaction is not possible for an unleashed port. Obviously, the <CODE>?</CODE> prompt will not be shown in such messages, since the user has specified that no interaction is desired at this point. 




<H2><A NAME="SEC78" HREF="ciao_toc.html#TOC78">Options available during debugging</A></H2>
<P>
<A NAME="IDX705"></A>
<A NAME="IDX706"></A>


<P>
This section describes the particular options that are available when the debugger prompts after printing out a debugging message. All the options are one letter mnemonics, some of which can be optionally followed by a decimal integer. They are read from the terminal with any blanks being completely ignored up to the next terminator (carriage-return, line-feed, or escape). Some options only actually require the terminator; e.g., the creep option, only requires <KBD>RET</KBD>. 


<P>
The only option which really needs to be remembered is '<CODE>h</CODE>' (followed by <KBD>RET</KBD>). This provides help in the form of the following list of available options. 



<PRE>
&#60;cr&#62;   creep            c      creep
 l     leap             s      skip
 r     retry            r &#60;i&#62;  retry i
 f     fail             f &#60;i&#62;  fail i
 d     display          p      print
 w     write
 g     ancestors        g &#60;n&#62;  ancestors n
 n     nodebug          =      debugging
 +     spy this         -      nospy this
 a     abort            
 @     command          u      unify
 &#60;     reset printdepth &#60; &#60;n&#62;  set printdepth
 ^     reset subterm    ^ &#60;n&#62;  set subterm
 ?     help             h      help
</PRE>


<UL>

<LI><CODE>c</CODE> (

<A NAME="IDX707"></A>
<A NAME="IDX708"></A>
<EM>creep</EM>) 

causes the debugger to single-step to the very next port and print a message. Then if the port is leashed the user is prompted for further interaction. Otherwise it continues creeping. If leashing is off, creep is the same as leap (see below) except that a complete trace is printed on the terminal. 

<LI><CODE>l</CODE> (

<A NAME="IDX709"></A>
<A NAME="IDX710"></A>
<EM>leap</EM>) 

causes the interpreter to resume running the program, only stopping when a spy-point or breakpoint is reached (or when the program terminates). Leaping can thus be used to follow the execution at a higher level than exhaustive tracing. All that is needed to do is to set spy-points and breakpoints on an evenly spread set of pertinent predicates or lines, and then follow the control flow through these by leaping from one to the other. 

<LI><CODE>s</CODE> (

<A NAME="IDX711"></A>
<A NAME="IDX712"></A>
<EM>skip</EM>) 

is only valid for Call and Redo ports, if it is issued in Exit or Fail ports it is equivalent to creep. It skips over the entire execution of the predicate. That is, no message will be seen until control comes back to this predicate (at either the Exit port or the Fail port). Skip is particularly useful while creeping since it guarantees that control will be returned after the (possibly complex) execution within the box. With skip then no message at all will appear until control returns to the Exit port or Fail port corresponding to this Call port or Redo port. This includes calls to predicates with spy-points and breakpoints set: they will be masked out during the skip. There is a way of overriding this: the <CODE>t</CODE> option after a <KBD>^C</KBD> interrupt will disable the masking. Normally, however, this masking is just what is required! 

<LI><CODE>r</CODE> (

<A NAME="IDX713"></A>
<A NAME="IDX714"></A>
<EM>retry</EM>) 

can be used at any of the four ports (although at the Call port it has no effect). It transfers control back to the Call port of the box. This allows restarting an invocation when, for example, it has left the programmer with some weird result. The state of execution is exactly the same as in the original call (unless the invocation has performed side effects, which will not be undone). When a retry is performed the invocation counter is reset so that counting will continue from the current invocation number regardless of what happened before the retry. This is in accord with the fact that execution has, in operational terms, returned to the state before anything else was called. 

If an integer is supplied after the retry command, then this is taken as specifying an invocation number and the system tries to get to the Call port, not of the current box, but of the invocation box specified. It does this by continuously failing until it reaches the right place. Unfortunately this process cannot be guaranteed: it may be the case that the invocation the programmer is looking for has been cut out of the search space by cuts in the program. In this case the system fails to the latest surviving Call port before the correct one. 

<LI><CODE>f</CODE> (

<A NAME="IDX715"></A>
<A NAME="IDX716"></A>
<EM>fail</EM>) 

can be used at any of the four ports (although at the Fail port it has no effect). It transfers control to the Fail port of the box, forcing the invocation to fail prematurely. If an integer is supplied after the command, then this is taken as specifying an invocation number and the system tries to get to the Fail port of the invocation box specified. It does this by continuously failing until it reaches the right place. Unfortunately, as before, this process cannot be guaranteed. 

<LI><CODE>d</CODE> (

<A NAME="IDX717"></A>
<A NAME="IDX718"></A>
<EM>display</EM>) 

displays the current goal using <CODE>display/1</CODE>. See <CODE>w</CODE> below. 

<LI><CODE>p</CODE> (

<A NAME="IDX719"></A>
<A NAME="IDX720"></A>
<EM>print</EM>) 

re-prints the current goal using <CODE>print/1</CODE>. Nested structures will be printed to the specified <EM>printdepth</EM> (see below). 

<LI><CODE>w</CODE> (

<A NAME="IDX721"></A>
<A NAME="IDX722"></A>
<EM>write</EM>) 

writes the current goal on the terminal using <CODE>write/1</CODE>. 

<LI><CODE>g</CODE> (

<A NAME="IDX723"></A>
<A NAME="IDX724"></A>
<EM>ancestors</EM>) 

provides a list of ancestors to the current goal, i.e., all goals that are hierarchically above the current goal in the calling sequence. It is always possible to jump to any goal in the ancestor list (by using retry, etc.). If an integer <CODE>n</CODE> is supplied, then only <CODE>n</CODE> ancestors will be printed. That is to say, the last <CODE>n</CODE> ancestors will be printed counting back from the current goal. Each entry in the list is preceded by the invocation number followed by the depth number (as would be given in a trace message). 

<LI><CODE>n</CODE> (

<A NAME="IDX725"></A>
<A NAME="IDX726"></A>
<EM>nodebug</EM>) 

switches the debugger off. Note that this is the correct way to switch debugging off at a trace point. The <CODE>@</CODE> option cannot be used because it always returns to the debugger. 

<LI><CODE>=</CODE> (

<A NAME="IDX727"></A>
<A NAME="IDX728"></A>
<EM>debugging</EM>) 

outputs information concerning the status of the current debugging session. 

<LI><CODE>+</CODE>

<A NAME="IDX729"></A>
<A NAME="IDX730"></A>
<EM>spy</EM> 

sets a spy-point on the current goal. 

<LI><CODE>-</CODE> (

<A NAME="IDX731"></A>
<A NAME="IDX732"></A>
<EM>nospy</EM>) 

removes the spy-point from the current goal. 

<LI><CODE>a</CODE> (

<A NAME="IDX733"></A>
<A NAME="IDX734"></A>
<EM>abort</EM>) 

causes an abort of the current execution. All the execution states built so far are destroyed and the system is put right back at the top-level of the interpreter. (This is the same as the built-in predicate <CODE>abort/0</CODE>.) 

<LI><CODE>@</CODE> (

<A NAME="IDX735"></A>
<A NAME="IDX736"></A>
<EM>command</EM>) 

allows calling arbitrary goals. The initial message <CODE>| ?- </CODE> will be output on the terminal, and a command is then read from the terminal and executed as if it was at top-level. 

<LI><CODE>u</CODE> (

<A NAME="IDX737"></A>
<A NAME="IDX738"></A>
<EM>unify</EM>() 

is available at the Call port and gives the option of providing a solution to the goal from the terminal rather than executing the goal. This is convenient, e.g., for providing a "stub" for a predicate that has not yet been written. A prompt <CODE>|: </CODE> will be output on the terminal, and the solution is then read from the terminal and unified with the goal. 

<LI><CODE>&#60;</CODE> (

<A NAME="IDX739"></A>
<A NAME="IDX740"></A>
<EM>printdepth</EM>) 

sets a limit for the subterm nesting level that is printed in messages. While in the debugger, a printdepth is in effect for limiting the subterm nesting level when printing the current goal. When displaying or writing the current goal, all nesting levels are shown. The limit is initially 10. This command, without arguments, resets the limit to 10. With an argument of <CODE>n</CODE> the limit is set to <CODE>n</CODE>. 

<LI><CODE>^</CODE> (

<A NAME="IDX741"></A>
<A NAME="IDX742"></A>
<EM>subterm</EM>) 

sets the subterm to be printed in messages. While at a particular port, a current subterm of the current goal is maintained. It is the current subterm which is displayed, printed, or written when prompting for a debugger command. Used in combination with the printdepth, this provides a means for navigating in the current goal for focusing on the part which is of interest. The current subterm is set to the current goal when arriving at a new port. This command, without arguments, resets the current subterm to the current goal. With an argument of <CODE>n</CODE> (greater than 0 and less or equal to the number of subterms of the current subterm), the current subterm is replaced by its <CODE>n</CODE>'th subterm. With an argument of <CODE>0</CODE>, the current subterm is replaced by its parent term. 

<LI><CODE>?</CODE> or <CODE>h</CODE> (

<A NAME="IDX743"></A>
<A NAME="IDX744"></A>
<EM>help</EM>) 

displays the table of options given above. 

</UL>



<H2><A NAME="SEC79" HREF="ciao_toc.html#TOC79">Calling predicates that are not exported by a module</A></H2>

<P>
The Ciao module system does not allow calling predicates which are not exported during debugging. However, as an aid during debugging, this is allowed (only from the top-level and for modules which are in debug mode or source-level debug mode) using the 
<A NAME="IDX745"></A>
<CODE>call_in_module/2</CODE> predicate. 


<P>
Note that this does not affect analysis or optimization issues, since it only works on modules which are loaded in debug mode or source-level debug mode, i.e. unoptimized. 




<H2><A NAME="SEC80" HREF="ciao_toc.html#TOC80">Acknowledgements</A></H2>

<P>
Originally written by Andrzej Ciepielewski. Minor modifications by Mats Carlsson. Later modifications (17 Dec 87) by Takashi Chikayama (making tracer to use 
<A NAME="IDX746"></A>
<CODE>print/1</CODE> rather than 
<A NAME="IDX747"></A>
<CODE>write/1</CODE>, temporarily switching debugging flag off while writing trace message and within "break" level). Additional modifications by Kish Shen (May 88): subterm navigation, handle unbound args in 
<A NAME="IDX748"></A>
<CODE>spy/1</CODE> and 
<A NAME="IDX749"></A>
<CODE>nospy/1</CODE>, trapping arithmetics errors in debug mode. Adapted then to &#38;-Prolog and Ciao by D. Cabeza and included in the Ciao version control system. Extended for source-level debugging by Manuel C. Rodr&iacute;guez. (See changelog if included in the document for more detailed documentation of the later changes.) 


<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_7.html">previous</A>, <A HREF="ciao_9.html">next</A>, <A HREF="ciao_241.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
