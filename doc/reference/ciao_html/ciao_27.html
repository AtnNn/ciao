<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 27 August 2003 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - Changing system behaviour and various flags</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_26.html">previous</A>, <A HREF="ciao_28.html">next</A>, <A HREF="ciao_232.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC163" HREF="ciao_toc.html#TOC163">Changing system behaviour and various flags</A></H1>
<P>
<A NAME="IDX1827"></A>


<P>
<STRONG>Author(s):</STRONG> Daniel Cabeza, Mats Carlsson.


<P>
<STRONG>Version:</STRONG> 1.9#93 (2003/7/29, 17:53:15 CEST)


<P>
<STRONG>Version of last change:</STRONG> 1.7#213 (2002/5/14, 18:11:29 CEST)


<P>
<A NAME="IDX1828"></A>
<A NAME="IDX1829"></A>
Flags define some parameters of the system and control the behavior of system or library predicates. Each flag has a name and an associated predefined value, and except some system flags which are fixed in general their associated value is changeable. Predefined flags in the system are: 


<DL COMPACT>

<DT><CODE>version</CODE>
<DD>
The Ciao version, as a term <CODE>ciao</CODE>(<CODE>Version</CODE>,<CODE>Patch</CODE>). <CODE>Version</CODE> is a floating point number, <CODE>Patch</CODE> is an integer. Unchangeable. 

<DT><CODE>argv</CODE>
<DD>
Its value is a list of atoms representing the program arguments supplied when the current executable was invoked. This is the value to which is instantiated the argument of the 
<A NAME="IDX1830"></A>
<CODE>main/1</CODE> predicate at executable startup. Unchangeable. 

<DT><CODE>bounded</CODE>
<DD>
It is <CODE>false</CODE>, to denote that the range of integers can be considered infinite (but see 
<A NAME="IDX1831"></A>
<CODE>int/1</CODE>). Unchangeable. <KBD> * ISO * </KBD>

<DT><CODE>fileerrors</CODE>
<DD>
If <CODE>on</CODE>, predicates handling files give errors (throw exceptions) when a file is inexistent or an operation is not allowed. If <CODE>off</CODE>, fail in that conditions. Initially <CODE>on</CODE>. 

<DT><CODE>gc</CODE>
<DD>
Controls whether garbage collection is done. May be <CODE>on</CODE> (default) or <CODE>off</CODE>. 

<DT><CODE>gc_margin</CODE>
<DD>
An integer <CODE>Margin</CODE>. If less than <CODE>Margin</CODE> kilobytes are reclaimed in a garbage collection then the size of the garbage collected area should be increased. Also, no garbage collection is attempted unless the garbage collected area has at least <CODE>Margin</CODE> kilobytes. Initially 500. 

<DT><CODE>gc_trace</CODE>
<DD>
Governs garbage collection trace messages. An element off <CODE>[on,off,terse,verbose]</CODE>. Initially <CODE>off</CODE>. 

<DT><CODE>integer_rounding_function</CODE>
<DD>
It is <CODE>toward_zero</CODE>, so that <CODE>-1 =:= -3//2</CODE> succeeds. Unchangeable. <KBD> * ISO * </KBD>

<DT><CODE>max_arity</CODE>
<DD>
It is 255, so that no compound term (or predicate) can have more than this number of arguments. Unchangeable. <KBD> * ISO * </KBD>

<DT><CODE>quiet</CODE>
<DD>
Controls which messages issued using 
<A NAME="IDX1832"></A>
<CODE>io_aux</CODE> are actually written. As the system uses that library to report its messages, this flag controls the <EM>verbosity</EM> of the system. Possible states of the flag are: 

<DL COMPACT>

<DT><CODE>on</CODE>
<DD>
No messages are reported. 

<DT><CODE>error</CODE>
<DD>
Only error messages are reported. 

<DT><CODE>warning</CODE>
<DD>
Only error and warning messages are reported. 

<DT><CODE>off</CODE>
<DD>
All messages are reported, except debug messages. This is the default state. 

<DT><CODE>debug</CODE>
<DD>
All messages, including debug messages, are reported. This is only intended for the system implementators. 

</DL>

<DT><CODE>unknown</CODE>
<DD>
Controls action on calls to undefined predicates. The possible states of the flag are: 

<DL COMPACT>

<DT><CODE>error</CODE>
<DD>
An error is thrown with the 
<A NAME="IDX1833"></A>
error term <CODE>existence_error(procedure, F/A)</CODE>. 

<DT><CODE>fail</CODE>
<DD>
The call simply fails. 

<DT><CODE>warning</CODE>
<DD>
A warning is written and the call fails. 

</DL>

The state is initially <CODE>error</CODE>. <KBD> * ISO * </KBD>

</DL>


<UL>
<LI><A HREF="ciao_27.html#SEC164">Usage and interface (prolog_flags)</A>
<LI><A HREF="ciao_27.html#SEC165">Documentation on exports (prolog_flags)</A>
<LI><A HREF="ciao_27.html#SEC166">Documentation on multifiles (prolog_flags)</A>
</UL>



<H2><A NAME="SEC164" HREF="ciao_toc.html#TOC164">Usage and interface (<CODE>prolog_flags</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

These predicates are builtin in Ciao, so nothing special has to be done to use them.

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX1834"></A>
<CODE>set_prolog_flag/2</CODE>, 
<A NAME="IDX1835"></A>
<CODE>current_prolog_flag/2</CODE>, 
<A NAME="IDX1836"></A>
<CODE>prolog_flag/3</CODE>, 
<A NAME="IDX1837"></A>
<CODE>push_prolog_flag/2</CODE>, 
<A NAME="IDX1838"></A>
<CODE>pop_prolog_flag/1</CODE>, 
<A NAME="IDX1839"></A>
<CODE>prompt/2</CODE>, 
<A NAME="IDX1840"></A>
<CODE>gc/0</CODE>, 
<A NAME="IDX1841"></A>
<CODE>nogc/0</CODE>, 
<A NAME="IDX1842"></A>
<CODE>fileerrors/0</CODE>, 
<A NAME="IDX1843"></A>
<CODE>nofileerrors/0</CODE>.

<LI><EM>Multifiles:</EM>

<A NAME="IDX1844"></A>
<CODE>define_flag/3</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC165" HREF="ciao_toc.html#TOC165">Documentation on exports (<CODE>prolog_flags</CODE>)</A></H2>
<P>
<A NAME="IDX1845"></A>
<A NAME="IDX1846"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>set_prolog_flag/2:</B>
<DD><A NAME="IDX1847"></A>


<P>
<CODE>set_prolog_flag(FlagName,Value)</CODE>


<P>
Set existing flag <CODE>FlagName</CODE> to <CODE>Value</CODE>.


<P>
<STRONG>Usage 2:</STRONG> 
<KBD> * ISO * </KBD>

<UL>
<LI><EM>The following properties should hold at call time:</EM>

<CODE>FlagName</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>Value</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1848"></A>
<A NAME="IDX1849"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>current_prolog_flag/2:</B>
<DD><A NAME="IDX1850"></A>


<P>
<CODE>current_prolog_flag(FlagName,Value)</CODE>


<P>
<CODE>FlagName</CODE> is an existing flag and <CODE>Value</CODE> is the value currently associated with it.


<P>
<STRONG>Usage 2:</STRONG> 
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Calls should, and exit will be compatible with:</EM>

<CODE>FlagName</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>Value</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
<LI><EM>The following properties hold upon exit:</EM>

<CODE>FlagName</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>Value</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1851"></A>
<A NAME="IDX1852"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>prolog_flag/3:</B>
<DD><A NAME="IDX1853"></A>


<P>
<CODE>prolog_flag(FlagName,OldValue,NewValue)</CODE>


<P>
<CODE>FlagName</CODE> is an existing flag, unify <CODE>OldValue</CODE> with the value associated with it, and set it to new value <CODE>NewValue</CODE>.


<P>
<STRONG>Usage 1:</STRONG> <CODE>prolog_flag(?atm,?term,+term)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>prolog_flag(?FlagName,-OldValue,-NewValue)</CODE>

<UL>
<LI><EM>Description:</EM> Same as <CODE>current_prolog_flag(<CODE>FlagName</CODE>, <CODE>OldValue</CODE>)</CODE>

<LI><EM>The following properties should hold at call time:</EM>

<CODE>FlagName</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

The terms <CODE>OldValue</CODE> and <CODE>NewValue</CODE> are strictly identical.
 (<CODE>term_compare:== /2</CODE>)
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

<P>
<STRONG>Usage 3:</STRONG> 

<UL>
<LI><EM>Calls should, and exit will be compatible with:</EM>

<CODE>FlagName</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>OldValue</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
<LI><EM>The following properties should hold at call time:</EM>

<CODE>NewValue</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
<LI><EM>The following properties hold upon exit:</EM>

<CODE>FlagName</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>OldValue</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

<P>
<STRONG>Usage 4:</STRONG> <CODE>prolog_flag(FlagName,OldValue,NewValue)</CODE>

<UL>
<LI><EM>Description:</EM> Same as <CODE>current_prolog_flag(<CODE>FlagName</CODE>, <CODE>OldValue</CODE>)</CODE>

<LI><EM>The following properties should hold at call time:</EM>

<CODE>OldValue</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)

<CODE>NewValue</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)

<CODE>FlagName</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

The terms <CODE>OldValue</CODE> and <CODE>NewValue</CODE> are strictly identical.
 (<CODE>term_compare:== /2</CODE>)
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1854"></A>
<A NAME="IDX1855"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>push_prolog_flag/2:</B>
<DD><A NAME="IDX1856"></A>


<P>
<CODE>push_prolog_flag(Flag,NewValue)</CODE>


<P>
Same as 
<A NAME="IDX1857"></A>
<CODE>set_prolog_flag/2</CODE>, but storing current value of <CODE>Flag</CODE> to restore it with 
<A NAME="IDX1858"></A>
<CODE>pop_prolog_flag/1</CODE>.


<P>
<STRONG>Usage 2:</STRONG> 

<UL>
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Flag</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>NewValue</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1859"></A>
<A NAME="IDX1860"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>pop_prolog_flag/1:</B>
<DD><A NAME="IDX1861"></A>


<P>
<CODE>pop_prolog_flag(Flag)</CODE>


<P>
Restore the value of <CODE>Flag</CODE> previous to the last non-canceled 
<A NAME="IDX1862"></A>
<CODE>push_prolog_flag/2</CODE> on it.


<P>
<STRONG>Usage 2:</STRONG> 

<UL>
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Flag</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1863"></A>
<A NAME="IDX1864"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>prompt/2:</B>
<DD><A NAME="IDX1865"></A>


<P>
<CODE>prompt(Old,New)</CODE>


<P>
Unify <CODE>Old</CODE> with the current prompt for reading, change it to <CODE>New</CODE>.


<P>
<STRONG>Usage 2:</STRONG> <CODE>prompt(Old,New)</CODE>

<UL>
<LI><EM>Description:</EM> Unify <CODE>Old</CODE> with the current prompt for reading without changing it.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Old</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)

<CODE>New</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)

The terms <CODE>Old</CODE> and <CODE>New</CODE> are strictly identical.
 (<CODE>term_compare:== /2</CODE>)
<LI><EM>The following properties hold upon exit:</EM>

<CODE>Old</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>New</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

<P>
<STRONG>Usage 3:</STRONG> 

<UL>
<LI><EM>Calls should, and exit will be compatible with:</EM>

<CODE>Old</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
<LI><EM>The following properties should hold at call time:</EM>

<CODE>New</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
<LI><EM>The following properties hold upon exit:</EM>

<CODE>Old</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

<P>
<STRONG>Usage 4:</STRONG> <CODE>prompt(Old,New)</CODE>

<UL>
<LI><EM>Description:</EM> Unify <CODE>Old</CODE> with the current prompt for reading without changing it.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Old</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)

<CODE>New</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)

The terms <CODE>Old</CODE> and <CODE>New</CODE> are strictly identical.
 (<CODE>term_compare:== /2</CODE>)
<LI><EM>The following properties hold upon exit:</EM>

<CODE>Old</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>New</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1866"></A>
<A NAME="IDX1867"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>gc/0:</B>
<DD><A NAME="IDX1868"></A>


<P>
<STRONG>Usage 1:</STRONG> 

<UL>
<LI><EM>Description:</EM> Enable garbage collection. Equivalent to <CODE>set_prolog_flag(gc, on)</CODE>

</UL>

<P>
<STRONG>Usage 2:</STRONG> 

<UL>
<LI><EM>Description:</EM> Enable garbage collection. Equivalent to <CODE>set_prolog_flag(gc, on)</CODE>

</UL>

</DL>

<P>
<A NAME="IDX1869"></A>
<A NAME="IDX1870"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>nogc/0:</B>
<DD><A NAME="IDX1871"></A>


<P>
<STRONG>Usage 1:</STRONG> 

<UL>
<LI><EM>Description:</EM> Disable garbage collection. Equivalent to <CODE>set_prolog_flag(gc, off)</CODE>

</UL>

<P>
<STRONG>Usage 2:</STRONG> 

<UL>
<LI><EM>Description:</EM> Disable garbage collection. Equivalent to <CODE>set_prolog_flag(gc, off)</CODE>

</UL>

</DL>

<P>
<A NAME="IDX1872"></A>
<A NAME="IDX1873"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>fileerrors/0:</B>
<DD><A NAME="IDX1874"></A>


<P>
<STRONG>Usage 1:</STRONG> 

<UL>
<LI><EM>Description:</EM> Enable reporting of file errors. Equivalent to <CODE>set_prolog_flag(fileerrors, on)</CODE>

</UL>

<P>
<STRONG>Usage 2:</STRONG> 

<UL>
<LI><EM>Description:</EM> Enable reporting of file errors. Equivalent to <CODE>set_prolog_flag(fileerrors, on)</CODE>

</UL>

</DL>

<P>
<A NAME="IDX1875"></A>
<A NAME="IDX1876"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>nofileerrors/0:</B>
<DD><A NAME="IDX1877"></A>


<P>
<STRONG>Usage 1:</STRONG> 

<UL>
<LI><EM>Description:</EM> Disable reporting of file errors. Equivalent to <CODE>set_prolog_flag(fileerrors, off)</CODE>

</UL>

<P>
<STRONG>Usage 2:</STRONG> 

<UL>
<LI><EM>Description:</EM> Disable reporting of file errors. Equivalent to <CODE>set_prolog_flag(fileerrors, off)</CODE>

</UL>

</DL>



<H2><A NAME="SEC166" HREF="ciao_toc.html#TOC166">Documentation on multifiles (<CODE>prolog_flags</CODE>)</A></H2>
<P>
<A NAME="IDX1878"></A>
<A NAME="IDX1879"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>define_flag/3:</B>
<DD><A NAME="IDX1880"></A>


<P>
<CODE>define_flag(Flag,Values,Default)</CODE>


<P>
New flags can be defined by writing facts of this predicate. <CODE>Flag</CODE> is the name of the new flag, <CODE>Values</CODE> defines the posible values for the flag (see below) and <CODE>Default</CODE> defines the predefined value associated with the flag (which should be compatible with <CODE>Values</CODE>).


<P>
The predicate is <EM>multifile</EM>.


<P>
<STRONG>Usage 1:</STRONG> <CODE>define_flag(-atm,Values,-atm)</CODE>

<UL>
<LI><EM>Description:</EM> Posible values for the flag are atoms.

Example: 

<PRE>
:- multifile define_flag/3.
define_flag(tmpdir, atom, '/tmp').
</PRE>

 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

The terms <CODE>Values</CODE> and <CODE>atom</CODE> are strictly identical.
 (<CODE>term_compare:== /2</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>define_flag(-atm,Values,-int)</CODE>

<UL>
<LI><EM>Description:</EM> Posible values for the flag are integers.

Example: 

<PRE>
:- multifile define_flag/3.
define_flag(max_connections, integer, 10).
</PRE>

 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

The terms <CODE>Values</CODE> and <CODE>integer</CODE> are strictly identical.
 (<CODE>term_compare:== /2</CODE>)
</UL>

<P>
<STRONG>Usage 3:</STRONG> <CODE>define_flag(Flag,Values,Default)</CODE>

<UL>
<LI><EM>Description:</EM> Posible values for the flag are the elements of <CODE>Values</CODE>.

Example: 

<PRE>
:- multifile define_flag/3.
define_flag(debug, [on,debug,trace,off], off).
</PRE>

 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>Flag</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>Values</CODE> is a list.
 (<CODE>basic_props:list/1</CODE>)
<LI><EM>The following properties should hold upon exit:</EM>

<CODE>Default</CODE> is an element of <CODE>Values</CODE>.
 (<CODE>basic_props:member/2</CODE>)
</UL>

</DL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_26.html">previous</A>, <A HREF="ciao_28.html">next</A>, <A HREF="ciao_232.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
