<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 28 November 1999 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - The stand-alone command-line compiler</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_4.html">previous</A>, <A HREF="ciao_6.html">next</A>, <A HREF="ciao_146.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC17" HREF="ciao_toc.html#TOC17">The stand-alone command-line compiler</A></H1>

<P>
<STRONG>Author(s):</STRONG> Daniel Cabeza and the CLIP Group.


<P>
<STRONG>Version:</STRONG> 1.3#120 (1999/11/26, 12:5:17 MET)


<P>
<STRONG>Version of last change:</STRONG> 0.9#103 (1999/5/30, 19:14:54 MEST)


<P>
<A NAME="IDX168"></A>
<CODE>ciaoc</CODE> is the Ciao stand-alone command-line compiler. 
<A NAME="IDX169"></A>
<CODE>ciaoc</CODE> can be used to create executables or to compile individual files to object code (to be later linked with other files). All these considerations apply also if the compilation is performed from the interactive top-level shell. 



<UL>
<LI><A HREF="ciao_5.html#SEC18">Building executables</A>
<LI><A HREF="ciao_5.html#SEC19">Paths used by the compiler during compilation</A>
<LI><A HREF="ciao_5.html#SEC20">Running the executables generated by the compiler</A>
<LI><A HREF="ciao_5.html#SEC21">Types of executables generated</A>
<LI><A HREF="ciao_5.html#SEC22">Intermediate files in the compilation process</A>
<LI><A HREF="ciao_5.html#SEC23">Usage (ciaoc)</A>
</UL>



<H2><A NAME="SEC18" HREF="ciao_toc.html#TOC18">Building executables</A></H2>

<P>
An 
<A NAME="IDX170"></A>
<A NAME="IDX171"></A>
<EM>executable</EM> can be built from a single file or from a collection of inter-related files. In the case of only one file, this file must define the predicate 
<A NAME="IDX172"></A>
<CODE>main/0</CODE> or 
<A NAME="IDX173"></A>
<CODE>main/1</CODE>. This predicate is the one which will be called when the executable is started. As an example, consider the following file, called <CODE>hello.pl</CODE>: 



<PRE>
main :-
     write('Hello world'), 
     nl.
</PRE>

<P>
It can be compiled using the 
<A NAME="IDX174"></A>
<CODE>ciaoc</CODE> standalone compiler as follows: 



<PRE>
/herme@clip:/tmp
[60]&#62; ciaoc hello

/herme@clip:/tmp
[61]&#62; 
</PRE>

<P>
This produces (in Un*x-like systems) an executable called <CODE>hello</CODE>, which can then run by simply typing its name: 



<PRE>
/herme@clip:/tmp
[61]&#62; hello
Hello world

</PRE>

<P>
If the application is composed of several files the process is identical. Assume <CODE>hello.pl</CODE> is now: 



<PRE>
:- use_module(aux,[p/1]).

main :-
     p(X),
     write(X), 
     nl.
</PRE>

<P>
where the file <CODE>aux.pl</CODE> contains: 



<PRE>
:- module(aux,[p/1]).

p('Hello world').
</PRE>

<P>
This can again be compiled using the 
<A NAME="IDX175"></A>
<CODE>ciaoc</CODE> standalone compiler as before: 



<PRE>
/herme@clip:/tmp
[60]&#62; ciaoc hello

/herme@clip:/tmp
[61]&#62; hello
Hello world

</PRE>

<P>
The invocation of <CODE>ciaoc hello</CODE> compiles the file <CODE>hello.pl</CODE> and all connected files that may need recompilation -- in this case the file <CODE>aux.pl</CODE>. Also, if any library files used had not been compiled previously they would be compiled at this point (See section <A HREF="ciao_5.html#SEC22">Intermediate files in the compilation process</A>). Also, if, say, <CODE>hello.pl</CODE> is changed and recompiled, the object code resulting from the previous compilation of <CODE>aux.pl</CODE> will be reused. This is all done without any need for <CODE>Makefile</CODE>s, and considerably accelerates the development process for large applications. This process can be observed by selecting the <CODE>-v</CODE> option when invoking <CODE>ciaoc</CODE> (which is equivalent to setting the <CODE>verbose_compilation</CODE> Prolog flag in the top-level interpreter). 


<P>
If 
<A NAME="IDX176"></A>
<CODE>main/1</CODE> is defined instead of 
<A NAME="IDX177"></A>
<CODE>main/0</CODE> then when the executable is started the argument of 
<A NAME="IDX178"></A>
<CODE>main/1</CODE> will be instantiated to a list of atoms, each one of them corresponding to a command line option. Consider the file <CODE>say.pl</CODE>: 



<PRE>
main(Argv) :-
     write_list(Argv), nl.

write_list([]).
write_list([Arg|Args]) :- 
     write(Arg),
     write(' '),
     write_list(Args).
</PRE>

<P>
Compiling it and running it results in the following output: 



<PRE>
/herme@clip:/tmp
[91]&#62; ciaoc say

/herme@clip:/tmp
[91]&#62; say hello dolly
hello dolly 
</PRE>

<P>
The name of the generated executable can be controlled with the <CODE>-o</CODE> option (See section <A HREF="ciao_5.html#SEC23">Usage (ciaoc)</A>). 




<H2><A NAME="SEC19" HREF="ciao_toc.html#TOC19">Paths used by the compiler during compilation</A></H2>

<P>
The compiler will look for files mentioned in commands such as 
<A NAME="IDX179"></A>
<CODE>use_module/1</CODE> or 
<A NAME="IDX180"></A>
<CODE>ensure_loaded/1</CODE> in the current directory. Other paths can be added by including them in a file whose name is given to <CODE>ciaoc</CODE> using the <CODE>-u</CODE> option. This file should contain facts of the predicates 
<A NAME="IDX181"></A>
<CODE>file_search_path/2</CODE> and 
<A NAME="IDX182"></A>
<CODE>library_directory/1</CODE> (see the documentation for these predicates and also section <A HREF="ciao_10.html#SEC44">Customizing library paths and path aliases</A> for details). 




<H2><A NAME="SEC20" HREF="ciao_toc.html#TOC20">Running the executables generated by the compiler</A></H2>

<P>
<A NAME="IDX183"></A>
<A NAME="IDX184"></A>


<P>
What the <CODE>ciaoc</CODE> compiler generates and how it is started varies somewhat from OS to OS. In general, the product of compiling an application with <CODE>ciaoc</CODE> is a <EM>shell script</EM> that contains the bytecode (the product of the compilation) and invokes the 
<A NAME="IDX185"></A>
Ciao engine on it (see the first lines of the file). To run the generated executable from a Un*x shell, or from the 
<A NAME="IDX186"></A>
<CODE>bash</CODE> shell that comes with the Cygwin libraries (See section <A HREF="ciao_138.html#SEC477">Installation and compilation under Windows</A>) it suffices to type its name at the shell command line, as in the examples above. In a raw Win32 system, an additional <CODE>.bat</CODE> file is typically needed to start the application from the command line (or by double-clicking on it). The procedure for creating this 
<A NAME="IDX187"></A>
<CODE>.bat</CODE> file changes somewhat depending on the Win32 operating system used. In Windows NT you can simply copy 
<A NAME="IDX188"></A>
<CODE>winNT_skel.bat</CODE> (located in the 
<A NAME="IDX189"></A>
<CODE>win32</CODE> directory of the Ciao Prolog distribution) to the directory where the application is, and rename it to the name of the application to run (+ the <CODE>.bat</CODE> suffix). In Windows 95/98 you have to use the file 
<A NAME="IDX190"></A>
<CODE>win95_skel.bat</CODE> and change its name as before, but in addition you need to edit it to include the absolute path to the Ciao executable. We apologize for this (temporary) inconvenience, which we will try to smooth out in the near future by generating these <CODE>.bat</CODE> files automatically. 
 




<H2><A NAME="SEC21" HREF="ciao_toc.html#TOC21">Types of executables generated</A></H2>

<P>
<A NAME="IDX191"></A>
<A NAME="IDX192"></A>


<P>
While the default options used by 
<A NAME="IDX193"></A>
<CODE>ciaoc</CODE> are sufficient for normal use, by selecting other options 
<A NAME="IDX194"></A>
<CODE>ciaoc</CODE> can generate several different types of executables, which offer interesting tradeoffs among size of the generated executable, portability, and startup time: 


<DL COMPACT>

<DT>Dynamic executables:
<DD>
<A NAME="IDX195"></A>
<A NAME="IDX196"></A>

<A NAME="IDX197"></A>
<CODE>ciaoc</CODE> produces by default <EM>dynamic</EM> executables. In this case the executable produced is a 
<A NAME="IDX198"></A>
platform-independent file which includes in compiled form all the user defined files. On the other hand, any system libraries used by the application are loaded dynamically at startup. More precisely, any files that appear as <CODE>library(...)</CODE> in 
<A NAME="IDX199"></A>
<CODE>use_module/1</CODE> and 
<A NAME="IDX200"></A>
<CODE>ensure_loaded/1</CODE> declarations will not be included explicitly in the executable and will intead be loaded dynamically. Is is also possible to mark other 
<A NAME="IDX201"></A>
path aliases (see the documentation for 
<A NAME="IDX202"></A>
<CODE>file_search_path/2</CODE>) for dynamic loading by using the <CODE>-d</CODE> option. Files accessed through such aliases will also be loaded dynamically. 

Dynamic loading allows making smaller executables. Such executables may be used directly in the same machine in which they were compiled, since suitable paths to the location of the libraries will be included as default in the executable by 
<A NAME="IDX203"></A>
<CODE>ciaoc</CODE> during compilation. 

The executable can also be used in another machine, even if the architecture and OS are different. The requirement is that the Ciao libraries (which will also include the appropriate 
<A NAME="IDX204"></A>
Ciao engine for that architecture and OS) be installed in the target machine, and that the <CODE>CIAOLIB</CODE> and <CODE>CIAOENGINE</CODE> environment variables are set appropriately for the executable to be able to find them (see section <A HREF="ciao_138.html#SEC489">Environment variables used by Ciao executables</A>). How to do this differs slightly from OS to OS. 

<DT>Static executables:
<DD>
<A NAME="IDX205"></A>
<A NAME="IDX206"></A>

Selecting the <CODE>-s</CODE> option <CODE>ciaoc</CODE> produces a <EM>static</EM> executable. In this case the executable produced (again a 
<A NAME="IDX207"></A>
platform-independent file) will include in it all the auxiliary files and any system libraries needed by the application. Thus, such an executable is almost complete, needing in order to run only the 
<A NAME="IDX208"></A>
Ciao engine, which is platform-specific.<A NAME="DOCF1" HREF="ciao_foot.html#FOOT1">(1)</A> Again, if the executable is run in the same machine in which it was compiled then the engine is found automatically. If the executable is moved to another machine, the executable only needs access to a suitable engine (which can be done by setting the <CODE>CIAOENGINE</CODE> environment variable to point to this engine). 

This type of compilation produces larger executables, but has the advantage that these executables can be installed and run in a different machine, with different architecture and OS, even if Ciao is not installed on that machine. To install (or distribute) such an executable, one only needs to copy the executable file itself and the appropriate engine for the target platform (See section <A HREF="ciao_138.html#SEC474">Installing Ciao</A> and section <A HREF="ciao_138.html#SEC490">Multiarchitecture support</A>), and to set things so that the executable can find the engine. <A NAME="DOCF2" HREF="ciao_foot.html#FOOT2">(2)</A> 

<DT>Dynamic executables, with lazy loading:
<DD>
<A NAME="IDX209"></A>
<A NAME="IDX210"></A>

Selecting the <CODE>-ll</CODE> option is very similar to the case of dynamic executables above, except that the code in the library modules is not loaded when the program is started but rather it is done during execution, the first time a predicate defined in that file is called. This is advantageous if a large application is composed of many parts but is such that typically only some of the parts are used in each invocation. The Ciao preprocessor, 
<A NAME="IDX211"></A>
<CODE>ciaopp</CODE>, is a good example of this: it has many capabilitites but typically only some of them are used in a given session. An executable with lazy load has the advantage that it starts fast, loading a minimal functionality on startup, and then loads the different modules automatically as needed. 

</DL>



<H2><A NAME="SEC22" HREF="ciao_toc.html#TOC22">Intermediate files in the compilation process</A></H2>

<P>
Compiling an individual source (i.e., <CODE>.pl</CODE>) file produces a <CODE>.itf</CODE> file and a <CODE>.po</CODE> file. The <CODE>.itf</CODE> file contains information of the 
<A NAME="IDX212"></A>
<A NAME="IDX213"></A>
<EM>modular interface</EM> of the file, such as information on exported and imported predicates and on the other modules used by this module. This information is used to know if a given file should be recompiled at a given point in time and also to be able to detect more errors statically including undefined predicates, mismatches on predicate charaterictics across modules, etc. The <CODE>.po</CODE> file contains the platform-independent object code for a file, ready for linking (statically or dynamically). 


<P>
It is also possible to use <CODE>ciaoc</CODE> to explicitly generate the <CODE>.po</CODE> file for one or more <CODE>.pl</CODE> files by using the <CODE>-c</CODE> option. 




<H2><A NAME="SEC23" HREF="ciao_toc.html#TOC23">Usage (ciaoc)</A></H2>

<P>
The following provides details on the different command line options available when invoking 
<A NAME="IDX214"></A>
<CODE>ciaoc</CODE>: 



<PRE>
ciaoc &#60;MiscOpts&#62; &#60;ExecOpts&#62; [-o &#60;execname&#62;] &#60;file&#62; ...

  Make an executable from the listed files.  If there is
  more than one file, they must be non-module, and the
  first one must include the main predicate.  The -o
  option allows generating an arbitrary executable name.

ciaoc &#60;MiscOpts&#62; &#60;ExecOpts&#62; -a &#60;publishmod&#62; &#60;module&#62;

  Make an active module executable from &#60;module&#62; with
  address publish module &#60;publishmod&#62;.

ciaoc &#60;MiscOpts&#62; -c  &#60;file&#62; ...

  Compile listed files (make .po objects).

&#60;MiscOpts&#62; can be: [-v] [-u &#60;file&#62;]

-v  verbose mode

-u  use &#60;file&#62; for compilation

&#60;ExecOpts&#62; can be: [-s|-e|-l|(-ll &#60;module&#62;)*] (-d &#60;alias&#62;)*

-s  make a static executable (otherwise dynamic files are not included)

-e  make executable with eager load of dynamic files at startup (default)

-l  idem with lazy load of dynamic files (except insecure cases)

-ll force &#60;module&#62; to be loaded lazily,  implies -l

-d  files using this path alias are dynamic (default: library)

default extension for files is '.pl'

</PRE>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_4.html">previous</A>, <A HREF="ciao_6.html">next</A>, <A HREF="ciao_146.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
