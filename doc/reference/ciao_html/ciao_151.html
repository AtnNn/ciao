<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 14 June 2002 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - Low-level Java to Prolog interface</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_150.html">previous</A>, <A HREF="ciao_152.html">next</A>, <A HREF="ciao_223.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC600" HREF="ciao_toc.html#TOC600">Low-level Java to Prolog interface</A></H1>
<P>
<A NAME="IDX6117"></A>


<P>
<STRONG>Author(s):</STRONG> Jes&uacute;s Correas.


<P>
<STRONG>Version:</STRONG> 1.8#2 (2002/6/14, 18:55:4 CEST)


<P>
<STRONG>Version of last change:</STRONG> 1.7#125 (2001/10/17, 13:42:47 CEST)


<P>
 
<A NAME="IDX6118"></A>
<A NAME="IDX6119"></A>
This module defines a low level Java to Prolog interface. This Prolog side of the Java to Prolog interface only has one public predicate: a server that listens at the socket connection with Java, and executes the commands received from the Java side. 


<P>
In order to evaluate the goals received from the Java side, this module can work in two ways: executing them in the same engine, or starting a thread for each goal. The easiest way is to launch them in the same engine, but the goals must be evaluated sequentially: once a goal provides the first solution, all the subsequent goals must be finished before this goal can backtrack to provide another solution. The Prolog side of this interface works as a top-level, and the goals partially evaluated are not independent. 


<P>
The solution of this goal dependence is to evaluate the goals in a different prolog engine. Although Ciao includes a mechanism to evaluate goals in different engines, the approach used in this interface is to launch each goal in a different thread. 


<P>
The decision of what kind of goal evaluation is selected is done by the Java side. Each evaluation type has its own command terms, so the Java side can choose the type it needs. 


<P>
A Prolog server starts by calling the <CODE>prolog_server/0</CODE> predicate, or by calling <CODE>prolog_server/1</CODE> predicate and providing the port number as argument. The user predicates and libraries to be called from Java must be included in the executable file, or be accesible using the built-in predicates dealing with code loading. 



<UL>
<LI><A HREF="ciao_151.html#SEC601">Usage and interface (jtopl)</A>
<LI><A HREF="ciao_151.html#SEC602">Documentation on exports (jtopl)</A>
<LI><A HREF="ciao_151.html#SEC603">Documentation on internals (jtopl)</A>
</UL>



<H2><A NAME="SEC601" HREF="ciao_toc.html#TOC601">Usage and interface (<CODE>jtopl</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

<CODE>:- use_module(library(jtopl)).</CODE>

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX6120"></A>
<CODE>prolog_server/0</CODE>, 
<A NAME="IDX6121"></A>
<CODE>prolog_server/1</CODE>, 
<A NAME="IDX6122"></A>
<CODE>shell_s/0</CODE>, 
<A NAME="IDX6123"></A>
<CODE>query_solutions/2</CODE>, 
<A NAME="IDX6124"></A>
<CODE>query_requests/2</CODE>, 
<A NAME="IDX6125"></A>
<CODE>running_queries/2</CODE>.

</UL>

<LI><STRONG>Other modules used:</STRONG>


<UL>

<LI><EM>System library modules:</EM>

<A NAME="IDX6126"></A>
<CODE>concurrency/concurrency</CODE>, 
<A NAME="IDX6127"></A>
<CODE>system</CODE>, 
<A NAME="IDX6128"></A>
<CODE>read</CODE>, 
<A NAME="IDX6129"></A>
<CODE>write</CODE>, 
<A NAME="IDX6130"></A>
<CODE>dynamic</CODE>, 
<A NAME="IDX6131"></A>
<CODE>lists</CODE>, 
<A NAME="IDX6132"></A>
<CODE>format</CODE>, 
<A NAME="IDX6133"></A>
<CODE>compiler/compiler</CODE>, 
<A NAME="IDX6134"></A>
<CODE>atom2term</CODE>, 
<A NAME="IDX6135"></A>
<CODE>javall/javasock</CODE>, 
<A NAME="IDX6136"></A>
<CODE>prolog_sys</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC602" HREF="ciao_toc.html#TOC602">Documentation on exports (<CODE>jtopl</CODE>)</A></H2>
<P>
<A NAME="IDX6137"></A>
<A NAME="IDX6138"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>prolog_server/0:</B>
<DD><A NAME="IDX6139"></A>


<P>
<STRONG>Usage:</STRONG> 

<UL>
<LI><EM>Description:</EM> Prolog server entry point. Reads from the standard input the node name and port number where the java client resides, and starts the prolog server listening at the jp socket. This predicate acts as a server: it includes an endless read-process loop until the <CODE>prolog_halt</CODE> command is received.

<A NAME="IDX6140"></A>
<A NAME="IDX6141"></A>
 
</UL>

</DL>

<P>
<A NAME="IDX6142"></A>
<A NAME="IDX6143"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>prolog_server/1:</B>
<DD><A NAME="IDX6144"></A>


<P>
<STRONG>Usage:</STRONG> 

<UL>
<LI><EM>Description:</EM> Prolog server entry point. Given a port number, starts the prolog server listening at the jp socket. This predicate acts as a server: it includes an endless read-process loop until the <CODE>prolog_halt</CODE> command is received.

<A NAME="IDX6145"></A>
<A NAME="IDX6146"></A>
 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>Arg1</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX6147"></A>
<A NAME="IDX6148"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>shell_s/0:</B>
<DD><A NAME="IDX6149"></A>


<P>
<STRONG>Usage:</STRONG> 

<UL>
<LI><EM>Description:</EM> Command execution loop. This predicate is called when the connection to Java is established, and performs an endless loop processing the commands received.

</UL>

</DL>

<P>
<A NAME="IDX6150"></A>
<A NAME="IDX6151"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>query_solutions/2:</B>
<DD><A NAME="IDX6152"></A>


<P>
No further documentation available for this predicate.


<P>
The predicate is of type <EM>concurrent</EM>.


</DL>

<P>
<A NAME="IDX6153"></A>
<A NAME="IDX6154"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>query_requests/2:</B>
<DD><A NAME="IDX6155"></A>


<P>
No further documentation available for this predicate.


<P>
The predicate is of type <EM>concurrent</EM>.


</DL>

<P>
<A NAME="IDX6156"></A>
<A NAME="IDX6157"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>running_queries/2:</B>
<DD><A NAME="IDX6158"></A>


<P>
No further documentation available for this predicate.


<P>
The predicate is of type <EM>concurrent</EM>.


</DL>



<H2><A NAME="SEC603" HREF="ciao_toc.html#TOC603">Documentation on internals (<CODE>jtopl</CODE>)</A></H2>
<P>
<A NAME="IDX6159"></A>
<A NAME="IDX6160"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>command/1:</B>
<DD><A NAME="IDX6161"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>command(X)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>X</CODE> is a command received from the java client, to be executed by the Prolog process. The command is represented as an atom or a functor with arity 1. The command to be executed must be one of the following types:

<A NAME="IDX6162"></A>
<A NAME="IDX6163"></A>

<UL>

<LI><CODE>prolog_launch_query(Q)</CODE> Compound term to create a new query, received as single argument of this structure. A reference to the new query is returned to Java.

<LI><CODE>prolog_next_solution</CODE> Atom to get the next solution of a goal. A term representing the goal instantiated with the next solution is returned to Java.

<LI><CODE>prolog_execute</CODE> Atom to indicate that next solution of a goal must be got, without blocking the requester (it has to check if this goal is still running using prolog_is_running command).

<LI><CODE>prolog_terminate_query</CODE> Atom to indicate that a goal must be terminated.

<LI><CODE>prolog_use_module(M)</CODE> Compound term to load dynamically a module given as argument.

<LI><CODE>prolog_is_running</CODE> Atom to check if a goal is yet running a prolog_execute command.

<LI><CODE>prolog_halt</CODE> Atom to terminate the current Prolog process.

</UL>

 
</UL>

</DL>

<P>
<A NAME="IDX6164"></A>
<A NAME="IDX6165"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>answer/1:</B>
<DD><A NAME="IDX6166"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>answer(X)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>X</CODE> is a response sent from the prolog server. Is represented as an atom or a functor with arity 1 or 2, depending on the functor name.

<A NAME="IDX6167"></A>
<A NAME="IDX6168"></A>

 
</UL>

</DL>

<P>
<A NAME="IDX6169"></A>
<A NAME="IDX6170"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>process_command/1:</B>
<DD><A NAME="IDX6171"></A>


<P>
No further documentation available for this predicate.


</DL>

<P>
<A NAME="IDX6172"></A>
<A NAME="IDX6173"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>solve/2:</B>
<DD><A NAME="IDX6174"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>solve(+Query,+JId)</CODE>

<UL>
<LI><EM>Description:</EM> Runs the query on a separate thread and stores the solutions on the <CODE>query_solutions/2</CODE> data predicate.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Query</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)

<CODE>+JId</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX6175"></A>
<A NAME="IDX6176"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>prolog_parse/2:</B>
<DD><A NAME="IDX6177"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>prolog_parse(+String,-Term)</CODE>

<UL>
<LI><EM>Description:</EM> Parses the string received as first argument and returns the prolog term as second argument. <STRONG>Important:</STRONG> This is a private predicate but could be called from java side, to parse strings to Prolog terms.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+String</CODE> is a string (a list of character codes).
 (<CODE>basic_props:string/1</CODE>)

<CODE>-Term</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX6178"></A>
<A NAME="IDX6179"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>read_command/1:</B>
<DD><A NAME="IDX6180"></A>


<P>
No further documentation available for this predicate.


</DL>

<P>
<A NAME="IDX6181"></A>
<A NAME="IDX6182"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>write_answer/2:</B>
<DD><A NAME="IDX6183"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>write_answer(+Id,+Answer)</CODE>

<UL>
<LI><EM>Description:</EM> writes to the output socket stream the given answer.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Id</CODE> is a prolog query identifier.
 (<CODE>jtopl:prolog_query_id/1</CODE>)

<CODE>+Answer</CODE> is a response sent from the prolog server. Is represented as an atom or a functor with arity 1 or 2, depending on the functor name. 
<A NAME="IDX6184"></A>
<A NAME="IDX6185"></A>

 (<CODE>jtopl:answer/1</CODE>)
</UL>

</DL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_150.html">previous</A>, <A HREF="ciao_152.html">next</A>, <A HREF="ciao_223.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
