<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 12 December 2002 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - Types and properties related to assertions</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_58.html">previous</A>, <A HREF="ciao_60.html">next</A>, <A HREF="ciao_223.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC263" HREF="ciao_toc.html#TOC263">Types and properties related to assertions</A></H1>
<P>
<A NAME="IDX3079"></A>


<P>
<STRONG>Author(s):</STRONG> Manuel Hermenegildo.


<P>
<STRONG>Version:</STRONG> 1.8#1 (2002/5/27, 19:57:48 CEST)


<P>
<STRONG>Version of last change:</STRONG> 1.7#156 (2001/11/24, 13:23:30 CET)


<P>
This module is part of the 
<A NAME="IDX3080"></A>
<CODE>assertions</CODE> library. It provides the formal definition of the syntax of several forms of assertions and describes their meaning. It does so by defining types and properties related to the assertions themselves. The text describes, for example, the overall fields which are admissible in the bodies of assertions, where properties can be used inside these bodies, how to combine properties for a given predicate argument (e.g., conjunctions) , etc. and provides some examples.



<UL>
<LI><A HREF="ciao_59.html#SEC264">Usage and interface (assertions_props)</A>
<LI><A HREF="ciao_59.html#SEC265">Documentation on exports (assertions_props)</A>
</UL>



<H2><A NAME="SEC264" HREF="ciao_toc.html#TOC264">Usage and interface (<CODE>assertions_props</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

<CODE>:- use_module(library(assertions_props)).</CODE>

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Properties:</EM>

<A NAME="IDX3081"></A>
<CODE>head_pattern/1</CODE>, 
<A NAME="IDX3082"></A>
<CODE>nabody/1</CODE>, 
<A NAME="IDX3083"></A>
<CODE>docstring/1</CODE>.

<LI><EM>Regular Types:</EM>

<A NAME="IDX3084"></A>
<CODE>assrt_body/1</CODE>, 
<A NAME="IDX3085"></A>
<CODE>complex_arg_property/1</CODE>, 
<A NAME="IDX3086"></A>
<CODE>property_conjunction/1</CODE>, 
<A NAME="IDX3087"></A>
<CODE>property_starterm/1</CODE>, 
<A NAME="IDX3088"></A>
<CODE>complex_goal_property/1</CODE>, 
<A NAME="IDX3089"></A>
<CODE>dictionary/1</CODE>, 
<A NAME="IDX3090"></A>
<CODE>c_assrt_body/1</CODE>, 
<A NAME="IDX3091"></A>
<CODE>s_assrt_body/1</CODE>, 
<A NAME="IDX3092"></A>
<CODE>g_assrt_body/1</CODE>, 
<A NAME="IDX3093"></A>
<CODE>assrt_status/1</CODE>, 
<A NAME="IDX3094"></A>
<CODE>assrt_type/1</CODE>, 
<A NAME="IDX3095"></A>
<CODE>predfunctor/1</CODE>, 
<A NAME="IDX3096"></A>
<CODE>propfunctor/1</CODE>.

</UL>

<LI><STRONG>Other modules used:</STRONG>


<UL>

<LI><EM>System library modules:</EM>

<A NAME="IDX3097"></A>
<CODE>dcg_expansion</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC265" HREF="ciao_toc.html#TOC265">Documentation on exports (<CODE>assertions_props</CODE>)</A></H2>
<P>
<A NAME="IDX3098"></A>
<A NAME="IDX3099"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>assrt_body/1:</B>
<DD><A NAME="IDX3100"></A>


<P>
 
<A NAME="IDX3101"></A>
<A NAME="IDX3102"></A>
This predicate defines the different types of syntax admissible in the bodies of 
<A NAME="IDX3103"></A>
<CODE>pred/1</CODE>, 
<A NAME="IDX3104"></A>
<CODE>decl/1</CODE>, etc. assertions. Such a body is of the form: 



<PRE>
      Pr [:: DP] [: CP] [=&#62; AP] [+ GP] [# CO]
</PRE>

<P>
where (fields between [...] are optional): 



<UL>

<LI><CODE>Pr</CODE> is a

<A NAME="IDX3105"></A>
head pattern (
<A NAME="IDX3106"></A>
<CODE>head_pattern/1</CODE>) which describes the predicate or property and possibly gives some implicit call/answer information. 

<LI><CODE>DP</CODE> is a (possibly empty)

<A NAME="IDX3107"></A>
complex argument property (
<A NAME="IDX3108"></A>
<CODE>complex_arg_property/1</CODE>) which expresses properties which are 
<A NAME="IDX3109"></A>
compatible with the predicate, i.e., instantiations made by the predicate are <EM>compatible</EM> with the properties in the sense that applying the property at any point to would not make it fail. 

<LI><CODE>CP</CODE> is a (possibly empty)

<A NAME="IDX3110"></A>
complex argument property (
<A NAME="IDX3111"></A>
<CODE>complex_arg_property/1</CODE>) which applies to the <EM>calls</EM> to the predicate. 

<LI><CODE>AP</CODE> is a (possibly empty)

<A NAME="IDX3112"></A>
complex argument property (
<A NAME="IDX3113"></A>
<CODE>complex_arg_property/1</CODE>) which applies to the <EM>answers</EM> to the predicate (if the predicate succeeds). These only apply if the (possibly empty) properties given for calls in the assertion hold. 

<LI><CODE>GP</CODE> is a (possibly empty)

<A NAME="IDX3114"></A>
complex goal property (
<A NAME="IDX3115"></A>
<CODE>complex_goal_property/1</CODE>) which applies to the <EM>whole execution</EM> of a call to the predicate. These only apply if the (possibly empty) properties given for calls in the assertion hold. 

<LI><CODE>CO</CODE> is a

<A NAME="IDX3116"></A>
comment string (
<A NAME="IDX3117"></A>
<CODE>docstring/1</CODE>). This comment only applies if the (possibly empty) properties given for calls in the assertion hold. The usual formatting commands that are applicable in comment strings can be used (see 
<A NAME="IDX3118"></A>
<CODE>stringcommand/1</CODE>). 

See the 
<A NAME="IDX3119"></A>
<CODE>lpdoc</CODE> manual for documentation on assertion comments. 

</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>assrt_body(X)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>X</CODE> is an assertion body.

</UL>

</DL>

<P>
<A NAME="IDX3120"></A>
<A NAME="IDX3121"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>head_pattern/1:</B>
<DD><A NAME="IDX3122"></A>


<P>
A 
<A NAME="IDX3123"></A>
head pattern can be a predicate name (functor/arity) (
<A NAME="IDX3124"></A>
<CODE>predname/1</CODE>) or a term. Thus, both <CODE>p/3</CODE> and <CODE>p(A,B,C)</CODE> are valid head patterns. In the case in which the head pattern is a term, each argument of such a term can be: 



<UL>

<LI>A variable. This is useful in order to be able to refer to the corresponding argument positions by name within properties and in comments. Thus, <CODE>p(Input,Parameter,Output)</CODE> is a valid head pattern.

<LI>A ground term. In this case this term determines a property of the corresponding argument. The actual property referred to is that given by the term but with one more argument added at the beginning, which is a new variable which, in a rewriting of the head pattern, appears at the argument position occupied by the term. Unless otherwise stated (see below), the property built this way is understood to hold for both calls and answers. For example, the head pattern <CODE>p(Input,list(integer),Output)</CODE> is valid and equivalent for example to having the head pattern <CODE>p(Input,A,Output)</CODE> and stating that the property <CODE>list(A,integer)</CODE> holds for the calls and successes of the predicate.

<LI>Finally, it can also be a variable or a ground term, as above, but preceded by a "

<A NAME="IDX3125"></A>
mode." This mode determines in a compact way certain call or answer properties. For example, the head pattern <CODE>p(Input,+list(integer),Output)</CODE> is valid, as long as 
<A NAME="IDX3126"></A>
<CODE>+/1</CODE> is declared as a mode. 

Acceptable modes 
<A NAME="IDX3127"></A>
<A NAME="IDX3128"></A>
are documented in 
<A NAME="IDX3129"></A>
<CODE>library(modes)</CODE>. User defined modes are documented in 
<A NAME="IDX3130"></A>
<CODE>modedef/1</CODE>. 

</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>head_pattern(Pr)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Pr</CODE> is a head pattern.

</UL>

</DL>

<P>
<A NAME="IDX3131"></A>
<A NAME="IDX3132"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>complex_arg_property/1:</B>
<DD><A NAME="IDX3133"></A>


<P>
<CODE>complex_arg_property(Props)</CODE>


<P>
<CODE>Props</CODE> is a (possibly empty) 
<A NAME="IDX3134"></A>
complex argument property. Such properties can appear in two formats, which are defined by 
<A NAME="IDX3135"></A>
<CODE>property_conjunction/1</CODE> and 
<A NAME="IDX3136"></A>
<CODE>property_starterm/1</CODE> respectively. The two formats can be mixed provided they are not in the same field of an assertion. I.e., the following is a valid assertion: 


<P>
<CODE>:- pred foo(X,Y) : nonvar * var =&#62; (ground(X),ground(Y)).</CODE> 


<P>
<STRONG>Usage:</STRONG> <CODE>complex_arg_property(Props)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Props</CODE> is a (possibly empty) complex argument property

</UL>

</DL>

<P>
<A NAME="IDX3137"></A>
<A NAME="IDX3138"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>property_conjunction/1:</B>
<DD><A NAME="IDX3139"></A>


<P>
This type defines the first, unabridged format in which properties can be expressed in the bodies of assertions. It is essentially a conjunction of properties which refer to variables. The following is an example of a complex property in this format: 



<UL>

<LI><CODE>(integer(X),list(Y,integer))</CODE>: <CODE>X</CODE> has the property

<A NAME="IDX3140"></A>
<CODE>integer/1</CODE> and <CODE>Y</CODE> has the property 
<A NAME="IDX3141"></A>
<CODE>list/2</CODE>, with second argument <CODE>integer</CODE>. 

</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>property_conjunction(Props)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Props</CODE> is either a term or a <EM>conjunction</EM> of terms. The main functor and arity of each of those terms corresponds to the definition of a property. The first argument of each such term is a variable which appears as a head argument.

</UL>

</DL>

<P>
<A NAME="IDX3142"></A>
<A NAME="IDX3143"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>property_starterm/1:</B>
<DD><A NAME="IDX3144"></A>


<P>
This type defines a second, compact format in which properties can be expressed in the bodies of assertions. A 
<A NAME="IDX3145"></A>
<CODE>property_starterm/1</CODE> is a term whose main functor is 
<A NAME="IDX3146"></A>
<CODE>*/2</CODE> and, when it appears in an assertion, the number of terms joined by 
<A NAME="IDX3147"></A>
<CODE>*/2</CODE> is exactly the arity of the predicate it refers to. A similar series of properties as in 
<A NAME="IDX3148"></A>
<CODE>property_conjunction/1</CODE> appears, but the arity of each property is one less: the argument position to which they refer (first argument) is left out and determined by the position of the property in the 
<A NAME="IDX3149"></A>
<CODE>property_starterm/1</CODE>. The idea is that each element of the 
<A NAME="IDX3150"></A>
<CODE>*/2</CODE> term corresponds to a head argument position. Several properties can be assigned to each argument position by grouping them in curly brackets. The following is an example of a complex property in this format: 



<UL>

<LI><CODE> integer * list(integer)</CODE>: the first argument of the procedure (or function, or ...) has the property

<A NAME="IDX3151"></A>
<CODE>integer/1</CODE> and the second one has the property 
<A NAME="IDX3152"></A>
<CODE>list/2</CODE>, with second argument <CODE>integer</CODE>. 

<LI><CODE> {integer,var} * list(integer)</CODE>: the first argument of the procedure (or function, or ...) has the properties

<A NAME="IDX3153"></A>
<CODE>integer/1</CODE> and 
<A NAME="IDX3154"></A>
<CODE>var/1</CODE> and the second one has the property 
<A NAME="IDX3155"></A>
<CODE>list/2</CODE>, with second argument <CODE>integer</CODE>. 

</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>property_starterm(Props)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Props</CODE> is either a term or several terms separated by

<A NAME="IDX3156"></A>
<CODE>*/2</CODE>. The main functor of each of those terms corresponds to that of the definition of a property, and the arity should be one less than in the definition of such property. All arguments of each such term are ground. 
</UL>

</DL>

<P>
<A NAME="IDX3157"></A>
<A NAME="IDX3158"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>complex_goal_property/1:</B>
<DD><A NAME="IDX3159"></A>


<P>
<CODE>complex_goal_property(Props)</CODE>


<P>
<CODE>Props</CODE> is a (possibly empty) 
<A NAME="IDX3160"></A>
complex goal property. Such properties can be either a term or a <EM>conjunction</EM> of terms. The main functor and arity of each of those terms corresponds to the definition of a property. Such properties apply to all executions of all goals of the predicate which comply with the assertion in which the <CODE>Props</CODE> appear. 


<P>
The arguments of the terms in <CODE>Props</CODE> are implicitely augmented with a first argument which corresponds to a goal of the predicate of the assertion in which the <CODE>Props</CODE> appear. For example, the assertion 

<PRE>
     :- comp var(A) + not_further_inst(A).
</PRE>

<P>
has property 
<A NAME="IDX3161"></A>
<CODE>not_further_inst/1</CODE> as goal property, and establishes that in all executions of <CODE>var(A)</CODE> it should hold that <CODE>not_further_inst(var(A),A)</CODE>. 


<P>
<STRONG>Usage:</STRONG> <CODE>complex_goal_property(Props)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Props</CODE> is either a term or a <EM>conjunction</EM> of terms. The main functor and arity of each of those terms corresponds to the definition of a property. A first implicit argument in such terms identifies goals to which the properties apply.

</UL>

</DL>

<P>
<A NAME="IDX3162"></A>
<A NAME="IDX3163"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>nabody/1:</B>
<DD><A NAME="IDX3164"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>nabody(ABody)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>ABody</CODE> is a normalized assertion body.

</UL>

</DL>

<P>
<A NAME="IDX3165"></A>
<A NAME="IDX3166"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>dictionary/1:</B>
<DD><A NAME="IDX3167"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>dictionary(D)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>D</CODE> is a dictionary of variable names.

</UL>

</DL>

<P>
<A NAME="IDX3168"></A>
<A NAME="IDX3169"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>c_assrt_body/1:</B>
<DD><A NAME="IDX3170"></A>


<P>
 


<P>
<A NAME="IDX3171"></A>
<A NAME="IDX3172"></A>
This predicate defines the different types of syntax admissible in the bodies of 
<A NAME="IDX3173"></A>
<CODE>call/1</CODE>, 
<A NAME="IDX3174"></A>
<CODE>entry/1</CODE>, etc. assertions. The following are admissible: 



<PRE>
      Pr : CP [# CO]
</PRE>

<P>
where (fields between [...] are optional): 



<UL>

<LI><CODE>CP</CODE> is a (possibly empty)

<A NAME="IDX3175"></A>
complex argument property (
<A NAME="IDX3176"></A>
<CODE>complex_arg_property/1</CODE>) which applies to the <EM>calls</EM> to the predicate. 

<LI><CODE>CO</CODE> is a

<A NAME="IDX3177"></A>
comment string (
<A NAME="IDX3178"></A>
<CODE>docstring/1</CODE>). This comment only applies if the (possibly empty) properties given for calls in the assertion hold. The usual formatting commands that are applicable in comment strings can be used (see 
<A NAME="IDX3179"></A>
<CODE>stringcommand/1</CODE>). 

</UL>

<P>
The format of the different parts of the assertion body are given by 
<A NAME="IDX3180"></A>
<CODE>n_assrt_body/5</CODE> and its auxiliary types. 


<P>
<STRONG>Usage:</STRONG> <CODE>c_assrt_body(X)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>X</CODE> is a call assertion body.

</UL>

</DL>

<P>
<A NAME="IDX3181"></A>
<A NAME="IDX3182"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>s_assrt_body/1:</B>
<DD><A NAME="IDX3183"></A>


<P>
 


<P>
<A NAME="IDX3184"></A>
<A NAME="IDX3185"></A>
This predicate defines the different types of syntax admissible in the bodies of 
<A NAME="IDX3186"></A>
<CODE>pred/1</CODE>, 
<A NAME="IDX3187"></A>
<CODE>func/1</CODE>, etc. assertions. The following are admissible: 



<PRE>
      Pr : CP =&#62; AP # CO       
      Pr : CP =&#62; AP            
      Pr =&#62; AP # CO            
      Pr =&#62; AP                 
</PRE>

<P>
where: 



<UL>

<LI><CODE>Pr</CODE> is a

<A NAME="IDX3188"></A>
head pattern (
<A NAME="IDX3189"></A>
<CODE>head_pattern/1</CODE>) which describes the predicate or property and possibly gives some implicit call/answer information. 

<LI><CODE>CP</CODE> is a (possibly empty)

<A NAME="IDX3190"></A>
complex argument property (
<A NAME="IDX3191"></A>
<CODE>complex_arg_property/1</CODE>) which applies to the <EM>calls</EM> to the predicate. 

<LI><CODE>AP</CODE> is a (possibly empty)

<A NAME="IDX3192"></A>
complex argument property (
<A NAME="IDX3193"></A>
<CODE>complex_arg_property/1</CODE>) which applies to the <EM>answers</EM> to the predicate (if the predicate succeeds). These only apply if the (possibly empty) properties given for calls in the assertion hold. 

<LI><CODE>CO</CODE> is a

<A NAME="IDX3194"></A>
comment string (
<A NAME="IDX3195"></A>
<CODE>docstring/1</CODE>). This comment only applies if the (possibly empty) properties given for calls in the assertion hold. The usual formatting commands that are applicable in comment strings can be used (see 
<A NAME="IDX3196"></A>
<CODE>stringcommand/1</CODE>). 

</UL>

<P>
The format of the different parts of the assertion body are given by 
<A NAME="IDX3197"></A>
<CODE>n_assrt_body/5</CODE> and its auxiliary types. 


<P>
<STRONG>Usage:</STRONG> <CODE>s_assrt_body(X)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>X</CODE> is a predicate assertion body.

</UL>

</DL>

<P>
<A NAME="IDX3198"></A>
<A NAME="IDX3199"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>g_assrt_body/1:</B>
<DD><A NAME="IDX3200"></A>


<P>
 


<P>
<A NAME="IDX3201"></A>
<A NAME="IDX3202"></A>
This predicate defines the different types of syntax admissible in the bodies of 
<A NAME="IDX3203"></A>
<CODE>comp/1</CODE> assertions. The following are admissible: 



<PRE>
      Pr : CP + GP # CO        
      Pr : CP + GP             
      Pr + GP # CO             
      Pr + GP                  
</PRE>

<P>
where: 



<UL>

<LI><CODE>Pr</CODE> is a

<A NAME="IDX3204"></A>
head pattern (
<A NAME="IDX3205"></A>
<CODE>head_pattern/1</CODE>) which describes the predicate or property and possibly gives some implicit call/answer information. 

<LI><CODE>CP</CODE> is a (possibly empty)

<A NAME="IDX3206"></A>
complex argument property (
<A NAME="IDX3207"></A>
<CODE>complex_arg_property/1</CODE>) which applies to the <EM>calls</EM> to the predicate. 

<LI><CODE>GP</CODE> contains (possibly empty)

<A NAME="IDX3208"></A>
complex goal property (
<A NAME="IDX3209"></A>
<CODE>complex_goal_property/1</CODE>) which applies to the <EM>whole execution</EM> of a call to the predicate. These only apply if the (possibly empty) properties given for calls in the assertion hold. 

<LI><CODE>CO</CODE> is a

<A NAME="IDX3210"></A>
comment string (
<A NAME="IDX3211"></A>
<CODE>docstring/1</CODE>). This comment only applies if the (possibly empty) properties given for calls in the assertion hold. The usual formatting commands that are applicable in comment strings can be used (see 
<A NAME="IDX3212"></A>
<CODE>stringcommand/1</CODE>). 

</UL>

<P>
The format of the different parts of the assertion body are given by 
<A NAME="IDX3213"></A>
<CODE>n_assrt_body/5</CODE> and its auxiliary types. 


<P>
<STRONG>Usage:</STRONG> <CODE>g_assrt_body(X)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>X</CODE> is a comp assertion body.

</UL>

</DL>

<P>
<A NAME="IDX3214"></A>
<A NAME="IDX3215"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>assrt_status/1:</B>
<DD><A NAME="IDX3216"></A>


<P>
The types of assertion status. They have the same meaning as the program-point assertions, and are as follows: 

<PRE>
assrt_status(true).
assrt_status(false).
assrt_status(check).
assrt_status(checked).
assrt_status(trust).
</PRE>

<P>
<STRONG>Usage:</STRONG> <CODE>assrt_status(X)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>X</CODE> is an acceptable status for an assertion.

</UL>

</DL>

<P>
<A NAME="IDX3217"></A>
<A NAME="IDX3218"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>assrt_type/1:</B>
<DD><A NAME="IDX3219"></A>


<P>
The admissible kinds of assertions: 

<PRE>
assrt_type(pred).
assrt_type(prop).
assrt_type(decl).
assrt_type(func).
assrt_type(calls).
assrt_type(success).
assrt_type(comp).
assrt_type(entry).
assrt_type(modedef).
</PRE>

<P>
<STRONG>Usage:</STRONG> <CODE>assrt_type(X)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>X</CODE> is an admissible kind of assertion.

</UL>

</DL>

<P>
<A NAME="IDX3220"></A>
<A NAME="IDX3221"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>predfunctor/1:</B>
<DD><A NAME="IDX3222"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>predfunctor(X)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>X</CODE> is a type of assertion which defines a predicate.

</UL>

</DL>

<P>
<A NAME="IDX3223"></A>
<A NAME="IDX3224"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>propfunctor/1:</B>
<DD><A NAME="IDX3225"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>propfunctor(X)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>X</CODE> is a type of assertion which defines a <EM>property</EM>.

</UL>

</DL>

<P>
<A NAME="IDX3226"></A>
<A NAME="IDX3227"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>docstring/1:</B>
<DD><A NAME="IDX3228"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>docstring(String)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>String</CODE> is a text comment with admissible documentation commands. The usual formatting commands that are applicable in comment strings are defined by

<A NAME="IDX3229"></A>
<CODE>stringcommand/1</CODE>. See the 
<A NAME="IDX3230"></A>
<CODE>lpdoc</CODE> manual for documentation on comments.  
</UL>

</DL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_58.html">previous</A>, <A HREF="ciao_60.html">next</A>, <A HREF="ciao_223.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
