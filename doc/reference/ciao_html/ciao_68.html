<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 28 November 1999 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - Operating system utilities</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_67.html">previous</A>, <A HREF="ciao_69.html">next</A>, <A HREF="ciao_146.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC239" HREF="ciao_toc.html#TOC239">Operating system utilities</A></H1>
<P>
<A NAME="IDX2919"></A>


<P>
<STRONG>Author(s):</STRONG> Daniel Cabeza, Manuel Carro.


<P>
<STRONG>Version:</STRONG> 1.3#120 (1999/11/26, 12:5:17 MET)


<P>
<STRONG>Version of last change:</STRONG> 1.3#50 (1999/9/8, 22:35:15 MEST)


<P>
This module contains predicates for invoking services which are typically provided by the operating system. Note that the predicates which take names of files or directories as arguments in this module expect atoms, not 
<A NAME="IDX2920"></A>
path aliases. I.e., generally these predicates will not call 
<A NAME="IDX2921"></A>
<CODE>absolute_file_name/2</CODE> on names of files or directories taken as arguments.



<UL>
<LI><A HREF="ciao_68.html#SEC240">Usage and interface (system)</A>
<LI><A HREF="ciao_68.html#SEC241">Documentation on exports (system)</A>
</UL>



<H2><A NAME="SEC240" HREF="ciao_toc.html#TOC240">Usage and interface (<CODE>system</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

<CODE>:- use_module(library(system)).</CODE>

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX2922"></A>
<CODE>pause/1</CODE>, 
<A NAME="IDX2923"></A>
<CODE>time/1</CODE>, 
<A NAME="IDX2924"></A>
<CODE>datime/1</CODE>, 
<A NAME="IDX2925"></A>
<CODE>datime/9</CODE>, 
<A NAME="IDX2926"></A>
<CODE>getenvstr/2</CODE>, 
<A NAME="IDX2927"></A>
<CODE>extract_paths/2</CODE>, 
<A NAME="IDX2928"></A>
<CODE>get_pid/1</CODE>, 
<A NAME="IDX2929"></A>
<CODE>current_host/1</CODE>, 
<A NAME="IDX2930"></A>
<CODE>current_executable/1</CODE>, 
<A NAME="IDX2931"></A>
<CODE>umask/2</CODE>, 
<A NAME="IDX2932"></A>
<CODE>working_directory/2</CODE>, 
<A NAME="IDX2933"></A>
<CODE>cd/1</CODE>, 
<A NAME="IDX2934"></A>
<CODE>shell/0</CODE>, 
<A NAME="IDX2935"></A>
<CODE>shell/1</CODE>, 
<A NAME="IDX2936"></A>
<CODE>shell/2</CODE>, 
<A NAME="IDX2937"></A>
<CODE>system/1</CODE>, 
<A NAME="IDX2938"></A>
<CODE>system/2</CODE>, 
<A NAME="IDX2939"></A>
<CODE>popen/3</CODE>, 
<A NAME="IDX2940"></A>
<CODE>exec/4</CODE>, 
<A NAME="IDX2941"></A>
<CODE>exec/3</CODE>, 
<A NAME="IDX2942"></A>
<CODE>directory_files/2</CODE>, 
<A NAME="IDX2943"></A>
<CODE>mktemp/2</CODE>, 
<A NAME="IDX2944"></A>
<CODE>file_exists/1</CODE>, 
<A NAME="IDX2945"></A>
<CODE>file_exists/2</CODE>, 
<A NAME="IDX2946"></A>
<CODE>file_property/2</CODE>, 
<A NAME="IDX2947"></A>
<CODE>file_properties/6</CODE>, 
<A NAME="IDX2948"></A>
<CODE>modif_time/2</CODE>, 
<A NAME="IDX2949"></A>
<CODE>modif_time0/2</CODE>, 
<A NAME="IDX2950"></A>
<CODE>fmode/2</CODE>, 
<A NAME="IDX2951"></A>
<CODE>chmod/2</CODE>, 
<A NAME="IDX2952"></A>
<CODE>chmod/3</CODE>, 
<A NAME="IDX2953"></A>
<CODE>delete_file/1</CODE>.

<LI><EM>Regular Types:</EM>

<A NAME="IDX2954"></A>
<CODE>datime_struct/1</CODE>, 
<A NAME="IDX2955"></A>
<CODE>popen_mode/1</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC241" HREF="ciao_toc.html#TOC241">Documentation on exports (<CODE>system</CODE>)</A></H2>
<P>
<A NAME="IDX2956"></A>
<A NAME="IDX2957"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>pause/1:</B>
<DD><A NAME="IDX2958"></A>


<P>
<CODE>pause(Seconds)</CODE>


<P>
Make this thread sleep for some <CODE>Seconds</CODE>.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>pause(+int)</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX2959"></A>
<A NAME="IDX2960"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>time/1:</B>
<DD><A NAME="IDX2961"></A>


<P>
<CODE>time(Time)</CODE>


<P>
<CODE>Time</CODE> is unified with the number of seconds elapsed since January, 1, 1970 (UTC).


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>time(?(int))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX2962"></A>
<A NAME="IDX2963"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>datime/1:</B>
<DD><A NAME="IDX2964"></A>


<P>
<CODE>datime(Datime)</CODE>


<P>
<CODE>Datime</CODE> is unified with a term of the form <CODE>datime(Year,Month,Day,Hour,Minute,Second)</CODE> which contains the current date and time.


<P>
<STRONG>Usage:</STRONG> <CODE>datime(?(datime_struct))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX2965"></A>
<A NAME="IDX2966"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>datime/9:</B>
<DD><A NAME="IDX2967"></A>


<P>
<CODE>datime(Time,Year,Month,Day,Hour,Min,Sec,WeekDay,YearDay)</CODE>


<P>
<CODE>Time</CODE> is as in 
<A NAME="IDX2968"></A>
<CODE>time/1</CODE>. If given, the rest of the arguments are unified with the date and time to which the <CODE>Time</CODE> argument refers. If <CODE>Time</CODE> is unbound, it is bound to current time and the rest of the arguments refer to current time. <CODE>WeekDay</CODE> is the number of days since Sunday, in the range 0 to 6. <CODE>YearDay</CODE> is the number of days since January 1, in the range 0 to 365.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>datime(?(int),?(int),?(int),?(int),?(int),?(int),?(int),?(int),?(int))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX2969"></A>
<A NAME="IDX2970"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>datime_struct/1:</B>
<DD><A NAME="IDX2971"></A>


<P>
A regular type, defined as follows:

<PRE>

<PRE>
datime_struct(datime(Year,Month,Day,Hour,Min,Sec)) :-
        int(Year),
        int(Month),
        int(Day),
        int(Hour),
        int(Min),
        int(Sec).
</PRE>

</PRE>

<P>
<STRONG>Usage:</STRONG> 

<UL>
<LI><EM>The following properties hold globally:</EM>

Defines a regular type.
 (<CODE>basic_props:regtype/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2972"></A>
<A NAME="IDX2973"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>getenvstr/2:</B>
<DD><A NAME="IDX2974"></A>


<P>
<CODE>getenvstr(Name,Value)</CODE>


<P>
The environment variable <CODE>Name</CODE> has <CODE>Value</CODE>. Fails if variable <CODE>Name</CODE> is not defined.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>getenvstr(+atm,?(string))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX2975"></A>
<A NAME="IDX2976"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>extract_paths/2:</B>
<DD><A NAME="IDX2977"></A>


<P>
<CODE>extract_paths(String,Paths)</CODE>


<P>
Interpret <CODE>String</CODE> as the value of a UNIX environment variable holding a list of paths and return in <CODE>Paths</CODE> the list of the paths. Paths in <CODE>String</CODE> are separated by colons, and an empty path is considered a shorthand for '.' (current path). The most typical environment variable with this format is PATH. For example, this is a typical use: 

<PRE>
?- set_prolog_flag(write_strings, on).

yes
?- getenvstr('PATH', PATH), extract_paths(PATH, Paths).

PATH = ":/home/bardo/bin:/home/clip/bin:/opt/bin/:/bin",
Paths = [".","/home/bardo/bin","/home/clip/bin","/opt/bin/","/bin"] ?

yes
?- 
</PRE>

<P>
<STRONG>Usage:</STRONG> <CODE>extract_paths(+string,?(list(string)))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX2978"></A>
<A NAME="IDX2979"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>get_pid/1:</B>
<DD><A NAME="IDX2980"></A>


<P>
<CODE>get_pid(Pid)</CODE>


<P>
Unifies <CODE>Pid</CODE> with the process identificator of the current process or thread.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>get_pid(?(int))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX2981"></A>
<A NAME="IDX2982"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>current_host/1:</B>
<DD><A NAME="IDX2983"></A>


<P>
<CODE>current_host(Hostname)</CODE>


<P>
<CODE>Hostname</CODE> is unified with the fully qualified name of the host.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>current_host(?(atm))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX2984"></A>
<A NAME="IDX2985"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>current_executable/1:</B>
<DD><A NAME="IDX2986"></A>


<P>
<CODE>current_executable(Path)</CODE>


<P>
Unifies <CODE>Path</CODE> with the path to the current executable.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>current_executable(?(atm))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX2987"></A>
<A NAME="IDX2988"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>umask/2:</B>
<DD><A NAME="IDX2989"></A>


<P>
<CODE>umask(OldMask,NewMask)</CODE>


<P>
The process file creation mask was <CODE>OldMask</CODE>, and it is changed to <CODE>NewMask</CODE>.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage 1:</STRONG> <CODE>umask(?(int),+int)</CODE>

<UL>
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>umask(OldMask,NewMask)</CODE>

<UL>
<LI><EM>Description:</EM> Gets the process file creation mask without changing it.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>OldMask</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)

<CODE>NewMask</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)

The terms <CODE>OldMask</CODE> and <CODE>NewMask</CODE> are strictly identical.
 (<CODE>term_compare:== /2</CODE>)
<LI><EM>The following properties hold upon exit:</EM>

<CODE>OldMask</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)

<CODE>NewMask</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2990"></A>
<A NAME="IDX2991"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>working_directory/2:</B>
<DD><A NAME="IDX2992"></A>


<P>
<CODE>working_directory(OldDir,NewDir)</CODE>


<P>
Unifies current working directory with <CODE>OldDir</CODE>, and then changes the working directory to <CODE>NewDir</CODE>. Calling <CODE>working_directory(Dir,Dir)</CODE> simply unifies <CODE>Dir</CODE> with the current working directory without changing anything else.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage 1:</STRONG> <CODE>working_directory(?(atm),+atm)</CODE>

<UL>
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>working_directory(OldDir,NewDir)</CODE>

<UL>
<LI><EM>Description:</EM> Gets current working directory.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>OldDir</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)

<CODE>NewDir</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)

The terms <CODE>OldDir</CODE> and <CODE>NewDir</CODE> are strictly identical.
 (<CODE>term_compare:== /2</CODE>)
<LI><EM>The following properties hold upon exit:</EM>

<CODE>OldDir</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>NewDir</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2993"></A>
<A NAME="IDX2994"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>cd/1:</B>
<DD><A NAME="IDX2995"></A>


<P>
<CODE>cd(Path)</CODE>


<P>
Changes working directory to <CODE>Path</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>cd(+atm)</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX2996"></A>
<A NAME="IDX2997"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>shell/0:</B>
<DD><A NAME="IDX2998"></A>


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> 

<UL>
<LI><EM>Description:</EM> Execs the shell specified by the environment variable <CODE>SHELL</CODE>. When the shell process terminates, control is returned to Prolog.

</UL>

</DL>

<P>
<A NAME="IDX2999"></A>
<A NAME="IDX3000"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>shell/1:</B>
<DD><A NAME="IDX3001"></A>


<P>
<CODE>shell(Command)</CODE>


<P>
<CODE>Command</CODE> is executed in the shell specified by the environment variable <CODE>SHELL</CODE>. It succeeds if the exit code is zero and fails otherwise.


<P>
<STRONG>Usage:</STRONG> <CODE>shell(+atm)</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX3002"></A>
<A NAME="IDX3003"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>shell/2:</B>
<DD><A NAME="IDX3004"></A>


<P>
<CODE>shell(Command,ReturnCode)</CODE>


<P>
Executes <CODE>Command</CODE> in the shell specified by the environment variable <CODE>SHELL</CODE> and stores the exit code in <CODE>ReturnCode</CODE>.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>shell(+atm,?(int))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX3005"></A>
<A NAME="IDX3006"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>system/1:</B>
<DD><A NAME="IDX3007"></A>


<P>
<CODE>system(Command)</CODE>


<P>
Executes <CODE>Command</CODE> using the shell 
<A NAME="IDX3008"></A>
<CODE>/bin/sh</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>system(+atm)</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX3009"></A>
<A NAME="IDX3010"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>system/2:</B>
<DD><A NAME="IDX3011"></A>


<P>
<CODE>system(Command,ReturnCode)</CODE>


<P>
Executes <CODE>Command</CODE> in the 
<A NAME="IDX3012"></A>
<CODE>/bin/sh</CODE> shell and stores the exit code in <CODE>ReturnCode</CODE>.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>system(+atm,?(int))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX3013"></A>
<A NAME="IDX3014"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>popen/3:</B>
<DD><A NAME="IDX3015"></A>


<P>
<CODE>popen(Command,Mode,Stream)</CODE>


<P>
Open a pipe to process <CODE>Command</CODE> in a new shell with a given <CODE>Mode</CODE> and return a communication <CODE>Stream</CODE> (as in UNIX <CODE>popen(3)</CODE>). If <CODE>Mode</CODE> is <CODE>read</CODE> the output from the process is sent to <CODE>Stream</CODE>. If <CODE>Mode</CODE> is <CODE>write</CODE>, <CODE>Stream</CODE> is sent as input to the process. <CODE>Stream</CODE> may be read from or written into using the ordinary stream I/O predicates. <CODE>Stream</CODE> must be closed explicitly using 
<A NAME="IDX3016"></A>
<CODE>close/1</CODE>, i.e., it is not closed automatically when the process dies. 


<P>
<STRONG>Usage:</STRONG> <CODE>popen(+atm,+popen_mode,-(stream))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX3017"></A>
<A NAME="IDX3018"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>popen_mode/1:</B>
<DD><A NAME="IDX3019"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>popen_mode(M)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>M</CODE> is 'read' or 'write'.

<LI><EM>The following properties should hold globally:</EM>

Defines a regular type.
 (<CODE>basic_props:regtype/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3020"></A>
<A NAME="IDX3021"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>exec/4:</B>
<DD><A NAME="IDX3022"></A>


<P>
<CODE>exec(Command,StdIn,StdOut,StdErr)</CODE>


<P>
Starts the process <CODE>Command</CODE> and returns the I/O streams of the process in <CODE>StdIn</CODE>, <CODE>StdOut</CODE>, and <CODE>StdErr</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>exec(+atm,-(stream),-(stream),-(stream))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX3023"></A>
<A NAME="IDX3024"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>exec/3:</B>
<DD><A NAME="IDX3025"></A>


<P>
<CODE>exec(Command,StdIn,StdOut)</CODE>


<P>
Starts the process <CODE>Command</CODE> and returns the I/O streams of the process in <CODE>StdIn</CODE> and <CODE>StdOut</CODE>. <CODE>Standard error</CODE> is connected to whichever the parent process had it connected to.


<P>
<STRONG>Usage:</STRONG> <CODE>exec(+atm,-(stream),-(stream))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX3026"></A>
<A NAME="IDX3027"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>directory_files/2:</B>
<DD><A NAME="IDX3028"></A>


<P>
<CODE>directory_files(Directory,FileList)</CODE>


<P>
<CODE>FileList</CODE> is the unordered list of entries (files, directories, etc.) in <CODE>Directory</CODE>.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>directory_files(+atm,?(list(atm)))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX3029"></A>
<A NAME="IDX3030"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>mktemp/2:</B>
<DD><A NAME="IDX3031"></A>


<P>
<CODE>mktemp(Template,Filename)</CODE>


<P>
Returns a unique <CODE>Filename</CODE> based on <CODE>Template</CODE>: <CODE>Template</CODE> must be a valid file name with six trailing X, which are substituted to create a new file name.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>mktemp(+atm,?(atm))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX3032"></A>
<A NAME="IDX3033"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>file_exists/1:</B>
<DD><A NAME="IDX3034"></A>


<P>
<CODE>file_exists(File)</CODE>


<P>
Succeeds if <CODE>File</CODE> (a file or directory) exists (and is accessible).


<P>
<STRONG>Usage:</STRONG> <CODE>file_exists(+atm)</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX3035"></A>
<A NAME="IDX3036"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>file_exists/2:</B>
<DD><A NAME="IDX3037"></A>


<P>
<CODE>file_exists(File,Mode)</CODE>


<P>
<CODE>File</CODE> (a file or directory) exists and it is accessible with <CODE>Mode</CODE>, as in the Unix call <CODE>access(2)</CODE>. Typically, <CODE>Mode</CODE> is 4 for read permission, 2 for write permission and 1 for execute permission.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>file_exists(+atm,+int)</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX3038"></A>
<A NAME="IDX3039"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>file_property/2:</B>
<DD><A NAME="IDX3040"></A>


<P>
<CODE>file_property(File,Property)</CODE>


<P>
<CODE>File</CODE> has the property <CODE>Property</CODE>. The possible properties are: 


<DL COMPACT>

<DT>type(<CODE>Type</CODE>)
<DD>
<CODE>Type</CODE> is one of <CODE>regular</CODE>, <CODE>directory</CODE>, <CODE>symlink</CODE>, <CODE>fifo</CODE>, <CODE>socket</CODE> or <CODE>unknown</CODE>. 

<DT>linkto(<CODE>Linkto</CODE>)
<DD>
If <CODE>File</CODE> is a symbolic link, <CODE>Linkto</CODE> is the file pointed to by the link (and the other properties come from that file, not from the link itself). 

<DT>mod_time(<CODE>ModTime</CODE>)
<DD>
<CODE>ModTime</CODE> is the time of last modification (seconds since January, 1, 1970). 

<DT>mode(<CODE>Protection</CODE>)
<DD>
<CODE>Protection</CODE> is the protection mode. 

<DT>size(<CODE>Size</CODE>)
<DD>
<CODE>Size</CODE> is the size. 

</DL>

<P>
If <CODE>Property</CODE> is uninstantiated, the predicate will enumerate the properties on backtracking.


<P>
<STRONG>Usage:</STRONG> <CODE>file_property(+atm,?(struct))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX3041"></A>
<A NAME="IDX3042"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>file_properties/6:</B>
<DD><A NAME="IDX3043"></A>


<P>
<CODE>file_properties(Path,Type,Linkto,Time,Protection,Size)</CODE>


<P>
The file <CODE>Path</CODE> has the following properties: 



<UL>

<LI>File type <CODE>Type</CODE> (one of <CODE>regular</CODE>, <CODE>directory</CODE>, <CODE>symlink</CODE>, <CODE>fifo</CODE>, <CODE>socket</CODE> or <CODE>unknown</CODE>).

<LI>If <CODE>Path</CODE> is a symbolic link, <CODE>Linkto</CODE> is the file pointed to. All other properties come from the file pointed, not the link. <CODE>Linkto</CODE> is " if <CODE>Path</CODE> is not a symbolic link.

<LI>Time of last modification <CODE>Time</CODE> (seconds since January, 1, 1970).

<LI>Protection mode <CODE>Protection</CODE>.

<LI>Size in bytes <CODE>Size</CODE>.

</UL>

<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>file_properties(+atm,?(atm),?(atm),?(int),?(int),?(int))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX3044"></A>
<A NAME="IDX3045"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>modif_time/2:</B>
<DD><A NAME="IDX3046"></A>


<P>
<CODE>modif_time(File,Time)</CODE>


<P>
The file <CODE>File</CODE> was last modified at <CODE>Time</CODE>, which is in seconds since January, 1, 1970. Fails if <CODE>File</CODE> does not exist.


<P>
<STRONG>Usage:</STRONG> <CODE>modif_time(+atm,?(int))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX3047"></A>
<A NAME="IDX3048"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>modif_time0/2:</B>
<DD><A NAME="IDX3049"></A>


<P>
<CODE>modif_time0(File,Time)</CODE>


<P>
If <CODE>File</CODE> exists, <CODE>Time</CODE> is its latest modification time, as in 
<A NAME="IDX3050"></A>
<CODE>modif_time/2</CODE>. Otherwise, if <CODE>File</CODE> does not exist, <CODE>Time</CODE> is zero.


<P>
<STRONG>Usage:</STRONG> <CODE>modif_time0(+atm,?(int))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX3051"></A>
<A NAME="IDX3052"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>fmode/2:</B>
<DD><A NAME="IDX3053"></A>


<P>
<CODE>fmode(File,Mode)</CODE>


<P>
The file <CODE>File</CODE> has protection mode <CODE>Mode</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>fmode(+atm,?(int))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX3054"></A>
<A NAME="IDX3055"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>chmod/2:</B>
<DD><A NAME="IDX3056"></A>


<P>
<CODE>chmod(File,NewMode)</CODE>


<P>
Change the protection mode of file <CODE>File</CODE> to <CODE>NewMode</CODE>.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>chmod(+atm,+int)</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX3057"></A>
<A NAME="IDX3058"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>chmod/3:</B>
<DD><A NAME="IDX3059"></A>


<P>
<CODE>chmod(File,OldMode,NewMode)</CODE>


<P>
The file <CODE>File</CODE> has protection mode <CODE>OldMode</CODE> and it is changed to <CODE>NewMode</CODE>.


<P>
<STRONG>Usage 1:</STRONG> <CODE>chmod(+atm,?(int),+int)</CODE>

<UL>
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>chmod(File,OldMode,NewMode)</CODE>

<UL>
<LI><EM>Description:</EM> Equivalent to fmode(<CODE>File</CODE>,<CODE>OldMode</CODE>)

<LI><EM>The following properties should hold at call time:</EM>

<CODE>File</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>OldMode</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)

<CODE>NewMode</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)

The terms <CODE>OldMode</CODE> and <CODE>NewMode</CODE> are strictly identical.
 (<CODE>term_compare:== /2</CODE>)
<LI><EM>The following properties hold upon exit:</EM>

<CODE>File</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>OldMode</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>NewMode</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3060"></A>
<A NAME="IDX3061"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>delete_file/1:</B>
<DD><A NAME="IDX3062"></A>


<P>
<CODE>delete_file(File)</CODE>


<P>
Delete the file <CODE>File</CODE>.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>delete_file(+atm)</CODE>

<UL>
</UL>

</DL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_67.html">previous</A>, <A HREF="ciao_69.html">next</A>, <A HREF="ciao_146.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
