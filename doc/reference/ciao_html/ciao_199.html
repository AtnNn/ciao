<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 11 July 2001 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - lookup (library)</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_198.html">previous</A>, <A HREF="ciao_200.html">next</A>, <A HREF="ciao_216.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC750" HREF="ciao_toc.html#TOC750">lookup (library)</A></H1>
<P>
<A NAME="IDX7782"></A>


<P>
<STRONG>Version:</STRONG> 0.1 (1999/1/14, 13:30:46 MET)



<UL>
<LI><A HREF="ciao_199.html#SEC751">Usage and interface (lookup)</A>
<LI><A HREF="ciao_199.html#SEC752">Documentation on exports (lookup)</A>
</UL>



<H2><A NAME="SEC751" HREF="ciao_toc.html#TOC751">Usage and interface (<CODE>lookup</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

<CODE>:- use_module(library(lookup)).</CODE>

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX7783"></A>
<CODE>create_proto_element/3</CODE>, 
<A NAME="IDX7784"></A>
<CODE>get_prototype_interface/2</CODE>, 
<A NAME="IDX7785"></A>
<CODE>get_prototype_definition/2</CODE>, 
<A NAME="IDX7786"></A>
<CODE>lookup_check_node/4</CODE>, 
<A NAME="IDX7787"></A>
<CODE>lookup_check_field/6</CODE>, 
<A NAME="IDX7788"></A>
<CODE>lookup_check_interface_fieldValue/8</CODE>, 
<A NAME="IDX7789"></A>
<CODE>lookup_field/4</CODE>, 
<A NAME="IDX7790"></A>
<CODE>lookup_route/5</CODE>, 
<A NAME="IDX7791"></A>
<CODE>lookup_fieldTypeId/1</CODE>, 
<A NAME="IDX7792"></A>
<CODE>lookup_get_fieldType/4</CODE>, 
<A NAME="IDX7793"></A>
<CODE>lookup_field_access/4</CODE>, 
<A NAME="IDX7794"></A>
<CODE>lookup_set_def/3</CODE>, 
<A NAME="IDX7795"></A>
<CODE>lookup_set_prototype/4</CODE>, 
<A NAME="IDX7796"></A>
<CODE>lookup_set_extern_prototype/4</CODE>.

</UL>

<LI><STRONG>Other modules used:</STRONG>


<UL>

<LI><EM>Application modules:</EM>

<A NAME="IDX7797"></A>
<CODE>error</CODE>, 
<A NAME="IDX7798"></A>
<CODE>io</CODE>, 
<A NAME="IDX7799"></A>
<CODE>parser_util</CODE>, 
<A NAME="IDX7800"></A>
<CODE>dictionary</CODE>, 
<A NAME="IDX7801"></A>
<CODE>dictionary_tree</CODE>, 
<A NAME="IDX7802"></A>
<CODE>field_value_check</CODE>, 
<A NAME="IDX7803"></A>
<CODE>boundary</CODE>, 
<A NAME="IDX7804"></A>
<CODE>generator_util</CODE>, 
<A NAME="IDX7805"></A>
<CODE>field_type</CODE>.

<LI><EM>System library modules:</EM>

<A NAME="IDX7806"></A>
<CODE>aggregates</CODE>, 
<A NAME="IDX7807"></A>
<CODE>dynamic</CODE>, 
<A NAME="IDX7808"></A>
<CODE>iso_misc</CODE>, 
<A NAME="IDX7809"></A>
<CODE>iso_byte_char</CODE>, 
<A NAME="IDX7810"></A>
<CODE>iso_incomplete</CODE>, 
<A NAME="IDX7811"></A>
<CODE>operators</CODE>, 
<A NAME="IDX7812"></A>
<CODE>read</CODE>, 
<A NAME="IDX7813"></A>
<CODE>write</CODE>, 
<A NAME="IDX7814"></A>
<CODE>lists</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC752" HREF="ciao_toc.html#TOC752">Documentation on exports (<CODE>lookup</CODE>)</A></H2>
<P>
<A NAME="IDX7815"></A>
<A NAME="IDX7816"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>create_proto_element/3:</B>
<DD><A NAME="IDX7817"></A>


<P>
<STRONG>Usage 1:</STRONG> <CODE>create_proto_element(+Interface,+Definition,-Proto)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will construct a proto structure containing the interface and the definition.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Interface</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>+Definition</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>-Proto</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>create_proto_element(Interface,Definition,Proto)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will construct a proto structure containing the interface and the definition.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>Interface</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>Definition</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>Proto</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Interface</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>Definition</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>Proto</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX7818"></A>
<A NAME="IDX7819"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>get_prototype_interface/2:</B>
<DD><A NAME="IDX7820"></A>


<P>
<STRONG>Usage 1:</STRONG> <CODE>get_prototype_interface(+Proto,-Interface)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will return the interface from a proto structure.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Proto</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>-Interface</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>get_prototype_interface(Proto,Interface)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will return the interface from a proto structure.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>Proto</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>Interface</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Proto</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>Interface</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX7821"></A>
<A NAME="IDX7822"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>get_prototype_definition/2:</B>
<DD><A NAME="IDX7823"></A>


<P>
<STRONG>Usage 1:</STRONG> <CODE>get_prototype_definition(+Proto,-Definition)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will return the definition from a proto structure.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Proto</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>-Definition</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>get_prototype_definition(Proto,Definition)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will return the definition from a proto structure.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>Proto</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>Definition</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Proto</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>Definition</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX7824"></A>
<A NAME="IDX7825"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>lookup_check_node/4:</B>
<DD><A NAME="IDX7826"></A>


<P>
No further documentation available for this predicate.


</DL>

<P>
<A NAME="IDX7827"></A>
<A NAME="IDX7828"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>lookup_check_field/6:</B>
<DD><A NAME="IDX7829"></A>


<P>
No further documentation available for this predicate.


</DL>

<P>
<A NAME="IDX7830"></A>
<A NAME="IDX7831"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>lookup_check_interface_fieldValue/8:</B>
<DD><A NAME="IDX7832"></A>


<P>
No further documentation available for this predicate.


</DL>

<P>
<A NAME="IDX7833"></A>
<A NAME="IDX7834"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>lookup_field/4:</B>
<DD><A NAME="IDX7835"></A>


<P>
<STRONG>Usage 1:</STRONG> <CODE>lookup_field(+Parse,+FieldTypeId,+FieldId0,+FieldId1)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will control that the two connected Fields are of the same type, e.g., SFColor - SFColor, MFVec3f - MFVec3f.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>+FieldTypeId</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+FieldId0</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+FieldId1</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>lookup_field(Parse,FieldTypeId,FieldId0,FieldId1)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will control that the two connected Fields are of the same type, e.g., SFColor - SFColor, MFVec3f - MFVec3f.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>FieldTypeId</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>FieldId0</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>FieldId1</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Parse</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>FieldTypeId</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>FieldId0</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>FieldId1</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX7836"></A>
<A NAME="IDX7837"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>lookup_route/5:</B>
<DD><A NAME="IDX7838"></A>


<P>
<STRONG>Usage 1:</STRONG> <CODE>lookup_route(+Parse,+NodeTypeId0,+FieldId0,+NodeTypeId1,+FieldId1)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will check the routing behaviour for two given fields. They will be checked according to the binding rules, like name changes access proporties. The node types for the field must of course be given for the identification.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>+NodeTypeId0</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+FieldId0</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+NodeTypeId1</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+FieldId1</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>lookup_route(Parse,NodeTypeId0,FieldId0,NodeTypeId1,FieldId1)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will check the routing behaviour for two given fields. They will be checked according to the binding rules, like name changes access proporties. The node types for the field must of course be given for the identification.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>NodeTypeId0</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>FieldId0</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>NodeTypeId1</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>FieldId1</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Parse</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>NodeTypeId0</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>FieldId0</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>NodeTypeId1</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>FieldId1</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX7839"></A>
<A NAME="IDX7840"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>lookup_fieldTypeId/1:</B>
<DD><A NAME="IDX7841"></A>


<P>
<STRONG>Usage 1:</STRONG> <CODE>lookup_fieldTypeId(+FieldTypeId)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate just make a check to see if the given FieldType id is among the allowed. You can not construct own ones and the check is mearly a spellcheck.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+FieldTypeId</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>lookup_fieldTypeId(FieldTypeId)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate just make a check to see if the given FieldType id is among the allowed. You can not construct own ones and the check is mearly a spellcheck.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>FieldTypeId</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
<LI><EM>The following properties should hold at call time:</EM>

<CODE>FieldTypeId</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX7842"></A>
<A NAME="IDX7843"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>lookup_get_fieldType/4:</B>
<DD><A NAME="IDX7844"></A>


<P>
<STRONG>Usage 1:</STRONG> <CODE>lookup_get_fieldType(+Parse,+NodeTypeId,+fieldId,-FieldType)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will return the given field's type. It will start the search in the ordinar dictionary and then to the personal dictionary sarting off with 'PROTO'. After it will go for 'DEF' and 'EXTERNPROTO'.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>+NodeTypeId</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+fieldId</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>-FieldType</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>lookup_get_fieldType(Parse,NodeTypeId,Arg3,FieldType)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will return the given field's type. It will start the search in the ordinar dictionary and then to the personal dictionary sarting off with 'PROTO'. After it will go for 'DEF' and 'EXTERNPROTO'.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>NodeTypeId</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>Arg3</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>FieldType</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Parse</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>NodeTypeId</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>undefined:fieldId(Arg3)</CODE>
 (undefined property)

<CODE>FieldType</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX7845"></A>
<A NAME="IDX7846"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>lookup_field_access/4:</B>
<DD><A NAME="IDX7847"></A>


<P>
<STRONG>Usage 1:</STRONG> <CODE>lookup_field_access(+Parse,+NodenameId,+FieldId,+FieldId)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will control that the access proporties are correct according to the certain rules that we have. It makes a check to see if the fields are of the same access type or if one of them is an exposedField. It is not doing a route check up to control that behaviour entirely.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>+NodenameId</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+FieldId</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+FieldId</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>lookup_field_access(Parse,NodenameId,FieldId,FieldId)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will control that the access proporties are correct according to the certain rules that we have. It makes a check to see if the fields are of the same access type or if one of them is an exposedField. It is not doing a route check up to control that behaviour entirely.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>NodenameId</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>FieldId</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>FieldId</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Parse</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>NodenameId</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>FieldId</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>FieldId</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX7848"></A>
<A NAME="IDX7849"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>lookup_set_def/3:</B>
<DD><A NAME="IDX7850"></A>


<P>
<STRONG>Usage 1:</STRONG> <CODE>lookup_set_def(+Parse,+Name,+Node)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will enter a new post in the personal dictionary for the node definition.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>+Name</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+Node</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>lookup_set_def(Parse,Name,Node)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will enter a new post in the personal dictionary for the node definition.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>Name</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>Node</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Parse</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>Name</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>Node</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX7851"></A>
<A NAME="IDX7852"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>lookup_set_prototype/4:</B>
<DD><A NAME="IDX7853"></A>


<P>
<STRONG>Usage 1:</STRONG> <CODE>lookup_set_prototype(+Parse,+Name,+Interface,+Definition)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will insert the prototype definition in the personal dictionary and will give a warning if there is a multiple name given.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>+Name</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+Interface</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>+Definition</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>lookup_set_prototype(Parse,Name,Interface,Definition)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will insert the prototype definition in the personal dictionary and will give a warning if there is a multiple name given.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>Name</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>Interface</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>Definition</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Parse</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>Name</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>Interface</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>Definition</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX7854"></A>
<A NAME="IDX7855"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>lookup_set_extern_prototype/4:</B>
<DD><A NAME="IDX7856"></A>


<P>
<STRONG>Usage 1:</STRONG> <CODE>lookup_set_extern_prototype(+Parse,+Name,+Interface,+Strings)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will insert the external prototype definition in the personal dictionary and will give a warning if there is a multiple name given.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>+Name</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+Interface</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>+Strings</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>lookup_set_extern_prototype(Parse,Name,Interface,Strings)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will insert the external prototype definition in the personal dictionary and will give a warning if there is a multiple name given.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>Name</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>Interface</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>Strings</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Parse</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>Name</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>Interface</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)

<CODE>Strings</CODE> is currently a term which is not a free variable.
 (<CODE>term_typing:nonvar/1</CODE>)
</UL>

</DL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_198.html">previous</A>, <A HREF="ciao_200.html">next</A>, <A HREF="ciao_216.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
