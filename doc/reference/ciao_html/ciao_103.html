<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 5 May 2000 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - Run time usage of objects</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_102.html">previous</A>, <A HREF="ciao_104.html">next</A>, <A HREF="ciao_158.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC410" HREF="ciao_toc.html#TOC410">Run time usage of objects</A></H1>
<P>
<A NAME="IDX4341"></A>


<P>
<STRONG>Author(s):</STRONG> Angel Fernandez Pineda, Angel Fernandez Pineda.


<P>
<STRONG>Version:</STRONG> 1.5#118 (2000/4/19, 18:13:43 CEST)


<P>
<STRONG>Version of last change:</STRONG> 1.5#4 (1999/11/29, 19:11:21 MET)


<P>
This library provides run-time support for 
<A NAME="IDX4342"></A>
object creation and manipulation. Objects are also called 
<A NAME="IDX4343"></A>
class instances, or simply 
<A NAME="IDX4344"></A>
instances. 


<P>
Objects in Ciao are treated as normal modules. This is, an object is a run-time generated Prolog module, which may be identified by an unique term across the whole application. 


<P>
This is a very simple example of how to create an instance, and how to make calls to it: 



<PRE>
            AnObj new myclass,
            AnObj:mymethod.
</PRE>

<P>
In order to make any object accessible from code, an usage relationship must be established between the class (from which instances are derived) and the code itself. Refer to 
<A NAME="IDX4345"></A>
<CODE>use_class/1</CODE> predicate or 
<A NAME="IDX4346"></A>
<CODE>use_class/1</CODE> declaration in order to do so. 



<UL>
<LI><A HREF="ciao_103.html#SEC411">Usage and interface (objects_rt)</A>
<LI><A HREF="ciao_103.html#SEC412">Documentation on exports (objects_rt)</A>
<LI><A HREF="ciao_103.html#SEC413">Known bugs and planned improvements (objects_rt)</A>
</UL>



<H2><A NAME="SEC411" HREF="ciao_toc.html#TOC411">Usage and interface (<CODE>objects_rt</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

This library is automatically loaded when using the <EM>objects</EM> package: 

<PRE>
    :- module(<EM>ModuleName</EM>,<EM>Exports</EM>,[objects]).
</PRE>

Nothing special needs to be done. 

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX4347"></A>
<CODE>new/2</CODE>, 
<A NAME="IDX4348"></A>
<CODE>instance_of/2</CODE>, 
<A NAME="IDX4349"></A>
<CODE>derived_from/2</CODE>, 
<A NAME="IDX4350"></A>
<CODE>interface/2</CODE>, 
<A NAME="IDX4351"></A>
<CODE>instance_codes/2</CODE>, 
<A NAME="IDX4352"></A>
<CODE>destroy/1</CODE>, 
<A NAME="IDX4353"></A>
<CODE>use_class/1</CODE>.

<LI><EM>Properties:</EM>

<A NAME="IDX4354"></A>
<CODE>constructor/1</CODE>, 
<A NAME="IDX4355"></A>
<CODE>class_name/1</CODE>, 
<A NAME="IDX4356"></A>
<CODE>interface_name/1</CODE>, 
<A NAME="IDX4357"></A>
<CODE>instance_id/1</CODE>, 
<A NAME="IDX4358"></A>
<CODE>class_source/1</CODE>, 
<A NAME="IDX4359"></A>
<CODE>interface_source/1</CODE>, 
<A NAME="IDX4360"></A>
<CODE>method_spec/1</CODE>, 
<A NAME="IDX4361"></A>
<CODE>virtual_method_spec/1</CODE>.

</UL>

<LI><STRONG>Other modules used:</STRONG>


<UL>

<LI><EM>System library modules:</EM>

<A NAME="IDX4362"></A>
<CODE>aggregates</CODE>, 
<A NAME="IDX4363"></A>
<CODE>dynamic</CODE>, 
<A NAME="IDX4364"></A>
<CODE>iso_misc</CODE>, 
<A NAME="IDX4365"></A>
<CODE>iso_byte_char</CODE>, 
<A NAME="IDX4366"></A>
<CODE>iso_incomplete</CODE>, 
<A NAME="IDX4367"></A>
<CODE>operators</CODE>, 
<A NAME="IDX4368"></A>
<CODE>read</CODE>, 
<A NAME="IDX4369"></A>
<CODE>streams</CODE>, 
<A NAME="IDX4370"></A>
<CODE>write</CODE>, 
<A NAME="IDX4371"></A>
<CODE>dynmods</CODE>, 
<A NAME="IDX4372"></A>
<CODE>prolog_sys</CODE>, 
<A NAME="IDX4373"></A>
<CODE>system</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC412" HREF="ciao_toc.html#TOC412">Documentation on exports (<CODE>objects_rt</CODE>)</A></H2>
<P>
<A NAME="IDX4374"></A>
<A NAME="IDX4375"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>new/2:</B>
<DD><A NAME="IDX4376"></A>


<P>
Dynamic instance creation takes place by the ways of this predicate. 


<P>
It takes a free variable as first argument which will be instantiated to an internal object identifier. 


<P>
Second argument must be instantiated to a 
<A NAME="IDX4377"></A>
class constructor. Class constructors are designed to perform an initialization on the new created instance. Notice that instance initialization may involve some kind of computation, not only <EM>state initialization</EM>. 


<P>
A class constructor is made by a functor, which must match the intended class name, and any number of parameters. For example: 



<PRE>
            Obj new myclass(1500,'hello, world!!!')
</PRE>

<P>
Those parameters depends (obviously) on the constructors defined at the class source. If no constructors where defined, no parameters are needed. This is called the 
<A NAME="IDX4378"></A>
default constructor. An example: 



<PRE>
            Obj new myclass
</PRE>

<P>
The default constructor can not be called if there is any constructor available at the class source. 


<P>
Instantiation will raise an exception and fail whenever any of this conditions occur: 

<UL>
<LI>First argument is not a free variable.

<LI>Second argument functor is a class, but there is no usage relationship with it.

<LI>Second argument functor is not a class.

<LI>The given constructor is unknown.

<LI>The given constructor fails (notice that default constructor never fails).

</UL>

<P>
Objects may also be statically declared, refer to 
<A NAME="IDX4379"></A>
<CODE>instance_of/2</CODE> declaration. 


<P>
<STRONG>Usage:</STRONG> <CODE>new(InstanceVar,Constructor)</CODE>

<UL>
<LI><EM>Description:</EM> Creates a new instance of the class specified by <CODE>Constructor</CODE> returning its identifier in <CODE>InstanceVar</CODE>

<LI><EM>The following properties should hold at call time:</EM>

<CODE>InstanceVar</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)

<CODE>Constructor</CODE> is a term whose functor matches a class name.
 (<CODE>objects_rt:constructor/1</CODE>)
<LI><EM>The following properties should hold upon exit:</EM>

<CODE>InstanceVar</CODE> is an unique term which identifies an object.
 (<CODE>objects_rt:instance_id/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4380"></A>
<A NAME="IDX4381"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>instance_of/2:</B>
<DD><A NAME="IDX4382"></A>


<P>
This predicate is used to perform dynamic type checking. You may check whether a particular instance belongs to a particular class or related descendants. 


<P>
instance_of/2 is used to perform static 
<A NAME="IDX4383"></A>
semantic analisys over object oriented code constructions. 


<P>
By the use of instance_of/2 you may help to perform such analisys. 


<P>
<STRONG>Usage 1:</STRONG> <CODE>instance_of(Instance,Class)</CODE>

<UL>
<LI><EM>Description:</EM> Test whether <CODE>Instance</CODE> was derived from any descendant of <CODE>Class</CODE>, or that class itself

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Instance</CODE> is an unique term which identifies an object.
 (<CODE>objects_rt:instance_id/1</CODE>)

<CODE>Class</CODE> is an atom denoting a class.
 (<CODE>objects_rt:class_name/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>instance_of(Instance,Class)</CODE>

<UL>
<LI><EM>Description:</EM> Retrieves, on backtracking, the inheritance line of <CODE>Instance</CODE> commencing on the creation class (that specified on call to

<A NAME="IDX4384"></A>
<CODE>new/2</CODE>) and continuing on the rest of ascendant classes, if any. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Instance</CODE> is an unique term which identifies an object.
 (<CODE>objects_rt:instance_id/1</CODE>)

<CODE>Class</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)
<LI><EM>The following properties should hold upon exit:</EM>

<CODE>Class</CODE> is an atom denoting a class.
 (<CODE>objects_rt:class_name/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4385"></A>
<A NAME="IDX4386"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>derived_from/2:</B>
<DD><A NAME="IDX4387"></A>


<P>
Test whether an object identifier was derived directly from a class, by the usage of 
<A NAME="IDX4388"></A>
<CODE>new/2</CODE> or a static instance declaration (
<A NAME="IDX4389"></A>
<CODE>instance_of/2</CODE>). 


<P>
<STRONG>Usage 1:</STRONG> <CODE>derived_from(Instance,Class)</CODE>

<UL>
<LI><EM>Description:</EM> Test derivation of <CODE>Instance</CODE> from <CODE>Class</CODE>

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Instance</CODE> is an unique term which identifies an object.
 (<CODE>objects_rt:instance_id/1</CODE>)

<CODE>Class</CODE> is an atom denoting a class.
 (<CODE>objects_rt:class_name/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>derived_from(Instance,Class)</CODE>

<UL>
<LI><EM>Description:</EM> Retrieves the <CODE>Class</CODE> responsable of the derivation of <CODE>Instance</CODE>.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Instance</CODE> is an unique term which identifies an object.
 (<CODE>objects_rt:instance_id/1</CODE>)

<CODE>Class</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)
<LI><EM>The following properties should hold upon exit:</EM>

<CODE>Class</CODE> is an atom denoting a class.
 (<CODE>objects_rt:class_name/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4390"></A>
<A NAME="IDX4391"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>interface/2:</B>
<DD><A NAME="IDX4392"></A>


<P>
This predicate is used to ensure a given interface to be implemented by a given instance. 


<P>
<STRONG>Usage 1:</STRONG> <CODE>interface(Instance,Interface)</CODE>

<UL>
<LI><EM>Description:</EM> Check whether <CODE>Instance</CODE> implements the given <CODE>Interface</CODE>.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Instance</CODE> is an unique term which identifies an object.
 (<CODE>objects_rt:instance_id/1</CODE>)

<CODE>Interface</CODE> is an unique atom which identifies a public interface.
 (<CODE>objects_rt:interface_name/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>interface(Instance,Interfaces)</CODE>

<UL>
<LI><EM>Description:</EM> Retrieves on backtracking all the implemented <CODE>Interfaces</CODE> of <CODE>Instance</CODE>.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Instance</CODE> is an unique term which identifies an object.
 (<CODE>objects_rt:instance_id/1</CODE>)

<CODE>Interfaces</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)
<LI><EM>The following properties should hold upon exit:</EM>

<CODE>Interfaces</CODE> is an unique atom which identifies a public interface.
 (<CODE>objects_rt:interface_name/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4393"></A>
<A NAME="IDX4394"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>instance_codes/2:</B>
<DD><A NAME="IDX4395"></A>


<P>
Retrieves a character string representation from an object identifier and vice-versa. 


<P>
<STRONG>Usage 1:</STRONG> <CODE>instance_codes(Instance,String)</CODE>

<UL>
<LI><EM>Description:</EM> Retrieves a <CODE>String</CODE> representation of given <CODE>Instance</CODE>.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Instance</CODE> is an unique term which identifies an object.
 (<CODE>objects_rt:instance_id/1</CODE>)

<CODE>String</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)
<LI><EM>The following properties should hold upon exit:</EM>

<CODE>String</CODE> is a string (a list of character codes).
 (<CODE>basic_props:string/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>instance_codes(Instance,String)</CODE>

<UL>
<LI><EM>Description:</EM> Reproduces an <CODE>Instance</CODE> from its <CODE>String</CODE> representation. Such an instance must be alive across the application: this predicate will fail whether the involved instance has been destroyed.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Instance</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)

<CODE>String</CODE> is a string (a list of character codes).
 (<CODE>basic_props:string/1</CODE>)
<LI><EM>The following properties should hold upon exit:</EM>

<CODE>Instance</CODE> is an unique term which identifies an object.
 (<CODE>objects_rt:instance_id/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4396"></A>
<A NAME="IDX4397"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>destroy/1:</B>
<DD><A NAME="IDX4398"></A>


<P>
As well as instances are created, they must be destroyed when no longer needed in order to release system resources. 


<P>
Unfortunately, current O'Ciao implementation does not support automatic instance destruction, so user must manually call <EM>destroy/1</EM> in order to do so. 


<P>
The programmer <STRONG>must ensure</STRONG> that no other references to the involved object are left in memory when destroy/1 is called. If not, unexpected results may be obtained. 


<P>
<STRONG>Usage:</STRONG> <CODE>destroy(Instance)</CODE>

<UL>
<LI><EM>Description:</EM> Destroys the object identified by <CODE>Instance</CODE>.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Instance</CODE> is an unique term which identifies an object.
 (<CODE>objects_rt:instance_id/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4399"></A>
<A NAME="IDX4400"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>use_class/1:</B>
<DD><A NAME="IDX4401"></A>


<P>
The behaviour of this predicate is identical to that provided by the declaration of the same name 
<A NAME="IDX4402"></A>
<CODE>use_class/1</CODE>. It allows user programs to dynamically load classes. Whether the given source is not a class it will perform a 
<A NAME="IDX4403"></A>
<CODE>use_module/1</CODE> predicate call.


<P>
<STRONG>Usage:</STRONG> <CODE>use_class(ClassSource)</CODE>

<UL>
<LI><EM>Description:</EM> Dynamically loads the given <CODE>ClassSource</CODE>

<LI><EM>The following properties should hold at call time:</EM>

<CODE>ClassSource</CODE> is a valid path to a prolog file containing a class declaration (without .pl extension).
 (<CODE>objects_rt:class_source/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4404"></A>
<A NAME="IDX4405"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>constructor/1:</B>
<DD><A NAME="IDX4406"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>constructor(Cons)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Cons</CODE> is a term whose functor matches a class name.

</UL>

</DL>

<P>
<A NAME="IDX4407"></A>
<A NAME="IDX4408"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>class_name/1:</B>
<DD><A NAME="IDX4409"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>class_name(ClassName)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>ClassName</CODE> is an atom denoting a class.

</UL>

</DL>

<P>
<A NAME="IDX4410"></A>
<A NAME="IDX4411"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>interface_name/1:</B>
<DD><A NAME="IDX4412"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>interface_name(Interface)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Interface</CODE> is an unique atom which identifies a public interface.

</UL>

</DL>

<P>
<A NAME="IDX4413"></A>
<A NAME="IDX4414"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>instance_id/1:</B>
<DD><A NAME="IDX4415"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>instance_id(ID)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>ID</CODE> is an unique term which identifies an object.

</UL>

</DL>

<P>
<A NAME="IDX4416"></A>
<A NAME="IDX4417"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>class_source/1:</B>
<DD><A NAME="IDX4418"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>class_source(Source)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Source</CODE> is a valid path to a prolog file containing a class declaration (without .pl extension).

</UL>

</DL>

<P>
<A NAME="IDX4419"></A>
<A NAME="IDX4420"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>interface_source/1:</B>
<DD><A NAME="IDX4421"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>interface_source(Source)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Source</CODE> is a valid path to a prolog file containing a class declaration or an interface declaration (without .pl extension).

</UL>

</DL>

<P>
<A NAME="IDX4422"></A>
<A NAME="IDX4423"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>method_spec/1:</B>
<DD><A NAME="IDX4424"></A>


<P>
There is no difference between method or attribute specifications, and habitual predicate specifications. It is just a Functor/Arity term. 


<P>
<STRONG>Usage:</STRONG> <CODE>method_spec(Spec)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Spec</CODE> is a method or attribute specification.

</UL>

</DL>

<P>
<A NAME="IDX4425"></A>
<A NAME="IDX4426"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>virtual_method_spec/1:</B>
<DD><A NAME="IDX4427"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>virtual_method_spec(Spec)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Spec</CODE> is a method specification.

</UL>

</DL>



<H2><A NAME="SEC413" HREF="ciao_toc.html#TOC413">Known bugs and planned improvements (<CODE>objects_rt</CODE>)</A></H2>


<UL>

<LI>

Not really a bug: when loading code which declares static instances from the toplevel shell, predicate 
<A NAME="IDX4428"></A>
<CODE>use_module/1</CODE>) will not work properly: those instances may be not correctly created, and predicates will fail whenever they are not supposed to do. This may be avoided by reloading again the involved module, but make sure it is modified and saved to disk before doing so. 
</UL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_102.html">previous</A>, <A HREF="ciao_104.html">next</A>, <A HREF="ciao_158.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
