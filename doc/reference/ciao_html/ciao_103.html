<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 28 November 1999 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - Foreign interface</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_102.html">previous</A>, <A HREF="ciao_104.html">next</A>, <A HREF="ciao_146.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC354" HREF="ciao_toc.html#TOC354">Foreign interface</A></H1>
<P>
<A NAME="IDX3764"></A>


<P>
<STRONG>Author(s):</STRONG> Jose Morales, Manuel Carro.


<P>
<STRONG>Version:</STRONG> 1.4 (1999/11/27, 19:0:0 MEST)


<P>
<STRONG>Version of last change:</STRONG> 1.3#123 (1999/11/27, 3:3:55 MET)


<P>
This module exports two predicates, 
<A NAME="IDX3765"></A>
<CODE>build_foreign_interface/1</CODE> and 
<A NAME="IDX3766"></A>
<CODE>rebuild_foreign_interface/1</CODE>. These predicates know about the correspondence between C types and Ciao Prolog types through the assertions documenting them. 


<P>
Each predicate implemented as a foreign C function must appear in the module as: 



<PRE>
     :- true pred prolog_predicate(m1(Arg1), ... mN(ArgN)) :: type1 *
          ... * typeN + (foreign(foreign_function_name), returns(ArgR)).

     :- impl_defined([..., prolog_predicate/N, ...]).
</PRE>

<P>
where <CODE>m1</CODE>, ..., <CODE>mN</CODE> and <CODE>type1</CODE>, ..., <CODE>typeN</CODE> are respectively the modes and types of the arguments. 


<P>
<A NAME="IDX3767"></A>
<CODE>prolog_predicate/N</CODE> is implemented by <CODE>foreign_function_name</CODE>, whose result is unified with <CODE>ArgR</CODE>. 


<P>
This notation can be simplified if the name of the foreign function is the same as the name of the Ciao Prolog predicate, replacing <CODE>foreign(foreign_function)</CODE> with just <CODE>foreign</CODE>. <CODE>returns(ArgR)</CODE> specifies that the result of the function corresponds to the <CODE>ArgR</CODE> argument of the Ciao Prolog predicate. If the foreign function does not return anything, then <CODE>returns(ArgR)</CODE> must be removed. Note that <CODE>returns</CODE> cannot be used without <CODE>foreign</CODE>. 



<PRE>
     :- true pred prolog_predicate(m1(Arg1), ... mN(ArgN)) :: type1 *
          ... * typeN + foreign.
</PRE>


<UL>
<LI><A HREF="ciao_103.html#SEC355">Equivalence between Ciao Prolog and C modes</A>
<LI><A HREF="ciao_103.html#SEC356">Equivalence between Ciao Prolog and C types</A>
<LI><A HREF="ciao_103.html#SEC357">Examples</A>
<LI><A HREF="ciao_103.html#SEC362">Usage and interface (foreign_interface)</A>
<LI><A HREF="ciao_103.html#SEC363">Documentation on exports (foreign_interface)</A>
</UL>



<H2><A NAME="SEC355" HREF="ciao_toc.html#TOC355">Equivalence between Ciao Prolog and C modes</A></H2>

<P>
(This section has not been written yet) 




<H2><A NAME="SEC356" HREF="ciao_toc.html#TOC356">Equivalence between Ciao Prolog and C types</A></H2>

<P>
The translation between Ciao Prolog and C types is defined only for some simple types. The translation to be performed is solely defined by types of the arguments in the Ciao Prolog predicate, obeying the table below: 



<UL>
<LI>num &#60;-&#62; double

<LI>int &#60;-&#62; int

<LI>atm &#60;-&#62; char *

<LI>string &#60;-&#62; char * (with trailing zero)

<LI>byte_list &#60;-&#62; char * (a buffer, with associated length)

<LI>address &#60;-&#62; void *

</UL>

<P>
Strings, atoms, and lists of bytes are passed to (and from) C as dynamically (malloc) created arrays of characters (bytes). Those arrays are freed by Ciao Prolog upon return of the foreign function unless 
<A NAME="IDX3768"></A>
<CODE>do_not_free/2</CODE> is specified (see examples below). 


<P>
Empty lists of bytes are converted into <CODE>NULL</CODE>, and strings <CODE>[]</CODE> or atoms " are converted into <EM>""</EM> (a zero ended C string). <EM>NULL</EM> is converted into an empty list or the <EM>"</EM> atom. 


<P>
<CODE>NULL</CODE> strings and empty buffers are converted into the empty list or the null atom (<CODE>"</CODE>). Empty Ciao Prolog strings (<CODE>"</CODE> or <CODE>[]</CODE>) and null atoms are converted into zero-terminated strings of zero length. Empty Ciao Prolog lists are converted into <CODE>NULL</CODE>. 


<P>
The type 
<A NAME="IDX3769"></A>
<CODE>byte_list/1</CODE> requires an additional property, 
<A NAME="IDX3770"></A>
<CODE>size_of/3</CODE>, to indicate which argument represents its size. 




<H2><A NAME="SEC357" HREF="ciao_toc.html#TOC357">Examples</A></H2>


<UL>
<LI><A HREF="ciao_103.html#SEC358">Mathematical functions</A>
<LI><A HREF="ciao_103.html#SEC359">Addresses and C pointers</A>
<LI><A HREF="ciao_103.html#SEC360">Lists of bytes and buffers</A>
<LI><A HREF="ciao_103.html#SEC361">Strings and atoms</A>
</UL>



<H3><A NAME="SEC358" HREF="ciao_toc.html#TOC358">Mathematical functions</A></H3>

<P>
<EM>math.pl</EM> 



<PRE>
:- module(math,
	[sin/2,
	 cos/2,
	 fabs/2
	],
	[assertions,
	 basicmodes,
	 regtypes,
	 'foreign_interface/syntax'
	]).

:- true pred sin(in(X),go(Y)) :: num * num + (foreign,returns(Y)).
:- true pred cos(in(X),go(Y)) :: num * num + (foreign,returns(Y)).
:- true pred fabs(in(X),go(Y)) :: num * num + (foreign,returns(Y)).

:- extra_compiler_opts(['-O2']).
:- extra_compiler_opts('LINUXi86',['-ffast-math']).
:- use_foreign_library([m]).

:- impl_defined([sin/2,cos/2,fabs/2]).
</PRE>



<H3><A NAME="SEC359" HREF="ciao_toc.html#TOC359">Addresses and C pointers</A></H3>

<P>
<EM>objects.pl</EM> 



<PRE>
:- module(objects,
	[object/2,
	 show_object/1
	],
	[assertions,
	 basicmodes,
	 regtypes,
	 'foreign_interface/syntax'
	]).
	 
:- true pred object(in(N),go(Object)) :: int * address +
	(foreign,returns(Object)).

:- true pred show_object(in(Object)) :: address + foreign.

:- use_foreign_source(objects_c).
:- extra_compiler_opts('-O2').

:- impl_defined([object/2,show_object/1]).
</PRE>

<P>
<EM>objects_c.c</EM> 
 

<PRE>
#include &#60;stdio.h&#62;

struct object {
  char *name;
  char *colour;
};

#define OBJECTS 3

struct object objects[OBJECTS] =
{ {"ring","golden"},
  {"table","brown"},
  {"bottle","green"} };

struct object *object(int n) {
  return &#38;objects[n % OBJECTS];
}

void show_object(struct object *o) {
  printf("I show you a %s %s\n", o-&#62;colour, o-&#62;name);
}
</PRE>



<H3><A NAME="SEC360" HREF="ciao_toc.html#TOC360">Lists of bytes and buffers</A></H3>

<P>
<EM>byte_lists.pl</EM> 



<PRE>
:- module(byte_lists,
	[obtain_list/3,
	 show_list/2
	],
	[assertions,
	 basicmodes,
	 regtypes,
	 'foreign_interface/syntax'
	]).
	 
:- true pred obtain_list(in(N),go(Length),go(List)) :: int * int * byte_list
	+ (foreign,size_of(List,Length)).
:- true pred show_list(in(Length),in(List)) :: int * byte_list
	+ (foreign,size_of(List,Length)).

:- use_foreign_source(bytes_op).

:- impl_defined([obtain_list/3,show_list/2]).
</PRE>

<P>
<EM>bytes_op.c</EM> 



<PRE>
#include &#60;malloc.h&#62;
#include &#60;stdio.h&#62;

void obtain_list(int n, int *l, char **s) {
  int i;
  int c;
  if (n &#60; 0) n = 0;
  *l = n;
  *s = (char *)malloc(*l);
  for (i = 0; i &#60; *l; i++) {
    (*s)[i] = i;
  }
}

void show_list(int l, char *s) {
  if (s) {
    int n;
    printf("From C: [");
    for (n = 0; n &#60; l; n++) {
      printf(" %d", s[n]);
    }
    printf("]\n");
  } else {
    printf("From C: []\n");
  }
}
</PRE>



<H3><A NAME="SEC361" HREF="ciao_toc.html#TOC361">Strings and atoms</A></H3>

<P>
<EM>strings_and_atoms.pl</EM> 



<PRE>
:- module(strings_and_atoms,
	[lookup_string/2,
	 lookup_atom/2,
	 a_string/1,
	 show_string/1,
	 show_atom/1
	],
	[assertions,
	 basicmodes,
	 regtypes,
	 'foreign_interface/syntax'
	]).

:- true pred a_string(go(S)) ::
	string + (foreign(get_static_str),returns(S),do_not_free(S)).
	 
:- true pred lookup_string(in(N),go(S)) ::
	int * string + (foreign(get_str),returns(S)).
:- true pred lookup_atom(in(N),go(S)) ::
	int * atm + (foreign(get_str),returns(S)).

:- true pred show_string(in(S)) :: string + foreign(put_str).
:- true pred show_atom(in(S)) :: atm + foreign(put_str).

:- use_foreign_source(str_op).

:- impl_defined([lookup_string/2,lookup_atom/2,show_string/1,show_atom/1,
                 a_string/1]).
</PRE>

<P>
<EM>str_op.c</EM> 



<PRE>
#include &#60;malloc.h&#62;
#include &#60;stdio.h&#62;

char *get_static_str() {
  return "this is a string Ciao Prolog should not free";
}

char *get_str(int n) {
  char *s;
  int size;
  int i;
  int c;
  if (n &#60; 0) n = -n;
  size = (n%4) + 5;
  s = (char *)malloc(size+1);
  for (i = 0, c = ((i + n) % ('z' - 'a' + 1)) + 'a'; i &#60; size; i++,c++) {
    if (c &#62; 'z') c = 'a'; 
    s[i] = c;
  }
  s[i] = 0;
  return s;
}

void put_str(char *s) {
  if (s) {
    printf("From C: \"%s\"\n", s);
  } else {
    printf("From C: null\n");
  }
}
</PRE>



<H2><A NAME="SEC362" HREF="ciao_toc.html#TOC362">Usage and interface (<CODE>foreign_interface</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

<CODE>:- use_module(library(foreign_interface)).</CODE>

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX3771"></A>
<CODE>build_foreign_interface/1</CODE>, 
<A NAME="IDX3772"></A>
<CODE>rebuild_foreign_interface/1</CODE>, 
<A NAME="IDX3773"></A>
<CODE>build_foreign_interface_explicit_decls/2</CODE>, 
<A NAME="IDX3774"></A>
<CODE>build_foreign_interface_object/1</CODE>, 
<A NAME="IDX3775"></A>
<CODE>rebuild_foreign_interface_object/1</CODE>, 
<A NAME="IDX3776"></A>
<CODE>do_interface/1</CODE>.

</UL>

<LI><STRONG>Other modules used:</STRONG>


<UL>

<LI><EM>System library modules:</EM>

<A NAME="IDX3777"></A>
<CODE>terms</CODE>, 
<A NAME="IDX3778"></A>
<CODE>lists</CODE>, 
<A NAME="IDX3779"></A>
<CODE>llists</CODE>, 
<A NAME="IDX3780"></A>
<CODE>aggregates</CODE>, 
<A NAME="IDX3781"></A>
<CODE>system</CODE>, 
<A NAME="IDX3782"></A>
<CODE>format</CODE>, 
<A NAME="IDX3783"></A>
<CODE>messages</CODE>, 
<A NAME="IDX3784"></A>
<CODE>assertions/assrt_lib</CODE>, 
<A NAME="IDX3785"></A>
<CODE>foreign_compilation</CODE>, 
<A NAME="IDX3786"></A>
<CODE>compiler/c_itf</CODE>, 
<A NAME="IDX3787"></A>
<CODE>ctrlcclean</CODE>, 
<A NAME="IDX3788"></A>
<CODE>errhandle</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC363" HREF="ciao_toc.html#TOC363">Documentation on exports (<CODE>foreign_interface</CODE>)</A></H2>
<P>
<A NAME="IDX3789"></A>
<A NAME="IDX3790"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>build_foreign_interface/1:</B>
<DD><A NAME="IDX3791"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>build_foreign_interface(in(File))</CODE>

<UL>
<LI><EM>Description:</EM> Reads assertions from <CODE>File</CODE>, generates the gluecode for the Ciao Prolog interface, compiles the foreign files and the gluecode file, and links everything in a shared object. Checks modification times to determine automatically which files must be generated/compiled/linked.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>in(File)</CODE> is a source name.
 (<CODE>streams_basic:sourcename/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3792"></A>
<A NAME="IDX3793"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>rebuild_foreign_interface/1:</B>
<DD><A NAME="IDX3794"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>rebuild_foreign_interface(in(File))</CODE>

<UL>
<LI><EM>Description:</EM> Like

<A NAME="IDX3795"></A>
<CODE>build_foreign_interface/1</CODE>, but it does not check the modification time of any file. 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>in(File)</CODE> is a source name.
 (<CODE>streams_basic:sourcename/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3796"></A>
<A NAME="IDX3797"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>build_foreign_interface_explicit_decls/2:</B>
<DD><A NAME="IDX3798"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>build_foreign_interface_explicit_decls(in(File),in(Decls))</CODE>

<UL>
<LI><EM>Description:</EM> Like

<A NAME="IDX3799"></A>
<CODE>build_foreign_interface/1</CODE>, but use declarations in <CODE>Decls</CODE> instead of reading the declarations from <CODE>File</CODE>. 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>in(File)</CODE> is a source name.
 (<CODE>streams_basic:sourcename/1</CODE>)

<CODE>in(Decls)</CODE> is a list of <CODE>term</CODE>s.
 (<CODE>basic_props:list/2</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3800"></A>
<A NAME="IDX3801"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>build_foreign_interface_object/1:</B>
<DD><A NAME="IDX3802"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>build_foreign_interface_object(in(File))</CODE>

<UL>
<LI><EM>Description:</EM> Compiles the gluecode file with the foreign source files producing an unique object file.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>in(File)</CODE> is a source name.
 (<CODE>streams_basic:sourcename/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3803"></A>
<A NAME="IDX3804"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>rebuild_foreign_interface_object/1:</B>
<DD><A NAME="IDX3805"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>rebuild_foreign_interface_object(in(File))</CODE>

<UL>
<LI><EM>Description:</EM> Compiles (again) the gluecode file with the foreign source files producing an unique object file.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>in(File)</CODE> is a source name.
 (<CODE>streams_basic:sourcename/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3806"></A>
<A NAME="IDX3807"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>do_interface/1:</B>
<DD><A NAME="IDX3808"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>do_interface(in(Decls))</CODE>

<UL>
<LI><EM>Description:</EM> Given the declarations in <CODE>Decls</CODE>, this predicate succeeds if these declarations involve the creation of the foreign interface

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>in(Decls)</CODE> is a list of <CODE>term</CODE>s.
 (<CODE>basic_props:list/2</CODE>)
</UL>

</DL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_102.html">previous</A>, <A HREF="ciao_104.html">next</A>, <A HREF="ciao_146.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
