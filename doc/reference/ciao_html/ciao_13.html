<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 26 January 2000 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - The module system</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_12.html">previous</A>, <A HREF="ciao_14.html">next</A>, <A HREF="ciao_148.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC70" HREF="ciao_toc.html#TOC70">The module system</A></H1>
<P>
<A NAME="IDX697"></A>


<P>
<STRONG>Author(s):</STRONG> Daniel Cabeza and the CLIP Group.


<P>
<STRONG>Version:</STRONG> 1.5#1 (1999/11/29, 17:12:34 MET)


<P>
Modularity is a basic notion in a modern computer language. Modules allow dividing programs in several parts, which have its own independent name spaces. The module system in CIAO, as in many other Prolog implementations, is procedure based. This means that predicate names are local to a module, but functor/atom names in data are shared. 


<P>
The predicates visible in a module are the predicates defined in that module, plus the predicates imported from other modules. Only predicates exported by a module can be imported from other modules. The default module of a given predicate name is the local one if the predicate is defined locally, else the last module from which the predicate is imported, having explicit imports priority. To refer to a predicate from a module which is not the default for that predicate the name has to be module 
<A NAME="IDX698"></A>
<A NAME="IDX699"></A>
qualified. A module qualified predicate name has the form <CODE>Module</CODE>:<CODE>Predicate</CODE> as in the call <CODE>debugger:debug_module(M)</CODE>. Note that this does not allow having access to predicates not imported, nor defining clauses of other modules. 


<P>
All predicates defined in files with no module declaration belong to a special module called 
<A NAME="IDX700"></A>
<A NAME="IDX701"></A>
<CODE>user</CODE>, and all are implicitly exported. This allows dividing programs in several files without being aware of the module system at all. Note that this feature is only supported for compatibility reasons, being its use discouraged. Many attractive compilation features of CIAO cannot be performed in <CODE>user</CODE> modules. 


<P>
The case of multifile predicates (defined with the declaration 
<A NAME="IDX702"></A>
<CODE>multifile/1</CODE>) is also special. Multifile predicates can be defined by clauses distributed in several modules, and all modules which define a predicate as multifile can use that predicate. The name space of multifile predicates is independent, as if they belonged to special module <CODE>multifile</CODE>. 


<P>
Every <CODE>user</CODE> or module file imports implicitly a number of modules called 
<A NAME="IDX703"></A>
builtin modules. They are imported before all other importations of the module, allowing thus redefining any of their predicates (with the exception of 
<A NAME="IDX704"></A>
<CODE>true/0</CODE>) by defining local versions or importing them from other modules. Importing explicitly from a builtin module, however, disables the implicit importation of the rest (this feature is used by package 
<A NAME="IDX705"></A>
<CODE>library(pure)</CODE> to define pure prolog code).



<UL>
<LI><A HREF="ciao_13.html#SEC71">Usage and interface (modules)</A>
<LI><A HREF="ciao_13.html#SEC72">Documentation on internals (modules)</A>
</UL>



<H2><A NAME="SEC71" HREF="ciao_toc.html#TOC71">Usage and interface (<CODE>modules</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

Modules are an intrinsic feature of CIAO, so nothing special has to be done to use them.
</UL>

</div class="cartouche">



<H2><A NAME="SEC72" HREF="ciao_toc.html#TOC72">Documentation on internals (<CODE>modules</CODE>)</A></H2>
<P>
<A NAME="IDX706"></A>
<A NAME="IDX707"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>module/3:</B>
<DD><A NAME="IDX708"></A>


<P>
<STRONG>Usage:</STRONG> :- <CODE>module(Name,Exports,Packages)</CODE>.

<UL>
<LI><EM>Description:</EM> Declares a module of name <CODE>Name</CODE> which exports the predicates in <CODE>Exports</CODE>, and uses the packages in <CODE>Packages</CODE>. <CODE>Name</CODE> must match with the name of the file where the module resides, without extension. For each source in <CODE>Packages</CODE>, a

<A NAME="IDX709"></A>
package file is included, as if by an 
<A NAME="IDX710"></A>
<CODE>include/1</CODE> declaration. If the source is specified with a 
<A NAME="IDX711"></A>
path alias, this is the file included, if it is an atom, the library paths are searched. Package files provide functionalities by declaring imports from other modules, defining operators, new declarations, translations of code, etc. 

This directive must appear the first in the file. 

Also, if the compiler finds an unknown declaration as the first term in a file, the name of the declaration is regarded as a package library to be included, and the arguments of the declaration (if present) are interpreted like the arguments of 
<A NAME="IDX712"></A>
<CODE>module/3</CODE>. 
<LI><EM>The following properties hold at call time:</EM>

<CODE>Name</CODE> is a module name (an atom).
 (<CODE>modules:modulename/1</CODE>)

<CODE>Exports</CODE> is a list of <CODE>predname</CODE>s.
 (<CODE>basic_props:list/2</CODE>)

<CODE>Packages</CODE> is a list of <CODE>sourcename</CODE>s.
 (<CODE>basic_props:list/2</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX713"></A>
<A NAME="IDX714"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>module/2:</B>
<DD><A NAME="IDX715"></A>


<P>
<STRONG>Usage:</STRONG> :- <CODE>module(Name,Exports)</CODE>.

<UL>
<LI><EM>Description:</EM> Same as directive

<A NAME="IDX716"></A>
<CODE>module/3</CODE>, with an implicit package <CODE>iso</CODE>, which enables to include 
<A NAME="IDX717"></A>
ISO-Prolog compatible code (compatibility not 100% yet). 
<LI><EM>The following properties hold at call time:</EM>

<CODE>Name</CODE> is a module name (an atom).
 (<CODE>modules:modulename/1</CODE>)

<CODE>Exports</CODE> is a list of <CODE>predname</CODE>s.
 (<CODE>basic_props:list/2</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX718"></A>
<A NAME="IDX719"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>export/1:</B>
<DD><A NAME="IDX720"></A>


<P>
<STRONG>Usage 1:</STRONG> :- <CODE>export(Pred)</CODE>.

<UL>
<LI><EM>Description:</EM> Adds <CODE>Pred</CODE> to the set of exported predicates.

<LI><EM>The following properties hold at call time:</EM>

<CODE>Pred</CODE> is a Name/Arity structure denoting a predicate name: 

<PRE>
predname(P/A) :-
        atm(P),
        int(A).
</PRE>

 (<CODE>basic_props:predname/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> :- <CODE>export(Exports)</CODE>.

<UL>
<LI><EM>Description:</EM> Adds <CODE>Exports</CODE> to the set of exported predicates.

<LI><EM>The following properties hold at call time:</EM>

<CODE>Exports</CODE> is a list of <CODE>predname</CODE>s.
 (<CODE>basic_props:list/2</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX721"></A>
<A NAME="IDX722"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>use_module/2:</B>
<DD><A NAME="IDX723"></A>


<P>
<STRONG>Usage:</STRONG> :- <CODE>use_module(Module,Imports)</CODE>.

<UL>
<LI><EM>Description:</EM> Specifies that this code imports from the module defined in <CODE>Module</CODE> the predicates in <CODE>Imports</CODE>. The imported predicates must be exported by the other module.

<LI><EM>The following properties hold at call time:</EM>

<CODE>Module</CODE> is a source name.
 (<CODE>streams_basic:sourcename/1</CODE>)

<CODE>Imports</CODE> is a list of <CODE>predname</CODE>s.
 (<CODE>basic_props:list/2</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX724"></A>
<A NAME="IDX725"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>use_module/1:</B>
<DD><A NAME="IDX726"></A>


<P>
<STRONG>Usage:</STRONG> :- <CODE>use_module(Module)</CODE>.

<UL>
<LI><EM>Description:</EM> Specifies that this code imports from the module defined in <CODE>Module</CODE> all the predicates exported by it. The previous version with the explicit import list is preferred to this as it minimizes the chances to have to recompile this code if the other module changes.

<LI><EM>The following properties hold at call time:</EM>

<CODE>Module</CODE> is a source name.
 (<CODE>streams_basic:sourcename/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX727"></A>
<A NAME="IDX728"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>import/2:</B>
<DD><A NAME="IDX729"></A>


<P>
<STRONG>Usage:</STRONG> :- <CODE>import(Module,Imports)</CODE>.

<UL>
<LI><EM>Description:</EM> Declares that this code imports from the module with name <CODE>Module</CODE> the predicates in <CODE>Imports</CODE>.

<STRONG>Important note:</STRONG> this declaration is intended to be used when the current module or the imported module is going to be dynamically loaded, and so the compiler does not include the code of the imported module in the current executable (if only because the compiler cannot know the location of the module file at the time of compilation). For the same reason the predicates imported are not checked to be exported by <CODE>Module</CODE>. Its use in other cases is strongly discouraged, as it disallows many compiler optimizations. 
<LI><EM>The following properties hold at call time:</EM>

<CODE>Module</CODE> is a module name (an atom).
 (<CODE>modules:modulename/1</CODE>)

<CODE>Imports</CODE> is a list of <CODE>predname</CODE>s.
 (<CODE>basic_props:list/2</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX730"></A>
<A NAME="IDX731"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>reexport/2:</B>
<DD><A NAME="IDX732"></A>


<P>
<STRONG>Usage:</STRONG> :- <CODE>reexport(Module,Preds)</CODE>.

<UL>
<LI><EM>Description:</EM> Specifies that this code reexports from the module defined in <CODE>Module</CODE> the predicates in <CODE>Preds</CODE>. This implies that this module imports from the module defined in <CODE>Module</CODE> the predicates in <CODE>Preds</CODE>, an also that this module exports the predicates in <CODE>Preds</CODE> .

<LI><EM>The following properties hold at call time:</EM>

<CODE>Module</CODE> is a source name.
 (<CODE>streams_basic:sourcename/1</CODE>)

<CODE>Preds</CODE> is a list of <CODE>predname</CODE>s.
 (<CODE>basic_props:list/2</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX733"></A>
<A NAME="IDX734"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>reexport/1:</B>
<DD><A NAME="IDX735"></A>


<P>
<STRONG>Usage:</STRONG> :- <CODE>reexport(Module)</CODE>.

<UL>
<LI><EM>Description:</EM> Specifies that this code reexports from the module defined in <CODE>Module</CODE> all the predicates exported by it. This implies that this module imports from the module defined in <CODE>Module</CODE> all the predicates exported by it, an also that this module exports all such predicates .

<LI><EM>The following properties hold at call time:</EM>

<CODE>Module</CODE> is a source name.
 (<CODE>streams_basic:sourcename/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX736"></A>
<A NAME="IDX737"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>meta_predicate/1:</B>
<DD><A NAME="IDX738"></A>


<P>
<STRONG>Usage:</STRONG> :- <CODE>meta_predicate MetaSpecs</CODE>.

<UL>
<LI><EM>Description:</EM> Specifies that the predicates in <CODE>MetaSpecs</CODE> have arguments which represent predicates and thus have to be module expanded. The directive is not mandatory in programs which do not use modules. This directive is defined as a prefix operator in the compiler.

<LI><EM>The following properties hold at call time:</EM>

<CODE>MetaSpecs</CODE> is a sequence of <CODE>metaspec</CODE>s.
 (<CODE>basic_props:sequence/2</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX739"></A>
<A NAME="IDX740"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>modulename/1:</B>
<DD><A NAME="IDX741"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>modulename(M)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>M</CODE> is a module name (an atom).

<LI><EM>The following properties should hold globally:</EM>

Defines a regular type.
 (<CODE>basic_props:regtype/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX742"></A>
<A NAME="IDX743"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>metaspec/1:</B>
<DD><A NAME="IDX744"></A>


<P>
A meta-predicate specification for a predicate is the functor of that predicate applied to atoms which represent the kind of module expansion that should be done with the arguments. Possible contents are represented as: 


<DL COMPACT>

<DT><CODE>goal</CODE>
<DD>
This argument will be a term denoting a goal (either a simple or complex one) which will be called. For commpatibility reasons it can be named as <CODE>:</CODE> as well. 

<DT><CODE>clause</CODE>
<DD>
This argument will be a term denoting a clause. 

<DT><CODE>fact</CODE>
<DD>
This argument should be instantiated to a term denoting a fact (head-only clause). 

<DT><CODE>spec</CODE>
<DD>
This argument should be instantiated to a predicate name, as Functor/Arity. 

<DT><CODE>pred(<EM>N</EM>)</CODE>
<DD>
This argument should be instantiated to a predicate construct to be called by means of a <CODE>call/<EM>N</EM></CODE> predicate call (see 
<A NAME="IDX745"></A>
<CODE>call/2</CODE>). Thus, it should be an atom equal to the name of a predicate of arity <EM>N</EM>, or a structure with functor the name of a predicate of arity <EM>M</EM> (greater than <EM>N</EM>) and with <EM>M</EM>-<EM>N</EM> arguments. 

<DT><CODE>?,+,-,_</CODE>
<DD>
These other values denote that this argument is not module expanded. 

</DL>

<P>
<STRONG>Usage:</STRONG> <CODE>metaspec(M)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>M</CODE> is a meta-predicate specification.

<LI><EM>The following properties should hold globally:</EM>

Defines a regular type.
 (<CODE>basic_props:regtype/1</CODE>)
</UL>

</DL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_12.html">previous</A>, <A HREF="ciao_14.html">next</A>, <A HREF="ciao_148.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
