<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 27 August 2003 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - SQL persistent database interface</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_149.html">previous</A>, <A HREF="ciao_151.html">next</A>, <A HREF="ciao_232.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC625" HREF="ciao_toc.html#TOC625">SQL persistent database interface</A></H1>
<P>
<A NAME="IDX6447"></A>


<P>
<STRONG>Author(s):</STRONG> I. Caballero, D. Cabeza, J.M. G&oacute;mez, M. Hermenegildo, J. F. Morales, and M. Carro, <CODE>clip@dia.fi.upm.es</CODE>, <CODE>http://www.clip.dia.fi.upm.es/</CODE>, The CLIP Group, Facultad de Inform&aacute;tica, Universidad Polit&eacute;cnica de Madrid.


<P>
<STRONG>Version:</STRONG> 1.9#93 (2003/7/29, 17:53:15 CEST)


<P>
<STRONG>Version of last change:</STRONG> 1.9#58 (2003/2/5, 10:44:19 CET)


<P>
The purpose of this library is to implement an instance of the generic concept of 
<A NAME="IDX6448"></A>
persistent predicates, where external 
<A NAME="IDX6449"></A>
relational databases are used for storage (see the documentation of the 
<A NAME="IDX6450"></A>
<CODE>persdb</CODE> library and [CHGT98,Par97] for details). To this end, this library exports SQL persistent versions of the 
<A NAME="IDX6451"></A>
<CODE>assertz_fact/1</CODE>, 
<A NAME="IDX6452"></A>
<CODE>retract_fact/1</CODE> and 
<A NAME="IDX6453"></A>
<CODE>retractall_fact/1</CODE> builtin predicates. Persistent predicates also allow 
<A NAME="IDX6454"></A>
concurrent updates from several programs, since each update is atomic. 


<P>
The notion of persistence provides a very natural and transparent way to access database relations from a Prolog program. Stub definitions are provided for such predicates which access the database when the predicate is called (using the 
<A NAME="IDX6455"></A>
<CODE>db_client</CODE> library). A 
<A NAME="IDX6456"></A>
Prolog to SQL translator is used to generate the required 
<A NAME="IDX6457"></A>
SQL code dynamically (see library 
<A NAME="IDX6458"></A>
<CODE>pl2sql</CODE>). 


<P>
This library also provides facilities for reflecting more complex 
<A NAME="IDX6459"></A>
views of the database relations as Prolog predicates. Such views can be constructed as conjunctions, disjunctions, projections, etc. of database relations. Also, 
<A NAME="IDX6460"></A>
SQL-like 
<A NAME="IDX6461"></A>
aggregation operations are supported. 



<UL>
<LI><A HREF="ciao_150.html#SEC626">Implementation of the Database Interface</A>
<LI><A HREF="ciao_150.html#SEC627">Example(s)</A>
<LI><A HREF="ciao_150.html#SEC628">Usage and interface (persdbrt_mysql)</A>
<LI><A HREF="ciao_150.html#SEC629">Documentation on exports (persdbrt_mysql)</A>
<LI><A HREF="ciao_150.html#SEC630">Documentation on multifiles (persdbrt_mysql)</A>
<LI><A HREF="ciao_150.html#SEC631">Documentation on internals (persdbrt_mysql)</A>
<LI><A HREF="ciao_150.html#SEC632">Known bugs and planned improvements (persdbrt_mysql)</A>
</UL>



<H2><A NAME="SEC626" HREF="ciao_toc.html#TOC626">Implementation of the Database Interface</A></H2>

<P>
The architecture of the low-level implementation of the database interface was defined with two goals in mind: 



<UL>
<LI>to simplify the communication between the Prolog system and the relational database engines as much as possible, and

<LI>to give as much flexibility as possible to the overall system. This includes simultaneous access to several databases, allowing both the databases and clients to reside on the same physical machine or different machines, and allowing the clients to reside in Win95/NT or Unix machines.

</UL>

<P>
 
In order to allow the flexibility mentioned above, a client-sever architecture was chosen. At the server side, a MySQL server connects to the databases using the MySQL. At the client side, a MySQL client interface connects to this server. The server daemon (mysqld) should be running in the server machine; check your MySQL documentation on how to do that. 


<P>
After the connection is established a client can send commands to the mediator server which will pass them to the corresponding database server, and then the data will traverse in the opposite direction. These messages include logging on and off from the database, sending SQL queries, and receiving the responses. 


<P>
The low level implementation of the current library is accomplished by providing abstraction levels over the MySQL interface library. These layers of abstraction implement the persistent predicate view, build the appropriate commands for the database using a translator of Prolog goals to SQL commands, issue such commands using the mediator send/receive procedures, parse the responses, and present such responses to the Prolog engine via backtracking. 




<H2><A NAME="SEC627" HREF="ciao_toc.html#TOC627">Example(s)</A></H2>


<PRE>
:- module(_, _, [persdb_mysql, functions]).

% Some contributions from Guy-Noel Mathieu

:- use_module(library(write)).
:- use_module(library(format)).

:- use_module(user_and_password).

sql_persistent_location(people, db(people, User, Password, HP)):-
        mysql_host_and_port(HP),
        mysql_user(User),
        mysql_password(Password).

:- sql_persistent(
        people(string, string, int),   %% Prolog predicate and types
        people(name, sex, age),        %% Table name and attributes
        people).                       %% Database local id

% Low level MySQL interface.
:- use_module(library('persdb_mysql/mysql_client')).

main :-
        nl,
        display('Creating database'), nl,nl,
        create_people_db,
        nl,
        display('Inserting people'), nl,nl,
        insert_people,
        nl,
        display('Showing people'), nl,nl,
        show_people,
        display('Removing John'), nl,nl,
        remove_people(john,_Y,_Z),
        display('Showing people, after removing John'), nl,nl,
        show_people,
        remove_people(_X,female,_Z),
        display('Showing people, after removing female'), nl,nl,
        show_people.

% Create a database and a table of people.  Still needs to be ironed out.

create_people_db :-
        mysql_user(User),
        mysql_password(Password),
        mysql_host_and_port(HP),
        mysql_connect(HP, '', User, Password, DbConnection),
        
        write(~mysql_query(DbConnection, "drop database if exists people")), nl,
        write(~mysql_query(DbConnection, "create database people")), nl,
        write(~mysql_query(DbConnection, "use people")), nl,
        write(~mysql_query(DbConnection, "create table people(name char(16) not null, sex text, age int, primary key(name))")), nl,
        mysql_disconnect(DbConnection).

% Inserts people into the 'people' table.

male(john, 15).
male(peter, 24).
male(ralph, 24).
male(bart, 50).
female(kirsten, 24).
female(mary, 17).
female(jona, 12).
female(maija, 34).

%% Tuples are inserted as in the local Prolog dynamic database
insert_people :-
        (
            male(N, A),
            display('Inserting '), 
            display(male(N, A)), 
            nl,
            dbassertz_fact(people(N, male, A)), 
            fail 
        ; 
            true
        ),
        (
            female(N, A), 
            display('Inserting '), 
            display(female(N, A)), 
            nl,
            dbassertz_fact(people(N, female, A)),
            fail 
        ; 
            true
        ).

 %% Removes people from the 'people' table.

 %% Still not working in MySQL due to differences in SQL: working on it.

remove_people(A, B, C) :-
        dbretractall_fact(people(A, B, C)).
 
remove_people_2(A, B, C) :-
        dbretract_fact(people(A, B, C)),
        display('Removed row '), display(people(A, B, C)), nl,
        fail.
remove_people_2(_, _, _) :-
         display('No more rows'), nl.

show_people :-
        people(Name, Sex, Age),
        display(people(Name, Sex, Age)),
        nl,
        fail.
show_people :-
        display('No more rows'), nl.
        

</PRE>



<H2><A NAME="SEC628" HREF="ciao_toc.html#TOC628">Usage and interface (<CODE>persdbrt_mysql</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

Typically, this library is used including the 'persdb_mysql' package into the package list of the module, or using the 
<A NAME="IDX6462"></A>
<CODE>use_package/1</CODE> declaration: 
<DL COMPACT>

<DT>In a module:
<DD>

<PRE>
	:- module(bar, [main/1], [persdb_mysql]).
</PRE>

or 

<PRE>
        :- module(bar, [main/1]).
        :- include(library(persdb_mysql)).
</PRE>

<DT>In a <EM>user</EM> file:
<DD>

<PRE>
	:- use_package([persdb_mysql]).
</PRE>

or 

<PRE>
        :- include(library(persdb_mysql)).
</PRE>

</DL>
This loads the run-time and compile-time versions of the library (<CODE>persdbtr_mysql.pl</CODE> and <CODE>persdbrt_mysql.pl</CODE>) and includes some needed declarations.

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX6463"></A>
<CODE>init_sql_persdb/0</CODE>, 
<A NAME="IDX6464"></A>
<CODE>dbassertz_fact/1</CODE>, 
<A NAME="IDX6465"></A>
<CODE>dbretract_fact/1</CODE>, 
<A NAME="IDX6466"></A>
<CODE>dbcurrent_fact/1</CODE>, 
<A NAME="IDX6467"></A>
<CODE>dbretractall_fact/1</CODE>, 
<A NAME="IDX6468"></A>
<CODE>make_sql_persistent/3</CODE>, 
<A NAME="IDX6469"></A>
<CODE>dbfindall/4</CODE>, 
<A NAME="IDX6470"></A>
<CODE>dbcall/2</CODE>, 
<A NAME="IDX6471"></A>
<CODE>sql_query/3</CODE>, 
<A NAME="IDX6472"></A>
<CODE>sql_get_tables/2</CODE>, 
<A NAME="IDX6473"></A>
<CODE>sql_table_types/3</CODE>.

<LI><EM>Multifiles:</EM>

<A NAME="IDX6474"></A>
<CODE>sql_persistent_location/2</CODE>.

</UL>

<LI><STRONG>Other modules used:</STRONG>


<UL>

<LI><EM>System library modules:</EM>

<A NAME="IDX6475"></A>
<CODE>det_hook/det_hook_rt</CODE>, 
<A NAME="IDX6476"></A>
<CODE>persdb_mysql/db_client_types</CODE>, 
<A NAME="IDX6477"></A>
<CODE>persdb_mysql/pl2sql</CODE>, 
<A NAME="IDX6478"></A>
<CODE>persdb_sql_common/sqltypes</CODE>, 
<A NAME="IDX6479"></A>
<CODE>dynamic</CODE>, 
<A NAME="IDX6480"></A>
<CODE>terms</CODE>, 
<A NAME="IDX6481"></A>
<CODE>terms_vars</CODE>, 
<A NAME="IDX6482"></A>
<CODE>messages</CODE>, 
<A NAME="IDX6483"></A>
<CODE>lists</CODE>, 
<A NAME="IDX6484"></A>
<CODE>aggregates</CODE>, 
<A NAME="IDX6485"></A>
<CODE>persdb_mysql/mysql_client</CODE>, 
<A NAME="IDX6486"></A>
<CODE>persdb_sql_common/pl2sqlinsert</CODE>, 
<A NAME="IDX6487"></A>
<CODE>persdb_mysql/delete_compiler/pl2sqldelete</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC629" HREF="ciao_toc.html#TOC629">Documentation on exports (<CODE>persdbrt_mysql</CODE>)</A></H2>
<P>
<A NAME="IDX6488"></A>
<A NAME="IDX6489"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>init_sql_persdb/0:</B>
<DD><A NAME="IDX6490"></A>


<P>
<STRONG>Usage:</STRONG> 

<UL>
<LI><EM>Description:</EM> Internal predicate, used to transform predicates statically declared as persistent (see

<A NAME="IDX6491"></A>
<CODE>sql_persistent/3</CODE>) into real persistent predicates.  
</UL>

</DL>

<P>
<A NAME="IDX6492"></A>
<A NAME="IDX6493"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>dbassertz_fact/1:</B>
<DD><A NAME="IDX6494"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>dbassertz_fact(+Fact)</CODE>

<UL>
<LI><EM>Description:</EM> Persistent extension of

<A NAME="IDX6495"></A>
<CODE>assertz_fact/1</CODE>: the current instance of <CODE>Fact</CODE> is interpreted as a fact (i.e., a relation tuple) and is added to the end of the definition of the corresponding predicate. If any integrity constraint violation is done (database stored predicates), an error will be displayed. The predicate concerned must be statically (
<A NAME="IDX6496"></A>
<CODE>sql_persistent/3</CODE>) or dinamically (
<A NAME="IDX6497"></A>
<CODE>make_sql_persistent/3</CODE>) declared. Any uninstantiated variables in the <CODE>Fact</CODE> will be replaced by new, private variables. <STRONG>Note:</STRONG> <EM>assertion of facts with uninstantiated variables not implemented at this time.</EM> 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Fact</CODE> is a fact (a term whose main functor is not <CODE>':-'/2</CODE>).
 (<CODE>persdbrt_mysql:fact/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX6498"></A>
<A NAME="IDX6499"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>dbretract_fact/1:</B>
<DD><A NAME="IDX6500"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>dbretract_fact(+Fact)</CODE>

<UL>
<LI><EM>Description:</EM> Persistent extension of

<A NAME="IDX6501"></A>
<CODE>retract_fact/1</CODE>: deletes on backtracking all the facts which unify with <CODE>Fact</CODE>. The predicate concerned must be statically (
<A NAME="IDX6502"></A>
<CODE>sql_persistent/3</CODE>) or dinamically (
<A NAME="IDX6503"></A>
<CODE>make_sql_persistent/3</CODE>) declared. 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Fact</CODE> is a fact (a term whose main functor is not <CODE>':-'/2</CODE>).
 (<CODE>persdbrt_mysql:fact/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX6504"></A>
<A NAME="IDX6505"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>dbcurrent_fact/1:</B>
<DD><A NAME="IDX6506"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>dbcurrent_fact(+Fact)</CODE>

<UL>
<LI><EM>Description:</EM> Persistent extension of

<A NAME="IDX6507"></A>
<CODE>current_fact/1</CODE>: the fact <CODE>Fact</CODE> exists in the current database. The predicate concerned must be declared 
<A NAME="IDX6508"></A>
<CODE>sql_persistent/3</CODE>. Provides on backtracking all the facts (tuples) which unify with <CODE>Fact</CODE>. 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Fact</CODE> is a fact (a term whose main functor is not <CODE>':-'/2</CODE>).
 (<CODE>persdbrt_mysql:fact/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX6509"></A>
<A NAME="IDX6510"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>dbretractall_fact/1:</B>
<DD><A NAME="IDX6511"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>dbretractall_fact(+Fact)</CODE>

<UL>
<LI><EM>Description:</EM> Persistent extension of

<A NAME="IDX6512"></A>
<CODE>retractall_fact/1</CODE>: when called deletes all the facts which unify with <CODE>Fact</CODE>. The predicate concerned must be statically (
<A NAME="IDX6513"></A>
<CODE>sql_persistent/3</CODE>) or dinamically (
<A NAME="IDX6514"></A>
<CODE>make_sql_persistent/3</CODE>) declared. 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Fact</CODE> is a fact (a term whose main functor is not <CODE>':-'/2</CODE>).
 (<CODE>persdbrt_mysql:fact/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX6515"></A>
<A NAME="IDX6516"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>make_sql_persistent/3:</B>
<DD><A NAME="IDX6517"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>make_sql_persistent(addmodule,?,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>make_sql_persistent(PrologPredTypes,TableAttributes,Keyword)</CODE>

<UL>
<LI><EM>Description:</EM> Dynamic version of the

<A NAME="IDX6518"></A>
<CODE>sql_persistent/3</CODE> declaration. 
<LI><EM>The following properties should hold upon exit:</EM>

<CODE>PrologPredTypes</CODE> is a structure describing a Prolog predicate name with its types.
 (<CODE>persdbrt_mysql:prologPredTypes/1</CODE>)

<CODE>TableAttributes</CODE> is a structure describing a table name and some attributes.
 (<CODE>persdbrt_mysql:tableAttributes/1</CODE>)

<CODE>Keyword</CODE> is the name of a persistent storage location.
 (<CODE>persdbrt_mysql:persLocId/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX6519"></A>
<A NAME="IDX6520"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>dbfindall/4:</B>
<DD><A NAME="IDX6521"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>dbfindall(?,?,goal,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>dbfindall(+DBId,+Pattern,+ComplexGoal,-Results)</CODE>

<UL>
<LI><EM>Description:</EM> Similar to

<A NAME="IDX6522"></A>
<CODE>findall/3</CODE>, but <CODE>Goal</CODE> is executed in database <CODE>DBId</CODE>. Certain restrictions and extensions apply to both <CODE>Pattern</CODE> and <CODE>ComplexGoal</CODE> stemming from the Prolog to SQL translation involved (see the corresponding type definitions for details). 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+DBId</CODE> a unique identifier of a database session connection.
 (<CODE>mysql_client:dbconnection/1</CODE>)

<CODE>+Pattern</CODE> is a database projection term.
 (<CODE>pl2sql:projterm/1</CODE>)

<CODE>+ComplexGoal</CODE> is a database query goal.
 (<CODE>pl2sql:querybody/1</CODE>)

<CODE>-Results</CODE> is a list.
 (<CODE>basic_props:list/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX6523"></A>
<A NAME="IDX6524"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>dbcall/2:</B>
<DD><A NAME="IDX6525"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>dbcall(+DBId,+ComplexGoal)</CODE>

<UL>
<LI><EM>Description:</EM> Internal predicate, used by the transformed versions of the persistent predicates. Not meant to be called directly by users. It is exported by the library so that it can be used by the transformed versions of the persistent predicates in the modules in which they reside. Sends <CODE>ComplexGoal</CODE> to database <CODE>DBId</CODE> for evaluation. <CODE>ComplexGoal</CODE> must be a call to a persistent predicate which resides in database <CODE>DBId</CODE>.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+DBId</CODE> a unique identifier of a database session connection.
 (<CODE>mysql_client:dbconnection/1</CODE>)

<CODE>+ComplexGoal</CODE> is a database query goal.
 (<CODE>pl2sql:querybody/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX6526"></A>
<A NAME="IDX6527"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>sql_query/3:</B>
<DD><A NAME="IDX6528"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>sql_query(+DBId,+SQLString,AnswerTableTerm)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>ResultTerm</CODE> is the response from database <CODE>DBId</CODE> to the

<A NAME="IDX6529"></A>
SQL query in <CODE>SQLString</CODE> to database <CODE>DBId</CODE>. <CODE>AnswerTableTerm</CODE> can express a set of tuples, an error answer or a 'ok' response (see 
<A NAME="IDX6530"></A>
<CODE>answertableterm/1</CODE> for details). At the moment, 
<A NAME="IDX6531"></A>
<CODE>sql_query/3</CODE> log in and out for each query. This should be changed to log in only the first time and log out on exit and/or via a timer in the standard way. 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+DBId</CODE> a unique identifier of a database session connection.
 (<CODE>mysql_client:dbconnection/1</CODE>)

<CODE>+SQLString</CODE> is a string containing SQL code.
 (<CODE>pl2sql:sqlstring/1</CODE>)

<CODE>AnswerTableTerm</CODE> is a response from the ODBC database interface.
 (<CODE>persdbrt_mysql:answertableterm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX6532"></A>
<A NAME="IDX6533"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>sql_get_tables/2:</B>
<DD><A NAME="IDX6534"></A>


<P>
<STRONG>Usage 1:</STRONG> <CODE>sql_get_tables(+Location,-Tables)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Tables</CODE> contains the tables available in <CODE>Location</CODE>.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Location</CODE> is a structure describing a database.
 (<CODE>persdbrt_mysql:database_desc/1</CODE>)

<CODE>-Tables</CODE> is a list of <CODE>atm</CODE>s.
 (<CODE>basic_props:list/2</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>sql_get_tables(+DbConnection,-Tables)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Tables</CODE> contains the tables available in <CODE>DbConnection</CODE>.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+DbConnection</CODE> a unique identifier of a database session connection.
 (<CODE>mysql_client:dbconnection/1</CODE>)

<CODE>-Tables</CODE> is a list of <CODE>atm</CODE>s.
 (<CODE>basic_props:list/2</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX6535"></A>
<A NAME="IDX6536"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>sql_table_types/3:</B>
<DD><A NAME="IDX6537"></A>


<P>
<STRONG>Usage 1:</STRONG> <CODE>sql_table_types(+Location,+Table,-AttrTypes)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>AttrTypes</CODE> are the attributes and types of <CODE>Table</CODE> in <CODE>Location</CODE>.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Location</CODE> is a structure describing a database.
 (<CODE>persdbrt_mysql:database_desc/1</CODE>)

<CODE>+Table</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>-AttrTypes</CODE> is a list.
 (<CODE>basic_props:list/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>sql_table_types(+DbConnection,+Table,-AttrTypes)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>AttrTypes</CODE> are the attributes and types of <CODE>Table</CODE> in <CODE>DbConnection</CODE>.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+DbConnection</CODE> a unique identifier of a database session connection.
 (<CODE>mysql_client:dbconnection/1</CODE>)

<CODE>+Table</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>-AttrTypes</CODE> is a list.
 (<CODE>basic_props:list/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX6538"></A>
<A NAME="IDX6539"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>socketname/1:</B>
<DD><A NAME="IDX6540"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>socketname(IPP)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>IPP</CODE> is a structure describing a complete TCP/IP port address.

</UL>

</DL>

<P>
<A NAME="IDX6541"></A>
<A NAME="IDX6542"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>dbname/1:</B>
<DD><A NAME="IDX6543"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>dbname(DBId)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>DBId</CODE> is the identifier of an database.

</UL>

</DL>

<P>
<A NAME="IDX6544"></A>
<A NAME="IDX6545"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>user/1:</B>
<DD><A NAME="IDX6546"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>user(User)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>User</CODE> is a user name in the database.

</UL>

</DL>

<P>
<A NAME="IDX6547"></A>
<A NAME="IDX6548"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>passwd/1:</B>
<DD><A NAME="IDX6549"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>passwd(Passwd)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Passwd</CODE> is the password for the user name in the database.

</UL>

</DL>

<P>
<A NAME="IDX6550"></A>
<A NAME="IDX6551"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>projterm/1:</B>
<DD><A NAME="IDX6552"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>projterm(DBProjTerm)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>DBProjTerm</CODE> is a database projection term.

</UL>

</DL>

<P>
<A NAME="IDX6553"></A>
<A NAME="IDX6554"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>querybody/1:</B>
<DD><A NAME="IDX6555"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>querybody(DBGoal)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>DBGoal</CODE> is a database query goal.

</UL>

</DL>

<P>
<A NAME="IDX6556"></A>
<DL>
<DT><span class="define">(UNDOC_REEXPORT):</span> <B>sqltype/1:</B>
<DD><A NAME="IDX6557"></A>


<P>
 Imported from 
<A NAME="IDX6558"></A>
<CODE>sqltypes</CODE> (see the corresponding documentation for details).


</DL>



<H2><A NAME="SEC630" HREF="ciao_toc.html#TOC630">Documentation on multifiles (<CODE>persdbrt_mysql</CODE>)</A></H2>
<P>
<A NAME="IDX6559"></A>
<A NAME="IDX6560"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>sql_persistent_location/2:</B>
<DD><A NAME="IDX6561"></A>


<P>
Relates names of locations (the <CODE>Keyword</CODE>s) with descriptions of such locations (<CODE>Location</CODE>s).


<P>
The predicate is <EM>multifile</EM>.


<P>
The predicate is of type <EM>dynamic</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>sql_persistent_location(Keyword,DBLocation)</CODE>

<UL>
<LI><EM>Description:</EM> In this usage, <CODE>DBLocation</CODE> is a <EM>relational database</EM>, in which case the predicate is stored as tuples in the database.

<LI><EM>The following properties should hold upon exit:</EM>

<CODE>Keyword</CODE> is the name of a persistent storage location.
 (<CODE>persdbrt_mysql:persLocId/1</CODE>)

<CODE>DBLocation</CODE> is a structure describing a database.
 (<CODE>persdbrt_mysql:database_desc/1</CODE>)
</UL>

</DL>



<H2><A NAME="SEC631" HREF="ciao_toc.html#TOC631">Documentation on internals (<CODE>persdbrt_mysql</CODE>)</A></H2>
<P>
<A NAME="IDX6562"></A>
<A NAME="IDX6563"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>tuple/1:</B>
<DD><A NAME="IDX6564"></A>



<PRE>
tuple(T) :-
        list(T,atm).
tuple(T) :-
        list(T,atm).
</PRE>

<P>
<STRONG>Usage:</STRONG> <CODE>tuple(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is a tuple of values from the ODBC database interface.

</UL>

</DL>

<P>
<A NAME="IDX6565"></A>
<A NAME="IDX6566"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>dbconnection/1:</B>
<DD><A NAME="IDX6567"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>dbconnection(H)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>H</CODE> a unique identifier of a database session connection.

</UL>

</DL>

<P>
<A NAME="IDX6568"></A>
<A NAME="IDX6569"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>sql_persistent/3:</B>
<DD><A NAME="IDX6570"></A>


<P>
<STRONG>Usage:</STRONG> :- <CODE>sql_persistent(PrologPredTypes,TableAttributes,Keyword)</CODE>.

<UL>
<LI><EM>Description:</EM> Declares the predicate corresponding to the main functor of <CODE>PrologPredTypes</CODE> as SQL persistent. <CODE>Keyword</CODE> is the

<A NAME="IDX6571"></A>
name of a location where the 
<A NAME="IDX6572"></A>
persistent storage for the predicate is kept, which in this case must be an external relational database. The description of this database is given through the 
<A NAME="IDX6573"></A>
<CODE>sql_persistent_location</CODE> predicate, which must contain a fact in which the first argument unifies with <CODE>Keyword</CODE>. <CODE>TableAttributes</CODE> provides the 
<A NAME="IDX6574"></A>
table name and 
<A NAME="IDX6575"></A>
attributes in the database corresponding respectively to the predicate name and arguments of the (virtual) Prolog predicate. 

Although a predicate may be persistent, other usual clauses can be defined in the source code. When querying a persistent predicate with non-persistent clauses, persistent and non-persisten clauses will be evaluated in turn; the order of evaluation is the usual Prolog order, considering that persistent clauses are defined in the program point where the 
<A NAME="IDX6576"></A>
<CODE>sql_persistent/3</CODE> declaration is. 

<STRONG>Example:</STRONG> 


<PRE>
:- sql_persistent(product( integer,    integer, string, string ),
              product( quantity,   id,      name,   size   ),
              radiowebdb).

sql_persistent_location(radiowebdb,
   db('SQL Anywhere 5.0 Sample', user, pass,
      'r2d5.dia.fi.upm.es':2020)).
</PRE>

 
<LI><EM>The following properties should hold upon exit:</EM>

<CODE>PrologPredTypes</CODE> is a structure describing a Prolog predicate name with its types.
 (<CODE>persdbrt_mysql:prologPredTypes/1</CODE>)

<CODE>TableAttributes</CODE> is a structure describing a table name and some attributes.
 (<CODE>persdbrt_mysql:tableAttributes/1</CODE>)

<CODE>Keyword</CODE> is the name of a persistent storage location.
 (<CODE>persdbrt_mysql:persLocId/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX6577"></A>
<A NAME="IDX6578"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>db_query/4:</B>
<DD><A NAME="IDX6579"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>db_query(+DBId,+ProjTerm,+Goal,ResultTerm)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>ResultTerm</CODE> contains all the

<A NAME="IDX6580"></A>
tuples which are the response from database <CODE>DBId</CODE> to the Prolog query <CODE>Goal</CODE>, projected onto <CODE>ProjTerm</CODE>. Uses 
<A NAME="IDX6581"></A>
<CODE>pl2sqlstring/3</CODE> for the 
<A NAME="IDX6582"></A>
Prolog to SQL translation and 
<A NAME="IDX6583"></A>
<CODE>sql_query/3</CODE> for posing the actual query. 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+DBId</CODE> a unique identifier of a database session connection.
 (<CODE>mysql_client:dbconnection/1</CODE>)

<CODE>+ProjTerm</CODE> is a database projection term.
 (<CODE>pl2sql:projterm/1</CODE>)

<CODE>+Goal</CODE> is a database query goal.
 (<CODE>pl2sql:querybody/1</CODE>)

<CODE>ResultTerm</CODE> is a tuple of values from the ODBC database interface.
 (<CODE>persdbrt_mysql:tuple/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX6584"></A>
<A NAME="IDX6585"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>db_query_one_tuple/4:</B>
<DD><A NAME="IDX6586"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>db_query_one_tuple(+DBId,+ProjTerm,+Goal,ResultTerm)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>ResultTerm</CODE> is one of the

<A NAME="IDX6587"></A>
tuples which are the response from database <CODE>DBId</CODE> to the Prolog query <CODE>Goal</CODE>, projected onto <CODE>ProjTerm</CODE>. Uses 
<A NAME="IDX6588"></A>
<CODE>pl2sqlstring/3</CODE> for the 
<A NAME="IDX6589"></A>
Prolog to SQL translation and 
<A NAME="IDX6590"></A>
<CODE>sql_query_one_tuple/3</CODE> for posing the actual query. After last tuple has been reached, a null tuple is unified with ResultTerm, and the connection to the database finishes. 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+DBId</CODE> a unique identifier of a database session connection.
 (<CODE>mysql_client:dbconnection/1</CODE>)

<CODE>+ProjTerm</CODE> is a database projection term.
 (<CODE>pl2sql:projterm/1</CODE>)

<CODE>+Goal</CODE> is a database query goal.
 (<CODE>pl2sql:querybody/1</CODE>)

<CODE>ResultTerm</CODE> is a predicate containing a tuple.
 (<CODE>persdbrt_mysql:answertupleterm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX6591"></A>
<A NAME="IDX6592"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>sql_query_one_tuple/3:</B>
<DD><A NAME="IDX6593"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>sql_query_one_tuple(+DBId,+SQLString,ResultTuple)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>ResultTuple</CODE> contains an element from the set of tuples which represents the response in <CODE>DBId</CODE> to the

<A NAME="IDX6594"></A>
SQL query <CODE>SQLString</CODE>. If the connection is kept, succesive calls return consecutive tuples, until the last tuple is reached. Then a null tuple is unified with <CODE>ResultTuple</CODE> and the connection is finished (calls to 
<A NAME="IDX6595"></A>
<CODE>mysql_disconnect/1</CODE>). 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+DBId</CODE> a unique identifier of a database session connection.
 (<CODE>mysql_client:dbconnection/1</CODE>)

<CODE>+SQLString</CODE> is a string containing SQL code.
 (<CODE>pl2sql:sqlstring/1</CODE>)

<CODE>ResultTuple</CODE> is a tuple of values from the ODBC database interface.
 (<CODE>persdbrt_mysql:tuple/1</CODE>)
</UL>

</DL>



<H2><A NAME="SEC632" HREF="ciao_toc.html#TOC632">Known bugs and planned improvements (<CODE>persdbrt_mysql</CODE>)</A></H2>


<UL>

<LI>

At least in the shell, reloading a file after changing the definition of a persistent predicate does not eliminate the old definition...

<LI>

Functionality missing: some questions need to be debugged.

<LI>

Warning: still using kludgey string2term and still using some non-uniquified temp files.

<LI>

Needs to be unified with the file-based library.
</UL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_149.html">previous</A>, <A HREF="ciao_151.html">next</A>, <A HREF="ciao_232.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
