<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 20 April 2004 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - Filed predicates</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_149.html">previous</A>, <A HREF="ciao_151.html">next</A>, <A HREF="ciao_241.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC626" HREF="ciao_toc.html#TOC626">Filed predicates</A></H1>
<P>
<A NAME="IDX6867"></A>


<P>
<STRONG>Author(s):</STRONG> Francisco Bueno.


<P>
<STRONG>Version:</STRONG> 1.9#330 (2004/3/25, 16:54:55 CET)


<P>
<STRONG>Version of last change:</STRONG> 1.9#10 (2002/5/30, 19:46:8 CEST)


<P>
This package allows using files as a "
<A NAME="IDX6868"></A>
cache" for predicates defined by facts. This is useful for huge tables of facts that may push the memory limits of the system too far. Goals of a 
<A NAME="IDX6869"></A>
filed predicate are executed simply by reading from the corresponding file. 


<P>
Anything in the DB file used for the predicate that is different from a fact for the corresponding predicate is ignored. Each call to a filed predicate forces opening the file, so the use of this package is subject to the limit on the number of open files that the system can support. 


<P>
Dynamic modification of the filed predicates is also allowed during execution of the program. Thus filed predicates are regarded as dynamic, data predicates residing in a file. However, dynamic modifications to the predicates do not affect the file, unless the predicate is also declared persistent. 


<P>
The package is compatible with 
<A NAME="IDX6870"></A>
<CODE>persdb</CODE> in the sense that a predicate can be made both filed and persistent. In this way, the predicate can be used in programs, but it will not be loaded (saving memory), can also be modified during execution, and modifications will persist in the file. Thus, the user interface to both packages is the same (so the DB file must be one for both filing and persistency). 



<UL>
<LI><A HREF="ciao_150.html#SEC627">Usage and interface (factsdb_rt)</A>
<LI><A HREF="ciao_150.html#SEC628">Documentation on exports (factsdb_rt)</A>
<LI><A HREF="ciao_150.html#SEC629">Documentation on multifiles (factsdb_rt)</A>
<LI><A HREF="ciao_150.html#SEC630">Documentation on internals (factsdb_rt)</A>
<LI><A HREF="ciao_150.html#SEC631">Known bugs and planned improvements (factsdb_rt)</A>
</UL>



<H2><A NAME="SEC627" HREF="ciao_toc.html#TOC627">Usage and interface (<CODE>factsdb_rt</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

This facility is used as a package, thus either including 
<A NAME="IDX6871"></A>
<CODE>factsdb</CODE> in the package list of the module, or by using the 
<A NAME="IDX6872"></A>
<CODE>use_package/1</CODE> declaration. The facility predicates are defined in library module 
<A NAME="IDX6873"></A>
<CODE>factsdb_rt</CODE>.

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX6874"></A>
<CODE>asserta_fact/1</CODE>, 
<A NAME="IDX6875"></A>
<CODE>assertz_fact/1</CODE>, 
<A NAME="IDX6876"></A>
<CODE>call/1</CODE>, 
<A NAME="IDX6877"></A>
<CODE>current_fact/1</CODE>, 
<A NAME="IDX6878"></A>
<CODE>retract_fact/1</CODE>.

<LI><EM>Multifiles:</EM>

<A NAME="IDX6879"></A>
<CODE>$factsdb$cached_goal/3</CODE>, 
<A NAME="IDX6880"></A>
<CODE>persistent_dir/2</CODE>, 
<A NAME="IDX6881"></A>
<CODE>file_alias/2</CODE>.

</UL>

<LI><STRONG>Other modules used:</STRONG>


<UL>

<LI><EM>System library modules:</EM>

<A NAME="IDX6882"></A>
<CODE>counters</CODE>, 
<A NAME="IDX6883"></A>
<CODE>read</CODE>, 
<A NAME="IDX6884"></A>
<CODE>persdb/persdbcache</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC628" HREF="ciao_toc.html#TOC628">Documentation on exports (<CODE>factsdb_rt</CODE>)</A></H2>
<P>
<A NAME="IDX6885"></A>
<A NAME="IDX6886"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>asserta_fact/1:</B>
<DD><A NAME="IDX6887"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>asserta_fact(fact)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>asserta_fact(Fact)</CODE>

<UL>
<LI><EM>Description:</EM> Version of

<A NAME="IDX6888"></A>
<CODE>data_facts:asserta_fact/1</CODE> for filed predicates. The current instance of <CODE>Fact</CODE> is interpreted as a fact and is added at the beginning of the definition of the corresponding predicate. Therefore, before all the facts filed in the DB file for the predicate. The predicate concerned must be declared as 
<A NAME="IDX6889"></A>
<CODE>facts</CODE>; if it is not, then 
<A NAME="IDX6890"></A>
<CODE>data_facts:asserta_fact/1</CODE> is used. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Fact</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX6891"></A>
<A NAME="IDX6892"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>assertz_fact/1:</B>
<DD><A NAME="IDX6893"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>assertz_fact(fact)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>assertz_fact(Fact)</CODE>

<UL>
<LI><EM>Description:</EM> Version of

<A NAME="IDX6894"></A>
<CODE>data_facts:assertz_fact/1</CODE> for filed predicates. The current instance of <CODE>Fact</CODE> is interpreted as a fact and is added at the end of the definition of the corresponding predicate. Therefore, after all the facts filed in the DB file for the predicate. The predicate concerned must be declared as 
<A NAME="IDX6895"></A>
<CODE>facts</CODE>; if it is not, then 
<A NAME="IDX6896"></A>
<CODE>data_facts:assertz_fact/1</CODE> is used. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Fact</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX6897"></A>
<A NAME="IDX6898"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>call/1:</B>
<DD><A NAME="IDX6899"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>call(fact)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>call(Fact)</CODE>

<UL>
<LI><EM>Description:</EM> Same as

<A NAME="IDX6900"></A>
<CODE>current_fact/1</CODE> if the predicate concerned is declared as 
<A NAME="IDX6901"></A>
<CODE>facts</CODE>. If it is not, an exception is raised. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Fact</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX6902"></A>
<A NAME="IDX6903"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>current_fact/1:</B>
<DD><A NAME="IDX6904"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>current_fact(fact)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>current_fact(Fact)</CODE>

<UL>
<LI><EM>Description:</EM> Version of

<A NAME="IDX6905"></A>
<CODE>data_facts:current_fact/1</CODE> for filed predicates. The current instance of <CODE>Fact</CODE> is interpreted as a fact and is unified with an actual fact in the current definition of the corresponding predicate. Therefore, with a fact previously asserted or filed in the DB file for the predicate, if it has not been retracted. The predicate concerned must be declared as 
<A NAME="IDX6906"></A>
<CODE>facts</CODE>; if it is not, then 
<A NAME="IDX6907"></A>
<CODE>data_facts:current_fact/1</CODE> is used. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Fact</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX6908"></A>
<A NAME="IDX6909"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>retract_fact/1:</B>
<DD><A NAME="IDX6910"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>retract_fact(fact)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>retract_fact(Fact)</CODE>

<UL>
<LI><EM>Description:</EM> Version of

<A NAME="IDX6911"></A>
<CODE>data_facts:retract_fact/1</CODE> for filed predicates. The current instance of <CODE>Fact</CODE> is interpreted as a fact and is unified with an actual fact in the current definition of the corresponding predicate; such a fact is deleted from the predicate definition. This is true even for the facts filed in the DB file for the predicate; but these are NOT deleted from the file (unless the predicate is persistent). The predicate concerned must be declared as 
<A NAME="IDX6912"></A>
<CODE>facts</CODE>; if it is not, then 
<A NAME="IDX6913"></A>
<CODE>data_facts:retract_fact/1</CODE> is used. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Fact</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)
</UL>

</DL>



<H2><A NAME="SEC629" HREF="ciao_toc.html#TOC629">Documentation on multifiles (<CODE>factsdb_rt</CODE>)</A></H2>
<P>
<A NAME="IDX6914"></A>
<A NAME="IDX6915"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>$factsdb$cached_goal/3:</B>
<DD><A NAME="IDX6916"></A>


<P>
<CODE>$factsdb$cached_goal(Spec, Spec, Key)</CODE>


<P>
Predicate <CODE>Spec</CODE> is filed within database <CODE>Key</CODE>. Programmers should not define this predicate directly in the program.


<P>
The predicate is <EM>multifile</EM>.


</DL>

<P>
<A NAME="IDX6917"></A>
<A NAME="IDX6918"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>persistent_dir/2:</B>
<DD><A NAME="IDX6919"></A>


<P>
See 
<A NAME="IDX6920"></A>
<CODE>persdb</CODE>.


<P>
The predicate is <EM>multifile</EM>.


<P>
The predicate is of type <EM>data</EM>.


</DL>

<P>
<A NAME="IDX6921"></A>
<A NAME="IDX6922"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>file_alias/2:</B>
<DD><A NAME="IDX6923"></A>


<P>
See 
<A NAME="IDX6924"></A>
<CODE>symfnames</CODE>. This predicate is used only if 
<A NAME="IDX6925"></A>
<CODE>persistent_dir/2</CODE> fails.


<P>
The predicate is <EM>multifile</EM>.


<P>
The predicate is of type <EM>data</EM>.


</DL>



<H2><A NAME="SEC630" HREF="ciao_toc.html#TOC630">Documentation on internals (<CODE>factsdb_rt</CODE>)</A></H2>
<P>
<A NAME="IDX6926"></A>
<A NAME="IDX6927"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>facts/2:</B>
<DD><A NAME="IDX6928"></A>


<P>
<STRONG>Usage:</STRONG> :- <CODE>facts(PredDesc, Keyword)</CODE>.

<UL>
<LI><EM>Description:</EM> Declares the predicate <CODE>PredDesc</CODE> as filed. <CODE>Keyword</CODE> is the

<A NAME="IDX6929"></A>
identifier of a location where the file DB for the predicate is kept. The location <CODE>Keyword</CODE> is described in the 
<A NAME="IDX6930"></A>
<CODE>file_alias</CODE> predicate, which must contain a fact in which the first argument unifies with <CODE>Keyword</CODE>. 
<LI><EM>The following properties should hold upon exit:</EM>

<CODE>PredDesc</CODE> is a Name/Arity structure denoting a predicate name: 

<PRE>
predname(P/A) :-
        atm(P),
        nnegint(A).
</PRE>

 (<CODE>basic_props:predname/1</CODE>)

<CODE>Keyword</CODE> is an atom corresponding to a directory identifier.
 (<CODE>persdbcache:keyword/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX6931"></A>
<A NAME="IDX6932"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>keyword/1:</B>
<DD><A NAME="IDX6933"></A>


<P>
See 
<A NAME="IDX6934"></A>
<CODE>persdbrt</CODE>. The same conventions for location of DB files apply in both packages.


</DL>



<H2><A NAME="SEC631" HREF="ciao_toc.html#TOC631">Known bugs and planned improvements (<CODE>factsdb_rt</CODE>)</A></H2>


<UL>

<LI>

The DB files for persistent predicates have to be used as such from the beginning. Using a DB file for a filed predicate first, and then using it also when making the predicate persistent won't work. Nor the other way around: using a DB file for a persistent predicate first, and then using it also when making the predicate filed.
</UL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_149.html">previous</A>, <A HREF="ciao_151.html">next</A>, <A HREF="ciao_241.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
