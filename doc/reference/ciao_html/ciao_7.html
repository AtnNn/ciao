<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 23 April 2004 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - The interactive top-level shell</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_6.html">previous</A>, <A HREF="ciao_8.html">next</A>, <A HREF="ciao_241.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC65" HREF="ciao_toc.html#TOC65">The interactive top-level shell</A></H1>
<P>
<A NAME="IDX527"></A>


<P>
<STRONG>Author(s):</STRONG> Daniel Cabeza and the CLIP Group.


<P>
<STRONG>Version:</STRONG> 1.9#330 (2004/3/25, 16:54:55 CET)


<P>
<STRONG>Version of last change:</STRONG> 1.7#129 (2001/10/28, 15:38:52 CET)


<P>
<A NAME="IDX528"></A>
<CODE>ciaosh</CODE> is the Ciao interactive top-level shell. It provides the user with an interactive programming environment with tools for incrementally building programs, debugging programs by following their executions, and modifying parts of programs without having to start again from scratch. If available, it is strongly recommended to use it with the 
<A NAME="IDX529"></A>
emacs interface provided, as it greatly simplifies the operation. This chapter documents general operation in the shell itself. Other chapters document the 



<UL>
<LI><A HREF="ciao_7.html#SEC66">Shell invocation and startup</A>
<LI><A HREF="ciao_7.html#SEC67">Shell interaction</A>
<LI><A HREF="ciao_7.html#SEC68">Entering recursive (conjunctive) shell levels</A>
<LI><A HREF="ciao_7.html#SEC69">Usage and interface (ciaosh)</A>
<LI><A HREF="ciao_7.html#SEC70">Documentation on exports (ciaosh)</A>
<LI><A HREF="ciao_7.html#SEC71">Documentation on internals (ciaosh)</A>
</UL>



<H2><A NAME="SEC66" HREF="ciao_toc.html#TOC66">Shell invocation and startup</A></H2>

<P>
When invoked, the shell responds with a message of identification and the prompt <CODE>?- </CODE> as soon as it is ready to accept input, thus: 



<PRE>
Ciao-Prolog X.Y #PP: Thu Mar 25 17:20:55 MET 1999
?- 
</PRE>

<P>
When the shell is initialized it looks for a file 
<A NAME="IDX530"></A>
<CODE>.ciaorc</CODE> in the HOME directory and makes an <CODE>include</CODE> of it, if it exists. This file is useful for including 
<A NAME="IDX531"></A>
<CODE>use_module/1</CODE> declarations for the modules one wants to be loaded by default, changing 
<A NAME="IDX532"></A>
prolog flags, etc. (Note that the 
<A NAME="IDX533"></A>
<CODE>.ciaorc</CODE> file can only contain directives, not actual code; to load some code at startup put it in a separate file and load it using e.g. a 
<A NAME="IDX534"></A>
<CODE>use_module/1</CODE> declaration.) If the initialization file does not exist, the default package 
<A NAME="IDX535"></A>
<CODE>default</CODE> is included, to provide more or less what other prologs define by default. Thus, if you want to have available all builtins you had before adding the initialization file, you have to include <CODE>:- use_package(default)</CODE> in it. Two command-line options control the loading of the initialization file: 


<DL COMPACT>

<DT><CODE>-f</CODE>
<DD>
Fast start, do not load any initialization file. 

<DT><CODE>-l</CODE> <CODE>File</CODE>
<DD>
Look for initialization file <CODE>File</CODE> instead of <CODE>~/.ciaorc</CODE>. If it does not exist, include the default package. 

</DL>



<H2><A NAME="SEC67" HREF="ciao_toc.html#TOC67">Shell interaction</A></H2>

<P>
After the shell outputs the prompt, it is expecting either an internal command (see the following sections) or a 
<A NAME="IDX536"></A>
<A NAME="IDX537"></A>
<EM>query</EM> (a goal or sequence of goals). When typing in the input, which must be a valid prolog term, if the term does not end in the first line, subsequent lines are indented. For example: 



<PRE>
?- X =
   f(a,
   b).

X = f(a,b) ? 

yes
?- 
</PRE>

<P>
The queries are executed by the shell as if they appeared in the 
<A NAME="IDX538"></A>
user module. Thus, in addition to builtin predicates, predicates available to be executed directly are all predicates defined by loaded user files (files with no module declaration), and imported predicates from modules by the use of <CODE>use_module</CODE>. 


<P>
The possible answers of the shell, after executing an internal command or query, are: 



<UL>

<LI>If the execution failed (or produced an error), the answer is <CODE>no</CODE>.

<LI>If the execution was successful, and no

<A NAME="IDX539"></A>
answer variable (see below) was bound (or constraints where imposed on such variables), the answer is simply <CODE>yes</CODE>. This behavior can be changed by doing <CODE>set_prolog_flag(prompt_alternatives_no_bindings, on).</CODE>, so that in any case the user will be consulted as explained in the next point (useful if the solutions produce side effects). 

<LI>If the execution was successful and bindings where made (or constraints where imposed) on

<A NAME="IDX540"></A>
answer variables, then the shell outputs the values of answer variables, as a sequence of bindings (or constraints), and then prints a <CODE>?</CODE> as a prompt. At this point it is expecting an input line from the user. By entering a carriage-return (<KBD>RET</KBD>) or any line starting with <CODE>y</CODE>, the query terminates and the shell answer <CODE>yes</CODE>. Entering a `<CODE>,</CODE>' the shell enters a 
<A NAME="IDX541"></A>
recursive level (see below). Finally, any other answer forces the system to backtrack and look for the next solution (answering as with the first solution). 

</UL>

<P>
To allow using connection variables in queries without having to report their results, variables whose name starts with <CODE>_</CODE> are not considered in answers, the rest being the 
<A NAME="IDX542"></A>
<A NAME="IDX543"></A>
<EM>answer variable</EM>s. This example illustrates the previous points: 



<PRE>
?- member(a, [b, c]).

no
?- member(a, [a, b]).

yes
?- member(X, [a|L]).

X = a ? ;

L = [X|_] ? 

yes
?- atom_codes(ciao, _C), member(L, _C).

L = 99 ? ;

L = 105 ? ;

L = 97 ? ;

L = 111 ? ;

no
?- 
</PRE>



<H2><A NAME="SEC68" HREF="ciao_toc.html#TOC68">Entering recursive (conjunctive) shell levels</A></H2>

<P>
As stated before, when the user answers with `<CODE>,</CODE>' after a solution is presented, the shell enters a 
<A NAME="IDX544"></A>
<A NAME="IDX545"></A>
<EM>recursive level</EM>, changing its prompt to <EM>N</EM> <CODE>?- </CODE> (where <EM>N</EM> is the recursion level) and keeping the bindings or constraints of the solution (this is inspired by the 
<A NAME="IDX546"></A>
<A NAME="IDX547"></A>
<EM>LogIn</EM> language developed by 
<A NAME="IDX548"></A>
<A NAME="IDX549"></A>
<EM>H. Ait-Kaci</EM>, 
<A NAME="IDX550"></A>
<A NAME="IDX551"></A>
<EM>P. Lincoln</EM> and 
<A NAME="IDX552"></A>
<A NAME="IDX553"></A>
<EM>Roger Nasr</EM> [AKNL86]). Thus, the following queries will be executed within that context, and all variables in the lower level solutions will be reported in subsequent solutions at this level. To exit a recursive level, input an <KBD>EOF</KBD> character or the command <CODE>up</CODE>. The last solution after entering the level is repeated, to allow asking for more solutions. Use command <CODE>top</CODE> to exit all recursive levels and return to the top level. Example interaction: 



<PRE>
?- directory_files('.',_Fs), member(F,_Fs).

F = 'file_utils.po' ? ,

1 ?- file_property(F, mod_time(T)).

F = 'file_utils.po',
T = 923497679 ? 

yes
1 ?- up.

F = 'file_utils.po' ? ;

F = 'file_utils.pl' ? ;

F = 'file_utils.itf' ? ,

1 ?- file_property(F, mod_time(T)).

F = 'file_utils.itf',
T = 923497679 ? 

yes
1 ?- ^D
F = 'file_utils.itf' ? 

yes
?- 
</PRE>



<H2><A NAME="SEC69" HREF="ciao_toc.html#TOC69">Usage and interface (<CODE>ciaosh</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

The following predicates can be used at the top-level shell natively (but see also the commands available in section <A HREF="ciao_8.html#SEC72">The interactive debugger</A> which are also available within the top-level shell).

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX554"></A>
<CODE>use_module/1</CODE>, 
<A NAME="IDX555"></A>
<CODE>use_module/2</CODE>, 
<A NAME="IDX556"></A>
<CODE>ensure_loaded/1</CODE>, 
<A NAME="IDX557"></A>
<CODE>make_exec/2</CODE>, 
<A NAME="IDX558"></A>
<CODE>include/1</CODE>, 
<A NAME="IDX559"></A>
<CODE>use_package/1</CODE>, 
<A NAME="IDX560"></A>
<CODE>consult/1</CODE>, 
<A NAME="IDX561"></A>
<CODE>compile/1</CODE>, 
<A NAME="IDX562"></A>
<CODE>./2</CODE>, 
<A NAME="IDX563"></A>
<CODE>make_po/1</CODE>, 
<A NAME="IDX564"></A>
<CODE>unload/1</CODE>, 
<A NAME="IDX565"></A>
<CODE>set_debug_mode/1</CODE>, 
<A NAME="IDX566"></A>
<CODE>set_nodebug_mode/1</CODE>, 
<A NAME="IDX567"></A>
<CODE>make_actmod/2</CODE>, 
<A NAME="IDX568"></A>
<CODE>force_lazy/1</CODE>, 
<A NAME="IDX569"></A>
<CODE>undo_force_lazy/1</CODE>, 
<A NAME="IDX570"></A>
<CODE>dynamic_search_path/1</CODE>, 
<A NAME="IDX571"></A>
<CODE>multifile/1</CODE>.

</UL>

<LI><STRONG>Other modules used:</STRONG>


<UL>

<LI><EM>Application modules:</EM>

<A NAME="IDX572"></A>
<CODE>library(ciaosh)</CODE>.

<LI><EM>System library modules:</EM>

<A NAME="IDX573"></A>
<CODE>libpaths</CODE>, 
<A NAME="IDX574"></A>
<CODE>compiler/compiler</CODE>, 
<A NAME="IDX575"></A>
<CODE>compiler/exemaker</CODE>, 
<A NAME="IDX576"></A>
<CODE>compiler/c_itf</CODE>, 
<A NAME="IDX577"></A>
<CODE>debugger/debugger</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC70" HREF="ciao_toc.html#TOC70">Documentation on exports (<CODE>ciaosh</CODE>)</A></H2>
<P>
<A NAME="IDX578"></A>
<A NAME="IDX579"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>use_module/1:</B>
<DD><A NAME="IDX580"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>use_module(Module)</CODE>

<UL>
<LI><EM>Description:</EM> Load into the top-level the module defined in <CODE>Module</CODE>, importing all the predicates it exports.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Module</CODE> is a source name.
 (<CODE>streams_basic:sourcename/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX581"></A>
<A NAME="IDX582"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>use_module/2:</B>
<DD><A NAME="IDX583"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>use_module(Module, Imports)</CODE>

<UL>
<LI><EM>Description:</EM> Load into the top-level the module defined in <CODE>Module</CODE>, importing the predicates in <CODE>Imports</CODE>.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Module</CODE> is a source name.
 (<CODE>streams_basic:sourcename/1</CODE>)

<CODE>Imports</CODE> is a list of <CODE>predname</CODE>s.
 (<CODE>basic_props:list/2</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX584"></A>
<A NAME="IDX585"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>ensure_loaded/1:</B>
<DD><A NAME="IDX586"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>ensure_loaded(File)</CODE>

<UL>
<LI><EM>Description:</EM> Load into the top-level the code residing in file (or files) <CODE>File</CODE>, which is user (i.e. non-module) code.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>File</CODE> is a source name or a list of source names.
 (<CODE>ciaosh_doc:sourcenames/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX587"></A>
<A NAME="IDX588"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>make_exec/2:</B>
<DD><A NAME="IDX589"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>make_exec(File, ExecName)</CODE>

<UL>
<LI><EM>Description:</EM> Make a Ciao executable from file (or files) <CODE>File</CODE>, giving it name <CODE>ExecName</CODE>. If <CODE>ExecName</CODE> is a variable, the compiler will choose a default name for the executable and will bind the variable <CODE>ExecName</CODE> to that name. The name is chosen as follows: if the main prolog file has no <CODE>.pl</CODE> extension or we are in Windows, the executable will have extension <CODE>.cpx</CODE>; else the executable will be named as the main prolog file without extension.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>File</CODE> is a source name or a list of source names.
 (<CODE>ciaosh_doc:sourcenames/1</CODE>)
<LI><EM>The following properties hold upon exit:</EM>

<CODE>ExecName</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX590"></A>
<A NAME="IDX591"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>include/1:</B>
<DD><A NAME="IDX592"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>include(File)</CODE>

<UL>
<LI><EM>Description:</EM> The contents of the file <CODE>File</CODE> are included in the top-level shell. For the moment, it only works with some directives, which are interpreted by the shell, or with normal clauses (which are asserted), if library(dynamic) is loaded beforehand.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>File</CODE> is a source name.
 (<CODE>streams_basic:sourcename/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX593"></A>
<A NAME="IDX594"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>use_package/1:</B>
<DD><A NAME="IDX595"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>use_package(Package)</CODE>

<UL>
<LI><EM>Description:</EM> Equivalent to issuing an include(library(<CODE>Package</CODE>)) for each listed file. By now some package contents cannot be handled.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Package</CODE> is a source name or a list of source names.
 (<CODE>ciaosh_doc:sourcenames/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX596"></A>
<A NAME="IDX597"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>consult/1:</B>
<DD><A NAME="IDX598"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>consult(File)</CODE>

<UL>
<LI><EM>Description:</EM> Provided for backward compatibility. Similar to

<A NAME="IDX599"></A>
<CODE>ensure_loaded/1</CODE>, but ensuring each listed file is loaded in consult mode (see section <A HREF="ciao_8.html#SEC72">The interactive debugger</A>). 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>File</CODE> is a source name or a list of source names.
 (<CODE>ciaosh_doc:sourcenames/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX600"></A>
<A NAME="IDX601"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>compile/1:</B>
<DD><A NAME="IDX602"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>compile(File)</CODE>

<UL>
<LI><EM>Description:</EM> Provided for backward compatibility. Similar to

<A NAME="IDX603"></A>
<CODE>ensure_loaded/1</CODE>, but ensuring each listed file is loaded in compile mode (see section <A HREF="ciao_8.html#SEC72">The interactive debugger</A>). 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>File</CODE> is a source name or a list of source names.
 (<CODE>ciaosh_doc:sourcenames/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX604"></A>
<A NAME="IDX605"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>./2:</B>
<DD><A NAME="IDX606"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>.(File, Files)</CODE>

<UL>
<LI><EM>Description:</EM> Provided for backward compatibility, obsoleted by

<A NAME="IDX607"></A>
<CODE>ensure_loaded/1</CODE>. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>File</CODE> is a source name.
 (<CODE>streams_basic:sourcename/1</CODE>)

<CODE>Files</CODE> is a list of <CODE>sourcename</CODE>s.
 (<CODE>basic_props:list/2</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX608"></A>
<A NAME="IDX609"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>make_po/1:</B>
<DD><A NAME="IDX610"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>make_po(Files)</CODE>

<UL>
<LI><EM>Description:</EM> Make object (<CODE>.po</CODE>) files from <CODE>Files</CODE>. Equivalent to executing "<CODE>ciaoc -c</CODE>" on the files.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Files</CODE> is a source name or a list of source names.
 (<CODE>ciaosh_doc:sourcenames/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX611"></A>
<A NAME="IDX612"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>unload/1:</B>
<DD><A NAME="IDX613"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>unload(File)</CODE>

<UL>
<LI><EM>Description:</EM> Unloads dynamically loaded file <CODE>File</CODE>.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>File</CODE> is a source name.
 (<CODE>streams_basic:sourcename/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX614"></A>
<A NAME="IDX615"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>set_debug_mode/1:</B>
<DD><A NAME="IDX616"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>set_debug_mode(File)</CODE>

<UL>
<LI><EM>Description:</EM> Set the loading mode of <CODE>File</CODE> to <EM>consult</EM>. See section <A HREF="ciao_8.html#SEC72">The interactive debugger</A>.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>File</CODE> is a source name.
 (<CODE>streams_basic:sourcename/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX617"></A>
<A NAME="IDX618"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>set_nodebug_mode/1:</B>
<DD><A NAME="IDX619"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>set_nodebug_mode(File)</CODE>

<UL>
<LI><EM>Description:</EM> Set the loading mode of <CODE>File</CODE> to <EM>compile</EM>. See section <A HREF="ciao_8.html#SEC72">The interactive debugger</A>.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>File</CODE> is a source name.
 (<CODE>streams_basic:sourcename/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX620"></A>
<A NAME="IDX621"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>make_actmod/2:</B>
<DD><A NAME="IDX622"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>make_actmod(ModuleFile, PublishMod)</CODE>

<UL>
<LI><EM>Description:</EM> Make an

<A NAME="IDX623"></A>
active module executable from the module residing in <CODE>ModuleFile</CODE>, using address publish module of name <CODE>PublishMod</CODE> (which needs to be in the library paths). 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>ModuleFile</CODE> is a source name.
 (<CODE>streams_basic:sourcename/1</CODE>)

<CODE>PublishMod</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX624"></A>
<A NAME="IDX625"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>force_lazy/1:</B>
<DD><A NAME="IDX626"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>force_lazy(Module)</CODE>

<UL>
<LI><EM>Description:</EM> Force module of name <CODE>Module</CODE> to be loaded lazily in the subsequent created executables.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Module</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX627"></A>
<A NAME="IDX628"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>undo_force_lazy/1:</B>
<DD><A NAME="IDX629"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>undo_force_lazy(Module)</CODE>

<UL>
<LI><EM>Description:</EM> Disable a previous

<A NAME="IDX630"></A>
<CODE>force_lazy/1</CODE> on module <CODE>Module</CODE> (or, if it is uninstantiated, all previous 
<A NAME="IDX631"></A>
<CODE>force_lazy/1</CODE>). 
<LI><EM>Calls should, and exit will be compatible with:</EM>

<CODE>Module</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX632"></A>
<A NAME="IDX633"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>dynamic_search_path/1:</B>
<DD><A NAME="IDX634"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>dynamic_search_path(Name)</CODE>

<UL>
<LI><EM>Description:</EM> Asserting a fact to this data predicate, files using

<A NAME="IDX635"></A>
path alias <CODE>Name</CODE> will be treated as dynamic in the subsequent created executables. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Name</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX636"></A>
<A NAME="IDX637"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>multifile/1:</B>
<DD><A NAME="IDX638"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>multifile Pred</CODE>

<UL>
<LI><EM>Description:</EM> Dynamically declare predicate <CODE>Pred</CODE> as multifile. This is useful at the top-level shell to be able to call multifile predicates of loaded files.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Pred</CODE> is a Name/Arity structure denoting a predicate name: 

<PRE>
predname(P/A) :-
        atm(P),
        nnegint(A).
</PRE>

 (<CODE>basic_props:predname/1</CODE>)
</UL>

</DL>



<H2><A NAME="SEC71" HREF="ciao_toc.html#TOC71">Documentation on internals (<CODE>ciaosh</CODE>)</A></H2>
<P>
<A NAME="IDX639"></A>
<A NAME="IDX640"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>sourcenames/1:</B>
<DD><A NAME="IDX641"></A>


<P>
Is defined as follows:

<PRE>
sourcenames(File) :-
        sourcename(File).
sourcenames(Files) :-
        list(Files,sourcename).
</PRE>

<P>
See 
<A NAME="IDX642"></A>
<CODE>sourcename/1</CODE> in section <A HREF="ciao_24.html#SEC153">Basic file/stream handling</A>


<P>
<STRONG>Usage:</STRONG> <CODE>sourcenames(Files)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Files</CODE> is a source name or a list of source names.

</UL>

</DL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_6.html">previous</A>, <A HREF="ciao_8.html">next</A>, <A HREF="ciao_241.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
