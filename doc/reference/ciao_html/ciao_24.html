<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 26 October 2001 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - Basic file/stream handling</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_23.html">previous</A>, <A HREF="ciao_25.html">next</A>, <A HREF="ciao_218.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC152" HREF="ciao_toc.html#TOC152">Basic file/stream handling</A></H1>
<P>
<A NAME="IDX1523"></A>


<P>
<STRONG>Author(s):</STRONG> Daniel Cabeza, Mats Carlsson.


<P>
<STRONG>Version:</STRONG> 1.7#116 (2001/8/9, 17:56:37 CEST)


<P>
<STRONG>Version of last change:</STRONG> 1.7#47 (2001/1/22, 10:24:23 CET)


<P>
This module provides basic predicates for handling files and streams, in order to make input/output on them.



<UL>
<LI><A HREF="ciao_24.html#SEC153">Usage and interface (streams_basic)</A>
<LI><A HREF="ciao_24.html#SEC154">Documentation on exports (streams_basic)</A>
<LI><A HREF="ciao_24.html#SEC155">Documentation on multifiles (streams_basic)</A>
</UL>



<H2><A NAME="SEC153" HREF="ciao_toc.html#TOC153">Usage and interface (<CODE>streams_basic</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

These predicates are builtin in Ciao, so nothing special has to be done to use them.

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX1524"></A>
<CODE>open/3</CODE>, 
<A NAME="IDX1525"></A>
<CODE>close/1</CODE>, 
<A NAME="IDX1526"></A>
<CODE>set_input/1</CODE>, 
<A NAME="IDX1527"></A>
<CODE>current_input/1</CODE>, 
<A NAME="IDX1528"></A>
<CODE>set_output/1</CODE>, 
<A NAME="IDX1529"></A>
<CODE>current_output/1</CODE>, 
<A NAME="IDX1530"></A>
<CODE>character_count/2</CODE>, 
<A NAME="IDX1531"></A>
<CODE>line_count/2</CODE>, 
<A NAME="IDX1532"></A>
<CODE>line_position/2</CODE>, 
<A NAME="IDX1533"></A>
<CODE>flush_output/1</CODE>, 
<A NAME="IDX1534"></A>
<CODE>flush_output/0</CODE>, 
<A NAME="IDX1535"></A>
<CODE>clearerr/1</CODE>, 
<A NAME="IDX1536"></A>
<CODE>current_stream/3</CODE>, 
<A NAME="IDX1537"></A>
<CODE>stream_code/2</CODE>, 
<A NAME="IDX1538"></A>
<CODE>absolute_file_name/2</CODE>, 
<A NAME="IDX1539"></A>
<CODE>absolute_file_name/7</CODE>.

<LI><EM>Regular Types:</EM>

<A NAME="IDX1540"></A>
<CODE>sourcename/1</CODE>, 
<A NAME="IDX1541"></A>
<CODE>stream/1</CODE>, 
<A NAME="IDX1542"></A>
<CODE>stream_alias/1</CODE>, 
<A NAME="IDX1543"></A>
<CODE>io_mode/1</CODE>.

<LI><EM>Multifiles:</EM>

<A NAME="IDX1544"></A>
<CODE>file_search_path/2</CODE>, 
<A NAME="IDX1545"></A>
<CODE>library_directory/1</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC154" HREF="ciao_toc.html#TOC154">Documentation on exports (<CODE>streams_basic</CODE>)</A></H2>
<P>
<A NAME="IDX1546"></A>
<A NAME="IDX1547"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>open/3:</B>
<DD><A NAME="IDX1548"></A>


<P>
<CODE>open(File,Mode,Stream)</CODE>


<P>
Open <CODE>File</CODE> with mode <CODE>Mode</CODE> and return in <CODE>Stream</CODE> the stream associated with the file. No extension is implicit in <CODE>File</CODE>.


<P>
<STRONG>Usage 1:</STRONG> <CODE>open(+sourcename,+io_mode,?stream)</CODE>
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Description:</EM> Normal use.

</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>open(+int,+io_mode,?stream)</CODE>

<UL>
<LI><EM>Description:</EM> In the special case that <CODE>File</CODE> is an integer, it is assumed to be a file descriptor passed to Prolog from a foreign function call. The file descriptor is connected to a Prolog stream (invoking the UNIX function <CODE>fdopen</CODE>) which is unified with <CODE>Stream</CODE>.

</UL>

</DL>

<P>
<A NAME="IDX1549"></A>
<A NAME="IDX1550"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>close/1:</B>
<DD><A NAME="IDX1551"></A>


<P>
<CODE>close(Stream)</CODE>


<P>
Close the stream <CODE>Stream</CODE>.


</DL>

<P>
<A NAME="IDX1552"></A>
<A NAME="IDX1553"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>set_input/1:</B>
<DD><A NAME="IDX1554"></A>


<P>
<CODE>set_input(Stream)</CODE>


<P>
Set the current input stream to <CODE>Stream</CODE>. A notion of 
<A NAME="IDX1555"></A>
<A NAME="IDX1556"></A>
<EM>current input stream</EM> is maintained by the system, so that input predicates with no explicit stream operate on the current input stream. Initially it is set to <CODE>user_input</CODE>.


</DL>

<P>
<A NAME="IDX1557"></A>
<A NAME="IDX1558"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>current_input/1:</B>
<DD><A NAME="IDX1559"></A>


<P>
<CODE>current_input(Stream)</CODE>


<P>
Unify <CODE>Stream</CODE> with the 
<A NAME="IDX1560"></A>
current input stream.


</DL>

<P>
<A NAME="IDX1561"></A>
<A NAME="IDX1562"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>set_output/1:</B>
<DD><A NAME="IDX1563"></A>


<P>
<CODE>set_output(Stream)</CODE>


<P>
Set the current output stream to <CODE>Stream</CODE>. A notion of 
<A NAME="IDX1564"></A>
<A NAME="IDX1565"></A>
<EM>current output stream</EM> is maintained by the system, so that output predicates with no explicit stream operate on the current output stream. Initially it is set to <CODE>user_output</CODE>.


</DL>

<P>
<A NAME="IDX1566"></A>
<A NAME="IDX1567"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>current_output/1:</B>
<DD><A NAME="IDX1568"></A>


<P>
<CODE>current_output(Stream)</CODE>


<P>
Unify <CODE>Stream</CODE> with the 
<A NAME="IDX1569"></A>
current output stream.


</DL>

<P>
<A NAME="IDX1570"></A>
<A NAME="IDX1571"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>character_count/2:</B>
<DD><A NAME="IDX1572"></A>


<P>
<CODE>character_count(Stream,Count)</CODE>


<P>
<CODE>Count</CODE> characters have been read from or written to <CODE>Stream</CODE>.


</DL>

<P>
<A NAME="IDX1573"></A>
<A NAME="IDX1574"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>line_count/2:</B>
<DD><A NAME="IDX1575"></A>


<P>
<CODE>line_count(Stream,Count)</CODE>


<P>
<CODE>Count</CODE> lines have been read from or written to <CODE>Stream</CODE>.


</DL>

<P>
<A NAME="IDX1576"></A>
<A NAME="IDX1577"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>line_position/2:</B>
<DD><A NAME="IDX1578"></A>


<P>
<CODE>line_position(Stream,Count)</CODE>


<P>
<CODE>Count</CODE> characters have been read from or written to the current line of <CODE>Stream</CODE>.


</DL>

<P>
<A NAME="IDX1579"></A>
<A NAME="IDX1580"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>flush_output/1:</B>
<DD><A NAME="IDX1581"></A>


<P>
<CODE>flush_output(Stream)</CODE>


<P>
Flush any buffered data to output stream <CODE>Stream</CODE>.


</DL>

<P>
<A NAME="IDX1582"></A>
<A NAME="IDX1583"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>flush_output/0:</B>
<DD><A NAME="IDX1584"></A>


<P>
<CODE>flush_output</CODE>


<P>
Behaves like <CODE>current_output(S), flush_output(S)</CODE>


</DL>

<P>
<A NAME="IDX1585"></A>
<A NAME="IDX1586"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>clearerr/1:</B>
<DD><A NAME="IDX1587"></A>


<P>
<CODE>clearerr(Stream)</CODE>


<P>
Clear the end-of-file and error indicators for input stream <CODE>Stream</CODE>.


</DL>

<P>
<A NAME="IDX1588"></A>
<A NAME="IDX1589"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>current_stream/3:</B>
<DD><A NAME="IDX1590"></A>


<P>
<CODE>current_stream(Filename,Mode,Stream)</CODE>


<P>
<CODE>Stream</CODE> is a stream which was opened in mode <CODE>Mode</CODE> and which is connected to the absolute file name <CODE>Filename</CODE> (an atom) or to the file descriptor <CODE>Filename</CODE> (an integer). This predicate can be used for enumerating all currently open streams through backtracking.


</DL>

<P>
<A NAME="IDX1591"></A>
<A NAME="IDX1592"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>stream_code/2:</B>
<DD><A NAME="IDX1593"></A>


<P>
<CODE>stream_code(Stream,StreamCode)</CODE>


<P>
<CODE>StreamCode</CODE> is the file descriptor (an integer) corresponding to the Prolog stream <CODE>Stream</CODE>.


</DL>

<P>
<A NAME="IDX1594"></A>
<A NAME="IDX1595"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>absolute_file_name/2:</B>
<DD><A NAME="IDX1596"></A>


<P>
<CODE>absolute_file_name(RelFileSpec,AbsFileSpec)</CODE>


<P>
If <CODE>RelFileSpec</CODE> is an absolute pathname then do an absolute lookup. If <CODE>RelFileSpec</CODE> is a relative pathname then prefix the name with the name of the current directory and do an absolute lookup. If <CODE>RelFileSpec</CODE> is a path alias, perform the lookup following the path alias rules (see 
<A NAME="IDX1597"></A>
<CODE>sourcename/1</CODE>). In all cases: if a matching file with suffix <CODE>.pl</CODE> exists, then <CODE>AbsFileSpec</CODE> will be unified with this file. Failure to open a file normally causes an exception. The behaviour can be controlled by the <CODE>fileerrors</CODE> 
<A NAME="IDX1598"></A>
prolog flag.


<P>
<STRONG>Usage:</STRONG> <CODE>absolute_file_name(+RelFileSpec,-AbsFileSpec)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>AbsFileSpec</CODE> is the absolute name (with full path) of <CODE>RelFileSpec</CODE>.

<LI><EM>Calls should, and exit will be compatible with:</EM>

<CODE>+RelFileSpec</CODE> is a source name.
 (<CODE>streams_basic:sourcename/1</CODE>)

<CODE>-AbsFileSpec</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1599"></A>
<A NAME="IDX1600"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>absolute_file_name/7:</B>
<DD><A NAME="IDX1601"></A>


<P>
<CODE>absolute_file_name(Spec,Opt,Suffix,CurrDir,AbsFile,AbsBase,AbsDir)</CODE>


<P>
<CODE>AbsFile</CODE> is the absolute name (with full path) of <CODE>Spec</CODE>, which has an optional first suffix <CODE>Opt</CODE> and an optional second suffix <CODE>Suffix</CODE>, when the current directory is <CODE>CurrDir</CODE>. <CODE>AbsBase</CODE> is the same as <CODE>AbsFile</CODE>, but without the second suffix, and <CODE>AbsDir</CODE> is the absolute path of the directory where <CODE>AbsFile</CODE> is. The Ciao compiler invokes this predicate with <CODE>Opt</CODE>=<CODE>'_opt'</CODE> and <CODE>Suffix</CODE>=<CODE>'.pl'</CODE> when searching source files.


</DL>

<P>
<A NAME="IDX1602"></A>
<A NAME="IDX1603"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>sourcename/1:</B>
<DD><A NAME="IDX1604"></A>


<P>
A source name is a flexible way of referring to a concrete file. A source name is either a relative or absolute filename given as: 



<UL>

<LI>an atom, or

<LI>a unary functor (which represents a

<A NAME="IDX1605"></A>
<A NAME="IDX1606"></A>
<EM>path alias</EM>, see below) applied to a <EM>relative</EM> path, the latter being given as an atom. 

</UL>

<P>
In all cases certain filename extensions (e.g., <CODE>.pl</CODE>) can be implicit. In the first form above, file names can be relative to the current directory. Also, file names beginning with <CODE>~</CODE> or <CODE>$</CODE> are treated specially. For example, 


<DL COMPACT>

<DT><CODE>'~/ciao/sample.pl'</CODE>
<DD>
is equivalent to <CODE>'/home/staff/herme/ciao/sample.pl'</CODE>, if <CODE>/home/staff/herme</CODE> is the user's home directory. (This is also equivalent to <CODE>'$HOME/ciao/sample.pl'</CODE> as explained below.) 

<DT><CODE>'~bardo/prolog/sample.pl'</CODE>
<DD>
is equivalent to <CODE>'/home/bardo/prolog/sample.pl'</CODE>, if <CODE>/home/bardo</CODE> is bardo's home directory. 

<DT><CODE>'$UTIL/sample.pl'</CODE>
<DD>
is equivalent to <CODE>'/usr/local/src/utilities/sample.pl'</CODE>, if <CODE>/usr/local/src/utilities</CODE> is the value of the environment variable <CODE>UTIL</CODE>. 

</DL>

<P>
The second form allows using path aliases. Such aliases allow refering to files not with absolute file system paths but with paths which are relative to predefined (or user-defined) abstract names. For example, given the path alias <CODE>myutils</CODE> which has been defined to refer to path <CODE>'/home/bardo/utilities'</CODE>, if that directory contains the file <CODE>stuff.pl</CODE> then the term <CODE>myutils(stuff)</CODE> in a 
<A NAME="IDX1607"></A>
<CODE>use_module/1</CODE> declaration would refer to the file <CODE>'/home/bardo/utilities/stuff.pl'</CODE> (the <CODE>.pl</CODE> extension is implicit in the 
<A NAME="IDX1608"></A>
<CODE>use_module/1</CODE> declaration). As a special case, if that directory contains a subdirectory named <CODE>stuff</CODE> which in turn contains the file <CODE>stuff.pl</CODE>, the same term would refer to the file <CODE>'/home/bardo/utilities/stuff/stuff.pl'</CODE>. If a path alias is related to several paths, all paths are scanned in sequence until a match is found. For information on predefined path aliases or how to define new path aliases, see 
<A NAME="IDX1609"></A>
<CODE>file_search_path/2</CODE>. 


<P>
<STRONG>Usage:</STRONG> <CODE>sourcename(F)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>F</CODE> is a source name.

</UL>

</DL>

<P>
<A NAME="IDX1610"></A>
<A NAME="IDX1611"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>stream/1:</B>
<DD><A NAME="IDX1612"></A>


<P>
Streams correspond to the file pointers used at the operating system level, and usually represent opened files. There are four special streams which correspond with the operating system standard streams: 
<DL COMPACT>

<DT><CODE>user_input</CODE>
<DD>
The standard input stream, i.e. the terminal, usually. 

<DT><CODE>user_output</CODE>
<DD>
The standard output stream, i.e. the terminal, usually. 

<DT><CODE>user_error</CODE>
<DD>
The standard error stream. 

<DT><CODE>user</CODE>
<DD>
The standard input or output stream, depending on context. 

</DL>

<P>
<STRONG>Usage:</STRONG> <CODE>stream(S)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>S</CODE> is an open stream.

</UL>

</DL>

<P>
<A NAME="IDX1613"></A>
<A NAME="IDX1614"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>stream_alias/1:</B>
<DD><A NAME="IDX1615"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>stream_alias(S)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>S</CODE> is the alias of an open stream, i.e., an atom which represents a stream at Prolog level.

</UL>

</DL>

<P>
<A NAME="IDX1616"></A>
<A NAME="IDX1617"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>io_mode/1:</B>
<DD><A NAME="IDX1618"></A>


<P>
Can have the following values: 
<DL COMPACT>

<DT><CODE>read</CODE>
<DD>
Open the file for input. 

<DT><CODE>write</CODE>
<DD>
Open the file for output. The file is created if it does not already exist, the file will otherwise be truncated. 

<DT><CODE>append</CODE>
<DD>
Open the file for output. The file is created if it does not already exist, the file will otherwise be appended to. 

</DL>

<P>
<STRONG>Usage:</STRONG> <CODE>io_mode(M)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>M</CODE> is an opening mode ('read', 'write' or 'append').

</UL>

</DL>



<H2><A NAME="SEC155" HREF="ciao_toc.html#TOC155">Documentation on multifiles (<CODE>streams_basic</CODE>)</A></H2>
<P>
<A NAME="IDX1619"></A>
<A NAME="IDX1620"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>file_search_path/2:</B>
<DD><A NAME="IDX1621"></A>


<P>
<CODE>file_search_path(Alias,Path)</CODE>


<P>
The 
<A NAME="IDX1622"></A>
path alias <CODE>Alias</CODE> is linked to path <CODE>Path</CODE>. Both arguments must be atoms. New facts (or clauses) of this predicate can be asserted to define new path aliases. Predefined path aliases in Ciao are: 


<DL COMPACT>

<DT><CODE>library</CODE>
<DD>
Initially points to all Ciao library paths. See 
<A NAME="IDX1623"></A>
<CODE>library_directory/1</CODE>. 

<DT><CODE>engine</CODE>
<DD>
The path of the 
<A NAME="IDX1624"></A>
Ciao engine builtins. 

<DT><CODE>.</CODE>
<DD>
The current path (<CODE>'.'</CODE>). 

</DL>

<P>
The predicate is <EM>multifile</EM>.


<P>
The predicate is of type <EM>dynamic</EM>.


</DL>

<P>
<A NAME="IDX1625"></A>
<A NAME="IDX1626"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>library_directory/1:</B>
<DD><A NAME="IDX1627"></A>


<P>
<CODE>library_directory(Path)</CODE>


<P>
<CODE>Path</CODE> is a library path (a path represented by the 
<A NAME="IDX1628"></A>
path alias <CODE>library</CODE>). Predefined library paths in Ciao are <CODE>'$CIAOLIB/lib'</CODE>, <CODE>'$CIAOLIB/library'</CODE>, and <CODE>'$CIAOLIB/contrib'</CODE>, given that <CODE>$CIAOLIB</CODE> is the path of the root ciao library directory. More library paths can be defined by asserting new facts (or clauses) of this predicate.


<P>
The predicate is <EM>multifile</EM>.


<P>
The predicate is of type <EM>dynamic</EM>.


</DL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_23.html">previous</A>, <A HREF="ciao_25.html">next</A>, <A HREF="ciao_218.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
