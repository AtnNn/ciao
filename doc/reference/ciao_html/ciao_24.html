<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 28 November 1999 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - Basic file/stream handling</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_23.html">previous</A>, <A HREF="ciao_25.html">next</A>, <A HREF="ciao_146.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC101" HREF="ciao_toc.html#TOC101">Basic file/stream handling</A></H1>
<P>
<A NAME="IDX1214"></A>


<P>
<STRONG>Author(s):</STRONG> Daniel Cabeza, Mats Carlsson.


<P>
<STRONG>Version:</STRONG> 1.3#121 (1999/11/26, 20:23:11 MET)


<P>
This module provides basic predicates for handling files and streams, in order to make input/output on them.



<UL>
<LI><A HREF="ciao_24.html#SEC102">Usage and interface (streams_basic)</A>
<LI><A HREF="ciao_24.html#SEC103">Documentation on exports (streams_basic)</A>
<LI><A HREF="ciao_24.html#SEC104">Documentation on multifiles (streams_basic)</A>
</UL>



<H2><A NAME="SEC102" HREF="ciao_toc.html#TOC102">Usage and interface (<CODE>streams_basic</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

These predicates are builtin in CIAO, so nothing special has to be done to use them.

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX1215"></A>
<CODE>open/3</CODE>, 
<A NAME="IDX1216"></A>
<CODE>close/1</CODE>, 
<A NAME="IDX1217"></A>
<CODE>set_input/1</CODE>, 
<A NAME="IDX1218"></A>
<CODE>current_input/1</CODE>, 
<A NAME="IDX1219"></A>
<CODE>set_output/1</CODE>, 
<A NAME="IDX1220"></A>
<CODE>current_output/1</CODE>, 
<A NAME="IDX1221"></A>
<CODE>character_count/2</CODE>, 
<A NAME="IDX1222"></A>
<CODE>line_count/2</CODE>, 
<A NAME="IDX1223"></A>
<CODE>line_position/2</CODE>, 
<A NAME="IDX1224"></A>
<CODE>flush_output/1</CODE>, 
<A NAME="IDX1225"></A>
<CODE>flush_output/0</CODE>, 
<A NAME="IDX1226"></A>
<CODE>clearerr/1</CODE>, 
<A NAME="IDX1227"></A>
<CODE>current_stream/3</CODE>, 
<A NAME="IDX1228"></A>
<CODE>stream_code/2</CODE>, 
<A NAME="IDX1229"></A>
<CODE>absolute_file_name/2</CODE>, 
<A NAME="IDX1230"></A>
<CODE>absolute_file_name/7</CODE>.

<LI><EM>Regular Types:</EM>

<A NAME="IDX1231"></A>
<CODE>sourcename/1</CODE>, 
<A NAME="IDX1232"></A>
<CODE>stream/1</CODE>, 
<A NAME="IDX1233"></A>
<CODE>io_mode/1</CODE>.

<LI><EM>Multifiles:</EM>

<A NAME="IDX1234"></A>
<CODE>file_search_path/2</CODE>, 
<A NAME="IDX1235"></A>
<CODE>library_directory/1</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC103" HREF="ciao_toc.html#TOC103">Documentation on exports (<CODE>streams_basic</CODE>)</A></H2>
<P>
<A NAME="IDX1236"></A>
<A NAME="IDX1237"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>open/3:</B>
<DD><A NAME="IDX1238"></A>


<P>
<CODE>open(File,Mode,Stream)</CODE>


<P>
Open <CODE>File</CODE> with mode <CODE>Mode</CODE> and return in <CODE>Stream</CODE> the stream associated with the file. No extension is implicit in <CODE>File</CODE>.


<P>
<STRONG>Usage 1:</STRONG> <CODE>open(+sourcename,+io_mode,?(stream))</CODE>
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Description:</EM> Normal use.

</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>open(+int,+io_mode,?(stream))</CODE>

<UL>
<LI><EM>Description:</EM> In the special case that <CODE>File</CODE> is an integer, it is assumed to be a file descriptor passed to Prolog from a foreign function call. The file descriptor is connected to a Prolog stream (invoking the UNIX function <CODE>fdopen</CODE>) which is unified with <CODE>Stream</CODE>.

</UL>

</DL>

<P>
<A NAME="IDX1239"></A>
<A NAME="IDX1240"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>close/1:</B>
<DD><A NAME="IDX1241"></A>


<P>
<CODE>close(Stream)</CODE>


<P>
Close the stream <CODE>Stream</CODE>.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>close(+stream)</CODE>
<KBD> * ISO * </KBD>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX1242"></A>
<A NAME="IDX1243"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>set_input/1:</B>
<DD><A NAME="IDX1244"></A>


<P>
<CODE>set_input(Stream)</CODE>


<P>
Set the current input stream to <CODE>Stream</CODE>. A notion of 
<A NAME="IDX1245"></A>
<A NAME="IDX1246"></A>
<EM>current input stream</EM> is maintained by the system, so that input predicates with no explicit stream operate on the current input stream. Initially it is set to <CODE>user_input</CODE>.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>set_input(+stream)</CODE>
<KBD> * ISO * </KBD>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX1247"></A>
<A NAME="IDX1248"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>current_input/1:</B>
<DD><A NAME="IDX1249"></A>


<P>
<CODE>current_input(Stream)</CODE>


<P>
Unify <CODE>Stream</CODE> with the 
<A NAME="IDX1250"></A>
current input stream.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>current_input(?(stream))</CODE>
<KBD> * ISO * </KBD>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX1251"></A>
<A NAME="IDX1252"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>set_output/1:</B>
<DD><A NAME="IDX1253"></A>


<P>
<CODE>set_output(Stream)</CODE>


<P>
Set the current output stream to <CODE>Stream</CODE>. A notion of 
<A NAME="IDX1254"></A>
<A NAME="IDX1255"></A>
<EM>current output stream</EM> is maintained by the system, so that output predicates with no explicit stream operate on the current output stream. Initially it is set to <CODE>user_output</CODE>.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>set_output(+stream)</CODE>
<KBD> * ISO * </KBD>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX1256"></A>
<A NAME="IDX1257"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>current_output/1:</B>
<DD><A NAME="IDX1258"></A>


<P>
<CODE>current_output(Stream)</CODE>


<P>
Unify <CODE>Stream</CODE> with the 
<A NAME="IDX1259"></A>
current output stream.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>current_output(?(stream))</CODE>
<KBD> * ISO * </KBD>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX1260"></A>
<A NAME="IDX1261"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>character_count/2:</B>
<DD><A NAME="IDX1262"></A>


<P>
<CODE>character_count(Stream,Count)</CODE>


<P>
<CODE>Count</CODE> characters have been read from or written to <CODE>Stream</CODE>.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>character_count(+stream,?(int))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX1263"></A>
<A NAME="IDX1264"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>line_count/2:</B>
<DD><A NAME="IDX1265"></A>


<P>
<CODE>line_count(Stream,Count)</CODE>


<P>
<CODE>Count</CODE> lines have been read from or written to <CODE>Stream</CODE>.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>line_count(+stream,?(int))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX1266"></A>
<A NAME="IDX1267"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>line_position/2:</B>
<DD><A NAME="IDX1268"></A>


<P>
<CODE>line_position(Stream,Count)</CODE>


<P>
<CODE>Count</CODE> characters have been read from or written to the current line of <CODE>Stream</CODE>.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>line_position(+stream,?(int))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX1269"></A>
<A NAME="IDX1270"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>flush_output/1:</B>
<DD><A NAME="IDX1271"></A>


<P>
<CODE>flush_output(Stream)</CODE>


<P>
Flush any buffered data to output stream <CODE>Stream</CODE>.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>flush_output(+stream)</CODE>
<KBD> * ISO * </KBD>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX1272"></A>
<A NAME="IDX1273"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>flush_output/0:</B>
<DD><A NAME="IDX1274"></A>


<P>
<CODE>flush_output</CODE>


<P>
Behaves like <CODE>current_output(S), flush_output(S)</CODE>


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> 
<KBD> * ISO * </KBD>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX1275"></A>
<A NAME="IDX1276"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>clearerr/1:</B>
<DD><A NAME="IDX1277"></A>


<P>
<CODE>clearerr(Stream)</CODE>


<P>
Clear the end-of-file and error indicators for input stream <CODE>Stream</CODE>.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>clearerr(+stream)</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX1278"></A>
<A NAME="IDX1279"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>current_stream/3:</B>
<DD><A NAME="IDX1280"></A>


<P>
<CODE>current_stream(Filename,Mode,Stream)</CODE>


<P>
<CODE>Stream</CODE> is a stream which was opened in mode <CODE>Mode</CODE> and which is connected to the absolute file name <CODE>Filename</CODE> (an atom) or to the file descriptor <CODE>Filename</CODE> (an integer). This predicate can be used for enumerating all currently open streams through backtracking.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage 1:</STRONG> <CODE>current_stream(?(atm),?(io_mode),?(stream))</CODE>

<UL>
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>current_stream(?(int),?(io_mode),?(stream))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX1281"></A>
<A NAME="IDX1282"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>stream_code/2:</B>
<DD><A NAME="IDX1283"></A>


<P>
<CODE>stream_code(Stream,StreamCode)</CODE>


<P>
<CODE>StreamCode</CODE> is the file descriptor (an integer) corresponding to the Prolog stream <CODE>Stream</CODE>.


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage 1:</STRONG> <CODE>stream_code(+stream,?(int))</CODE>

<UL>
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>stream_code(-(stream),+int)</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX1284"></A>
<A NAME="IDX1285"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>absolute_file_name/2:</B>
<DD><A NAME="IDX1286"></A>


<P>
<CODE>absolute_file_name(RelFileSpec,AbsFileSpec)</CODE>


<P>
If <CODE>RelFileSpec</CODE> is an absolute pathname then do an absolute lookup. If <CODE>RelFileSpec</CODE> is a relative pathname then prefix the name with the name of the current directory and do an absolute lookup. If <CODE>RelFileSpec</CODE> is a path alias, perform the lookup following the path alias rules (see 
<A NAME="IDX1287"></A>
<CODE>sourcename/1</CODE>). In all cases: if a matching file with suffix <CODE>.pl</CODE> exists, then <CODE>AbsFileSpec</CODE> will be unified with this file. Failure to open a file normally causes an exception. The behaviour can be controlled by the <CODE>fileerrors</CODE> 
<A NAME="IDX1288"></A>
prolog flag.


<P>
<STRONG>Usage:</STRONG> <CODE>absolute_file_name(+RelFileSpec,-(AbsFileSpec))</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>AbsFileSpec</CODE> is the absolute name (with full path) of <CODE>RelFileSpec</CODE>.

<LI><EM>Calls should, and exit will be compatible with:</EM>

<CODE>+RelFileSpec</CODE> is a source name.
 (<CODE>streams_basic:sourcename/1</CODE>)

<CODE>-(AbsFileSpec)</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1289"></A>
<A NAME="IDX1290"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>absolute_file_name/7:</B>
<DD><A NAME="IDX1291"></A>


<P>
<CODE>absolute_file_name(Spec,Opt,Suffix,CurrDir,AbsFile,AbsBase,AbsDir)</CODE>


<P>
<CODE>AbsFile</CODE> is the absolute name (with full path) of <CODE>Spec</CODE>, which has an optional first suffix <CODE>Opt</CODE> and an optional second suffix <CODE>Suffix</CODE>, when the current directory is <CODE>CurrDir</CODE>. <CODE>AbsBase</CODE> is the same as <CODE>AbsFile</CODE>, but without the second suffix, and <CODE>AbsDir</CODE> is the absolute path of the directory where <CODE>AbsFile</CODE> is. The Ciao compiler invokes this predicate with <CODE>Opt</CODE>='_opt' and <CODE>Suffix</CODE>='.pl' when searching source files.


<P>
<STRONG>Usage:</STRONG> <CODE>absolute_file_name(+sourcename,+atm,+atm,+atm,-(atm),-(atm),-(atm))</CODE>

<UL>
</UL>

</DL>

<P>
<A NAME="IDX1292"></A>
<A NAME="IDX1293"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>sourcename/1:</B>
<DD><A NAME="IDX1294"></A>


<P>
A source name is a flexible way of referring to a concrete file. A source name is either a relative or absolute filename given as: 



<UL>

<LI>an atom, or

<LI>a unary functor (which represents a

<A NAME="IDX1295"></A>
<A NAME="IDX1296"></A>
<EM>path alias</EM>, see below) applied to a <EM>relative</EM> path, the latter being given as an atom. 

</UL>

<P>
In all cases certain filename extensions (e.g., <CODE>.pl</CODE>) can be implicit. In the first form above, file names can be relative to the current directory. Also, file names beginning with <CODE>~</CODE> or <CODE>$</CODE> are treated specially. For example, 


<DL COMPACT>

<DT><CODE>'~/ciao/sample.pl'</CODE>
<DD>
is equivalent to <CODE>'/home/staff/herme/ciao/sample.pl'</CODE>, if <CODE>/home/staff/herme</CODE> is the user's home directory. (This is also equivalent to <CODE>'$HOME/ciao/sample.pl'</CODE> as explained below.) 

<DT><CODE>'~bardo/prolog/sample.pl'</CODE>
<DD>
is equivalent to <CODE>'/home/bardo/prolog/sample.pl'</CODE>, if <CODE>/home/bardo</CODE> is bardo's home directory. 

<DT><CODE>'$UTIL/sample.pl'</CODE>
<DD>
is equivalent to <CODE>'/usr/local/src/utilities/sample.pl'</CODE>, if <CODE>/usr/local/src/utilities</CODE> is the value of the environment variable <CODE>UTIL</CODE>. 

</DL>

<P>
The second form allows using path aliases. Such aliases allow refering to files not with absolute file system paths but with paths which are relative to predefined (or user-defined) abstract names. For example, given the path alias <CODE>myutils</CODE> which has been defined to refer to path <CODE>'/home/bardo/utilities'</CODE>, if that directory contains the file <CODE>stuff.pl</CODE> then the term <CODE>myutils(stuff)</CODE> in a 
<A NAME="IDX1297"></A>
<CODE>use_module/1</CODE> declaration would refer to the file <CODE>'/home/bardo/utilities/stuff.pl'</CODE> (the <CODE>.pl</CODE> extension is implicit in the 
<A NAME="IDX1298"></A>
<CODE>use_module/1</CODE> declaration). As a special case, if that directory contains a subdirectory named <CODE>stuff</CODE> which in turn contains the file <CODE>stuff.pl</CODE>, the same term would refer to the file <CODE>'/home/bardo/utilities/stuff/stuff.pl'</CODE>. If a path alias is related to several paths, all paths are scanned in sequence until a match is found. For information on predefined path aliases or how to define new path aliases, see 
<A NAME="IDX1299"></A>
<CODE>file_search_path/2</CODE>. 


<P>
<STRONG>Usage:</STRONG> <CODE>sourcename(F)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>F</CODE> is a source name.

<LI><EM>The following properties hold globally:</EM>

Defines a regular type.
 (<CODE>basic_props:regtype/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1300"></A>
<A NAME="IDX1301"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>stream/1:</B>
<DD><A NAME="IDX1302"></A>


<P>
Streams correspond to the file pointers used at the operating system level, and usually represent opened files. There are four special streams which correspond with the operating system standard streams: 
<DL COMPACT>

<DT><CODE>user_input</CODE>
<DD>
The standard input stream, i.e. the terminal, usually. 

<DT><CODE>user_output</CODE>
<DD>
The standard output stream, i.e. the terminal, usually. 

<DT><CODE>user_error</CODE>
<DD>
The standard error stream. 

<DT><CODE>user</CODE>
<DD>
The standard input or output stream, depending on context. 

</DL>

<P>
<STRONG>Usage:</STRONG> <CODE>stream(S)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>S</CODE> is an open stream.

<LI><EM>The following properties hold globally:</EM>

Defines a regular type.
 (<CODE>basic_props:regtype/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1303"></A>
<A NAME="IDX1304"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>io_mode/1:</B>
<DD><A NAME="IDX1305"></A>


<P>
Can have the following values: 
<DL COMPACT>

<DT><CODE>read</CODE>
<DD>
Open the file for input. 

<DT><CODE>write</CODE>
<DD>
Open the file for output. The file is created if it does not already exist, the file will otherwise be truncated. 

<DT><CODE>append</CODE>
<DD>
Open the file for output. The file is created if it does not already exist, the file will otherwise be appended to. 

</DL>

<P>
<STRONG>Usage:</STRONG> <CODE>io_mode(M)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>M</CODE> is an opening mode ('read', 'write' or 'append').

<LI><EM>The following properties should hold globally:</EM>

Defines a regular type.
 (<CODE>basic_props:regtype/1</CODE>)
</UL>

</DL>



<H2><A NAME="SEC104" HREF="ciao_toc.html#TOC104">Documentation on multifiles (<CODE>streams_basic</CODE>)</A></H2>
<P>
<A NAME="IDX1306"></A>
<A NAME="IDX1307"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>file_search_path/2:</B>
<DD><A NAME="IDX1308"></A>


<P>
<CODE>file_search_path(Alias,Path)</CODE>


<P>
The 
<A NAME="IDX1309"></A>
path alias <CODE>Alias</CODE> is linked to path <CODE>Path</CODE>. Both arguments must be atoms. New facts (or clauses) of this predicate can be asserted to define new path aliases. Predefined path aliases in CIAO are: 


<DL COMPACT>

<DT><CODE>library</CODE>
<DD>
Initially points to all CIAO library paths. See 
<A NAME="IDX1310"></A>
<CODE>library_directory/1</CODE>. 

<DT><CODE>engine</CODE>
<DD>
The path of the 
<A NAME="IDX1311"></A>
CIAO engine builtins. 

<DT><CODE>.</CODE>
<DD>
The current path (<CODE>'.'</CODE>). 

</DL>

<P>
The predicate is <EM>multifile</EM> and of type <EM>dynamic</EM>.


</DL>

<P>
<A NAME="IDX1312"></A>
<A NAME="IDX1313"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>library_directory/1:</B>
<DD><A NAME="IDX1314"></A>


<P>
<CODE>library_directory(Path)</CODE>


<P>
<CODE>Path</CODE> is a library path (a path represented by the 
<A NAME="IDX1315"></A>
path alias <CODE>library</CODE>). Predefined library paths in CIAO are <CODE>'$CIAOLIB/lib'</CODE>, <CODE>'$CIAOLIB/library'</CODE>, and <CODE>'$CIAOLIB/contrib'</CODE>, given that <CODE>$CIAOLIB</CODE> is the path of the root ciao library directory. More library paths can be defined by asserting new facts (or clauses) of this predicate.


<P>
The predicate is <EM>multifile</EM> and of type <EM>dynamic</EM>.


</DL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_23.html">previous</A>, <A HREF="ciao_25.html">next</A>, <A HREF="ciao_146.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
