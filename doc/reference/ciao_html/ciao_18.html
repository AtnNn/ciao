<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 26 April 2006 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - Basic data types and properties</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_17.html">previous</A>, <A HREF="ciao_19.html">next</A>, <A HREF="ciao_241.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC135" HREF="ciao_toc.html#TOC135">Basic data types and properties</A></H1>
<P>
<A NAME="IDX1285"></A>


<P>
<STRONG>Author(s):</STRONG> Daniel Cabeza, Manuel Hermenegildo.


<P>
<STRONG>Version:</STRONG> 1.10#6 (2004/8/7, 21:46:39 CEST)


<P>
<STRONG>Version of last change:</STRONG> 1.9#93 (2003/7/29, 17:53:15 CEST)


<P>
<A NAME="IDX1286"></A>
<A NAME="IDX1287"></A>
This library contains the set of basic properties used by the builtin predicates, and which constitute the basic data types and properties of the language. They can be used both as type testing builtins within programs (by calling them explicitly) and as properties in assertions.



<UL>
<LI><A HREF="ciao_18.html#SEC136">Usage and interface (basic_props)</A>
<LI><A HREF="ciao_18.html#SEC137">Documentation on exports (basic_props)</A>
</UL>



<H2><A NAME="SEC136" HREF="ciao_toc.html#TOC136">Usage and interface (<CODE>basic_props</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

These predicates are builtin in Ciao, so nothing special has to be done to use them.

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Properties:</EM>

<A NAME="IDX1288"></A>
<CODE>member/2</CODE>, 
<A NAME="IDX1289"></A>
<CODE>compat/2</CODE>, 
<A NAME="IDX1290"></A>
<CODE>iso/1</CODE>, 
<A NAME="IDX1291"></A>
<CODE>not_further_inst/2</CODE>, 
<A NAME="IDX1292"></A>
<CODE>sideff/2</CODE>, 
<A NAME="IDX1293"></A>
<CODE>regtype/1</CODE>, 
<A NAME="IDX1294"></A>
<CODE>native/1</CODE>, 
<A NAME="IDX1295"></A>
<CODE>native/2</CODE>.

<LI><EM>Regular Types:</EM>

<A NAME="IDX1296"></A>
<CODE>term/1</CODE>, 
<A NAME="IDX1297"></A>
<CODE>int/1</CODE>, 
<A NAME="IDX1298"></A>
<CODE>nnegint/1</CODE>, 
<A NAME="IDX1299"></A>
<CODE>flt/1</CODE>, 
<A NAME="IDX1300"></A>
<CODE>num/1</CODE>, 
<A NAME="IDX1301"></A>
<CODE>atm/1</CODE>, 
<A NAME="IDX1302"></A>
<CODE>struct/1</CODE>, 
<A NAME="IDX1303"></A>
<CODE>gnd/1</CODE>, 
<A NAME="IDX1304"></A>
<CODE>constant/1</CODE>, 
<A NAME="IDX1305"></A>
<CODE>callable/1</CODE>, 
<A NAME="IDX1306"></A>
<CODE>operator_specifier/1</CODE>, 
<A NAME="IDX1307"></A>
<CODE>list/1</CODE>, 
<A NAME="IDX1308"></A>
<CODE>list/2</CODE>, 
<A NAME="IDX1309"></A>
<CODE>sequence/2</CODE>, 
<A NAME="IDX1310"></A>
<CODE>sequence_or_list/2</CODE>, 
<A NAME="IDX1311"></A>
<CODE>character_code/1</CODE>, 
<A NAME="IDX1312"></A>
<CODE>string/1</CODE>, 
<A NAME="IDX1313"></A>
<CODE>predname/1</CODE>, 
<A NAME="IDX1314"></A>
<CODE>atm_or_atm_list/1</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC137" HREF="ciao_toc.html#TOC137">Documentation on exports (<CODE>basic_props</CODE>)</A></H2>
<P>
<A NAME="IDX1315"></A>
<A NAME="IDX1316"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>term/1:</B>
<DD><A NAME="IDX1317"></A>


<P>
The most general type (includes all possible terms).


<P>
<STRONG>Usage:</STRONG> <CODE>term(X)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>X</CODE> is any term.

</UL>

</DL>

<P>
<A NAME="IDX1318"></A>
<A NAME="IDX1319"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>int/1:</B>
<DD><A NAME="IDX1320"></A>


<P>
The type of integers. The range of integers is <CODE>[-2^2147483616, 2^2147483616)</CODE>. Thus for all practical purposes, the range of integers can be considered infinite.


<P>
<STRONG>Usage:</STRONG> <CODE>int(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is an integer.

</UL>

</DL>

<P>
<A NAME="IDX1321"></A>
<A NAME="IDX1322"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>nnegint/1:</B>
<DD><A NAME="IDX1323"></A>


<P>
The type of non-negative integers, i.e., natural numbers.


<P>
<STRONG>Usage:</STRONG> <CODE>nnegint(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is a non-negative integer.

</UL>

</DL>

<P>
<A NAME="IDX1324"></A>
<A NAME="IDX1325"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>flt/1:</B>
<DD><A NAME="IDX1326"></A>


<P>
The type of floating-point numbers. The range of floats is the one provided by the C <CODE>double</CODE> type, typically <CODE>[4.9e-324, 1.8e+308]</CODE> (plus or minus). There are also three special values: Infinity, either positive or negative, represented as <CODE>1.0e1000</CODE> and <CODE>-1.0e1000</CODE>; and Not-a-number, which arises as the result of indeterminate operations, represented as <CODE>0.Nan</CODE>


<P>
<STRONG>Usage:</STRONG> <CODE>flt(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is a float.

</UL>

</DL>

<P>
<A NAME="IDX1327"></A>
<A NAME="IDX1328"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>num/1:</B>
<DD><A NAME="IDX1329"></A>


<P>
The type of numbers, that is, integer or floating-point.


<P>
<STRONG>Usage:</STRONG> <CODE>num(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is a number.

</UL>

</DL>

<P>
<A NAME="IDX1330"></A>
<A NAME="IDX1331"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>atm/1:</B>
<DD><A NAME="IDX1332"></A>


<P>
The type of atoms, or non-numeric constants. The size of atoms is unbound.


<P>
<STRONG>Usage:</STRONG> <CODE>atm(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is an atom.

</UL>

</DL>

<P>
<A NAME="IDX1333"></A>
<A NAME="IDX1334"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>struct/1:</B>
<DD><A NAME="IDX1335"></A>


<P>
The type of compound terms, or terms with non-zeroary functors. By now there is a limit of 255 arguments.


<P>
<STRONG>Usage:</STRONG> <CODE>struct(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is a compound term.

</UL>

</DL>

<P>
<A NAME="IDX1336"></A>
<A NAME="IDX1337"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>gnd/1:</B>
<DD><A NAME="IDX1338"></A>


<P>
The type of all terms without variables.


<P>
<STRONG>Usage:</STRONG> <CODE>gnd(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is ground.

</UL>

</DL>

<P>
<A NAME="IDX1339"></A>
<A NAME="IDX1340"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>constant/1:</B>
<DD><A NAME="IDX1341"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>constant(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is an atomic term (an atom or a number).

</UL>

</DL>

<P>
<A NAME="IDX1342"></A>
<A NAME="IDX1343"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>callable/1:</B>
<DD><A NAME="IDX1344"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>callable(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is a term which represents a goal, i.e., an atom or a structure.

</UL>

</DL>

<P>
<A NAME="IDX1345"></A>
<A NAME="IDX1346"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>operator_specifier/1:</B>
<DD><A NAME="IDX1347"></A>


<P>
The type and associativity of an operator is described by the following mnemonic atoms: 


<DL COMPACT>

<DT><CODE>xfx</CODE>
<DD>
Infix, non-associative: it is a requirement that both of the two subexpressions which are the arguments of the operator must be of <EM>lower</EM> precedence than the operator itself. 

<DT><CODE>xfy</CODE>
<DD>
Infix, right-associative: only the first (left-hand) subexpression must be of lower precedence; the right-hand subexpression can be of the <EM>same</EM> precedence as the main operator. 

<DT><CODE>yfx</CODE>
<DD>
Infix, left-associative: same as above, but the other way around. 

<DT><CODE>fx</CODE>
<DD>
Prefix, non-associative: the subexpression must be of <EM>lower</EM> precedence than the operator. 

<DT><CODE>fy</CODE>
<DD>
Prefix, associative: the subexpression can be of the <EM>same</EM> precedence as the operator. 

<DT><CODE>xf</CODE>
<DD>
Postfix, non-associative: the subexpression must be of <EM>lower</EM> precedence than the operator. 

<DT><CODE>yf</CODE>
<DD>
Postfix, associative: the subexpression can be of the <EM>same</EM> precedence as the operator. 

</DL>

<P>
<STRONG>Usage:</STRONG> <CODE>operator_specifier(X)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>X</CODE> specifies the type and associativity of an operator.

</UL>

</DL>

<P>
<A NAME="IDX1348"></A>
<A NAME="IDX1349"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>list/1:</B>
<DD><A NAME="IDX1350"></A>


<P>
A list is formed with successive applications of the functor <CODE>'.'/2</CODE>, and its end is the atom <CODE>[]</CODE>. Defined as 

<PRE>
list([]).
list([_1|L]) :-
        list(L).
</PRE>

<P>
<STRONG>Usage:</STRONG> <CODE>list(L)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>L</CODE> is a list.

</UL>

</DL>

<P>
<A NAME="IDX1351"></A>
<A NAME="IDX1352"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>list/2:</B>
<DD><A NAME="IDX1353"></A>


<P>
<CODE>list(L, T)</CODE>


<P>
<CODE>L</CODE> is a list, and for all its elements, <CODE>T</CODE> holds.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>list(?,pred(1))</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>list(L, T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>L</CODE> is a list of <CODE>T</CODE>s.

</UL>

</DL>

<P>
<A NAME="IDX1354"></A>
<A NAME="IDX1355"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>member/2:</B>
<DD><A NAME="IDX1356"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>member(X, L)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>X</CODE> is an element of <CODE>L</CODE>.

</UL>

</DL>

<P>
<A NAME="IDX1357"></A>
<A NAME="IDX1358"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>sequence/2:</B>
<DD><A NAME="IDX1359"></A>


<P>
A sequence is formed with zero, one or more occurrences of the operator 
<A NAME="IDX1360"></A>
<CODE>','/2</CODE>. For example, <CODE>a, b, c</CODE> is a sequence of three atoms, <CODE>a</CODE> is a sequence of one atom.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>sequence(?,pred(1))</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>sequence(S, T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>S</CODE> is a sequence of <CODE>T</CODE>s.

</UL>

</DL>

<P>
<A NAME="IDX1361"></A>
<A NAME="IDX1362"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>sequence_or_list/2:</B>
<DD><A NAME="IDX1363"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>sequence_or_list(?,pred(1))</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>sequence_or_list(S, T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>S</CODE> is a sequence or list of <CODE>T</CODE>s.

</UL>

</DL>

<P>
<A NAME="IDX1364"></A>
<A NAME="IDX1365"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>character_code/1:</B>
<DD><A NAME="IDX1366"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>character_code(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is an integer which is a character code.

<LI><EM>The following properties hold upon exit:</EM>

<CODE>T</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1367"></A>
<A NAME="IDX1368"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>string/1:</B>
<DD><A NAME="IDX1369"></A>


<P>
A string is a list of character codes. The usual syntax for strings <CODE>"string"</CODE> is allowed, which is equivalent to <CODE>[0's,0't,0'r,0'i,0'n,0'g]</CODE> or <CODE>[115,116,114,105,110,103]</CODE>. There is also a special Ciao syntax when the list is not complete: <CODE>"st"||R</CODE> is equivalent to <CODE>[0's,0't|R]</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>string(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is a string (a list of character codes).

<LI><EM>The following properties hold upon exit:</EM>

<CODE>T</CODE> is a list of <CODE>character_code</CODE>s.
 (<CODE>basic_props:list/2</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1370"></A>
<A NAME="IDX1371"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>predname/1:</B>
<DD><A NAME="IDX1372"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>predname(P)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>P</CODE> is a Name/Arity structure denoting a predicate name:


<PRE>
predname(P/A) :-
        atm(P),
        nnegint(A).
</PRE>

 
</UL>

</DL>

<P>
<A NAME="IDX1373"></A>
<A NAME="IDX1374"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>atm_or_atm_list/1:</B>
<DD><A NAME="IDX1375"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>atm_or_atm_list(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is an atom or a list of atoms.

</UL>

</DL>

<P>
<A NAME="IDX1376"></A>
<A NAME="IDX1377"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>compat/2:</B>
<DD><A NAME="IDX1378"></A>


<P>
This property captures the notion of type or 
<A NAME="IDX1379"></A>
property compatibility. The instantiation or constraint state of the term is compatible with the given property, in the sense that assuming that imposing that property on the term does not render the store inconsistent. For example, terms <CODE>X</CODE> (i.e., a free variable), <CODE>[Y|Z]</CODE>, and <CODE>[Y,Z]</CODE> are all compatible with the regular type 
<A NAME="IDX1380"></A>
<CODE>list/1</CODE>, whereas the terms <CODE>f(a)</CODE> and <CODE>[1|2]</CODE> are not.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>compat(?,pred(1))</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>compat(Term, Prop)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Term</CODE> is <EM>compatible</EM> with <CODE>Prop</CODE>

</UL>

</DL>

<P>
<A NAME="IDX1381"></A>
<A NAME="IDX1382"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>iso/1:</B>
<DD><A NAME="IDX1383"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>iso(G)</CODE>

<UL>
<LI><EM>Description:</EM> <EM>Complies with the ISO-Prolog standard.</EM>

</UL>

</DL>

<P>
<A NAME="IDX1384"></A>
<A NAME="IDX1385"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>not_further_inst/2:</B>
<DD><A NAME="IDX1386"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>not_further_inst(G, V)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>V</CODE> is not further instantiated.

</UL>

</DL>

<P>
<A NAME="IDX1387"></A>
<A NAME="IDX1388"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>sideff/2:</B>
<DD><A NAME="IDX1389"></A>


<P>
<CODE>sideff(G, X)</CODE>


<P>
Declares that <CODE>G</CODE> is side-effect free, soft (do not affect execution, e.g., input/output), or hard (e.g., assert/retract).


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>sideff(goal,?)</CODE>.


<P>
<STRONG>General properties:</STRONG> <CODE>sideff(G, X)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP as <CODE>sideff(G,X)</CODE>.
 (<CODE>basic_props:native/2</CODE>)
</UL>

<P>
<CODE>sideff(G, X)</CODE>

<UL>
<LI><EM>The following properties should hold at call time:</EM>

<CODE>X</CODE> is an element of <CODE>[free,soft,hard]</CODE>.
 (<CODE>basic_props:member/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>sideff(G, X)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>G</CODE> is side-effect <CODE>X</CODE>.

</UL>

</DL>

<P>
<A NAME="IDX1390"></A>
<A NAME="IDX1391"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>regtype/1:</B>
<DD><A NAME="IDX1392"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>regtype(goal)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>regtype(G)</CODE>

<UL>
<LI><EM>Description:</EM> Defines a regular type.

</UL>

</DL>

<P>
<A NAME="IDX1393"></A>
<A NAME="IDX1394"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>native/1:</B>
<DD><A NAME="IDX1395"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>native(goal)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>native(Pred)</CODE>

<UL>
<LI><EM>Description:</EM> This predicate is understood natively by CiaoPP.

</UL>

</DL>

<P>
<A NAME="IDX1396"></A>
<A NAME="IDX1397"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>native/2:</B>
<DD><A NAME="IDX1398"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>native(goal,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>native(Pred, Key)</CODE>

<UL>
<LI><EM>Description:</EM> This predicate is understood natively by CiaoPP as <CODE>Key</CODE>.

</UL>

</DL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_17.html">previous</A>, <A HREF="ciao_19.html">next</A>, <A HREF="ciao_241.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
