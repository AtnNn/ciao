<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 5 October 2004 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - Basic data types and properties</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_17.html">previous</A>, <A HREF="ciao_19.html">next</A>, <A HREF="ciao_243.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC109" HREF="ciao_toc.html#TOC109">Basic data types and properties</A></H1>
<P>
<A NAME="IDX1034"></A>


<P>
<STRONG>Author(s):</STRONG> Daniel Cabeza, Manuel Hermenegildo.


<P>
<STRONG>Version:</STRONG> 1.11#222 (2004/5/24, 13:8:7 CEST)


<P>
<STRONG>Version of last change:</STRONG> 1.11#166 (2004/2/3, 21:12:16 CET)


<P>
<A NAME="IDX1035"></A>
<A NAME="IDX1036"></A>
This library contains the set of basic properties used by the builtin predicates, and which constitute the basic data types and properties of the language. They can be used both as type testing builtins within programs (by calling them explicitly) and as properties in assertions.



<UL>
<LI><A HREF="ciao_18.html#SEC110">Usage and interface (basic_props)</A>
<LI><A HREF="ciao_18.html#SEC111">Documentation on exports (basic_props)</A>
</UL>



<H2><A NAME="SEC110" HREF="ciao_toc.html#TOC110">Usage and interface (<CODE>basic_props</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

These predicates are builtin in Ciao, so nothing special has to be done to use them.

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Properties:</EM>

<A NAME="IDX1037"></A>
<CODE>member/2</CODE>, 
<A NAME="IDX1038"></A>
<CODE>compat/2</CODE>, 
<A NAME="IDX1039"></A>
<CODE>iso/1</CODE>, 
<A NAME="IDX1040"></A>
<CODE>not_further_inst/2</CODE>, 
<A NAME="IDX1041"></A>
<CODE>sideff/2</CODE>, 
<A NAME="IDX1042"></A>
<CODE>regtype/1</CODE>, 
<A NAME="IDX1043"></A>
<CODE>native/1</CODE>, 
<A NAME="IDX1044"></A>
<CODE>native/2</CODE>, 
<A NAME="IDX1045"></A>
<CODE>eval/1</CODE>.

<LI><EM>Regular Types:</EM>

<A NAME="IDX1046"></A>
<CODE>term/1</CODE>, 
<A NAME="IDX1047"></A>
<CODE>int/1</CODE>, 
<A NAME="IDX1048"></A>
<CODE>nnegint/1</CODE>, 
<A NAME="IDX1049"></A>
<CODE>flt/1</CODE>, 
<A NAME="IDX1050"></A>
<CODE>num/1</CODE>, 
<A NAME="IDX1051"></A>
<CODE>atm/1</CODE>, 
<A NAME="IDX1052"></A>
<CODE>struct/1</CODE>, 
<A NAME="IDX1053"></A>
<CODE>gnd/1</CODE>, 
<A NAME="IDX1054"></A>
<CODE>constant/1</CODE>, 
<A NAME="IDX1055"></A>
<CODE>callable/1</CODE>, 
<A NAME="IDX1056"></A>
<CODE>operator_specifier/1</CODE>, 
<A NAME="IDX1057"></A>
<CODE>list/1</CODE>, 
<A NAME="IDX1058"></A>
<CODE>list/2</CODE>, 
<A NAME="IDX1059"></A>
<CODE>sequence/2</CODE>, 
<A NAME="IDX1060"></A>
<CODE>sequence_or_list/2</CODE>, 
<A NAME="IDX1061"></A>
<CODE>character_code/1</CODE>, 
<A NAME="IDX1062"></A>
<CODE>string/1</CODE>, 
<A NAME="IDX1063"></A>
<CODE>predname/1</CODE>, 
<A NAME="IDX1064"></A>
<CODE>atm_or_atm_list/1</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC111" HREF="ciao_toc.html#TOC111">Documentation on exports (<CODE>basic_props</CODE>)</A></H2>
<P>
<A NAME="IDX1065"></A>
<A NAME="IDX1066"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>term/1:</B>
<DD><A NAME="IDX1067"></A>


<P>
The most general type (includes all possible terms).


<P>
<STRONG>General properties:</STRONG> <CODE>term(X)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>term(X)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>term(X)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>X</CODE> is any term.

<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1068"></A>
<A NAME="IDX1069"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>int/1:</B>
<DD><A NAME="IDX1070"></A>


<P>
The type of integers. The range of integers is <CODE>[-2^2147483616, 2^2147483616)</CODE>. Thus for all practical purposes, the range of integers can be considered infinite.


<P>
<STRONG>General properties:</STRONG> <CODE>int(T)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>int(T)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>int(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is an integer.

<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1071"></A>
<A NAME="IDX1072"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>nnegint/1:</B>
<DD><A NAME="IDX1073"></A>


<P>
The type of non-negative integers, i.e., natural numbers.


<P>
<STRONG>General properties:</STRONG> <CODE>nnegint(T)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>nnegint(T)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>nnegint(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is a non-negative integer.

<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1074"></A>
<A NAME="IDX1075"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>flt/1:</B>
<DD><A NAME="IDX1076"></A>


<P>
The type of floating-point numbers. The range of floats is the one provided by the C <CODE>double</CODE> type, typically <CODE>[4.9e-324, 1.8e+308]</CODE> (plus or minus). There are also three special values: Infinity, either positive or negative, represented as <CODE>1.0e1000</CODE> and <CODE>-1.0e1000</CODE>; and Not-a-number, which arises as the result of indeterminate operations, represented as <CODE>0.Nan</CODE>


<P>
<STRONG>General properties:</STRONG> <CODE>flt(T)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>flt(T)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>flt(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is a float.

<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1077"></A>
<A NAME="IDX1078"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>num/1:</B>
<DD><A NAME="IDX1079"></A>


<P>
The type of numbers, that is, integer or floating-point.


<P>
<STRONG>General properties:</STRONG> <CODE>num(T)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>num(T)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>num(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is a number.

<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1080"></A>
<A NAME="IDX1081"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>atm/1:</B>
<DD><A NAME="IDX1082"></A>


<P>
The type of atoms, or non-numeric constants. The size of atoms is unbound.


<P>
<STRONG>General properties:</STRONG> <CODE>atm(T)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>atm(T)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>atm(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is an atom.

<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1083"></A>
<A NAME="IDX1084"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>struct/1:</B>
<DD><A NAME="IDX1085"></A>


<P>
The type of compound terms, or terms with non-zeroary functors. By now there is a limit of 255 arguments.


<P>
<STRONG>General properties:</STRONG> <CODE>struct(T)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>struct(T)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>struct(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is a compound term.

<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1086"></A>
<A NAME="IDX1087"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>gnd/1:</B>
<DD><A NAME="IDX1088"></A>


<P>
The type of all terms without variables.


<P>
<STRONG>General properties:</STRONG> <CODE>gnd(T)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>gnd(T)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>gnd(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is ground.

<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1089"></A>
<A NAME="IDX1090"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>constant/1:</B>
<DD><A NAME="IDX1091"></A>


<P>
<STRONG>General properties:</STRONG> <CODE>constant(T)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>constant(T)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>constant(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is an atomic term (an atom or a number).

</UL>

</DL>

<P>
<A NAME="IDX1092"></A>
<A NAME="IDX1093"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>callable/1:</B>
<DD><A NAME="IDX1094"></A>


<P>
<STRONG>General properties:</STRONG> <CODE>callable(T)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>callable(T)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>callable(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is a term which represents a goal, i.e., an atom or a structure.

</UL>

</DL>

<P>
<A NAME="IDX1095"></A>
<A NAME="IDX1096"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>operator_specifier/1:</B>
<DD><A NAME="IDX1097"></A>


<P>
The type and associativity of an operator is described by the following mnemonic atoms: 


<DL COMPACT>

<DT><CODE>xfx</CODE>
<DD>
Infix, non-associative: it is a requirement that both of the two subexpressions which are the arguments of the operator must be of <EM>lower</EM> precedence than the operator itself. 

<DT><CODE>xfy</CODE>
<DD>
Infix, right-associative: only the first (left-hand) subexpression must be of lower precedence; the right-hand subexpression can be of the <EM>same</EM> precedence as the main operator. 

<DT><CODE>yfx</CODE>
<DD>
Infix, left-associative: same as above, but the other way around. 

<DT><CODE>fx</CODE>
<DD>
Prefix, non-associative: the subexpression must be of <EM>lower</EM> precedence than the operator. 

<DT><CODE>fy</CODE>
<DD>
Prefix, associative: the subexpression can be of the <EM>same</EM> precedence as the operator. 

<DT><CODE>xf</CODE>
<DD>
Postfix, non-associative: the subexpression must be of <EM>lower</EM> precedence than the operator. 

<DT><CODE>yf</CODE>
<DD>
Postfix, associative: the subexpression can be of the <EM>same</EM> precedence as the operator. 

</DL>

<P>
<STRONG>General properties:</STRONG> <CODE>operator_specifier(X)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>operator_specifier(X)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>operator_specifier(X)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>X</CODE> specifies the type and associativity of an operator.

</UL>

</DL>

<P>
<A NAME="IDX1098"></A>
<A NAME="IDX1099"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>list/1:</B>
<DD><A NAME="IDX1100"></A>


<P>
A list is formed with successive applications of the functor <CODE>'.'/2</CODE>, and its end is the atom <CODE>[]</CODE>. Defined as 

<PRE>
list([]).
list([_1|L]) :-
        list(L).
</PRE>

<P>
<STRONG>General properties:</STRONG> <CODE>list(L)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>list(L)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>list(L)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>L</CODE> is a list.

</UL>

</DL>

<P>
<A NAME="IDX1101"></A>
<A NAME="IDX1102"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>list/2:</B>
<DD><A NAME="IDX1103"></A>


<P>
<CODE>list(L, T)</CODE>


<P>
<CODE>L</CODE> is a list, and for all its elements, <CODE>T</CODE> holds.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>list(?,pred(1))</CODE>.


<P>
<STRONG>General properties:</STRONG> <CODE>list(L, T)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>list(L,T)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>list(L, T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>L</CODE> is a list of <CODE>T</CODE>s.

</UL>

</DL>

<P>
<A NAME="IDX1104"></A>
<A NAME="IDX1105"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>member/2:</B>
<DD><A NAME="IDX1106"></A>


<P>
<STRONG>General properties:</STRONG> <CODE>member(X, L)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>member(X,L)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>member(X, L)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>X</CODE> is an element of <CODE>L</CODE>.

</UL>

</DL>

<P>
<A NAME="IDX1107"></A>
<A NAME="IDX1108"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>sequence/2:</B>
<DD><A NAME="IDX1109"></A>


<P>
A sequence is formed with zero, one or more occurrences of the operator 
<A NAME="IDX1110"></A>
<CODE>','/2</CODE>. For example, <CODE>a, b, c</CODE> is a sequence of three atoms, <CODE>a</CODE> is a sequence of one atom.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>sequence(?,pred(1))</CODE>.


<P>
<STRONG>General properties:</STRONG> <CODE>sequence(S, T)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>sequence(S,T)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>sequence(S, T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>S</CODE> is a sequence of <CODE>T</CODE>s.

</UL>

</DL>

<P>
<A NAME="IDX1111"></A>
<A NAME="IDX1112"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>sequence_or_list/2:</B>
<DD><A NAME="IDX1113"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>sequence_or_list(?,pred(1))</CODE>.


<P>
<STRONG>General properties:</STRONG> <CODE>sequence_or_list(S, T)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>sequence_or_list(S,T)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>sequence_or_list(S, T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>S</CODE> is a sequence or list of <CODE>T</CODE>s.

</UL>

</DL>

<P>
<A NAME="IDX1114"></A>
<A NAME="IDX1115"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>character_code/1:</B>
<DD><A NAME="IDX1116"></A>


<P>
<STRONG>General properties:</STRONG> <CODE>character_code(T)</CODE>

<UL>
<LI><EM>The following properties hold upon exit:</EM>

<CODE>T</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)
</UL>

<P>
<CODE>character_code(T)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>character_code(T)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>character_code(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is an integer which is a character code.

</UL>

</DL>

<P>
<A NAME="IDX1117"></A>
<A NAME="IDX1118"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>string/1:</B>
<DD><A NAME="IDX1119"></A>


<P>
A string is a list of character codes. The usual syntax for strings <CODE>"string"</CODE> is allowed, which is equivalent to <CODE>[0's,0't,0'r,0'i,0'n,0'g]</CODE> or <CODE>[115,116,114,105,110,103]</CODE>. There is also a special Ciao syntax when the list is not complete: <CODE>"st"||R</CODE> is equivalent to <CODE>[0's,0't|R]</CODE>.


<P>
<STRONG>General properties:</STRONG> <CODE>string(T)</CODE>

<UL>
<LI><EM>The following properties hold upon exit:</EM>

<CODE>T</CODE> is a list of <CODE>character_code</CODE>s.
 (<CODE>basic_props:list/2</CODE>)
</UL>

<P>
<CODE>string(T)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>string(T)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>string(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is a string (a list of character codes).

</UL>

</DL>

<P>
<A NAME="IDX1120"></A>
<A NAME="IDX1121"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>predname/1:</B>
<DD><A NAME="IDX1122"></A>


<P>
<STRONG>General properties:</STRONG> <CODE>predname(P)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>predname(P)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>predname(P)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>P</CODE> is a Name/Arity structure denoting a predicate name:


<PRE>
predname(P/A) :-
        atm(P),
        nnegint(A).
</PRE>

 
</UL>

</DL>

<P>
<A NAME="IDX1123"></A>
<A NAME="IDX1124"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>atm_or_atm_list/1:</B>
<DD><A NAME="IDX1125"></A>


<P>
<STRONG>General properties:</STRONG> <CODE>atm_or_atm_list(T)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>atm_or_atm_list(T)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>atm_or_atm_list(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is an atom or a list of atoms.

</UL>

</DL>

<P>
<A NAME="IDX1126"></A>
<A NAME="IDX1127"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>compat/2:</B>
<DD><A NAME="IDX1128"></A>


<P>
This property captures the notion of type or 
<A NAME="IDX1129"></A>
property compatibility. The instantiation or constraint state of the term is compatible with the given property, in the sense that assuming that imposing that property on the term does not render the store inconsistent. For example, terms <CODE>X</CODE> (i.e., a free variable), <CODE>[Y|Z]</CODE>, and <CODE>[Y,Z]</CODE> are all compatible with the regular type 
<A NAME="IDX1130"></A>
<CODE>list/1</CODE>, whereas the terms <CODE>f(a)</CODE> and <CODE>[1|2]</CODE> are not.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>compat(?,pred(1))</CODE>.


<P>
<STRONG>General properties:</STRONG> <CODE>compat(Term, Prop)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>compat(Term,Prop)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>compat(Term, Prop)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Term</CODE> is <EM>compatible</EM> with <CODE>Prop</CODE>

</UL>

</DL>

<P>
<A NAME="IDX1131"></A>
<A NAME="IDX1132"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>iso/1:</B>
<DD><A NAME="IDX1133"></A>


<P>
<STRONG>General properties:</STRONG> <CODE>iso(G)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>iso(G)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>iso(G)</CODE>

<UL>
<LI><EM>Description:</EM> <EM>Complies with the ISO-Prolog standard.</EM>

</UL>

</DL>

<P>
<A NAME="IDX1134"></A>
<A NAME="IDX1135"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>not_further_inst/2:</B>
<DD><A NAME="IDX1136"></A>


<P>
<STRONG>General properties:</STRONG> <CODE>not_further_inst(G, V)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>not_further_inst(G,V)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>not_further_inst(G, V)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>V</CODE> is not further instantiated.

</UL>

</DL>

<P>
<A NAME="IDX1137"></A>
<A NAME="IDX1138"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>sideff/2:</B>
<DD><A NAME="IDX1139"></A>


<P>
<CODE>sideff(G, X)</CODE>


<P>
Declares that <CODE>G</CODE> is side-effect free (if its execution has no observable result other than its success, its failure, or its abortion), soft (if its execution may have other observable results which, however, do not affect subsequent execution, e.g., input/output), or hard (e.g., assert/retract).


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>sideff(goal,?)</CODE>.


<P>
<STRONG>General properties:</STRONG> <CODE>sideff(G, X)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)

<CODE>sideff(G,X)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>sideff(G, X)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>G</CODE> is side-effect <CODE>X</CODE>.

<LI><EM>If the following properties should hold at call time:</EM>

<CODE>X</CODE> is an element of <CODE>[free,soft,hard]</CODE>.
 (<CODE>basic_props:member/2</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1140"></A>
<A NAME="IDX1141"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>regtype/1:</B>
<DD><A NAME="IDX1142"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>regtype(goal)</CODE>.


<P>
<STRONG>General properties:</STRONG> <CODE>regtype(G)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>regtype(G)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>regtype(G)</CODE>

<UL>
<LI><EM>Description:</EM> Defines a regular type.

</UL>

</DL>

<P>
<A NAME="IDX1143"></A>
<A NAME="IDX1144"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>native/1:</B>
<DD><A NAME="IDX1145"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>native(goal)</CODE>.


<P>
<STRONG>General properties:</STRONG> <CODE>native(P)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>native(P)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>native(Pred)</CODE>

<UL>
<LI><EM>Description:</EM> This predicate is understood natively by CiaoPP.

</UL>

</DL>

<P>
<A NAME="IDX1146"></A>
<A NAME="IDX1147"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>native/2:</B>
<DD><A NAME="IDX1148"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>native(goal,?)</CODE>.


<P>
<STRONG>General properties:</STRONG> <CODE>native(P, K)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

<CODE>native(P,K)</CODE> is side-effect <CODE>free</CODE>.
 (<CODE>basic_props:sideff/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>native(Pred, Key)</CODE>

<UL>
<LI><EM>Description:</EM> This predicate is understood natively by CiaoPP as <CODE>Key</CODE>.

</UL>

</DL>

<P>
<A NAME="IDX1149"></A>
<A NAME="IDX1150"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>eval/1:</B>
<DD><A NAME="IDX1151"></A>


<P>
A property, defined as follows:

<PRE>
</PRE>

</DL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_17.html">previous</A>, <A HREF="ciao_19.html">next</A>, <A HREF="ciao_243.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
