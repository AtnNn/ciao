<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 14 June 2002 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - Fuzzy Prolog</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_105.html">previous</A>, <A HREF="ciao_107.html">next</A>, <A HREF="ciao_223.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC404" HREF="ciao_toc.html#TOC404">Fuzzy Prolog</A></H1>
<P>
<A NAME="IDX4147"></A>


<P>
<STRONG>Author(s):</STRONG> Claudio Vaucheret, Sergio Guadarrama, Francisco Bueno.


<P>
<STRONG>Version:</STRONG> 1.8#1 (2002/5/27, 19:57:48 CEST)


<P>
<STRONG>Version of last change:</STRONG> 1.7#199 (2002/4/18, 18:5:46 CEST)


<P>
This package impements an extension of prolog to deal with uncertainty. We implement a fuzzy prolog that models interval-valued fuzzy logic. This approach is more general than other fuzzy prologs in two aspects: 



<OL>
<LI>Truth values are sub-intervals on [0,1]. In fact, it could be a finite union of sub-intervals, as we will see below. Having a unique truth value is a particular case modeled with a unitary interval.

<LI>Truth values are propagated through the rules by means of a set of <EM>aggregation operators</EM>. The definition of an <EM>aggregation operator</EM> is a generalization that subsumes conjunctive operators (triangular norms as min, prod, etc.), disjunctive operators (triangular co-norms as max, sum, etc.), average operators (averages as arithmetic average, cuasi-linear average, etc.) and hybrid operators (combinations of previous operators).

</OL>

<P>
We add uncertainty using CLP(R) instead of implementing a new fuzzy resolution as other fuzzy prologs. In this way, we use the original inference mechanism of Prolog, and we use the constraints and its operations provided by CLP(R) to handle the concept of partial truth. We represent intervals as constrains over real numbers and <EM>aggregation operators</EM> as operations with constraints. 


<P>
Each fuzzy predicate has an additional argument which represents its truth value. We use ":~" instead of ":-" to distinguish fuzzy clauses from prolog clauses. In fuzzy clauses, truth values are obtained via an aggregation operator. There is also some syntactic sugar for defining fuzzy predicates with certain membership functions, the fuzzy counterparts of crisp predicates, and the fuzzy negation of a fuzzy predicate. 



<UL>
<LI><A HREF="ciao_106.html#SEC405">Usage and interface (fuzzy)</A>
<LI><A HREF="ciao_106.html#SEC406">Documentation on new declarations (fuzzy)</A>
<LI><A HREF="ciao_106.html#SEC407">Documentation on exports (fuzzy)</A>
<LI><A HREF="ciao_106.html#SEC408">Other information (fuzzy)</A>
<LI><A HREF="ciao_106.html#SEC409">Known bugs and planned improvements (fuzzy)</A>
</UL>



<H2><A NAME="SEC405" HREF="ciao_toc.html#TOC405">Usage and interface (<CODE>fuzzy</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

<CODE>:- use_package(fuzzy).</CODE>

or

<CODE>:- module(...,...,[fuzzy]).</CODE>

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX4148"></A>
<CODE>:#/2</CODE>, 
<A NAME="IDX4149"></A>
<CODE>fuzzy_predicate/1</CODE>, 
<A NAME="IDX4150"></A>
<CODE>fuzzy/1</CODE>, 
<A NAME="IDX4151"></A>
<CODE>fnot/1</CODE>, 
<A NAME="IDX4152"></A>
<CODE>:~/2</CODE>, 
<A NAME="IDX4153"></A>
<CODE>=&#62;/4</CODE>.

<LI><EM>Properties:</EM>

<A NAME="IDX4154"></A>
<CODE>fuzzybody/1</CODE>.

<LI><EM>Regular Types:</EM>

<A NAME="IDX4155"></A>
<CODE>faggregator/1</CODE>.

</UL>

<LI><STRONG>New operators defined:</STRONG>

<A NAME="IDX4156"></A>
<CODE>:~/2</CODE> [1200,xfx], 
<A NAME="IDX4157"></A>
<CODE>:~/1</CODE> [1200,xf], 
<A NAME="IDX4158"></A>
<CODE>:=/2</CODE> [1200,xfx], 
<A NAME="IDX4159"></A>
<CODE>:=/1</CODE> [1200,xf], 
<A NAME="IDX4160"></A>
<CODE>:#/2</CODE> [1200,xfx], 
<A NAME="IDX4161"></A>
<CODE>=&#62;/1</CODE> [1175,fx], 
<A NAME="IDX4162"></A>
<CODE>fnot/1</CODE> [1150,fx], 
<A NAME="IDX4163"></A>
<CODE>aggr/1</CODE> [1150,fx], 
<A NAME="IDX4164"></A>
<CODE>##/2</CODE> [1120,xfy], 
<A NAME="IDX4165"></A>
<CODE>&#60;#/2</CODE> [1120,xfy], 
<A NAME="IDX4166"></A>
<CODE>#&#62;/2</CODE> [1120,xfy], 
<A NAME="IDX4167"></A>
<CODE>fuzzy/1</CODE> [1150,fx], 
<A NAME="IDX4168"></A>
<CODE>fuzzy_predicate/1</CODE> [1190,fx], 
<A NAME="IDX4169"></A>
<CODE>fuzzy_discrete/1</CODE> [1190,fx].

<LI><STRONG>New declarations defined:</STRONG>

<A NAME="IDX4170"></A>
<CODE>aggr/1</CODE>.

</UL>

</div class="cartouche">



<H2><A NAME="SEC406" HREF="ciao_toc.html#TOC406">Documentation on new declarations (<CODE>fuzzy</CODE>)</A></H2>
<P>
<A NAME="IDX4171"></A>
<A NAME="IDX4172"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>aggr/1:</B>
<DD><A NAME="IDX4173"></A>


<P>
<STRONG>Usage:</STRONG> :- <CODE>aggr(Name)</CODE>.

<UL>
<LI><EM>Description:</EM> Declares <CODE>Name</CODE> an aggregator. Its binary definition has to be provided. For example:


<PRE>
:- aggr myaggr.

myaggr(X,Y,Z):- Z .=. X*Y.
</PRE>

defines an aggregator identical to <CODE>prod</CODE>. 
<LI><EM>The following properties hold at call time:</EM>

<CODE>Name</CODE> is an atomic term (an atom or a number).
 (<CODE>basic_props:constant/1</CODE>)
</UL>

</DL>



<H2><A NAME="SEC407" HREF="ciao_toc.html#TOC407">Documentation on exports (<CODE>fuzzy</CODE>)</A></H2>
<P>
<A NAME="IDX4174"></A>
<A NAME="IDX4175"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>:#/2:</B>
<DD><A NAME="IDX4176"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>:#(Name,Decl)</CODE>

<UL>
<LI><EM>Description:</EM> Defines fuzzy predicate <CODE>Name</CODE> from the declaration <CODE>Decl</CODE>.

<LI><EM>The following properties hold upon exit:</EM>

<CODE>Name</CODE> is a Name/Arity structure denoting a predicate name: 

<PRE>
predname(P/A) :-
        atm(P),
        nnegint(A).
</PRE>

 (<CODE>basic_props:predname/1</CODE>)

<CODE>Decl</CODE> is one of the following three: 

<PRE>
fuzzydecl(fuzzy_predicate(_1)).
fuzzydecl(fuzzy(_1)).
fuzzydecl(fnot(_1)).
</PRE>

 (<CODE>user(... /fuzzy_doc):fuzzydecl/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4177"></A>
<A NAME="IDX4178"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>fuzzy_predicate/1:</B>
<DD><A NAME="IDX4179"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>fuzzy_predicate(Domain)</CODE>

<UL>
<LI><EM>Description:</EM> Defines a fuzzy predicate with piecewise linear continuous membership function. This is given by <CODE>Domain</CODE>, which is a list of pairs of domain-truth values, in increasing order and exhaustive. For example:


<PRE>
young :# fuzzy_predicate([(0,1),(35,1),(45,0),(120,0)]).
</PRE>

defines the predicate: 

<PRE>
young(X,1):- X .&#62;=. 0, X .&#60;. 35.
young(X,M):- X .&#62;=. 35, X .&#60;. 45, 10*M .=. 45-X.
young(X,0):- X .&#62;=. 45, X .=&#60;. 120. 
</PRE>

 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Domain</CODE> is a list.
 (<CODE>basic_props:list/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4180"></A>
<A NAME="IDX4181"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>fuzzy/1:</B>
<DD><A NAME="IDX4182"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>fuzzy(Name)</CODE>

<UL>
<LI><EM>Description:</EM> Defines a fuzzy predicate as the fuzzy counterpart of a crisp predicate <CODE>Name</CODE>. For example,


<PRE>
p_f :# fuzzy p/2
</PRE>

defines a new fuzzy predicate <CODE>p_f/3</CODE> (the last argument is the truth value) with truth value equal to 0 if <CODE>p/2</CODE> fails and 1 otherwise. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Name</CODE> is a Name/Arity structure denoting a predicate name: 

<PRE>
predname(P/A) :-
        atm(P),
        nnegint(A).
</PRE>

 (<CODE>basic_props:predname/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4183"></A>
<A NAME="IDX4184"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>fnot/1:</B>
<DD><A NAME="IDX4185"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>fnot(Name)</CODE>

<UL>
<LI><EM>Description:</EM> Defines a fuzzy predicate as the fuzzy negation of another fuzzy predicate <CODE>Name</CODE>. For example,


<PRE>
notp_f :# fnot p_f/3
</PRE>

defines the predicate: 

<PRE>
notp_f(X,Y,M) :-
        p_f(X,Y,Mp),
        M .=. 1 - Mp.
</PRE>

 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Name</CODE> is a Name/Arity structure denoting a predicate name: 

<PRE>
predname(P/A) :-
        atm(P),
        nnegint(A).
</PRE>

 (<CODE>basic_props:predname/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4186"></A>
<A NAME="IDX4187"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>:~/2:</B>
<DD><A NAME="IDX4188"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>:~(Head,Body)</CODE>

<UL>
<LI><EM>Description:</EM> Defines a fuzzy clause for a fuzzy predicate. The clause contains calls to either fuzzy or crisp predicates. Calls to crisp predicates are automatically fuzzified. The last argument of <CODE>Head</CODE> is the truth value of the clause, which is obtained as the aggregation of the truth values of the body goals. An example:


<PRE>
:- module(young2,_,[fuzzy]).

young_couple(X,Y,Mu) :~ min
        age(X,X1),
        age(Y,Y1),
        young(X1,MuX),
        young(Y1,MuY).

age(john,37).
age(rose,39).

young :# fuzzy_predicate([(0,1),(35,1),(45,0),(120,0)]).

</PRE>

so that: 

<PRE>
?- young_couple(john,rose,M).

M .=. 0.6 ? 
</PRE>

 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Head</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)

<CODE>Body</CODE> is a clause body plus an optional aggregation operator.
 (<CODE>user(... /fuzzy_doc):fuzzybody/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4189"></A>
<A NAME="IDX4190"></A>
<DL>
<DT><span class="define">PROPERTY:</span> <B>fuzzybody/1:</B>
<DD><A NAME="IDX4191"></A>


<P>
A clause body, optionally prefixed by the name of an aggregation operator. The agregators currently provided are listed under <CODE>faggregator/1</CODE>. By default, the aggregator used is <CODE>min</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>fuzzybody(B)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>B</CODE> is a clause body plus an optional aggregation operator.

</UL>

</DL>

<P>
<A NAME="IDX4192"></A>
<A NAME="IDX4193"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>faggregator/1:</B>
<DD><A NAME="IDX4194"></A>


<P>
The first three are, respectively, the T-norms: minimum, product, and Lukasiewicz's. The last three are their corresponding T-conorms. Aggregators can be defined by the user, see <CODE>aggr/1</CODE>. 

<PRE>
faggregator(min).
faggregator(prod).
faggregator(luka).
faggregator(max).
faggregator(dprod).
faggregator(dluka).
</PRE>

<P>
<STRONG>Usage:</STRONG> <CODE>faggregator(Aggr)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Aggr</CODE> is an aggregator which is cumulative, i.e., its application to several values by iterating pairwise the binary operation is safe.

</UL>

</DL>

<P>
<A NAME="IDX4195"></A>
<A NAME="IDX4196"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>=&#62;/4:</B>
<DD><A NAME="IDX4197"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>=&#62;(Aggr,A,B,Truth)</CODE>

<UL>
<LI><EM>Description:</EM> The fuzzy implication <CODE>A =&#62; B</CODE> defined by aggregator <CODE>Aggr</CODE>, resulting in the truth value <CODE>Truth</CODE>.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Aggr</CODE> is an aggregator which is cumulative, i.e., its application to several values by iterating pairwise the binary operation is safe.
 (<CODE>user(... /fuzzy_doc):faggregator/1</CODE>)

<CODE>A</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)

<CODE>B</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)

<CODE>Truth</CODE> is a free variable.
 (<CODE>term_typing:var/1</CODE>)
</UL>

</DL>



<H2><A NAME="SEC408" HREF="ciao_toc.html#TOC408">Other information (<CODE>fuzzy</CODE>)</A></H2>

<P>
An example program: 

<PRE>
:- module(dicesum5,_,[fuzzy]).

% this example tries to measure which is the possibility
% that a couple of values, obtained throwing two loaded dice, sum 5. Let
% us suppose we only know that one die is loaded to obtain a small value
% and the other is loaded to obtain a large value. 
%
% the query is  ? sum(5,M)
%

small :# fuzzy_predicate([(1,1),(2,1),(3,0.7),(4,0.3),(5,0),(6,0)]).
large :# fuzzy_predicate([(1,0),(2,0),(3,0.3),(4,0.7),(5,1),(6,1)]).

die1(X,M) :~
        small(X,M).

die2(X,M) :~
        large(X,M).

two_dice(X,Y,M):~ prod
        die1(X,M1),
        die2(Y,M2).

sum(2,M) :~  
        two_dice(1,1,M1).

sum(5,M) :~ dprod
        two_dice(4,1,M1),
        two_dice(1,4,M2),
        two_dice(3,2,M3),
        two_dice(2,3,M4).

</PRE>

<P>
There are more examples in the subdirectory <CODE>fuzzy/examples</CODE> of the distribution. 




<H2><A NAME="SEC409" HREF="ciao_toc.html#TOC409">Known bugs and planned improvements (<CODE>fuzzy</CODE>)</A></H2>


<UL>

<LI>

General aggregations defined by users.

<LI>

Inconsistent behaviour of meta-calls in fuzzy clauses.

<LI>

Some meta-predicate constructions need be added, specially for 'disjunctive' fuzzy clauses, e.g., <CODE>sum/2</CODE> in the dice example.
</UL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_105.html">previous</A>, <A HREF="ciao_107.html">next</A>, <A HREF="ciao_223.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
