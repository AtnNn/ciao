<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 11 July 2001 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - Foreign Language Interface Guidelines and Usage</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_106.html">previous</A>, <A HREF="ciao_108.html">next</A>, <A HREF="ciao_216.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC431" HREF="ciao_toc.html#TOC431">Foreign Language Interface Guidelines and Usage</A></H1>
<P>
<A NAME="IDX4621"></A>


<P>
<STRONG>Author(s):</STRONG> Jose Morales, Manuel Carro.


<P>
<STRONG>Version:</STRONG> 1.7#83 (2001/4/2, 14:30:17 CEST)


<P>
<STRONG>Version of last change:</STRONG> 1.7#76 (2001/3/26, 18:8:57 CEST)


<P>
Ciao Prolog provides a high-level, flexible way to interface C and Prolog, based on the use of assertions to declare what are the expected types and modes of the arguments of a Prolog predicate, and which C files contain the corresponding code. I.e., the user must provide: 



<UL>
<LI>A set of C files,

<LI>A Ciao Prolog module defining whith predicates are implemented in the C files and the types and modes of their arguments, and an (optional) set of flags required for the compilation of the files.

</UL>

<P>
 
The Ciao Prolog compiler analyzes the Prolog code written by the user and gathers this information to generate automatically C code implementing the data translation between Prolog and C, and to compile the C code into dynamically loadable C object files, which are loaded automatically when needed. 


<P>
To this end, each predicate implemented as a foreign C function must appear in the Ciao Prolog module as: 



<PRE>
     :- true pred prolog_predicate(m1(Arg1), ... mN(ArgN)) :: type1 *
          ... * typeN + (foreign(foreign_function_name), returns(ArgR)).

     :- impl_defined([..., prolog_predicate/N, ...]).
</PRE>

<P>
where <CODE>m1</CODE>, ..., <CODE>mN</CODE> and <CODE>type1</CODE>, ..., <CODE>typeN</CODE> are respectively the modes and types of the arguments. <CODE>foreign_function_name</CODE> is the name of the C function implementing 
<A NAME="IDX4622"></A>
<CODE>prolog_predicate/N</CODE>, and the result of this function is unified with <CODE>ArgR</CODE>. 


<P>
This notation can be simplified in several ways. If the name of the foreign function is the same as the name of the Ciao Prolog predicate, <CODE>foreign(foreign_function_name)</CODE> can be replaced by <CODE>foreign/0</CODE>. <CODE>returns(ArgR)</CODE> specifies that the result of the function corresponds to the <CODE>ArgR</CODE> argument of the Ciao Prolog predicate. If the foreign function does not return anything (or if its value is ignored), then <CODE>returns(ArgR)</CODE> must be removed. Note that <CODE>returns</CODE> cannot be used without <CODE>foreign</CODE>. A simplified form is thus: 



<PRE>
     :- true pred prolog_predicate(m1(Arg1), ... mN(ArgN)) :: type1 *
          ... * typeN + foreign.
</PRE>


<UL>
<LI><A HREF="ciao_107.html#SEC432">Equivalence between Ciao Prolog and C types</A>
<LI><A HREF="ciao_107.html#SEC433">Equivalence between Ciao Prolog and C modes</A>
<LI><A HREF="ciao_107.html#SEC434">Examples</A>
<LI><A HREF="ciao_107.html#SEC440">Usage and interface (foreign_interface)</A>
<LI><A HREF="ciao_107.html#SEC441">Known bugs and planned improvements (foreign_interface)</A>
</UL>



<H2><A NAME="SEC432" HREF="ciao_toc.html#TOC432">Equivalence between Ciao Prolog and C types</A></H2>

<P>
The translation between Ciao Prolog and C types is defined at the moment only for some simple, but very useful, types. The translation to be performed is solely defined by types of the arguments in the Ciao Prolog file (i.e., no inspection of the corresponding C file is done), obeying the table below. The Ciao Prolog types understood by the interface are contained in the 
<A NAME="IDX4623"></A>
package section <A HREF="ciao_108.html#SEC442">Foreign Language Interface Properties</A>, and are the following (Prolog types are on the left, and the corresponding C types on the right): 



<UL>
<LI>num &#60;-&#62; double

<LI>int &#60;-&#62; int

<LI>atm &#60;-&#62; char *

<LI>string &#60;-&#62; char * (with trailing zero)

<LI>byte_list &#60;-&#62; char * (a buffer of bytes, with associated length)

<LI>int_list &#60;-&#62; int * (a buffer of integers, with associated length)

<LI>address &#60;-&#62; void *

</UL>

<P>
Strings, atoms, and lists of bytes are passed to (and from) C as dynamically (malloc) created arrays of characters (bytes). Those arrays are freed by Ciao Prolog upon return of the foreign function unless 
<A NAME="IDX4624"></A>
<CODE>do_not_free/2</CODE> is specified (see examples below). This caters for the case in which the C files save in a private state (either by themselves, or by library being called by them) the values passed on from Prolog. 


<P>
Empty lists of bytes are converted into <CODE>NULL</CODE>, and strings <CODE>[]</CODE> or atoms " are converted into <EM>""</EM> (a zero ended C string). <EM>NULL</EM> is converted into an empty list or the <EM>"</EM> atom. 


<P>
<CODE>NULL</CODE> strings and empty buffers are converted into the empty list or the null atom (<CODE>"</CODE>). Empty Ciao Prolog strings (<CODE>"</CODE> or <CODE>[]</CODE>) and null atoms are converted into zero-terminated strings of zero length. Empty Ciao Prolog lists are converted into <CODE>NULL</CODE>. 


<P>
The type 
<A NAME="IDX4625"></A>
<CODE>byte_list/1</CODE> requires an additional property, 
<A NAME="IDX4626"></A>
<CODE>size_of/3</CODE>, to indicate which argument represents its size. 


<P>
Most of the work is performed by the predicates in the @xref{Foreign Language Interface Builder}, which can be called explicitly by the user. Doing that is not usually needed, since the Ciao Prolog Compiler takes care of building glue code files an of compiling and linking whichever is necessary. 
 




<H2><A NAME="SEC433" HREF="ciao_toc.html#TOC433">Equivalence between Ciao Prolog and C modes</A></H2>

<P>
The in/1 or (prefix) +/1 mode states that the corresponding argument is given a value in Prolog, and therefore it is an input argument in the C part. The go/1 or (prefix) -/1 mode states that the Prolog side expects the C side to generate a value for that argument. The return value of a function can always be used as an output argument. Other output arguments should appear as pointers to the corresponding base type in the C files. E.g., an argument which is an integer generated by the C file, declared as 



<PRE>
:- true pred get_int(go(ThisInt)) :: int + foreign
</PRE>

<P>
or as 



<PRE>
:- true pred get_int(+ThisInt) :: int + foreign
</PRE>

<P>
should appear in the C code as 



<PRE>
void get_int(int *thisint)
{
        ....
}
</PRE>

<P>
The examples below illustrate this point, and the use of several assertions to guide the compilation. 
 




<H2><A NAME="SEC434" HREF="ciao_toc.html#TOC434">Examples</A></H2>


<UL>
<LI><A HREF="ciao_107.html#SEC435">Mathematical functions</A>
<LI><A HREF="ciao_107.html#SEC436">Addresses and C pointers</A>
<LI><A HREF="ciao_107.html#SEC437">Lists of bytes and buffers</A>
<LI><A HREF="ciao_107.html#SEC438">Lists of integers</A>
<LI><A HREF="ciao_107.html#SEC439">Strings and atoms</A>
</UL>



<H3><A NAME="SEC435" HREF="ciao_toc.html#TOC435">Mathematical functions</A></H3>

<P>
The mathematical library is accessed to provide the <EM>sin</EM>, <EM>cos</EM>, and <EM>fabs</EM> functions. Note that that library is specified simply as 



<PRE>
:- use_foreign_library([m]).
</PRE>

<P>
The foreign interface adds the <CODE>-lm</CODE> at compile time. Note also how some additional options are added to optimize the compiled code (only glue code, in this case) and mathematics (only in the case of Linux in an Intel processor). 


<P>
The functions imported from the C file, and exported as predicates by the Prolog module are stated as defined elsewhere by the directive 



<PRE>
:- impl_defined([sin/2,cos/2,fabs/2]).
</PRE>

<P>
so that the Prolog compiler does not complain when examining the Prolog file. 


<P>
<EM>math.pl</EM> 



<PRE>
:- module(math,
	[sin/2,
	 cos/2,
	 fabs/2
	],
	[assertions,
	 basicmodes,
	 regtypes,
	 foreign_interface
	]).

:- true pred sin(in(X),go(Y)) :: num * num + (foreign,returns(Y)).
:- true pred cos(in(X),go(Y)) :: num * num + (foreign,returns(Y)).
:- true pred fabs(in(X),go(Y)) :: num * num + (foreign,returns(Y)).

:- extra_compiler_opts(['-O2']).
:- extra_compiler_opts('LINUXi86',['-ffast-math']).
:- use_foreign_library([m]).

:- impl_defined([sin/2,cos/2,fabs/2]).
</PRE>



<H3><A NAME="SEC436" HREF="ciao_toc.html#TOC436">Addresses and C pointers</A></H3>

<P>
The <CODE>address</CODE> type designates any pointer, and provides a means to deal with C pointers in Prolog without interpreting them whatsoever. The C source file which implements the operations accessed from Prolog is declared with the 



<PRE>
:- use_foreign_source(objects_c).
</PRE>

<P>
directive. 


<P>
<EM>objects.pl</EM> 



<PRE>
:- module(objects,
	[object/2,
	 show_object/1
	],
	[assertions,
	 basicmodes,
	 regtypes,
	 foreign_interface
	]).
	 
:- true pred object(in(N),go(Object)) :: int * address +
	(foreign,returns(Object)).

:- true pred show_object(in(Object)) :: address + foreign.

:- use_foreign_source(objects_c).
:- extra_compiler_opts('-O2').

:- impl_defined([object/2,show_object/1]).
</PRE>

<P>
<EM>objects_c.c</EM> 
 

<PRE>
#include &#60;stdio.h&#62;

struct object {
  char *name;
  char *colour;
};

#define OBJECTS 3

struct object objects[OBJECTS] =
{ {"ring","golden"},
  {"table","brown"},
  {"bottle","green"} };

struct object *object(int n) {
  return &#38;objects[n % OBJECTS];
}

void show_object(struct object *o) {
  printf("I show you a %s %s\n", o-&#62;colour, o-&#62;name);
}
</PRE>



<H3><A NAME="SEC437" HREF="ciao_toc.html#TOC437">Lists of bytes and buffers</A></H3>

<P>
A list of bytes (c.f., a list of ints) corresponds to a buffer in C. The length of the buffer always goes associated to the list using the property <CODE>size_of/2</CODE>. The returned buffer <STRONG>is freed by Ciao Prolog</STRONG> upon its recepction, unless the <CODE>do_not_free/1</CODE> property is specified (see later). Conversely, a list of natural numbers not exceeding 255 can be passed to C as a buffer. 


<P>
<EM>byte_lists.pl</EM> 



<PRE>
:- module(byte_lists,
	[obtain_list/3,
	 show_list/2
	],
	[assertions,
	 basicmodes,
	 regtypes,
	 foreign_interface
	]).
	 
:- true pred obtain_list(in(N),go(Length),go(List)) :: int * int * byte_list
	+ (foreign,size_of(List,Length)).
:- true pred show_list(in(Length),in(List)) :: int * byte_list
	+ (foreign,size_of(List,Length)).

:- use_foreign_source(bytes_op).

:- impl_defined([obtain_list/3,show_list/2]).
</PRE>

<P>
<EM>bytes_op.c</EM> 



<PRE>
#include &#60;malloc.h&#62;
#include &#60;stdio.h&#62;

void obtain_list(int n, int *l, char **s) {
  int i;
  int c;
  if (n &#60; 0) n = 0;
  *l = n;
  *s = (char *)malloc(*l);
  for (i = 0; i &#60; *l; i++) {
    (*s)[i] = i;
  }
}

void show_list(int l, char *s) {
  if (s) {
    int n;
    printf("From C: [");
    for (n = 0; n &#60; l; n++) {
      printf(" %d", s[n]);
    }
    printf("]\n");
  } else {
    printf("From C: []\n");
  }
}
</PRE>



<H3><A NAME="SEC438" HREF="ciao_toc.html#TOC438">Lists of integers</A></H3>

<P>
<EM>int_lists.pl</EM> 



<PRE>
:- module(int_lists,
	[obtain_list/3,
	 show_list/2
	],
	[assertions,
	 basicmodes,
	 regtypes,
	 foreign_interface
	]).
	 
:- true pred obtain_list(in(N),go(Length),go(List)) :: int * int * int_list
	+ (foreign,size_of(List,Length)).
:- true pred show_list(in(Length),in(List)) :: int * int_list
	+ (foreign,size_of(List,Length)).

:- use_foreign_source(ints_op).

:- impl_defined([obtain_list/3,show_list/2]).
</PRE>

<P>
<EM>ints_op.c</EM> 



<PRE>
#include &#60;malloc.h&#62;
#include &#60;stdio.h&#62;

void obtain_list(int n, int *l, int **s) {
  int i;
  int c;
  if (n &#60; 0) n = 0;
  *l = n;
  *s = (int *)malloc((*l) * sizeof(int));
  for (i = 0; i &#60; *l; i++) {
    (*s)[i] = i;
  }
}

void show_list(int l, int *s) {
  if (s) {
    int n;
    printf("From C:");
    for (n = 0; n &#60; l; n++) {
      printf(" %d", s[n]);
    }
    printf(".\n");
  } else {
    printf("From C: []\n");
  }
}
</PRE>



<H3><A NAME="SEC439" HREF="ciao_toc.html#TOC439">Strings and atoms</A></H3>

<P>
A C string can be seen as a buffer whose end is denoted by the trailing zero, and therefore stating its length is not needed. Two translations are possible into Ciao Prolog: as a Prolog string (list of bytes, with no trailing zero) and as an atom. These are selected automatically just by choosing the corresponding type (look at the examples below). 


<P>
Note how the <CODE>do_not_free/1</CODE> property is specified in the 
<A NAME="IDX4627"></A>
<CODE>a_string/1</CODE> predicate: the string returned by C is static, and therefore it should not be freed by Prolog. 
 
<EM>strings_and_atoms.pl</EM> 



<PRE>
:- module(strings_and_atoms,
	[lookup_string/2,
	 lookup_atom/2,
	 a_string/1,
	 show_string/1,
	 show_atom/1
	],
	[assertions,
	 basicmodes,
	 regtypes,
	 foreign_interface
	]).

:- true pred a_string(go(S)) ::
	string + (foreign(get_static_str),returns(S),do_not_free(S)).
	 
:- true pred lookup_string(in(N),go(S)) ::
	int * string + (foreign(get_str),returns(S)).
:- true pred lookup_atom(in(N),go(S)) ::
	int * atm + (foreign(get_str),returns(S)).

:- true pred show_string(in(S)) :: string + foreign(put_str).
:- true pred show_atom(in(S)) :: atm + foreign(put_str).

:- use_foreign_source(str_op).

:- impl_defined([lookup_string/2,lookup_atom/2,show_string/1,show_atom/1,
                 a_string/1]).
</PRE>

<P>
<EM>str_op.c</EM> 



<PRE>
#include &#60;malloc.h&#62;
#include &#60;stdio.h&#62;

char *get_static_str() {
  return "this is a string Ciao Prolog should not free";
}

char *get_str(int n) {
  char *s;
  int size;
  int i;
  int c;
  if (n &#60; 0) n = -n;
  size = (n%4) + 5;
  s = (char *)malloc(size+1);
  for (i = 0, c = ((i + n) % ('z' - 'a' + 1)) + 'a'; i &#60; size; i++,c++) {
    if (c &#62; 'z') c = 'a'; 
    s[i] = c;
  }
  s[i] = 0;
  return s;
}

void put_str(char *s) {
  if (s) {
    printf("From C: \"%s\"\n", s);
  } else {
    printf("From C: null\n");
  }
}
</PRE>



<H2><A NAME="SEC440" HREF="ciao_toc.html#TOC440">Usage and interface (<CODE>foreign_interface</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

The foreign interface is used by including <CODE>foreign_interface</CODE> in the include list of a module, or by means of an explicit <CODE>:- use_package(foreign_interface)</CODE>.
</UL>

</div class="cartouche">



<H2><A NAME="SEC441" HREF="ciao_toc.html#TOC441">Known bugs and planned improvements (<CODE>foreign_interface</CODE>)</A></H2>


<UL>

<LI>

The idea is nice, and should be extended to other languages
</UL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_106.html">previous</A>, <A HREF="ciao_108.html">next</A>, <A HREF="ciao_216.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
