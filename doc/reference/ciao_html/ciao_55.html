<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 20 April 2004 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - Quintus-like internal database</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_54.html">previous</A>, <A HREF="ciao_56.html">next</A>, <A HREF="ciao_241.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC257" HREF="ciao_toc.html#TOC257">Quintus-like internal database</A></H1>
<P>
<A NAME="IDX3553"></A>


<P>
<STRONG>Author(s):</STRONG> The CLIP Group.


<P>
<STRONG>Version:</STRONG> 1.9#213 (2003/12/21, 2:20:13 CET)


<P>
 The predicates described in this section were introduced in early implementations of Prolog to provide efficient means of performing operations on large quantities of data. The introduction of indexed dynamic predicates have rendered these predicates obsolete, and the sole purpose of providing them is to support existing code. There is no reason whatsoever to use them in new code. 


<P>
These predicates store arbitrary terms in the database without interfering with the clauses which make up the program. The terms which are stored in this way can subsequently be retrieved via the key on which they were stored. Many terms may be stored on the same key, and they can be individually accessed by pattern matching. Alternatively, access can be achieved via a special identifier which uniquely identifies each recorded term and which is returned when the term is stored. 



<UL>
<LI><A HREF="ciao_55.html#SEC258">Usage and interface (old_database)</A>
<LI><A HREF="ciao_55.html#SEC259">Documentation on exports (old_database)</A>
</UL>



<H2><A NAME="SEC258" HREF="ciao_toc.html#TOC258">Usage and interface (<CODE>old_database</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

<CODE>:- use_module(library(old_database)).</CODE>

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX3554"></A>
<CODE>recorda/3</CODE>, 
<A NAME="IDX3555"></A>
<CODE>recordz/3</CODE>, 
<A NAME="IDX3556"></A>
<CODE>recorded/3</CODE>, 
<A NAME="IDX3557"></A>
<CODE>current_key/2</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC259" HREF="ciao_toc.html#TOC259">Documentation on exports (<CODE>old_database</CODE>)</A></H2>
<P>
<A NAME="IDX3558"></A>
<A NAME="IDX3559"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>recorda/3:</B>
<DD><A NAME="IDX3560"></A>


<P>
<CODE>recorda(Key, Term, Ref)</CODE>


<P>
The term <CODE>Term</CODE> is recorded in the internal database as the first item for the key <CODE>Key</CODE>, where <CODE>Ref</CODE> is its implementation-defined identifier. The key must be given, and only its principal functor is significant. Any uninstantiated variables in the <CODE>Term</CODE> will be replaced by new private variables, along with copies of any subgoals blocked on these variables.


<P>
<STRONG>Usage:</STRONG> <CODE>recorda(+Key, ?Term, -Ref)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3561"></A>
<A NAME="IDX3562"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>recordz/3:</B>
<DD><A NAME="IDX3563"></A>


<P>
<CODE>recordz(Key, Term, Ref)</CODE>


<P>
Like <CODE>recorda/3</CODE>, except that the new term becomes the <EM>last</EM> item for the key <CODE>Key</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>recordz(+Key, ?Term, -Ref)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3564"></A>
<A NAME="IDX3565"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>recorded/3:</B>
<DD><A NAME="IDX3566"></A>


<P>
<CODE>recorded(Key, Term, Ref)</CODE>


<P>
The internal database is searched for terms recorded under the key <CODE>Key</CODE>. These terms are successively unified with <CODE>Term</CODE> in the order they occur in the database. At the same time, <CODE>Ref</CODE> is unified with the implementation-defined identifier uniquely identifying the recorded item. If the key is instantiated to a compound term, only its principal functor is significant. If the key is uninstantiated, all terms in the database are successively unified with <CODE>Term</CODE> in the order they occur.


<P>
<STRONG>Usage:</STRONG> <CODE>recorded(?Key, ?Term, ?Ref)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX3567"></A>
<A NAME="IDX3568"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>current_key/2:</B>
<DD><A NAME="IDX3569"></A>


<P>
<CODE>current_key(KeyName, KeyTerm)</CODE>


<P>
<CODE>KeyTerm</CODE> is the most general form of the key for a currently recorded term, and <CODE>KeyName</CODE> is the name of that key. This predicate can be used to enumerate in undefined order all keys for currently recorded terms through backtracking.


<P>
<STRONG>Usage:</STRONG> <CODE>current_key(?Name, ?Key)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_54.html">previous</A>, <A HREF="ciao_56.html">next</A>, <A HREF="ciao_241.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
