<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 5 October 2004 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - All solutions predicates</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_35.html">previous</A>, <A HREF="ciao_37.html">next</A>, <A HREF="ciao_243.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC167" HREF="ciao_toc.html#TOC167">All solutions predicates</A></H1>
<P>
<A NAME="IDX2445"></A>


<P>
<STRONG>Author(s):</STRONG> First version by Richard A. O'Keefe and David H.D. Warren. Changes by Mats Carlsson, Daniel Cabeza, and Manuel Hermenegildo.


<P>
<STRONG>Version:</STRONG> 1.11#222 (2004/5/24, 13:8:7 CEST)


<P>
<STRONG>Version of last change:</STRONG> 1.5#115 (2000/4/12, 12:17:22 CEST)


<P>
This module implements the standard solution aggregation predicates. 


<P>
When there are many solutions to a problem, and when all those solutions are required to be collected together, this can be achieved by repeatedly backtracking and gradually building up a list of the solutions. The following built-in predicates are provided to automate this process. 



<UL>
<LI><A HREF="ciao_36.html#SEC168">Usage and interface (aggregates)</A>
<LI><A HREF="ciao_36.html#SEC169">Documentation on exports (aggregates)</A>
</UL>



<H2><A NAME="SEC168" HREF="ciao_toc.html#TOC168">Usage and interface (<CODE>aggregates</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

<CODE>:- use_module(library(aggregates)).</CODE>

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX2446"></A>
<CODE>setof/3</CODE>, 
<A NAME="IDX2447"></A>
<CODE>bagof/3</CODE>, 
<A NAME="IDX2448"></A>
<CODE>findall/3</CODE>, 
<A NAME="IDX2449"></A>
<CODE>findall/4</CODE>, 
<A NAME="IDX2450"></A>
<CODE>findnsols/4</CODE>, 
<A NAME="IDX2451"></A>
<CODE>findnsols/5</CODE>, 
<A NAME="IDX2452"></A>
<CODE>^/2</CODE>.

</UL>

<LI><STRONG>Other modules used:</STRONG>


<UL>

<LI><EM>System library modules:</EM>

<A NAME="IDX2453"></A>
<CODE>sort</CODE>, 
<A NAME="IDX2454"></A>
<CODE>lists</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC169" HREF="ciao_toc.html#TOC169">Documentation on exports (<CODE>aggregates</CODE>)</A></H2>
<P>
<A NAME="IDX2455"></A>
<A NAME="IDX2456"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>setof/3:</B>
<DD><A NAME="IDX2457"></A>


<P>
<CODE>setof(Template, Generator, Set)</CODE>


<P>
Finds the <CODE>Set</CODE> of instances of the <CODE>Template</CODE> satisfying <CODE>Generator</CODE>. The set is in ascending order (see section <A HREF="ciao_21.html#SEC118">Comparing terms</A> for a definition of this order) without duplicates, and is non-empty. If there are no solutions, <CODE>setof</CODE> fails. <CODE>setof</CODE> may succeed in more than one way, binding free variables in <CODE>Generator</CODE> to different values. This can be avoided by using existential quantifiers on the free variables in front of <CODE>Generator</CODE>, using 
<A NAME="IDX2458"></A>
<CODE>^/2</CODE>. For example, given the clauses: 

<PRE>
father(bill, tom).
father(bill, ann).
father(bill, john).
father(harry, july).
father(harry, daniel).
</PRE>

<P>
The following query produces two alternative solutions via backtracking: 

<PRE>
?- setof(X,father(F,X),Sons).

F = bill,
Sons = [ann,john,tom] ? ;

F = harry,
Sons = [daniel,july] ? ;

no
?- 
</PRE>

<P>
<EM>Meta-predicate</EM> with arguments: <CODE>setof(?,goal,?)</CODE>.


<P>
<STRONG>General properties:</STRONG> <CODE>setof(X, Y, Z)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP as <CODE>findall(X,Y,Z)</CODE>.
 (<CODE>basic_props:native/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> 
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Calls should, and exit will be compatible with:</EM>

<CODE>Set</CODE> is a list.
 (<CODE>basic_props:list/1</CODE>)
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Template</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>Generator</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)
<LI><EM>The following properties hold upon exit:</EM>

<CODE>Template</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>Set</CODE> is a list.
 (<CODE>basic_props:list/1</CODE>)
<LI><EM>The following properties hold globally:</EM>

<CODE>Template</CODE> is not further instantiated.
 (<CODE>basic_props:not_further_inst/2</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2459"></A>
<A NAME="IDX2460"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>bagof/3:</B>
<DD><A NAME="IDX2461"></A>


<P>
<CODE>bagof(Template, Generator, Bag)</CODE>


<P>
Finds all the instances of the <CODE>Template</CODE> produced by the <CODE>Generator</CODE>, and returns them in the <CODE>Bag</CODE> in the order in which they were found. If the <CODE>Generator</CODE> contains free variables which are not bound in the <CODE>Template</CODE>, it assumes that this is like any other Prolog question and that you want bindings for those variables. This can be avoided by using existential quantifiers on the free variables in front of the <CODE>Generator</CODE>, using 
<A NAME="IDX2462"></A>
<CODE>^/2</CODE>.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>bagof(?,goal,?)</CODE>.


<P>
<STRONG>General properties:</STRONG> <CODE>bagof(X, Y, Z)</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP as <CODE>findall(X,Y,Z)</CODE>.
 (<CODE>basic_props:native/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> 
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Calls should, and exit will be compatible with:</EM>

<CODE>Bag</CODE> is a list.
 (<CODE>basic_props:list/1</CODE>)
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Template</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>Generator</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)
<LI><EM>The following properties hold upon exit:</EM>

<CODE>Template</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>Bag</CODE> is a list.
 (<CODE>basic_props:list/1</CODE>)
<LI><EM>The following properties hold globally:</EM>

<CODE>Template</CODE> is not further instantiated.
 (<CODE>basic_props:not_further_inst/2</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2463"></A>
<A NAME="IDX2464"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>findall/3:</B>
<DD><A NAME="IDX2465"></A>


<P>
<CODE>findall(Template, Generator, List)</CODE>


<P>
A special case of bagof, where all free variables in the <CODE>Generator</CODE> are taken to be existentially quantified. Faster than the other aggregation predicates.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>findall(?,goal,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> 
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Calls should, and exit will be compatible with:</EM>

<CODE>List</CODE> is a list.
 (<CODE>basic_props:list/1</CODE>)
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Template</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>Generator</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)
<LI><EM>The following properties hold upon exit:</EM>

<CODE>Template</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>List</CODE> is a list.
 (<CODE>basic_props:list/1</CODE>)
<LI><EM>The following properties hold globally:</EM>

<CODE>Template</CODE> is not further instantiated.
 (<CODE>basic_props:not_further_inst/2</CODE>)

This predicate is understood natively by CiaoPP.
 (<CODE>basic_props:native/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2466"></A>
<A NAME="IDX2467"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>findall/4:</B>
<DD><A NAME="IDX2468"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>findall(?,goal,?,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>findall(Template, Generator, List, Tail)</CODE>

<UL>
<LI><EM>Description:</EM> As

<A NAME="IDX2469"></A>
<CODE>findall/3</CODE>, but returning in <CODE>Tail</CODE> the tail of <CODE>List</CODE>. 
</UL>

</DL>

<P>
<A NAME="IDX2470"></A>
<A NAME="IDX2471"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>findnsols/4:</B>
<DD><A NAME="IDX2472"></A>


<P>
<CODE>findnsols(N, Template, Generator, List)</CODE>


<P>
As 
<A NAME="IDX2473"></A>
<CODE>findall/3</CODE>, but generating at most <CODE>N</CODE> solutions of <CODE>Generator</CODE>. Thus, the length of <CODE>List</CODE> will not be greater than <CODE>N</CODE>. If <CODE>N</CODE>=&#60;0, returns directly an empty list. This predicate is especially useful if <CODE>Generator</CODE> may have an infinite number of solutions.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>findnsols(?,?,goal,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> 

<UL>
<LI><EM>Calls should, and exit will be compatible with:</EM>

<CODE>List</CODE> is a list.
 (<CODE>basic_props:list/1</CODE>)
<LI><EM>The following properties should hold at call time:</EM>

<CODE>N</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)

<CODE>Template</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>Generator</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)
<LI><EM>The following properties hold upon exit:</EM>

<CODE>Template</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>List</CODE> is a list.
 (<CODE>basic_props:list/1</CODE>)
<LI><EM>The following properties hold globally:</EM>

<CODE>Template</CODE> is not further instantiated.
 (<CODE>basic_props:not_further_inst/2</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2474"></A>
<A NAME="IDX2475"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>findnsols/5:</B>
<DD><A NAME="IDX2476"></A>


<P>
<CODE>findnsols(N, Template, Generator, List, Tail)</CODE>


<P>
As 
<A NAME="IDX2477"></A>
<CODE>findnsols/4</CODE>, but returning in <CODE>Tail</CODE> the tail of <CODE>List</CODE>.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>findnsols(?,?,goal,?,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> 

<UL>
<LI><EM>The following properties should hold at call time:</EM>

<CODE>N</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)

<CODE>Template</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>Generator</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)
<LI><EM>The following properties hold upon exit:</EM>

<CODE>Template</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
<LI><EM>The following properties hold globally:</EM>

<CODE>Template</CODE> is not further instantiated.
 (<CODE>basic_props:not_further_inst/2</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX2478"></A>
<A NAME="IDX2479"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>^/2:</B>
<DD><A NAME="IDX2480"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>(?)^goal</CODE>.


<P>
<STRONG>General properties:</STRONG> <CODE>_X ^ Y</CODE>

<UL>
<LI><EM>The following properties hold globally:</EM>

This predicate is understood natively by CiaoPP as <CODE>call(Y)</CODE>.
 (<CODE>basic_props:native/2</CODE>)
</UL>

<P>
<STRONG>Usage:</STRONG> <CODE>X ^ P</CODE>

<UL>
<LI><EM>Description:</EM> Existential quantification: <CODE>X</CODE> is existentially quantified in <CODE>P</CODE>. E.g., in <CODE>A^p(A,B)</CODE>, <CODE>A</CODE> is existentially quantified. Used only within

<A NAME="IDX2481"></A>
aggregation predicates. In all other contexts, simply, execute the procedure call <CODE>P</CODE>. 
</UL>

</DL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_35.html">previous</A>, <A HREF="ciao_37.html">next</A>, <A HREF="ciao_243.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
