<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 14 June 2002 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - Dynamic predicates</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_35.html">previous</A>, <A HREF="ciao_37.html">next</A>, <A HREF="ciao_223.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC160" HREF="ciao_toc.html#TOC160">Dynamic predicates</A></H1>
<P>
<A NAME="IDX1827"></A>


<P>
<STRONG>Version:</STRONG> 1.8#1 (2002/5/27, 19:57:48 CEST)


<P>
<STRONG>Version of last change:</STRONG> 1.7#93 (2001/4/24, 19:2:53 CEST)


<P>
This module implements the assert/retract family of predicates to manipulate dynamic predicates. 


<P>
The predicates defined in this module allow modification of the program as it is actually running. Clauses can be added to the program (<EM>asserted</EM>) or removed from the program (<EM>retracted</EM>). For these predicates, the argument which corresponds to the clause head must be instantiated to an atom or a compound term. The argument corresponding to the clause must be instantiated either to a term <CODE>Head :- Body</CODE> or, if the body part is empty, to <CODE>Head</CODE>. An empty body part is represented as <CODE>true</CODE>. Note that using this library is very detrimental to global analysis, and that for most uses the predicates listed in section <A HREF="ciao_28.html#SEC134">Fast/concurrent update of facts</A> suffice.



<UL>
<LI><A HREF="ciao_36.html#SEC161">Usage and interface (dynamic)</A>
<LI><A HREF="ciao_36.html#SEC162">Documentation on exports (dynamic)</A>
<LI><A HREF="ciao_36.html#SEC163">Documentation on multifiles (dynamic)</A>
</UL>



<H2><A NAME="SEC161" HREF="ciao_toc.html#TOC161">Usage and interface (<CODE>dynamic</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

<CODE>:- use_module(library(dynamic)).</CODE>

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX1828"></A>
<CODE>asserta/1</CODE>, 
<A NAME="IDX1829"></A>
<CODE>asserta/2</CODE>, 
<A NAME="IDX1830"></A>
<CODE>assertz/1</CODE>, 
<A NAME="IDX1831"></A>
<CODE>assertz/2</CODE>, 
<A NAME="IDX1832"></A>
<CODE>assert/1</CODE>, 
<A NAME="IDX1833"></A>
<CODE>assert/2</CODE>, 
<A NAME="IDX1834"></A>
<CODE>retract/1</CODE>, 
<A NAME="IDX1835"></A>
<CODE>retractall/1</CODE>, 
<A NAME="IDX1836"></A>
<CODE>abolish/1</CODE>, 
<A NAME="IDX1837"></A>
<CODE>clause/2</CODE>, 
<A NAME="IDX1838"></A>
<CODE>clause/3</CODE>, 
<A NAME="IDX1839"></A>
<CODE>current_predicate/1</CODE>, 
<A NAME="IDX1840"></A>
<CODE>current_predicate/2</CODE>, 
<A NAME="IDX1841"></A>
<CODE>dynamic/1</CODE>, 
<A NAME="IDX1842"></A>
<CODE>data/1</CODE>, 
<A NAME="IDX1843"></A>
<CODE>wellformed_body/3</CODE>.

<LI><EM>Multifiles:</EM>

<A NAME="IDX1844"></A>
<CODE>do_on_abolish/1</CODE>.

</UL>

<LI><STRONG>Other modules used:</STRONG>


<UL>

<LI><EM>System library modules:</EM>

<A NAME="IDX1845"></A>
<CODE>prolog_sys</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC162" HREF="ciao_toc.html#TOC162">Documentation on exports (<CODE>dynamic</CODE>)</A></H2>
<P>
<A NAME="IDX1846"></A>
<A NAME="IDX1847"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>asserta/1:</B>
<DD><A NAME="IDX1848"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>asserta(clause)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>asserta(+Clause)</CODE>
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Description:</EM> The current instance of <CODE>Clause</CODE> is interpreted as a clause and is added to the current program. The predicate concerned must be dynamic. The new clause becomes the <EM>first</EM> clause for the predicate concerned. Any uninstantiated variables in <CODE>Clause</CODE> will be replaced by new private variables.

</UL>

</DL>

<P>
<A NAME="IDX1849"></A>
<A NAME="IDX1850"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>asserta/2:</B>
<DD><A NAME="IDX1851"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>asserta(clause,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>asserta(+Clause,-Ref)</CODE>

<UL>
<LI><EM>Description:</EM> Like <CODE>asserta/1</CODE>. <CODE>Ref</CODE> is a unique identifier of the asserted clause.

</UL>

</DL>

<P>
<A NAME="IDX1852"></A>
<A NAME="IDX1853"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>assertz/1:</B>
<DD><A NAME="IDX1854"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>assertz(clause)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>assertz(+Clause)</CODE>
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Description:</EM> Like <CODE>asserta/1</CODE>, except that the new clause becomes the <EM>last</EM> clause for the predicate concerned.

</UL>

</DL>

<P>
<A NAME="IDX1855"></A>
<A NAME="IDX1856"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>assertz/2:</B>
<DD><A NAME="IDX1857"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>assertz(clause,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>assertz(+Clause,-Ref)</CODE>

<UL>
<LI><EM>Description:</EM> Like <CODE>assertz/1</CODE>. <CODE>Ref</CODE> is a unique identifier of the asserted clause.

</UL>

</DL>

<P>
<A NAME="IDX1858"></A>
<A NAME="IDX1859"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>assert/1:</B>
<DD><A NAME="IDX1860"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>assert(clause)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>assert(+Clause)</CODE>

<UL>
<LI><EM>Description:</EM> Identical to <CODE>assertz/1</CODE>. Included for compatibility.

</UL>

</DL>

<P>
<A NAME="IDX1861"></A>
<A NAME="IDX1862"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>assert/2:</B>
<DD><A NAME="IDX1863"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>assert(clause,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>assert(+Clause,-Ref)</CODE>

<UL>
<LI><EM>Description:</EM> Identical to <CODE>assertz/2</CODE>. Included for compatibility.

</UL>

</DL>

<P>
<A NAME="IDX1864"></A>
<A NAME="IDX1865"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>retract/1:</B>
<DD><A NAME="IDX1866"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>retract(clause)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>retract(+Clause)</CODE>
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Description:</EM> The first clause in the program that matches <CODE>Clause</CODE> is erased. The predicate concerned must be dynamic.

The predicate <CODE>retract/1</CODE> may be used in a non-determinate fashion, i.e., it will successively retract clauses matching the argument through backtracking. If reactivated by backtracking, invocations of the predicate whose clauses are being retracted will proceed unaffected by the retracts. This is also true for invocations of <CODE>clause</CODE> for the same predicate. The space occupied by a retracted clause will be recovered when instances of the clause are no longer in use. 
</UL>

</DL>

<P>
<A NAME="IDX1867"></A>
<A NAME="IDX1868"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>retractall/1:</B>
<DD><A NAME="IDX1869"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>retractall(fact)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>retractall(+Head)</CODE>

<UL>
<LI><EM>Description:</EM> Erase all clauses whose head matches <CODE>Head</CODE>, where <CODE>Head</CODE> must be instantiated to an atom or a compound term. The predicate concerned must be dynamic. The predicate definition is retained.

</UL>

</DL>

<P>
<A NAME="IDX1870"></A>
<A NAME="IDX1871"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>abolish/1:</B>
<DD><A NAME="IDX1872"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>abolish(spec)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>abolish(+Spec)</CODE>
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Description:</EM> Erase all clauses of the predicate specified by the predicate spec <CODE>Spec</CODE>. The predicate definition itself is also erased (the predicate is deemed undefined after execution of the abolish). The predicates concerned must all be user defined.

</UL>

</DL>

<P>
<A NAME="IDX1873"></A>
<A NAME="IDX1874"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>clause/2:</B>
<DD><A NAME="IDX1875"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>clause(fact,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>clause(+Head,?Body)</CODE>
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Description:</EM> The clause '<CODE>Head</CODE> <CODE>:-</CODE> <CODE>Body</CODE>' exists in the current program. The predicate concerned must be dynamic.

</UL>

</DL>

<P>
<A NAME="IDX1876"></A>
<A NAME="IDX1877"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>clause/3:</B>
<DD><A NAME="IDX1878"></A>


<P>
<CODE>clause(Head,Body,Ref)</CODE>


<P>
Like <CODE>clause(Head,Body)</CODE>, plus the clause is uniquely identified by <CODE>Ref</CODE>.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>clause(fact,?,?)</CODE>.


<P>
<STRONG>Usage 1:</STRONG> <CODE>clause(+Head,?Body,?Ref)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Head</CODE> must be instantiated to an atom or a compound term.

</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>clause(?Head,?Body,+Ref)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Ref</CODE> must be instantiated to a valid identifier.

</UL>

</DL>

<P>
<A NAME="IDX1879"></A>
<A NAME="IDX1880"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>current_predicate/1:</B>
<DD><A NAME="IDX1881"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>current_predicate(?Spec)</CODE>
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Description:</EM> A predicate in the current module is named <CODE>Spec</CODE>.

</UL>

</DL>

<P>
<A NAME="IDX1882"></A>
<A NAME="IDX1883"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>current_predicate/2:</B>
<DD><A NAME="IDX1884"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>current_predicate(?Spec,?Module)</CODE>

<UL>
<LI><EM>Description:</EM> A predicate in <CODE>Module</CODE> is named <CODE>Spec</CODE>. <CODE>Module</CODE> never is an engine module.

</UL>

</DL>

<P>
<A NAME="IDX1885"></A>
<A NAME="IDX1886"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>dynamic/1:</B>
<DD><A NAME="IDX1887"></A>


<P>
<CODE>dynamic F/A</CODE>


<P>
The predicate named <CODE>F</CODE> with arity <CODE>A</CODE> is made 
<A NAME="IDX1888"></A>
dynamic in the current module at runtime (useful for predicate names generated on-the-fly). If the predicate functor name <CODE>F</CODE> is uninstatiated, a new, unique, predicate name is generated at runtime.


</DL>

<P>
<A NAME="IDX1889"></A>
<A NAME="IDX1890"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>data/1:</B>
<DD><A NAME="IDX1891"></A>


<P>
<CODE>data F/A</CODE>


<P>
The predicate named <CODE>F</CODE> with arity <CODE>A</CODE> is made 
<A NAME="IDX1892"></A>
data in the current module at runtime (useful for predicate names generated on-the-fly). If the predicate functor name <CODE>F</CODE> is uninstatiated, a new, unique, predicate name is generated at runtime. 


</DL>

<P>
<A NAME="IDX1893"></A>
<A NAME="IDX1894"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>wellformed_body/3:</B>
<DD><A NAME="IDX1895"></A>


<P>
<CODE>wellformed_body(BodyIn,Env,BodyOut)</CODE>


<P>
<CODE>BodyIn</CODE> is a well-formed clause body. <CODE>BodyOut</CODE> is its counterpart with no single-variable meta-goals (i.e., with <CODE>call(X)</CODE> for <CODE>X</CODE>). <CODE>Env</CODE> denotes if global cuts are admissible in <CODE>BodyIn</CODE> (<CODE>+</CODE> if they are, <CODE>-</CODE> if they are not).


</DL>



<H2><A NAME="SEC163" HREF="ciao_toc.html#TOC163">Documentation on multifiles (<CODE>dynamic</CODE>)</A></H2>
<P>
<A NAME="IDX1896"></A>
<A NAME="IDX1897"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>do_on_abolish/1:</B>
<DD><A NAME="IDX1898"></A>


<P>
<CODE>do_on_abolish(Head)</CODE>


<P>
A hook predicate which will be called when the definition of the predicate of <CODE>Head</CODE> is abolished.


<P>
The predicate is <EM>multifile</EM>.


</DL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_35.html">previous</A>, <A HREF="ciao_37.html">next</A>, <A HREF="ciao_223.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
