<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 28 November 1999 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - All solutions predicates</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_35.html">previous</A>, <A HREF="ciao_37.html">next</A>, <A HREF="ciao_146.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC140" HREF="ciao_toc.html#TOC140">All solutions predicates</A></H1>
<P>
<A NAME="IDX1738"></A>


<P>
<STRONG>Author(s):</STRONG> First version by Richard A. O'Keefe and David H.D. Warren. Changes by Mats Carlsson, Daniel Cabeza, and Manuel Hermenegildo.


<P>
<STRONG>Version:</STRONG> 1.3#120 (1999/11/26, 12:5:17 MET)


<P>
<STRONG>Version of last change:</STRONG> 0.7#9 (1998/9/23, 19:34:28 MEST)


<P>
This module implements the standard solution aggregation predicates. 


<P>
When there are many solutions to a problem, and when all those solutions are required to be collected together, this can be achieved by repeatedly backtracking and gradually building up a list of the solutions. The following built-in predicates are provided to automate this process. 



<UL>
<LI><A HREF="ciao_36.html#SEC141">Usage and interface (aggregates)</A>
<LI><A HREF="ciao_36.html#SEC142">Documentation on exports (aggregates)</A>
</UL>



<H2><A NAME="SEC141" HREF="ciao_toc.html#TOC141">Usage and interface (<CODE>aggregates</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

<CODE>:- use_module(library(aggregates)).</CODE>

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX1739"></A>
<CODE>setof/3</CODE>, 
<A NAME="IDX1740"></A>
<CODE>bagof/3</CODE>, 
<A NAME="IDX1741"></A>
<CODE>findall/3</CODE>, 
<A NAME="IDX1742"></A>
<CODE>^/2</CODE>.

</UL>

<LI><STRONG>Other modules used:</STRONG>


<UL>

<LI><EM>System library modules:</EM>

<A NAME="IDX1743"></A>
<CODE>sort</CODE>, 
<A NAME="IDX1744"></A>
<CODE>lists</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC142" HREF="ciao_toc.html#TOC142">Documentation on exports (<CODE>aggregates</CODE>)</A></H2>
<P>
<A NAME="IDX1745"></A>
<A NAME="IDX1746"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>setof/3:</B>
<DD><A NAME="IDX1747"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>setof(?,goal,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>setof(@(Template),+Generator,?(Set))</CODE>
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Description:</EM> Finds the <CODE>Set</CODE> of instances of the <CODE>Template</CODE> satisfying <CODE>Generator</CODE>. The set is in ascending order (see section <A HREF="ciao_20.html#SEC89">Comparing terms</A> for a definition of this order) without duplicates, and is non-empty. If there are no solutions, <CODE>setof</CODE> fails. <CODE>setof</CODE> may succeed in more than one way, binding free variables in <CODE>Generator</CODE> to different values. This can be avoided by using existential quantifiers on the free variables in front of <CODE>Generator</CODE>, using

<A NAME="IDX1748"></A>
<CODE>^/2</CODE>. For example, given the clauses: 

<PRE>
father(bill, tom).
father(bill, ann).
father(bill, john).
father(harry, july).
father(harry, daniel).
</PRE>

The following query produces two alternative solutions via backtracking: 

<PRE>
?- setof(X,father(F,X),Sons).

F = bill,
Sons = [ann,john,tom] ? ;

F = harry,
Sons = [daniel,july] ? ;

no
?- 
</PRE>

 
<LI><EM>The following properties should hold upon exit:</EM>

<CODE>Template</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>Generator</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)

<CODE>Set</CODE> is a list.
 (<CODE>basic_props:list/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1749"></A>
<A NAME="IDX1750"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>bagof/3:</B>
<DD><A NAME="IDX1751"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>bagof(?,goal,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>bagof(@(Template),+Generator,?(Bag))</CODE>
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Description:</EM> Finds all the instances of the <CODE>Template</CODE> produced by the <CODE>Generator</CODE>, and returns them in the <CODE>Bag</CODE> in the order in which they were found. If the <CODE>Generator</CODE> contains free variables which are not bound in the <CODE>Template</CODE>, it assumes that this is like any other Prolog question and that you want bindings for those variables. This can be avoided by using existential quantifiers on the free variables in front of the <CODE>Generator</CODE>, using

<A NAME="IDX1752"></A>
<CODE>^/2</CODE>. 
</UL>

</DL>

<P>
<A NAME="IDX1753"></A>
<A NAME="IDX1754"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>findall/3:</B>
<DD><A NAME="IDX1755"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>findall(?,goal,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>findall(?(Template),+Generator,?(List))</CODE>
<KBD> * ISO * </KBD>

<UL>
<LI><EM>Description:</EM> A special case of bagof, where all free variables in the <CODE>Generator</CODE> are taken to be existentially quantified. Faster than the other aggregation predicates.

</UL>

</DL>

<P>
<A NAME="IDX1756"></A>
<A NAME="IDX1757"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>findall/4:</B>
<DD><A NAME="IDX1758"></A>


<P>
No further documentation available for this predicate.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>findall(?,goal,?,?)</CODE>.


</DL>

<P>
<A NAME="IDX1759"></A>
<A NAME="IDX1760"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>^/2:</B>
<DD><A NAME="IDX1761"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>X ^ P</CODE>

<UL>
<LI><EM>Description:</EM> Existential quantification: <CODE>X</CODE> is existentially quantified in <CODE>P</CODE>. E.g., in <CODE>A^p(A,B)</CODE>, <CODE>A</CODE> is existentially quantified. Used only within

<A NAME="IDX1762"></A>
aggregation predicates. In all other contexts, simply, execute the procedure call <CODE>P</CODE>. 
</UL>

</DL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_35.html">previous</A>, <A HREF="ciao_37.html">next</A>, <A HREF="ciao_146.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
