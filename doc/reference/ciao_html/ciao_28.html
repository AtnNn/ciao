<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 13 July 2000 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - Fast/concurrent update of facts</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_27.html">previous</A>, <A HREF="ciao_29.html">next</A>, <A HREF="ciao_175.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC140" HREF="ciao_toc.html#TOC140">Fast/concurrent update of facts</A></H1>
<P>
<A NAME="IDX1580"></A>


<P>
<STRONG>Author(s):</STRONG> Daniel Cabeza, Manuel Carro.


<P>
<STRONG>Version:</STRONG> 1.5#171 (2000/7/7, 16:10:17 CEST)


<P>
<A NAME="IDX1581"></A>
<A NAME="IDX1582"></A>
Prolog implementations traditionally implement the concept of 
<A NAME="IDX1583"></A>
dynamic predicates: predicates which can be inspected or modified at run-time, adding or deleting individual clauses. The powerfulness of this feature brings also a great disadvantage: as new clause bodies can be arbitrarily added to the program, new unknown predicate calls can arise, thus preventing any global analysis or optimization of the code. But it is the case that most of the time what the programmer wants is simply to store data, with the purpose of sharing it between search branches, predicates, or even execution threads. In Ciao the concept of data predicate serves this purpose: a data predicate is a predicate composed exclusively by facts, which can be inspected, and dynamically added or deleted, at run-time. Using data predicates instead of normal dynamic predicates brings benefits in terms of speed, but above all turns the code automatically analyzable.
<A NAME="IDX1584"></A>
<A NAME="IDX1585"></A>
There is also a special kind of data predicates, called concurrent predicates, which can be used to communicate/synchronize among different execution threads (see section <A HREF="ciao_82.html#SEC314">Low-level concurrency/multithreading primitives</A>).



<UL>
<LI><A HREF="ciao_28.html#SEC141">Usage and interface (data_facts)</A>
<LI><A HREF="ciao_28.html#SEC142">Documentation on exports (data_facts)</A>
<LI><A HREF="ciao_28.html#SEC143">Documentation on internals (data_facts)</A>
</UL>



<H2><A NAME="SEC141" HREF="ciao_toc.html#TOC141">Usage and interface (<CODE>data_facts</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

These predicates are builtin in Ciao, so nothing special has to be done to use them.

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX1586"></A>
<CODE>asserta_fact/1</CODE>, 
<A NAME="IDX1587"></A>
<CODE>asserta_fact/2</CODE>, 
<A NAME="IDX1588"></A>
<CODE>assertz_fact/1</CODE>, 
<A NAME="IDX1589"></A>
<CODE>assertz_fact/2</CODE>, 
<A NAME="IDX1590"></A>
<CODE>current_fact/1</CODE>, 
<A NAME="IDX1591"></A>
<CODE>current_fact/2</CODE>, 
<A NAME="IDX1592"></A>
<CODE>retract_fact/1</CODE>, 
<A NAME="IDX1593"></A>
<CODE>retractall_fact/1</CODE>, 
<A NAME="IDX1594"></A>
<CODE>current_fact_nb/1</CODE>, 
<A NAME="IDX1595"></A>
<CODE>retract_fact_nb/1</CODE>, 
<A NAME="IDX1596"></A>
<CODE>close_predicate/1</CODE>, 
<A NAME="IDX1597"></A>
<CODE>open_predicate/1</CODE>, 
<A NAME="IDX1598"></A>
<CODE>set_fact/1</CODE>, 
<A NAME="IDX1599"></A>
<CODE>erase/1</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC142" HREF="ciao_toc.html#TOC142">Documentation on exports (<CODE>data_facts</CODE>)</A></H2>
<P>
<A NAME="IDX1600"></A>
<A NAME="IDX1601"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>asserta_fact/1:</B>
<DD><A NAME="IDX1602"></A>


<P>
<CODE>asserta_fact(Fact)</CODE>


<P>
<CODE>Fact</CODE> is added to the corresponding 
<A NAME="IDX1603"></A>
data predicate. The fact becomes the first clause of the predicate concerned.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>asserta_fact(fact)</CODE>.


</DL>

<P>
<A NAME="IDX1604"></A>
<A NAME="IDX1605"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>asserta_fact/2:</B>
<DD><A NAME="IDX1606"></A>


<P>
<CODE>asserta_fact(Fact,Ref)</CODE>


<P>
Same as 
<A NAME="IDX1607"></A>
<CODE>asserta_fact/1</CODE>, instantiating <CODE>Ref</CODE> to a unique identifier of the asserted fact.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>asserta_fact(fact,?)</CODE>.


</DL>

<P>
<A NAME="IDX1608"></A>
<A NAME="IDX1609"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>assertz_fact/1:</B>
<DD><A NAME="IDX1610"></A>


<P>
<CODE>assertz_fact(Fact)</CODE>


<P>
<CODE>Fact</CODE> is added to the corresponding 
<A NAME="IDX1611"></A>
data predicate. The fact becomes the last clause of the predicate concerned.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>assertz_fact(fact)</CODE>.


</DL>

<P>
<A NAME="IDX1612"></A>
<A NAME="IDX1613"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>assertz_fact/2:</B>
<DD><A NAME="IDX1614"></A>


<P>
<CODE>assertz_fact(Fact,Ref)</CODE>


<P>
Same as 
<A NAME="IDX1615"></A>
<CODE>assertz_fact/1</CODE>, instantiating <CODE>Ref</CODE> to a unique identifier of the asserted fact.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>assertz_fact(fact,?)</CODE>.


</DL>

<P>
<A NAME="IDX1616"></A>
<A NAME="IDX1617"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>current_fact/1:</B>
<DD><A NAME="IDX1618"></A>


<P>
<CODE>current_fact(Fact)</CODE>


<P>
Gives on backtracking all the facts defined as data or concurrent which unify with <CODE>Fact</CODE>. It is faster than calling the predicate explicitly, which do invoke the meta-interpreter. If the <CODE>Fact</CODE> has been defined as concurrent and has not been 
<A NAME="IDX1619"></A>
closed, 
<A NAME="IDX1620"></A>
<CODE>current_fact/1</CODE> will wait (instead of failing) for more clauses to appear after the last clause of <CODE>Fact</CODE> is returned.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>current_fact(fact)</CODE>.


</DL>

<P>
<A NAME="IDX1621"></A>
<A NAME="IDX1622"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>current_fact/2:</B>
<DD><A NAME="IDX1623"></A>


<P>
<CODE>current_fact(Fact,Ref)</CODE>


<P>
<CODE>Fact</CODE> is a fact of a 
<A NAME="IDX1624"></A>
data predicate and <CODE>Ref</CODE> is its reference identifying it uniquely.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>current_fact(fact,?)</CODE>.


<P>
<STRONG>Usage 1:</STRONG> <CODE>current_fact(+callable,-reference)</CODE>

<UL>
<LI><EM>Description:</EM> Gives on backtracking all the facts defined as data which unify with <CODE>Fact</CODE>, instantiating <CODE>Ref</CODE> to a unique identifier for each fact.

</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>current_fact(?callable,+reference)</CODE>

<UL>
<LI><EM>Description:</EM> Given <CODE>Ref</CODE>, unifies <CODE>Fact</CODE> with the fact identified by it.

</UL>

</DL>

<P>
<A NAME="IDX1625"></A>
<A NAME="IDX1626"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>retract_fact/1:</B>
<DD><A NAME="IDX1627"></A>


<P>
<CODE>retract_fact(Fact)</CODE>


<P>
Unifies <CODE>Fact</CODE> with the first matching fact of a 
<A NAME="IDX1628"></A>
data predicate, and then erases it. On backtracking successively unifies with and erases new matching facts. If <CODE>Fact</CODE> is declared as 
<A NAME="IDX1629"></A>
concurrent and is non-
<A NAME="IDX1630"></A>
closed, 
<A NAME="IDX1631"></A>
<CODE>retract_fact/1</CODE> will wait for more clauses or for the closing of the predicate after the last matching clause has been removed.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>retract_fact(fact)</CODE>.


</DL>

<P>
<A NAME="IDX1632"></A>
<A NAME="IDX1633"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>retractall_fact/1:</B>
<DD><A NAME="IDX1634"></A>


<P>
<CODE>retractall_fact(Fact)</CODE>


<P>
Erase all the facts of a 
<A NAME="IDX1635"></A>
data predicate unifying with <CODE>Fact</CODE>. Even if all facts are removed, the predicate continues to exist.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>retractall_fact(fact)</CODE>.


</DL>

<P>
<A NAME="IDX1636"></A>
<A NAME="IDX1637"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>current_fact_nb/1:</B>
<DD><A NAME="IDX1638"></A>


<P>
<CODE>current_fact_nb(Fact)</CODE>


<P>
Behaves as 
<A NAME="IDX1639"></A>
<CODE>current_fact/1</CODE> but a fact is never waited on even if it is 
<A NAME="IDX1640"></A>
concurrent and non-closed.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>current_fact_nb(fact)</CODE>.


</DL>

<P>
<A NAME="IDX1641"></A>
<A NAME="IDX1642"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>retract_fact_nb/1:</B>
<DD><A NAME="IDX1643"></A>


<P>
<CODE>retract_fact_nb(Fact)</CODE>


<P>
Behaves as 
<A NAME="IDX1644"></A>
<CODE>retract_fact/1</CODE>, but never waits on a fact, even if it has been declared as 
<A NAME="IDX1645"></A>
concurrent and is non-
<A NAME="IDX1646"></A>
closed.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>retract_fact_nb(fact)</CODE>.


</DL>

<P>
<A NAME="IDX1647"></A>
<A NAME="IDX1648"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>close_predicate/1:</B>
<DD><A NAME="IDX1649"></A>


<P>
<CODE>close_predicate(Pred)</CODE>


<P>
<A NAME="IDX1650"></A>
<A NAME="IDX1651"></A>
Changes the behavior of the predicate <CODE>Pred</CODE> if it has been declared as a 
<A NAME="IDX1652"></A>
concurrent predicate: calls to this predicate will fail (instead of wait) if no more clauses of <CODE>Pred</CODE> are available.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>close_predicate(fact)</CODE>.


</DL>

<P>
<A NAME="IDX1653"></A>
<A NAME="IDX1654"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>open_predicate/1:</B>
<DD><A NAME="IDX1655"></A>


<P>
<CODE>open_predicate(Pred)</CODE>


<P>
Reverts the behavior of 
<A NAME="IDX1656"></A>
concurrent predicate <CODE>Pred</CODE> to waiting instead of failing if no more clauses of <CODE>Pred</CODE> are available.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>open_predicate(fact)</CODE>.


</DL>

<P>
<A NAME="IDX1657"></A>
<A NAME="IDX1658"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>set_fact/1:</B>
<DD><A NAME="IDX1659"></A>


<P>
<CODE>set_fact(Fact)</CODE>


<P>
Sets <CODE>Fact</CODE> as the unique fact of the corresponding 
<A NAME="IDX1660"></A>
data predicate.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>set_fact(fact)</CODE>.


</DL>

<P>
<A NAME="IDX1661"></A>
<A NAME="IDX1662"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>erase/1:</B>
<DD><A NAME="IDX1663"></A>


<P>
<CODE>erase(Ref)</CODE>


<P>
Deletes the clause referenced by <CODE>Ref</CODE>.


</DL>



<H2><A NAME="SEC143" HREF="ciao_toc.html#TOC143">Documentation on internals (<CODE>data_facts</CODE>)</A></H2>
<P>
<A NAME="IDX1664"></A>
<A NAME="IDX1665"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>reference/1:</B>
<DD><A NAME="IDX1666"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>reference(R)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>R</CODE> is a reference of a dynamic or data clause.

</UL>

</DL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_27.html">previous</A>, <A HREF="ciao_29.html">next</A>, <A HREF="ciao_175.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
