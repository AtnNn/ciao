<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 26 October 2001 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - Fast/concurrent update of facts</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_27.html">previous</A>, <A HREF="ciao_29.html">next</A>, <A HREF="ciao_218.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC166" HREF="ciao_toc.html#TOC166">Fast/concurrent update of facts</A></H1>
<P>
<A NAME="IDX1802"></A>


<P>
<STRONG>Author(s):</STRONG> Daniel Cabeza, Manuel Carro.


<P>
<STRONG>Version:</STRONG> 1.7#116 (2001/8/9, 17:56:37 CEST)


<P>
<STRONG>Version of last change:</STRONG> 1.7#95 (2001/5/2, 12:18:6 CEST)


<P>
<A NAME="IDX1803"></A>
<A NAME="IDX1804"></A>
Prolog implementations traditionally implement the concept of 
<A NAME="IDX1805"></A>
dynamic predicates: predicates which can be inspected or modified at run-time, adding or deleting individual clauses. The power of this feature comes at a cost: as new clause bodies can be arbitrarily added to the program, new predicate calls can arise which are not 'visible' at compile-time, thus complicating global analysis and optimization of the code. But it is the case that most of the time what the programmer wants is simply to store data, with the purpose of sharing it between search branches, predicates, or even execution threads. In Ciao the concept of data predicate serves this purpose: a data predicate is a predicate composed exclusively by facts, which can be inspected, and dynamically added or deleted, at run-time. Using data predicates instead of normal dynamic predicates brings benefits in terms of speed, but above all makes the code much easier to analyze automatically and thus allows better optimization.
<A NAME="IDX1806"></A>
<A NAME="IDX1807"></A>
<A NAME="IDX1808"></A>
<A NAME="IDX1809"></A>


<P>
Also, a special kind of data predicates exists, 
<A NAME="IDX1810"></A>
<A NAME="IDX1811"></A>
<EM>concurrent predicates</EM>, which can be used to communicate/synchronize among different execution threads (see section <A HREF="ciao_82.html#SEC342">Low-level concurrency/multithreading primitives</A>). 


<P>
Data predicates must be declared through a 
<A NAME="IDX1812"></A>
<CODE>data/1</CODE> declaration. Concurrent data predicates must be declared through a 
<A NAME="IDX1813"></A>
<CODE>concurrent/1</CODE> declaration. 



<UL>
<LI><A HREF="ciao_28.html#SEC167">Usage and interface (data_facts)</A>
<LI><A HREF="ciao_28.html#SEC168">Documentation on exports (data_facts)</A>
<LI><A HREF="ciao_28.html#SEC169">Documentation on internals (data_facts)</A>
</UL>



<H2><A NAME="SEC167" HREF="ciao_toc.html#TOC167">Usage and interface (<CODE>data_facts</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

These predicates are builtin in Ciao, so nothing special has to be done to use them.

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX1814"></A>
<CODE>asserta_fact/1</CODE>, 
<A NAME="IDX1815"></A>
<CODE>asserta_fact/2</CODE>, 
<A NAME="IDX1816"></A>
<CODE>assertz_fact/1</CODE>, 
<A NAME="IDX1817"></A>
<CODE>assertz_fact/2</CODE>, 
<A NAME="IDX1818"></A>
<CODE>current_fact/1</CODE>, 
<A NAME="IDX1819"></A>
<CODE>current_fact/2</CODE>, 
<A NAME="IDX1820"></A>
<CODE>retract_fact/1</CODE>, 
<A NAME="IDX1821"></A>
<CODE>retractall_fact/1</CODE>, 
<A NAME="IDX1822"></A>
<CODE>current_fact_nb/1</CODE>, 
<A NAME="IDX1823"></A>
<CODE>retract_fact_nb/1</CODE>, 
<A NAME="IDX1824"></A>
<CODE>close_predicate/1</CODE>, 
<A NAME="IDX1825"></A>
<CODE>open_predicate/1</CODE>, 
<A NAME="IDX1826"></A>
<CODE>set_fact/1</CODE>, 
<A NAME="IDX1827"></A>
<CODE>erase/1</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC168" HREF="ciao_toc.html#TOC168">Documentation on exports (<CODE>data_facts</CODE>)</A></H2>
<P>
<A NAME="IDX1828"></A>
<A NAME="IDX1829"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>asserta_fact/1:</B>
<DD><A NAME="IDX1830"></A>


<P>
<CODE>asserta_fact(Fact)</CODE>


<P>
<CODE>Fact</CODE> is added to the corresponding 
<A NAME="IDX1831"></A>
data predicate. The fact becomes the first clause of the predicate concerned.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>asserta_fact(fact)</CODE>.


</DL>

<P>
<A NAME="IDX1832"></A>
<A NAME="IDX1833"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>asserta_fact/2:</B>
<DD><A NAME="IDX1834"></A>


<P>
<CODE>asserta_fact(Fact,Ref)</CODE>


<P>
Same as 
<A NAME="IDX1835"></A>
<CODE>asserta_fact/1</CODE>, instantiating <CODE>Ref</CODE> to a unique identifier of the asserted fact.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>asserta_fact(fact,?)</CODE>.


</DL>

<P>
<A NAME="IDX1836"></A>
<A NAME="IDX1837"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>assertz_fact/1:</B>
<DD><A NAME="IDX1838"></A>


<P>
<CODE>assertz_fact(Fact)</CODE>


<P>
<CODE>Fact</CODE> is added to the corresponding 
<A NAME="IDX1839"></A>
data predicate. The fact becomes the last clause of the predicate concerned.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>assertz_fact(fact)</CODE>.


</DL>

<P>
<A NAME="IDX1840"></A>
<A NAME="IDX1841"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>assertz_fact/2:</B>
<DD><A NAME="IDX1842"></A>


<P>
<CODE>assertz_fact(Fact,Ref)</CODE>


<P>
Same as 
<A NAME="IDX1843"></A>
<CODE>assertz_fact/1</CODE>, instantiating <CODE>Ref</CODE> to a unique identifier of the asserted fact.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>assertz_fact(fact,?)</CODE>.


</DL>

<P>
<A NAME="IDX1844"></A>
<A NAME="IDX1845"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>current_fact/1:</B>
<DD><A NAME="IDX1846"></A>


<P>
<CODE>current_fact(Fact)</CODE>


<P>
Gives on backtracking all the facts defined as data or concurrent which unify with <CODE>Fact</CODE>. It is faster than calling the predicate explicitly, which do invoke the meta-interpreter. If the <CODE>Fact</CODE> has been defined as concurrent and has not been 
<A NAME="IDX1847"></A>
closed, 
<A NAME="IDX1848"></A>
<CODE>current_fact/1</CODE> will wait (instead of failing) for more clauses to appear after the last clause of <CODE>Fact</CODE> is returned.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>current_fact(fact)</CODE>.


</DL>

<P>
<A NAME="IDX1849"></A>
<A NAME="IDX1850"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>current_fact/2:</B>
<DD><A NAME="IDX1851"></A>


<P>
<CODE>current_fact(Fact,Ref)</CODE>


<P>
<CODE>Fact</CODE> is a fact of a 
<A NAME="IDX1852"></A>
data predicate and <CODE>Ref</CODE> is its reference identifying it uniquely.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>current_fact(fact,?)</CODE>.


<P>
<STRONG>Usage 1:</STRONG> <CODE>current_fact(+callable,-reference)</CODE>

<UL>
<LI><EM>Description:</EM> Gives on backtracking all the facts defined as data which unify with <CODE>Fact</CODE>, instantiating <CODE>Ref</CODE> to a unique identifier for each fact.

</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>current_fact(?callable,+reference)</CODE>

<UL>
<LI><EM>Description:</EM> Given <CODE>Ref</CODE>, unifies <CODE>Fact</CODE> with the fact identified by it.

</UL>

</DL>

<P>
<A NAME="IDX1853"></A>
<A NAME="IDX1854"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>retract_fact/1:</B>
<DD><A NAME="IDX1855"></A>


<P>
<CODE>retract_fact(Fact)</CODE>


<P>
Unifies <CODE>Fact</CODE> with the first matching fact of a 
<A NAME="IDX1856"></A>
data predicate, and then erases it. On backtracking successively unifies with and erases new matching facts. If <CODE>Fact</CODE> is declared as 
<A NAME="IDX1857"></A>
concurrent and is non-
<A NAME="IDX1858"></A>
closed, 
<A NAME="IDX1859"></A>
<CODE>retract_fact/1</CODE> will wait for more clauses or for the closing of the predicate after the last matching clause has been removed.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>retract_fact(fact)</CODE>.


</DL>

<P>
<A NAME="IDX1860"></A>
<A NAME="IDX1861"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>retractall_fact/1:</B>
<DD><A NAME="IDX1862"></A>


<P>
<CODE>retractall_fact(Fact)</CODE>


<P>
Erase all the facts of a 
<A NAME="IDX1863"></A>
data predicate unifying with <CODE>Fact</CODE>. Even if all facts are removed, the predicate continues to exist.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>retractall_fact(fact)</CODE>.


</DL>

<P>
<A NAME="IDX1864"></A>
<A NAME="IDX1865"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>current_fact_nb/1:</B>
<DD><A NAME="IDX1866"></A>


<P>
<CODE>current_fact_nb(Fact)</CODE>


<P>
Behaves as 
<A NAME="IDX1867"></A>
<CODE>current_fact/1</CODE> but a fact is never waited on even if it is 
<A NAME="IDX1868"></A>
concurrent and non-closed.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>current_fact_nb(fact)</CODE>.


</DL>

<P>
<A NAME="IDX1869"></A>
<A NAME="IDX1870"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>retract_fact_nb/1:</B>
<DD><A NAME="IDX1871"></A>


<P>
<CODE>retract_fact_nb(Fact)</CODE>


<P>
Behaves as 
<A NAME="IDX1872"></A>
<CODE>retract_fact/1</CODE>, but never waits on a fact, even if it has been declared as 
<A NAME="IDX1873"></A>
concurrent and is non-
<A NAME="IDX1874"></A>
closed.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>retract_fact_nb(fact)</CODE>.


</DL>

<P>
<A NAME="IDX1875"></A>
<A NAME="IDX1876"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>close_predicate/1:</B>
<DD><A NAME="IDX1877"></A>


<P>
<CODE>close_predicate(Pred)</CODE>


<P>
<A NAME="IDX1878"></A>
<A NAME="IDX1879"></A>
Changes the behavior of the predicate <CODE>Pred</CODE> if it has been declared as a 
<A NAME="IDX1880"></A>
concurrent predicate: calls to this predicate will fail (instead of wait) if no more clauses of <CODE>Pred</CODE> are available.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>close_predicate(fact)</CODE>.


</DL>

<P>
<A NAME="IDX1881"></A>
<A NAME="IDX1882"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>open_predicate/1:</B>
<DD><A NAME="IDX1883"></A>


<P>
<CODE>open_predicate(Pred)</CODE>


<P>
Reverts the behavior of 
<A NAME="IDX1884"></A>
concurrent predicate <CODE>Pred</CODE> to waiting instead of failing if no more clauses of <CODE>Pred</CODE> are available.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>open_predicate(fact)</CODE>.


</DL>

<P>
<A NAME="IDX1885"></A>
<A NAME="IDX1886"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>set_fact/1:</B>
<DD><A NAME="IDX1887"></A>


<P>
<CODE>set_fact(Fact)</CODE>


<P>
Sets <CODE>Fact</CODE> as the unique fact of the corresponding 
<A NAME="IDX1888"></A>
data predicate.


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>set_fact(fact)</CODE>.


</DL>

<P>
<A NAME="IDX1889"></A>
<A NAME="IDX1890"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>erase/1:</B>
<DD><A NAME="IDX1891"></A>


<P>
<CODE>erase(Ref)</CODE>


<P>
Deletes the clause referenced by <CODE>Ref</CODE>.


</DL>



<H2><A NAME="SEC169" HREF="ciao_toc.html#TOC169">Documentation on internals (<CODE>data_facts</CODE>)</A></H2>
<P>
<A NAME="IDX1892"></A>
<A NAME="IDX1893"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>data/1:</B>
<DD><A NAME="IDX1894"></A>


<P>
<STRONG>Usage:</STRONG> :- <CODE>data Predicates</CODE>.

<UL>
<LI><EM>Description:</EM> Defines each predicate in <CODE>Predicates</CODE> as a

<A NAME="IDX1895"></A>
data predicate. If a predicate is defined data in a file, it must be defined data in every file containing clauses for that predicate. The directive should precede all clauses of the affected predicates. This directive is defined as a prefix operator in the compiler. 
<LI><EM>The following properties hold at call time:</EM>

<CODE>Predicates</CODE> is a sequence or list of <CODE>predname</CODE>s.
 (<CODE>basic_props:sequence_or_list/2</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1896"></A>
<A NAME="IDX1897"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>concurrent/1:</B>
<DD><A NAME="IDX1898"></A>


<P>
<STRONG>Usage:</STRONG> :- <CODE>concurrent Predicates</CODE>.

<UL>
<LI><EM>Description:</EM> Defines each predicate in <CODE>Predicates</CODE> as a

<A NAME="IDX1899"></A>
concurrent predicate. If a predicate is defined concurrent in a file, it must be defined concurrent in every file containing clauses for that predicate. The directive should precede all clauses of the affected predicates. This directive is defined as a prefix operator in the compiler. 
<LI><EM>The following properties hold at call time:</EM>

<CODE>Predicates</CODE> is a sequence or list of <CODE>predname</CODE>s.
 (<CODE>basic_props:sequence_or_list/2</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1900"></A>
<A NAME="IDX1901"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>reference/1:</B>
<DD><A NAME="IDX1902"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>reference(R)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>R</CODE> is a reference of a dynamic or data clause.

</UL>

</DL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_27.html">previous</A>, <A HREF="ciao_29.html">next</A>, <A HREF="ciao_218.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
