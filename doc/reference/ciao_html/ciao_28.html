<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 28 November 1999 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - Concurrency/multithreading primitives</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_27.html">previous</A>, <A HREF="ciao_29.html">next</A>, <A HREF="ciao_146.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC116" HREF="ciao_toc.html#TOC116">Concurrency/multithreading primitives</A></H1>
<P>
<A NAME="IDX1488"></A>


<P>
<STRONG>Author(s):</STRONG> Manuel Carro.


<P>
<STRONG>Version:</STRONG> 1.3#120 (1999/11/26, 12:5:17 MET)


<P>
<STRONG>Version of last change:</STRONG> 1.3#118 (1999/11/25, 19:28:6 MET)


<P>
This module provides basic mechanisms for using concurrency and implementing multi-goal applications.
<A NAME="IDX1489"></A>
<A NAME="IDX1490"></A>
Goals can be specified to be run in a separate stack set; in that case, they are assigned a goal identifier with which further accesses (e.g., asking for more solutions) to the goal can be made. Additionally, in some architectures, these goals can be assigned an O.S. thread, separate from the one which made the initial call. On the architectures for which we were not able to implement it yet, the original thread switches to the new stack set, executes the goal there, and returns after it has completed. 


<P>
As for now, the memory space of the threads (c.f., stack sets) is separate in the sense that goals are copied to the new stack set, and bindings of variables are not seen among stack sets which allows forward and backward execution to proceed independently in each stack set, at the cost of the initial goal copy. However, the program space (including, specially, the 
<A NAME="IDX1491"></A>
concurrent predicates) are shared and seen by all the goals and threads. 


<P>
Additionally, a small set of lock-related predicates are provided: locks are associated with atom names. Whereas the concurrent database facilities are enough to implement locks, semaphores, messages, etc., the predicates implementing atom-based locks are faster than the ones accessing the concurrent database. 



<UL>
<LI><A HREF="ciao_28.html#SEC117">Usage and interface (concurrency)</A>
<LI><A HREF="ciao_28.html#SEC118">Documentation on exports (concurrency)</A>
<LI><A HREF="ciao_28.html#SEC119">Known bugs and planned improvements (concurrency)</A>
</UL>



<H2><A NAME="SEC117" HREF="ciao_toc.html#TOC117">Usage and interface (<CODE>concurrency</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

These predicates are builtin in CIAO, so nothing special has to be done to use them.

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX1492"></A>
<CODE>eng_call/4</CODE>, 
<A NAME="IDX1493"></A>
<CODE>eng_call/3</CODE>, 
<A NAME="IDX1494"></A>
<CODE>eng_backtrack/2</CODE>, 
<A NAME="IDX1495"></A>
<CODE>eng_cut/1</CODE>, 
<A NAME="IDX1496"></A>
<CODE>eng_release/1</CODE>, 
<A NAME="IDX1497"></A>
<CODE>eng_wait/1</CODE>, 
<A NAME="IDX1498"></A>
<CODE>eng_kill/1</CODE>, 
<A NAME="IDX1499"></A>
<CODE>eng_killothers/0</CODE>, 
<A NAME="IDX1500"></A>
<CODE>eng_self/1</CODE>, 
<A NAME="IDX1501"></A>
<CODE>eng_status/0</CODE>, 
<A NAME="IDX1502"></A>
<CODE>lock_atom/1</CODE>, 
<A NAME="IDX1503"></A>
<CODE>unlock_atom/1</CODE>, 
<A NAME="IDX1504"></A>
<CODE>atom_lock_state/2</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC118" HREF="ciao_toc.html#TOC118">Documentation on exports (<CODE>concurrency</CODE>)</A></H2>
<P>
<A NAME="IDX1505"></A>
<A NAME="IDX1506"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>eng_call/4:</B>
<DD><A NAME="IDX1507"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>eng_call(goal,?,?,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>eng_call(+Goal,+EngineCreation,+ThreadCreation,-(GoalId))</CODE>

<UL>
<LI><EM>Description:</EM> Calls <CODE>Goal</CODE> in a new engine (stack set), possibly using a new thread, and returns a <CODE>GoalId</CODE> to designate this new goal henceforth. <CODE>EngineCreation</CODE> can be either <CODE>wait</CODE> or <CODE>create</CODE>; the distinction is not yet meaningful. <CODE>ThreadCreation</CODE> can be one of <CODE>self</CODE>, <CODE>wait</CODE>, or <CODE>create</CODE>. In the first case the creating thread is used to execute <CODE>Goal</CODE>, and thus it has to wait until its first result or failure. In the other two cases, a new thread for the <CODE>Goal</CODE> is created and assigned the new engine. Some details still have to be woked out.

<A NAME="IDX1508"></A>
<CODE>eng_call/4</CODE> always succeeds and executes a copy (with new variables) of the original goal, so local and remote backtracking and execution do not affect each other. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>+Goal</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)

<CODE>+EngineCreation</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+ThreadCreation</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>-(GoalId)</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1509"></A>
<A NAME="IDX1510"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>eng_call/3:</B>
<DD><A NAME="IDX1511"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>eng_call(goal,?,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>eng_call(+Goal,+EngineCreation,+ThreadCreation)</CODE>

<UL>
<LI><EM>Description:</EM> Similar to

<A NAME="IDX1512"></A>
<CODE>eng_call/4</CODE>, but the thread (if created) and stack areas are automatically released upon success or failure of the goal. No <CODE>GoalId</CODE> is provided for further interaction with the goal. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>+Goal</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)

<CODE>+EngineCreation</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+ThreadCreation</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1513"></A>
<A NAME="IDX1514"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>eng_backtrack/2:</B>
<DD><A NAME="IDX1515"></A>


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>eng_backtrack(+GoalId,+ThreadCreation)</CODE>

<UL>
<LI><EM>Description:</EM> Performs backtracking on the goal designed by <CODE>GoalId</CODE>, maybe using a new thread, according to <CODE>ThreadCreation</CODE> (same as in

<A NAME="IDX1516"></A>
<CODE>eng_call/4</CODE>). Fails if the goal is backtracked over by the local thread, and there are no more solutions. Always succeeds if executed by a remote thread. The engine is automatically released and cleaned up upon failure. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>+GoalId</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)

<CODE>+ThreadCreation</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1517"></A>
<A NAME="IDX1518"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>eng_cut/1:</B>
<DD><A NAME="IDX1519"></A>


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>eng_cut(+GoalId)</CODE>

<UL>
<LI><EM>Description:</EM> Performs a <EM>cut</EM> in the execution of the goal <CODE>GoalId</CODE>. The next call to

<A NAME="IDX1520"></A>
<CODE>eng_backtrack/2</CODE> will therefore fail. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>+GoalId</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1521"></A>
<A NAME="IDX1522"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>eng_release/1:</B>
<DD><A NAME="IDX1523"></A>


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>eng_release(+GoalId)</CODE>

<UL>
<LI><EM>Description:</EM> Cleans up and releases the engine executing the goal designed by <CODE>GoalId</CODE>. The engine must be in <CODE>WAITING</CODE> state.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>+GoalId</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1524"></A>
<A NAME="IDX1525"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>eng_wait/1:</B>
<DD><A NAME="IDX1526"></A>


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>eng_wait(+GoalId)</CODE>

<UL>
<LI><EM>Description:</EM> Waits for the engine executing the goal denoted by <CODE>GoalId</CODE> to be in waiting state (i.e., it has finished searching for a solution, either with success or failure).

<LI><EM>The following properties should hold at call time:</EM>

<CODE>+GoalId</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1527"></A>
<A NAME="IDX1528"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>eng_kill/1:</B>
<DD><A NAME="IDX1529"></A>


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>eng_kill(+GoalId)</CODE>

<UL>
<LI><EM>Description:</EM> Kills the thread executing <CODE>GoalId</CODE> (if any), and frees the memory used up by the stack set. Usually one should wait (

<A NAME="IDX1530"></A>
<CODE>eng_wait/1</CODE>) for a goal, and then release it, but killing the thread explicitly allows recovering from error states, or imposing timeouts to a task. A goal can kill itself; use this feature with caution. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>+GoalId</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1531"></A>
<A NAME="IDX1532"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>eng_killothers/0:</B>
<DD><A NAME="IDX1533"></A>


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> 

<UL>
<LI><EM>Description:</EM> Kills threads and releases stack sets of all active goals, but the one calling

<A NAME="IDX1534"></A>
<CODE>eng_killothers</CODE>. Again, a safety measure. 
</UL>

</DL>

<P>
<A NAME="IDX1535"></A>
<A NAME="IDX1536"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>eng_self/1:</B>
<DD><A NAME="IDX1537"></A>


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>eng_self(?(GoalId))</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>GoalId</CODE> is unified with the identifier of the goal within which

<A NAME="IDX1538"></A>
<CODE>eng_self/1</CODE> is executed. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>?(GoalId)</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1539"></A>
<A NAME="IDX1540"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>eng_status/0:</B>
<DD><A NAME="IDX1541"></A>


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> 

<UL>
<LI><EM>Description:</EM> Prints to standard output the current status of the stack sets.

</UL>

</DL>

<P>
<A NAME="IDX1542"></A>
<A NAME="IDX1543"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>lock_atom/1:</B>
<DD><A NAME="IDX1544"></A>


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>lock_atom(+Atom)</CODE>

<UL>
<LI><EM>Description:</EM> The

<A NAME="IDX1545"></A>
semaphore associated to <CODE>Atom</CODE> is accessed; if its value is nonzero, it is atomically decremented and the execution of this thread proceeds. Otherwise, the goal waits until a nonzero value is reached. The semaphore is then atomically decremented and the execution of this thread proceeds. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>+Atom</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1546"></A>
<A NAME="IDX1547"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>unlock_atom/1:</B>
<DD><A NAME="IDX1548"></A>


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>unlock_atom(+Atom)</CODE>

<UL>
<LI><EM>Description:</EM> The

<A NAME="IDX1549"></A>
semaphore associated to <CODE>Atom</CODE> is atomically incremented. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>+Atom</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX1550"></A>
<A NAME="IDX1551"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>atom_lock_state/2:</B>
<DD><A NAME="IDX1552"></A>


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage 1:</STRONG> <CODE>atom_lock_state(+Atom,+Value)</CODE>

<UL>
<LI><EM>Description:</EM> Sets the semaphore associated to <CODE>Atom</CODE> to <CODE>Value</CODE>. This is usually done at the beginning of the execution, but can be executed at any time. If not called, semaphore associated to atoms are by default inited to 1. It should be used with caution: arbitrary use can transform programs using locks in a mess of internal relations. The change of a semaphore value in a place other than the initialization stage of a program is <STRONG>not</STRONG> among the allowed operations as defined by Dijkstra [Dij65,BA82].

<LI><EM>The following properties should hold at call time:</EM>

<CODE>+Atom</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+Value</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>atom_lock_state(+Atom,-(Value))</CODE>

<UL>
<LI><EM>Description:</EM> Consults the <CODE>Value</CODE> of the semaphore associated to <CODE>Atom</CODE>. Use sparingly and mainly as a medium to check state correctness. Not among the operations on semaphore by Djikstra.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>+Atom</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>-(Value)</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)
</UL>

</DL>



<H2><A NAME="SEC119" HREF="ciao_toc.html#TOC119">Known bugs and planned improvements (<CODE>concurrency</CODE>)</A></H2>


<UL>

<LI>

Not fully available in all architectures yet.

<LI>

Some implementation of threads have a limit on the total number of threads that can be created by a process (not only threads active at a time, but threads created at all). Thread creation, in this case, just hangs. A better solution is planned for the future.

<LI>

The thread-related part of the library is not yet final, an some characteristics may be revised in a near future. A higher level library for concurrency and distribution based on the low-level primitives in this module is being implemented. 
</UL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_27.html">previous</A>, <A HREF="ciao_29.html">next</A>, <A HREF="ciao_146.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
