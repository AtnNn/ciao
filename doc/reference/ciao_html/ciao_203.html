<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 26 October 2001 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - parser_util (library)</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_202.html">previous</A>, <A HREF="ciao_204.html">next</A>, <A HREF="ciao_218.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC765" HREF="ciao_toc.html#TOC765">parser_util (library)</A></H1>
<P>
<A NAME="IDX7906"></A>



<UL>
<LI><A HREF="ciao_203.html#SEC766">Usage and interface (parser_util)</A>
<LI><A HREF="ciao_203.html#SEC767">Documentation on exports (parser_util)</A>
</UL>



<H2><A NAME="SEC766" HREF="ciao_toc.html#TOC766">Usage and interface (<CODE>parser_util</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

<CODE>:- use_module(library(parser_util)).</CODE>

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX7907"></A>
<CODE>at_least_one/4</CODE>, 
<A NAME="IDX7908"></A>
<CODE>at_least_one/5</CODE>, 
<A NAME="IDX7909"></A>
<CODE>fillout/4</CODE>, 
<A NAME="IDX7910"></A>
<CODE>fillout/5</CODE>, 
<A NAME="IDX7911"></A>
<CODE>create_node/3</CODE>, 
<A NAME="IDX7912"></A>
<CODE>create_field/3</CODE>, 
<A NAME="IDX7913"></A>
<CODE>create_field/4</CODE>, 
<A NAME="IDX7914"></A>
<CODE>create_field/5</CODE>, 
<A NAME="IDX7915"></A>
<CODE>create_directed_field/5</CODE>, 
<A NAME="IDX7916"></A>
<CODE>correct_commenting/4</CODE>, 
<A NAME="IDX7917"></A>
<CODE>create_parse_structure/1</CODE>, 
<A NAME="IDX7918"></A>
<CODE>create_parse_structure/2</CODE>, 
<A NAME="IDX7919"></A>
<CODE>create_parse_structure/3</CODE>, 
<A NAME="IDX7920"></A>
<CODE>create_environment/4</CODE>, 
<A NAME="IDX7921"></A>
<CODE>insert_comments_in_beginning/3</CODE>, 
<A NAME="IDX7922"></A>
<CODE>get_environment_name/2</CODE>, 
<A NAME="IDX7923"></A>
<CODE>get_environment_type/2</CODE>, 
<A NAME="IDX7924"></A>
<CODE>get_row_number/2</CODE>, 
<A NAME="IDX7925"></A>
<CODE>add_environment_whitespace/3</CODE>, 
<A NAME="IDX7926"></A>
<CODE>get_indentation/2</CODE>, 
<A NAME="IDX7927"></A>
<CODE>inc_indentation/2</CODE>, 
<A NAME="IDX7928"></A>
<CODE>dec_indentation/2</CODE>, 
<A NAME="IDX7929"></A>
<CODE>add_indentation/3</CODE>, 
<A NAME="IDX7930"></A>
<CODE>reduce_indentation/3</CODE>, 
<A NAME="IDX7931"></A>
<CODE>push_whitespace/3</CODE>, 
<A NAME="IDX7932"></A>
<CODE>push_dictionaries/3</CODE>, 
<A NAME="IDX7933"></A>
<CODE>get_parsed/2</CODE>, 
<A NAME="IDX7934"></A>
<CODE>get_environment/2</CODE>, 
<A NAME="IDX7935"></A>
<CODE>inside_proto/1</CODE>, 
<A NAME="IDX7936"></A>
<CODE>get_dictionaries/2</CODE>, 
<A NAME="IDX7937"></A>
<CODE>strip_from_list/2</CODE>, 
<A NAME="IDX7938"></A>
<CODE>strip_from_term/2</CODE>, 
<A NAME="IDX7939"></A>
<CODE>strip_clean/2</CODE>, 
<A NAME="IDX7940"></A>
<CODE>strip_exposed/2</CODE>, 
<A NAME="IDX7941"></A>
<CODE>strip_restricted/2</CODE>, 
<A NAME="IDX7942"></A>
<CODE>strip_interface/2</CODE>, 
<A NAME="IDX7943"></A>
<CODE>set_parsed/3</CODE>, 
<A NAME="IDX7944"></A>
<CODE>set_environment/3</CODE>, 
<A NAME="IDX7945"></A>
<CODE>insert_parsed/3</CODE>, 
<A NAME="IDX7946"></A>
<CODE>reverse_parsed/2</CODE>, 
<A NAME="IDX7947"></A>
<CODE>stop_parse/2</CODE>, 
<A NAME="IDX7948"></A>
<CODE>look_first_parsed/2</CODE>, 
<A NAME="IDX7949"></A>
<CODE>get_first_parsed/3</CODE>, 
<A NAME="IDX7950"></A>
<CODE>remove_code/3</CODE>, 
<A NAME="IDX7951"></A>
<CODE>look_ahead/3</CODE>.

</UL>

<LI><STRONG>Other modules used:</STRONG>


<UL>

<LI><EM>System library modules:</EM>

<A NAME="IDX7952"></A>
<CODE>aggregates</CODE>, 
<A NAME="IDX7953"></A>
<CODE>dynamic</CODE>, 
<A NAME="IDX7954"></A>
<CODE>iso_misc</CODE>, 
<A NAME="IDX7955"></A>
<CODE>iso_byte_char</CODE>, 
<A NAME="IDX7956"></A>
<CODE>iso_incomplete</CODE>, 
<A NAME="IDX7957"></A>
<CODE>operators</CODE>, 
<A NAME="IDX7958"></A>
<CODE>read</CODE>, 
<A NAME="IDX7959"></A>
<CODE>write</CODE>, 
<A NAME="IDX7960"></A>
<CODE>lists</CODE>, 
<A NAME="IDX7961"></A>
<CODE>provrml/dictionary_tree</CODE>, 
<A NAME="IDX7962"></A>
<CODE>provrml/internal_types</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC767" HREF="ciao_toc.html#TOC767">Documentation on exports (<CODE>parser_util</CODE>)</A></H2>
<P>
<A NAME="IDX7963"></A>
<A NAME="IDX7964"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>at_least_one/4:</B>
<DD><A NAME="IDX7965"></A>


<P>
No further documentation available for this predicate.


</DL>

<P>
<A NAME="IDX7966"></A>
<A NAME="IDX7967"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>at_least_one/5:</B>
<DD><A NAME="IDX7968"></A>


<P>
No further documentation available for this predicate.


</DL>

<P>
<A NAME="IDX7969"></A>
<A NAME="IDX7970"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>fillout/4:</B>
<DD><A NAME="IDX7971"></A>


<P>
No further documentation available for this predicate.


</DL>

<P>
<A NAME="IDX7972"></A>
<A NAME="IDX7973"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>fillout/5:</B>
<DD><A NAME="IDX7974"></A>


<P>
No further documentation available for this predicate.


</DL>

<P>
<A NAME="IDX7975"></A>
<A NAME="IDX7976"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>create_node/3:</B>
<DD><A NAME="IDX7977"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>create_node(+NodeTypeId,+Parse,-Node)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will construct a node term with the read guts which is inside the parse structure. A node consists of its name and one argument, a list of its fields.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+NodeTypeId</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>-Node</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX7978"></A>
<A NAME="IDX7979"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>create_field/3:</B>
<DD><A NAME="IDX7980"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>create_field(+FieldNameId,+Arguments,-Field)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will construct a field with the Id as the fieldname and the arguments as they are, in a double list, which results in a single list or a single list which will result in free arguments.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+FieldNameId</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+Arguments</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>-Field</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX7981"></A>
<A NAME="IDX7982"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>create_field/4:</B>
<DD><A NAME="IDX7983"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>create_field(+FieldAccess,+FieldType,+FieldId,-Field)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will construct a field with its access type as the name with type and id as arguments.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+FieldAccess</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+FieldType</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+FieldId</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>-Field</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX7984"></A>
<A NAME="IDX7985"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>create_field/5:</B>
<DD><A NAME="IDX7986"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>create_field(+FieldAccess,+FieldType,+FieldId,+Fieldvalue,-Field)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will construct a field with its access type as the name with type, id and value as arguments.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+FieldAccess</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+FieldType</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+FieldId</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+Fieldvalue</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>-Field</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX7987"></A>
<A NAME="IDX7988"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>create_directed_field/5:</B>
<DD><A NAME="IDX7989"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>create_directed_field(+Access,+Type,+Id0,+Id1,-Field)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will construct a directed field with the key word IS in the middle. Its access type as the name with type, from id0 and to id1 as arguments.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Access</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+Type</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+Id0</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+Id1</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>-Field</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX7990"></A>
<A NAME="IDX7991"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>correct_commenting/4:</B>
<DD><A NAME="IDX7992"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>correct_commenting(+Place,+Comment,+ParsedIn,-ParsedOut)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate places the comment 'before' or 'after' the parsed term. This results in a list with the term and the comment or in just returning the term.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Place</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>undefined:str(+Comment)</CODE>
 (undefined property)

<CODE>+ParsedIn</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>-ParsedOut</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX7993"></A>
<A NAME="IDX7994"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>create_parse_structure/1:</B>
<DD><A NAME="IDX7995"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>create_parse_structure(-Parse)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will construct the parse structure with its three fields: the parsing list, the environment structure, and the dictionaries.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>-Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX7996"></A>
<A NAME="IDX7997"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>create_parse_structure/2:</B>
<DD><A NAME="IDX7998"></A>


<P>
<STRONG>Usage 1:</STRONG> <CODE>create_parse_structure(+ParseIn,-ParseOut)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will construct a parse structure with its three fields: the parsing list, the environment structure, and the dictionaries. It will reuse the environment and the dictionaries from the input.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+ParseIn</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>-ParseOut</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>create_parse_structure(+ParsedList,-ParseOut)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will construct a parse structure with its three fields: the parsing list, the environment structure, and the dictionaries. It will use the list of parsed items in its structure.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+ParsedList</CODE> is a list of <CODE>term</CODE>s.
 (<CODE>basic_props:list/2</CODE>)

<CODE>-ParseOut</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX7999"></A>
<A NAME="IDX8000"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>create_parse_structure/3:</B>
<DD><A NAME="IDX8001"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>create_parse_structure(+ParsedList,+ParseIn,-ParseOut)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will construct a parse structure with its three fields: the parsing list, the environment structure, and the dictionaries. It will use the list of parsed items in its structure and the environment and the dictionary from the parse structure given.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+ParsedList</CODE> is a list of <CODE>term</CODE>s.
 (<CODE>basic_props:list/2</CODE>)

<CODE>+ParseIn</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>-ParseOut</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX8002"></A>
<A NAME="IDX8003"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>create_environment/4:</B>
<DD><A NAME="IDX8004"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>create_environment(+Parse,+EnvType,+Name,-EnvStruct)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will construct an environment structure based on the information in the parse structure. Well only the white- space information will be reused. The are three types of environments 'PROTO', 'EXTERNPROTO', and 'DEF'.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>+EnvType</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+Name</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>-EnvStruct</CODE> is an environment structure.
 (<CODE>internal_types:environment/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX8005"></A>
<A NAME="IDX8006"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>insert_comments_in_beginning/3:</B>
<DD><A NAME="IDX8007"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>insert_comments_in_beginning(+Comment,+ParseIn,-ParseOut)</CODE>

<UL>
<LI><EM>Description:</EM> We add the comment in the beginneing of the parsed, to get the proper look.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>undefined:str(+Comment)</CODE>
 (undefined property)

<CODE>+ParseIn</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>-ParseOut</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX8008"></A>
<A NAME="IDX8009"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>get_environment_name/2:</B>
<DD><A NAME="IDX8010"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>get_environment_name(+Environment,-Name)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will return the enviroment name.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Environment</CODE> is an environment structure.
 (<CODE>internal_types:environment/1</CODE>)

<CODE>-Name</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX8011"></A>
<A NAME="IDX8012"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>get_environment_type/2:</B>
<DD><A NAME="IDX8013"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>get_environment_type(+Environment,-Type)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will return the enviroment type, one of the three: 'PROTO', 'EXTERNPROTO', and 'DEF'.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Environment</CODE> is an environment structure.
 (<CODE>internal_types:environment/1</CODE>)

<CODE>-Type</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX8014"></A>
<A NAME="IDX8015"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>get_row_number/2:</B>
<DD><A NAME="IDX8016"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>get_row_number(+Parse,-Row)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will return the row number from the parse structure. The row number is not fully implemented.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>-Row</CODE> is a number.
 (<CODE>basic_props:num/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX8017"></A>
<A NAME="IDX8018"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>add_environment_whitespace/3:</B>
<DD><A NAME="IDX8019"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>add_environment_whitespace(+EnvIn,+WhiteSpaceList,-EnvOut)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will add the new whitespace that is collected in a list of whitespaces to the environment.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+EnvIn</CODE> is an environment structure.
 (<CODE>internal_types:environment/1</CODE>)

<CODE>+WhiteSpaceList</CODE> is a list of <CODE>atm</CODE>s.
 (<CODE>basic_props:list/2</CODE>)

<CODE>-EnvOut</CODE> is an environment structure.
 (<CODE>internal_types:environment/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX8020"></A>
<A NAME="IDX8021"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>get_indentation/2:</B>
<DD><A NAME="IDX8022"></A>


<P>
<STRONG>Usage 1:</STRONG> <CODE>get_indentation(+Whitespace,-Indentation)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will return the indentation depth from a whitespace structure.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Whitespace</CODE> is a whitespace structure.
 (<CODE>internal_types:whitespace/1</CODE>)

<CODE>-Indentation</CODE> is a number.
 (<CODE>basic_props:num/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>get_indentation(+Parse,-Indentation)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will return the indentation depth from a parse structure.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>-Indentation</CODE> is a number.
 (<CODE>basic_props:num/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX8023"></A>
<A NAME="IDX8024"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>inc_indentation/2:</B>
<DD><A NAME="IDX8025"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>inc_indentation(+ParseIn,-ParseOut)</CODE>

<UL>
<LI><EM>Description:</EM> Will increase the indentation with one step to a parse structure.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+ParseIn</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>-ParseOut</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX8026"></A>
<A NAME="IDX8027"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>dec_indentation/2:</B>
<DD><A NAME="IDX8028"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>dec_indentation(+ParseIn,-ParseOut)</CODE>

<UL>
<LI><EM>Description:</EM> Will decrease the indentation with one step to a parse structure.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+ParseIn</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>-ParseOut</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX8029"></A>
<A NAME="IDX8030"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>add_indentation/3:</B>
<DD><A NAME="IDX8031"></A>


<P>
No further documentation available for this predicate.


</DL>

<P>
<A NAME="IDX8032"></A>
<A NAME="IDX8033"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>reduce_indentation/3:</B>
<DD><A NAME="IDX8034"></A>


<P>
No further documentation available for this predicate.


</DL>

<P>
<A NAME="IDX8035"></A>
<A NAME="IDX8036"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>push_whitespace/3:</B>
<DD><A NAME="IDX8037"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>push_whitespace(+ParseWithWhitespace,+ParseIn,-ParseOut)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will add the whitespace values from one parse structure to another one, resultin in the output, with the values from the second parse structure with the whitespace from the first added.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+ParseWithWhitespace</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>+ParseIn</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>-ParseOut</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX8038"></A>
<A NAME="IDX8039"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>push_dictionaries/3:</B>
<DD><A NAME="IDX8040"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>push_dictionaries(+Parse,+Parse,-Parse)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will set the first parse structure's directory to the second parsing structure argument. The resulting parsing structure will be returned.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>+Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>-Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX8041"></A>
<A NAME="IDX8042"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>get_parsed/2:</B>
<DD><A NAME="IDX8043"></A>


<P>
<STRONG>Usage 1:</STRONG> <CODE>get_parsed(+ParseStructure,-ListOfParsed)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will return a list of the parsed terms that is inside the parse structure.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+ParseStructure</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>-ListOfParsed</CODE> is a list of <CODE>term</CODE>s.
 (<CODE>basic_props:list/2</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>get_parsed(+ParseStructure,-EnvironmentStructure)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will return the environment of the parse structure.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+ParseStructure</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>-EnvironmentStructure</CODE> is an environment structure.
 (<CODE>internal_types:environment/1</CODE>)
</UL>

<P>
<STRONG>Usage 3:</STRONG> <CODE>get_parsed(+ParseStructure,-Dictionaries)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will return dictionary used within the parse structure.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+ParseStructure</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>-Dictionaries</CODE> is a dictionary.
 (<CODE>internal_types:dictionary/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX8044"></A>
<A NAME="IDX8045"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>get_environment/2:</B>
<DD><A NAME="IDX8046"></A>


<P>
No further documentation available for this predicate.


</DL>

<P>
<A NAME="IDX8047"></A>
<A NAME="IDX8048"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>inside_proto/1:</B>
<DD><A NAME="IDX8049"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>inside_proto(+Parse)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will answer to the question: are we parsing inside a PROTO/EXTERNPROTO.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX8050"></A>
<A NAME="IDX8051"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>get_dictionaries/2:</B>
<DD><A NAME="IDX8052"></A>


<P>
No further documentation available for this predicate.


</DL>

<P>
<A NAME="IDX8053"></A>
<A NAME="IDX8054"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>strip_from_list/2:</B>
<DD><A NAME="IDX8055"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>strip_from_list(+ListWithComments,-CleanList)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will strip the list from comments and return a list without any comments.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+ListWithComments</CODE> is a list of <CODE>term</CODE>s.
 (<CODE>basic_props:list/2</CODE>)

<CODE>-CleanList</CODE> is a list of <CODE>term</CODE>s.
 (<CODE>basic_props:list/2</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX8056"></A>
<A NAME="IDX8057"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>strip_from_term/2:</B>
<DD><A NAME="IDX8058"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>strip_from_term(+Term,-Stripped)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will remove comments from a term, it will reduce its arguments if there are comments as arguments.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Term</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>-Stripped</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX8059"></A>
<A NAME="IDX8060"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>strip_clean/2:</B>
<DD><A NAME="IDX8061"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>strip_clean(+ParsedIn,-ParsedOut)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will return a striped list or a single atom if there was no comments and no more items in the list. It will also return a atom if there is comments and only one other element.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+ParsedIn</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>-ParsedOut</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX8062"></A>
<A NAME="IDX8063"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>strip_exposed/2:</B>
<DD><A NAME="IDX8064"></A>


<P>
No further documentation available for this predicate.


</DL>

<P>
<A NAME="IDX8065"></A>
<A NAME="IDX8066"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>strip_restricted/2:</B>
<DD><A NAME="IDX8067"></A>


<P>
No further documentation available for this predicate.


</DL>

<P>
<A NAME="IDX8068"></A>
<A NAME="IDX8069"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>strip_interface/2:</B>
<DD><A NAME="IDX8070"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>strip_interface(+Interface,-StrippedInterface)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will remove comments from the interface that we read for the PROTOtype. This will help us when setting the properties.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Interface</CODE> is a list of <CODE>term</CODE>s.
 (<CODE>basic_props:list/2</CODE>)

<CODE>-StrippedInterface</CODE> is a list of <CODE>term</CODE>s.
 (<CODE>basic_props:list/2</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX8071"></A>
<A NAME="IDX8072"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>set_parsed/3:</B>
<DD><A NAME="IDX8073"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>set_parsed(+ParseIn,+NewParseList,-ParseOut)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will create a new parse structure from the first parse structure with the parse list from the second argument.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+ParseIn</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>+NewParseList</CODE> is a list of <CODE>term</CODE>s.
 (<CODE>basic_props:list/2</CODE>)

<CODE>-ParseOut</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX8074"></A>
<A NAME="IDX8075"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>set_environment/3:</B>
<DD><A NAME="IDX8076"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>set_environment(+Environment,+ParseIn,-ParseOut)</CODE>

<UL>
<LI><EM>Description:</EM> The modificator will return a parse structure with the environment given with the other properties from the first parse structure.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Environment</CODE> is an environment structure.
 (<CODE>internal_types:environment/1</CODE>)

<CODE>+ParseIn</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>-ParseOut</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX8077"></A>
<A NAME="IDX8078"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>insert_parsed/3:</B>
<DD><A NAME="IDX8079"></A>


<P>
No further documentation available for this predicate.


</DL>

<P>
<A NAME="IDX8080"></A>
<A NAME="IDX8081"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>reverse_parsed/2:</B>
<DD><A NAME="IDX8082"></A>


<P>
No further documentation available for this predicate.


</DL>

<P>
<A NAME="IDX8083"></A>
<A NAME="IDX8084"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>stop_parse/2:</B>
<DD><A NAME="IDX8085"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>stop_parse(+TermIn,-TermOut)</CODE>

<UL>
<LI><EM>Description:</EM> The predicate will bind the invalue to the outvalue, used to terminate a parsing.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+TermIn</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)

<CODE>-TermOut</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX8086"></A>
<A NAME="IDX8087"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>look_first_parsed/2:</B>
<DD><A NAME="IDX8088"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>look_first_parsed(+Parse,-First)</CODE>

<UL>
<LI><EM>Description:</EM> Look at the first item in the parse structure.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Parse</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>-First</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX8089"></A>
<A NAME="IDX8090"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>get_first_parsed/3:</B>
<DD><A NAME="IDX8091"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>get_first_parsed(+ParseIn,-ParseOut,-First)</CODE>

<UL>
<LI><EM>Description:</EM> Get the first item in the parse structure and return the parse structure with the item removed.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+ParseIn</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>-ParseOut</CODE> is a parse structure.
 (<CODE>internal_types:parse/1</CODE>)

<CODE>-First</CODE> is any term.
 (<CODE>basic_props:term/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX8092"></A>
<A NAME="IDX8093"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>remove_code/3:</B>
<DD><A NAME="IDX8094"></A>


<P>
No further documentation available for this predicate.


</DL>

<P>
<A NAME="IDX8095"></A>
<A NAME="IDX8096"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>look_ahead/3:</B>
<DD><A NAME="IDX8097"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>look_ahead(+Name,+Parsed,-Parsed)</CODE>

<UL>
<LI><EM>Description:</EM> This predicate is used normally by the CDG and the two last arguments will therefore be the same because we don't remove the parsed. The name is the name inside a term, the first argument.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Name</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>+Parsed</CODE> is a list of <CODE>term</CODE>s.
 (<CODE>basic_props:list/2</CODE>)

<CODE>-Parsed</CODE> is a list of <CODE>term</CODE>s.
 (<CODE>basic_props:list/2</CODE>)
</UL>

</DL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_202.html">previous</A>, <A HREF="ciao_204.html">next</A>, <A HREF="ciao_218.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
