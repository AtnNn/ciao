<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 10 November 2000 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - Active modules (high-level distributed execution)</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_94.html">previous</A>, <A HREF="ciao_96.html">next</A>, <A HREF="ciao_175.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC380" HREF="ciao_toc.html#TOC380">Active modules (high-level distributed execution)</A></H1>
<P>
<A NAME="IDX4196"></A>


<P>
<STRONG>Author(s):</STRONG> Manuel Hermenegildo, Daniel Cabeza.


<P>
<STRONG>Version:</STRONG> 1.5#171 (2000/7/7, 16:10:17 CEST)


<P>
<STRONG>Version of last change:</STRONG> 1.5#141 (2000/5/11, 13:33:29 CEST)


<P>
 


<P>
Active modules [CH95] provide a high-level model of 
<A NAME="IDX4197"></A>
inter-process communication and 
<A NAME="IDX4198"></A>
distributed execution (note that using Ciao's communication and concurrency primitives, such as sockets, concurrent predicates, etc.). An 
<A NAME="IDX4199"></A>
<A NAME="IDX4200"></A>
<EM>active module</EM> (or an 
<A NAME="IDX4201"></A>
<A NAME="IDX4202"></A>
<EM>active object</EM>) is an ordinary module to which computational resources are attached, and which resides at a given location on the network. Compiling an active module produces an executable which, when running, acts as a server for a number of predicates, the predicates exported by the module. Predicates exported by an active module can be accessed by a program on the network by simply "using" the module, which then imports such "remote predicates." The process of loading an active module does not involve transferring any code, but rather setting up things so that calls in the module using the active module are executed as remote procedure calls to the active module. This occurs in the same way independently of whether the active module and the using module are in the same machine or in different machines across the network. 


<P>
Except for having compiling it in a special way (see below), an active module is identical from the programmer point of view to an ordinary module. A program using an active module imports it and uses it in the same way as any other module, except that it uses "
<A NAME="IDX4203"></A>
<CODE>use_active_module</CODE>" rather than "
<A NAME="IDX4204"></A>
<CODE>use_module</CODE>" (see below). Also, an active module has an address (network address) which must be known in order to use it. In order to use an active module it is necessary to know its address. 
 
<A NAME="DOCF3" HREF="ciao_foot.html#FOOT3">(3)</A> 


<P>
From the implementation point of view, active modules are essentially daemons: executables which are started as independent processes at the operating system level. Communication with active modules is implemented using sockets (thus, the address of an active module is an IP socket address in a particular machine). Requests to execute goals in the module are sent through the socket by remote programs. When such a request arrives, the process running the active module takes it and executes it, returning through the socket the computed answers. These results are then taken and used by the remote processes. Backtracking over such remote calls works as usual and transparently. The only limitation (this may change in the future, but it is currently done for efficiency reasons) is that all alternative answers are precomputed (and cached) upon the first call to an active module and thus <EM>an active module should not export a predicate which has an infinite number of answers</EM>. 
 


<P>
The first thing to do is to select a method whereby the client(s) (the module(s) that will use the active module) can find out in which machine/port (IP address/socket number) the server (i.e., the active module) will be listening once started. The easiest way to do this is to use of the redezvous methods which are provided in the Ciao distribution in the <CODE>library/actmods</CODE> directory, such as <CODE>tmpbased...</CODE> or <CODE>filebased...</CODE>. 


<P>
The first is based on saving the IP address and socket number of the server in a file in a predefined directory (generally <CODE>/tmp</CODE>, but this can be changed by changing <CODE>tmpbased_common.pl</CODE>). 


<P>
The second one is similar but saves the info in the directory in which the server is started (as <EM>&#60;module_name&#62;</EM><CODE>.addr</CODE>). The clients must be started in the same directory. However, they can be started in different machines, provided this directory is shared (e.g., by NFS or Samba). 


<P>
These rendezvous methods are encoded in two modules: a first one, called <CODE>...publish.pl</CODE>, is used by the server to publish its info. The second one, called <CODE>...locate.pl</CODE>, is used by the client(s) to locate the server info. For efficiency, the client methods maintain a cache of addresses, so that the server information only needs to be read from the file system the first time the active module is accessed. 


<P>
Active modules are compiled using the <CODE>-a</CODE> option of the Ciao compiler (this can also be done from the interactive top-level shell using 
<A NAME="IDX4205"></A>
<CODE>make_actmod/2</CODE>). For example, issuing the following command: 



<PRE>
  ciaoc -a 'actmods/filebased_publish' simple_server
</PRE>

<P>
compiles the simple server example that comes with the distribution (in the <CODE>actmods/example</CODE> directory). The <CODE>simple_client_with_main</CODE> example (in the same directory) can be compiled as usual: 



<PRE>
  ciaoc simple_client_with_main
</PRE>

<P>
Now, if the server is running (e.g., <CODE>simple_server &#38;</CODE> in Un*x or double-clicking on it in Win32) when the client is executed it will connect with the server to access the predicate(s) that it imports from it. 


<P>
A simpler even client 
<A NAME="IDX4206"></A>
<CODE>simple_client.pl</CODE> can be loaded into the top level and its predicates called as usual (and they will connect with the server if it is running). 


<P>
The architecture of the active modules model in Ciao allows defining other methods for this communication to happen. For example, one can implement a 
<A NAME="IDX4207"></A>
name server. This can itself be an active module which resides at a fixed and known machine and port number (this is known as a <EM>service</EM> and is defined in <CODE>/etc/services</CODE> in a Un*x machine). In order the best way is to mimick the code of the redezvous methods provided in the Ciao distribution. 
 
Security: in the access method (?). 



<UL>
<LI><A HREF="ciao_95.html#SEC381">Usage and interface (actmods)</A>
<LI><A HREF="ciao_95.html#SEC382">Documentation on new declarations (actmods)</A>
</UL>



<H2><A NAME="SEC381" HREF="ciao_toc.html#TOC381">Usage and interface (<CODE>actmods</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

<CODE>:- use_package(actmods).</CODE>

or

<CODE>:- module(...,...,[actmods]).</CODE>

<LI><STRONG>New declarations defined:</STRONG>

<A NAME="IDX4208"></A>
<CODE>use_active_module/2</CODE>.

</UL>

</div class="cartouche">



<H2><A NAME="SEC382" HREF="ciao_toc.html#TOC382">Documentation on new declarations (<CODE>actmods</CODE>)</A></H2>
<P>
<A NAME="IDX4209"></A>
<A NAME="IDX4210"></A>
<DL>
<DT><span class="define">DECLARATION:</span> <B>use_active_module/2:</B>
<DD><A NAME="IDX4211"></A>


<P>
<STRONG>Usage:</STRONG> :- <CODE>use_active_module(AModule,Predicates)</CODE>.

<UL>
<LI><EM>Description:</EM> Specifies that this code imports from the <EM>active module</EM> defined in <CODE>AModule</CODE> the predicates in <CODE>Imports</CODE>. The imported predicates must be exported by the active module.

<LI><EM>The following properties should hold at call time:</EM>

<CODE>AModule</CODE> is a source name.
 (<CODE>streams_basic:sourcename/1</CODE>)

<CODE>Predicates</CODE> is a list of <CODE>predname</CODE>s.
 (<CODE>basic_props:list/2</CODE>)
</UL>

</DL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_94.html">previous</A>, <A HREF="ciao_96.html">next</A>, <A HREF="ciao_175.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
