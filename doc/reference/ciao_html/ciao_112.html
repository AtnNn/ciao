<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 5 May 2000 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - Persistent predicate database</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_111.html">previous</A>, <A HREF="ciao_113.html">next</A>, <A HREF="ciao_158.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC436" HREF="ciao_toc.html#TOC436">Persistent predicate database</A></H1>
<P>
<A NAME="IDX4765"></A>


<P>
<STRONG>Author(s):</STRONG> J.M. Gomez, D. Cabeza, and M. Hermenegildo, <CODE>clip@dia.fi.upm.es</CODE>, <CODE>http://www.clip.dia.fi.upm.es/</CODE>, The CLIP Group, Facultad de Inform&aacute;tica, Universidad Polit&eacute;cnica de Madrid.


<P>
<STRONG>Version:</STRONG> 1.5#118 (2000/4/19, 18:13:43 CEST)


<P>
<STRONG>Version of last change:</STRONG> 0.8#31 (1998/12/27, 19:17:20 MET)


<P>
 



<UL>
<LI><A HREF="ciao_112.html#SEC437">Introduction to persistent predicates</A>
<LI><A HREF="ciao_112.html#SEC438">Persistent predicates</A>
<LI><A HREF="ciao_112.html#SEC439">Using file-based persistent predicates</A>
<LI><A HREF="ciao_112.html#SEC440">Implementation Issues</A>
<LI><A HREF="ciao_112.html#SEC441">Using persistent predicates from the top level</A>
<LI><A HREF="ciao_112.html#SEC442">Usage and interface (persdbrt)</A>
<LI><A HREF="ciao_112.html#SEC443">Documentation on exports (persdbrt)</A>
<LI><A HREF="ciao_112.html#SEC444">Documentation on multifiles (persdbrt)</A>
<LI><A HREF="ciao_112.html#SEC445">Documentation on internals (persdbrt)</A>
<LI><A HREF="ciao_112.html#SEC446">Known bugs and planned improvements (persdbrt)</A>
</UL>



<H2><A NAME="SEC437" HREF="ciao_toc.html#TOC437">Introduction to persistent predicates</A></H2>

<P>
This library implements a <EM>generic persistent predicate database</EM>. The basic notion implemented by the library is that of a 
<A NAME="IDX4766"></A>
persistent predicate. The persistent predicate concept provides a simple, yet powerful generic persistent data access method [CHGT98,Par97]. A persistent predicate is a special kind of dynamic, data predicate that "resides" in some persistent medium (such as a set of files, a database, etc.) that is typically external to the program using such predicates. The main effect is that any changes made to to a persistent predicate from a program "survive" across executions. I.e., if the program is halted and restarted the predicate that the new process sees is in precisely the same state as it was when the old process was halted (provided no change was made in the meantime to the storage by other processes or the user). 


<P>
Persistent predicates appear to a program as ordinary predicates, and calls to these predicates can appear in clause bodies in the usual way. However, the definitions of these predicates do not appear in the program. Instead, the library maintains automatically the definitions of predicates which have been declared as persistent in the persistent storage. 


<P>
<A NAME="IDX4767"></A>
Updates to persistent predicates can be made by calling predicates similar to 
<A NAME="IDX4768"></A>
<CODE>assertz_fact/1</CODE> and 
<A NAME="IDX4769"></A>
<CODE>retract_fact/1</CODE>. The library makes sure that each update is a 
<A NAME="IDX4770"></A>
transactional update, in the sense that if the update terminates, then the permanent storage has definitely been modified. For example, if the program making the updates is halted just after the update and then restarted, then the updated state of the predicate will be seen. This provides security against possible data loss due to, for example, a system crash. Also, due to the atomicity of the transactions, persistent predicates allow 
<A NAME="IDX4771"></A>
concurrent updates from several programs. 




<H2><A NAME="SEC438" HREF="ciao_toc.html#TOC438">Persistent predicates, files, and relational databases</A></H2>

<P>
The concept of persistent predicates provided by this library essentially implements a light-weight, simple, and at the same time powerful form of relational database (a 
<A NAME="IDX4772"></A>
deductive database), and which is standalone, in the sense that it does not require external support, other than the file management capabilities provided by the operating system. This is due to the fact that the persistent predicates are in fact stored in one or more auxiliary files in a given directory. 


<P>
This type of database is specially useful when building small to medium-sized standalone applications in Prolog which require persistent storage. In many cases it provides a much easier way of implementing such storage than using files under direct program control. For example, interactive applications can use persistent predicates to represent their internal state in a way that is close to the application. The persistence of such predicates then allows automatically restoring the state to that at the end of a previous session. Using persistent predicates amounts to simply declaring some predicates as such and eliminates having to worry about opening files, closing them, recovering from system crashes, etc. 


<P>
In other cases, however, it may be convenient to use a relational database as persistent storage. This may be the case, for example, when the data already resides in such a database (where it is perhaps accessed also by other applications) or the volume of data is very large. 
<A NAME="IDX4773"></A>
<CODE>persdb_sql</CODE> [CCG98] is a companion library which implements the same notion of persistent predicates used herein, but keeping the storage in a relational database. This provides a very natural and transparent way to access SQL database relations from a Prolog program. In that library, facilities are also provided for reflecting more complex <EM>views</EM> of the database relations as predicates. Such views can be constructed as conjunctions, disjunctions, projections, etc. of database relations, and may include SQL-like aggregation operations. 


<P>
A nice characteristic of the notion of persistent predicates used in both of these libraries is that it abstracts away how the predicate is actually stored. Thus, a program can use persistent predicates stored in files or in external relational databases interchangeably, and the type of storage used for a given predicate can be changed without having to modify the program (except for replacing the corresponding 
<A NAME="IDX4774"></A>
<CODE>persistent/2</CODE> declarations). 


<P>
An example application of the 
<A NAME="IDX4775"></A>
<CODE>persdb</CODE> and 
<A NAME="IDX4776"></A>
<CODE>persdb_sql</CODE> libraries (and also the 
<A NAME="IDX4777"></A>
<CODE>pillow</CODE> library [CH97]), is 
<A NAME="IDX4778"></A>
<CODE>WebDB</CODE> [GCH98]. 
<A NAME="IDX4779"></A>
<CODE>WebDB</CODE> is a generic, highly customizable <EM>deductive database engine</EM> with an <EM>html interface</EM>. 
<A NAME="IDX4780"></A>
<CODE>WebDB</CODE> allows creating and maintaining Prolog-based databases as well as relational databases (residing in conventional relational database engines) using any standard WWW browser. 




<H2><A NAME="SEC439" HREF="ciao_toc.html#TOC439">Using file-based persistent predicates</A></H2>

<P>
Persistent predicates can be declared statically, using 
<A NAME="IDX4781"></A>
<CODE>persistent/2</CODE> declarations (which is the preferred method, when possible), or dynamically via calls to 
<A NAME="IDX4782"></A>
<CODE>make_persistent/2</CODE>. Currently, persistent predicates may only contain facts, i.e., they are <EM>dynamic</EM> predicates of type 
<A NAME="IDX4783"></A>
<CODE>data/1</CODE>, and <EM>should be declared as such</EM>. 


<P>
Predicates declared as persistent are linked to a directory, and the persistent state of the predicate will be kept in several files in that directory. The files in which the persistent predicates are stored are in readable, plain ASCII format, and in Prolog syntax. One advantage of this approach is that such files can also be created or edited by hand, in a text editor, or even by other applications. 


<P>
An example definition of a persistent predicate implemented by files follows: 



<PRE>
:- persistent(p/3,dbdir).

:- multifile persistent_dir/2.
:- data persistent_dir/2.

persistent_dir(dbdir, '/home/clip/public_html/db').
</PRE>

<P>
The first line declares the predicate <CODE>p/3</CODE> persistent. The argument <CODE>dbdir</CODE> is a key used to index into a fact of the relation 
<A NAME="IDX4784"></A>
<CODE>persistent_dir/2</CODE>, which specifies the directory where the corresponding files will be kept. The effect of the declaration, together with the 
<A NAME="IDX4785"></A>
<CODE>persistent_dir/2</CODE> fact, is that, although the predicate is handled in the same way as a normal data predicate, in addition the system will create and maintain efficiently a persistent version of <CODE>p/3</CODE> via files in the directory <CODE>/home/clip/public_html/db</CODE>. 


<P>
The level of indirection provided by the <CODE>dbdir</CODE> argument makes it easy to place the storage of several persistent predicates in a common directory, by specifying the same key for all of them. It also allows changing the directory for several such persistent predicates by modifying only one fact in the program. Furthermore, the 
<A NAME="IDX4786"></A>
<CODE>persistent_dir/2</CODE> predicate can even be dynamic and specified at run-time. 




<H2><A NAME="SEC440" HREF="ciao_toc.html#TOC440">Implementation Issues</A></H2>

<P>
We outline the current implementation approach. This implementation attempts to provide at the same time efficiency and security. To this end, up to three files are used for each predicate (the 
<A NAME="IDX4787"></A>
persistence set): the 
<A NAME="IDX4788"></A>
data file, the 
<A NAME="IDX4789"></A>
operations file, and the 
<A NAME="IDX4790"></A>
backup file. In the 
<A NAME="IDX4791"></A>
updated state the facts (tuples) that define the predicate are stored in the data file and the operations file is empty (the backup file, which contains a security copy of the data file, may or may not exist). 


<P>
While a program using a persistent predicate is running, any insertion (assert) or deletion (retract) operations on the predicate are performed on both the program memory and on the persistence set. However, in order to incurr only a small overhead in the execution, rather than changing the data file directly, a record of each of the insertion and deletion operations is <EM>appended</EM> to the operations file. The predicate is then in a 
<A NAME="IDX4792"></A>
transient state, in that the contents of the data file do not reflect exactly the current state of the corresponding predicate. However, the complete persistence set does. 


<P>
When a program starts, when it is halted, or, periodically, when it is idle for some time, all pending operations in the operations file are performed on the data file. A backup of the data file is created first to prevent data loss if the system crashes during this operation. The order in which this updating of files is done ensures that, if at any point the process dies, on restart data will be completely recovered. This process of updating the persistence set can also be triggered at any point in the execution of a program by calling 
<A NAME="IDX4793"></A>
<CODE>update_files/2</CODE>. 




<H2><A NAME="SEC441" HREF="ciao_toc.html#TOC441">Using persistent predicates from the top level</A></H2>

<P>
Special care must be taken when using persistent predicates from the top level. This includes not only defining persistent predicates on the fly from de top level (which is not really very useful in practice) but also the more frequent case of loading into the top level modules or user files which use persistent predicates. As mentioned before, the persistence set is updated automatically each time a program using the corresponding persistent predicates is run or halted. However, since the top level itself is also a standard program, persistent predicates would only be updated whenever the top level is started, when they are typically still not loaded. 


<P>
If a program launched from a top level needs to update the persistence sets of any persistent predicate it must be done by calling the 
<A NAME="IDX4794"></A>
<CODE>update_files/2</CODE> method explicitly. 




<H2><A NAME="SEC442" HREF="ciao_toc.html#TOC442">Usage and interface (<CODE>persdbrt</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

Typically, this library is used including the 'persdb' package into the syntax list of the module, or using the 
<A NAME="IDX4795"></A>
<CODE>syntax/1</CODE> declaration: 
<DL COMPACT>

<DT>In a module:
<DD>

<PRE>
        :- module(bar, [main/1], [persdb]).
</PRE>

or 

<PRE>
        :- module(bar, [main/1]).
        :- include(library(persdb)).
</PRE>

<DT>In a <EM>user</EM> file:
<DD>

<PRE>
        :- syntax([persdb]).
</PRE>

or 

<PRE>
        :- include(library(persdb)).
</PRE>

</DL>
This syntax file loads the run-time and compile-time versions of the library (<CODE>persdbtr.pl</CODE> and <CODE>persdbrt.pl</CODE>) and includes some needed declarations.

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX4796"></A>
<CODE>passertz_fact/1</CODE>, 
<A NAME="IDX4797"></A>
<CODE>pretract_fact/1</CODE>, 
<A NAME="IDX4798"></A>
<CODE>pcurrent_fact/1</CODE>, 
<A NAME="IDX4799"></A>
<CODE>init_persdb/0</CODE>, 
<A NAME="IDX4800"></A>
<CODE>initialize_db/0</CODE>, 
<A NAME="IDX4801"></A>
<CODE>make_persistent/2</CODE>, 
<A NAME="IDX4802"></A>
<CODE>update_files/2</CODE>.

<LI><EM>Multifiles:</EM>

<A NAME="IDX4803"></A>
<CODE>persistent_dir/2</CODE>, 
<A NAME="IDX4804"></A>
<CODE>$is_persistent/2</CODE>.

</UL>

<LI><STRONG>Other modules used:</STRONG>


<UL>

<LI><EM>System library modules:</EM>

<A NAME="IDX4805"></A>
<CODE>lists</CODE>, 
<A NAME="IDX4806"></A>
<CODE>streams</CODE>, 
<A NAME="IDX4807"></A>
<CODE>read</CODE>, 
<A NAME="IDX4808"></A>
<CODE>system</CODE>, 
<A NAME="IDX4809"></A>
<CODE>file_locks/file_locks</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC443" HREF="ciao_toc.html#TOC443">Documentation on exports (<CODE>persdbrt</CODE>)</A></H2>
<P>
<A NAME="IDX4810"></A>
<A NAME="IDX4811"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>passertz_fact/1:</B>
<DD><A NAME="IDX4812"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>passertz_fact(fact)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>passertz_fact(Fact)</CODE>

<UL>
<LI><EM>Description:</EM> Persistent version of

<A NAME="IDX4813"></A>
<CODE>assertz_fact/1</CODE>: the current instance of <CODE>Fact</CODE> is interpreted as a fact (i.e., a relation tuple) and is added at the end of the definition of the corresponding predicate. The predicate concerned must be declared 
<A NAME="IDX4814"></A>
<CODE>persistent</CODE>. Any uninstantiated variables in the <CODE>Fact</CODE> will be replaced by new, private variables. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Fact</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4815"></A>
<A NAME="IDX4816"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>pretract_fact/1:</B>
<DD><A NAME="IDX4817"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>pretract_fact(fact)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>pretract_fact(Fact)</CODE>

<UL>
<LI><EM>Description:</EM> Persistent version of

<A NAME="IDX4818"></A>
<CODE>retract_fact/1</CODE>: deletes on backtracking all the facts which unify with <CODE>Fact</CODE>. The predicate concerned must be declared 
<A NAME="IDX4819"></A>
<CODE>persistent</CODE>. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Fact</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4820"></A>
<A NAME="IDX4821"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>pcurrent_fact/1:</B>
<DD><A NAME="IDX4822"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>pcurrent_fact(fact)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>pcurrent_fact(Fact)</CODE>

<UL>
<LI><EM>Description:</EM> Persistent version of

<A NAME="IDX4823"></A>
<CODE>current_fact/1</CODE>: the fact <CODE>Fact</CODE> exists in the current database. The predicate concerned must be declared 
<A NAME="IDX4824"></A>
<CODE>persistent</CODE>. Provides on backtracking all the facts (tuples) which unify with <CODE>Fact</CODE>. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>Fact</CODE> is a term which represents a goal, i.e., an atom or a structure.
 (<CODE>basic_props:callable/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4825"></A>
<A NAME="IDX4826"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>init_persdb/0:</B>
<DD><A NAME="IDX4827"></A>


<P>
<STRONG>Usage:</STRONG> 

<UL>
<LI><EM>Description:</EM> Executes

<A NAME="IDX4828"></A>
<CODE>initialize_db/0</CODE> if no initialization has been done yet. Needed when accesing persistent predicates before doing any of 
<A NAME="IDX4829"></A>
<CODE>passertz_fact/1</CODE>, 
<A NAME="IDX4830"></A>
<CODE>pretract_fact/1</CODE>, or 
<A NAME="IDX4831"></A>
<CODE>pcurrent_fact/1</CODE>. 
</UL>

</DL>

<P>
<A NAME="IDX4832"></A>
<A NAME="IDX4833"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>initialize_db/0:</B>
<DD><A NAME="IDX4834"></A>


<P>
<STRONG>Usage:</STRONG> 

<UL>
<LI><EM>Description:</EM>

<A NAME="IDX4835"></A>
<A NAME="IDX4836"></A>
Initializes the whole database, updating the state of the declared persistent predicates. 
</UL>

</DL>

<P>
<A NAME="IDX4837"></A>
<A NAME="IDX4838"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>make_persistent/2:</B>
<DD><A NAME="IDX4839"></A>


<P>
<EM>Meta-predicate</EM> with arguments: <CODE>make_persistent(spec,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>make_persistent(PredDesc,Keyword)</CODE>

<UL>
<LI><EM>Description:</EM> Dynamic version of the

<A NAME="IDX4840"></A>
<CODE>persistent</CODE> declaration. 
<LI><EM>The following properties should hold at call time:</EM>

<CODE>PredDesc</CODE> is a Name/Arity structure denoting a predicate name: 

<PRE>
predname(P/A) :-
        atm(P),
        int(A).
</PRE>

 (<CODE>basic_props:predname/1</CODE>)

<CODE>Keyword</CODE> is an atom corresponding to a directory identifier.
 (<CODE>persdbrt:keyword/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4841"></A>
<A NAME="IDX4842"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>update_files/2:</B>
<DD><A NAME="IDX4843"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>update_files(PredDesc,Arity)</CODE>

<UL>
<LI><EM>Description:</EM> Updates the state of the given persistent predicate and its corresponding persistence set.

<LI><EM>The following properties should hold upon exit:</EM>

<CODE>PredDesc</CODE> is a Name/Arity structure denoting a predicate name: 

<PRE>
predname(P/A) :-
        atm(P),
        int(A).
</PRE>

 (<CODE>basic_props:predname/1</CODE>)

<CODE>Arity</CODE> is an integer.
 (<CODE>basic_props:int/1</CODE>)
</UL>

</DL>



<H2><A NAME="SEC444" HREF="ciao_toc.html#TOC444">Documentation on multifiles (<CODE>persdbrt</CODE>)</A></H2>
<P>
<A NAME="IDX4844"></A>
<A NAME="IDX4845"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>persistent_dir/2:</B>
<DD><A NAME="IDX4846"></A>


<P>
The predicate is <EM>multifile</EM>.


<P>
The predicate is of type <EM>data</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>persistent_dir(Keyword,Location_Path)</CODE>

<UL>
<LI><EM>Description:</EM> Relates identifiers of locations (the <CODE>Keyword</CODE>s) with descriptions of such locations (<CODE>Location_Path</CODE>s). <CODE>Location_Path</CODE> is <STRONG>a directory</STRONG> and it means that the definition for the persistent predicates associated with <CODE>Keyword</CODE> is kept in files in that directory. These files, in the updated state, contain the actual definition of the predicate in Prolog syntax (but with module names resolved).

<LI><EM>The following properties should hold at call time:</EM>

<CODE>Keyword</CODE> is an atom corresponding to a directory identifier.
 (<CODE>persdbrt:keyword/1</CODE>)

<CODE>Location_Path</CODE> is an atom which is the name of a directory.
 (<CODE>persdbrt:directoryname/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4847"></A>
<A NAME="IDX4848"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>$is_persistent/2:</B>
<DD><A NAME="IDX4849"></A>


<P>
No further documentation available for this predicate.


<P>
The predicate is <EM>multifile</EM>.


</DL>



<H2><A NAME="SEC445" HREF="ciao_toc.html#TOC445">Documentation on internals (<CODE>persdbrt</CODE>)</A></H2>
<P>
<A NAME="IDX4850"></A>
<A NAME="IDX4851"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>keyword/1:</B>
<DD><A NAME="IDX4852"></A>


<P>
An atom which identifies a fact of the 
<A NAME="IDX4853"></A>
<CODE>persistent_dir/2</CODE> relation. This fact relates this atom to a directory in which the persistent storage for one or more persistent predicates is kept.


<P>
<STRONG>Usage:</STRONG> <CODE>keyword(X)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>X</CODE> is an atom corresponding to a directory identifier.

</UL>

</DL>

<P>
<A NAME="IDX4854"></A>
<A NAME="IDX4855"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>directoryname/1:</B>
<DD><A NAME="IDX4856"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>directoryname(X)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>X</CODE> is an atom which is the name of a directory.

</UL>

</DL>



<H2><A NAME="SEC446" HREF="ciao_toc.html#TOC446">Known bugs and planned improvements (<CODE>persdbrt</CODE>)</A></H2>


<UL>

<LI>

Shouldn't the declarations for persistent_dir/2 be inside persdb.pl? (would save a lot of writing).

<LI>

make_persistent/2 should really be persistent/2 (since it doesn't really make a predicate persistent but rather declares it as such, i.e., we do not use make_data/1, we use data/1) ?

<LI>

having to use pcurrent_fact is not so nice

<LI>

passert, pretract, etc. should really be overloaded versions of assert, retract etc., i.e., it should be possible to use assertz_fact directly

<LI>

we need also asserta_fact, right? Otherwise isn't it difficult to do many things?
</UL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_111.html">previous</A>, <A HREF="ciao_113.html">next</A>, <A HREF="ciao_158.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
