<HTML>
<HEAD>
<!-- Created by texi2html 1.56k + clip patches and <A href="http://www.clip.dia.fi.upm.es/Software">lpdoc</A> from ciao.texi on 26 January 2000 -->

<LINK rel="stylesheet" href="ciao.css" type="text/css">
<TITLE>The Ciao Prolog System               - SQL persistent database interface</TITLE>
</HEAD>
<BODY> 
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_111.html">previous</A>, <A HREF="ciao_113.html">next</A>, <A HREF="ciao_148.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC399" HREF="ciao_toc.html#TOC399">SQL persistent database interface</A></H1>
<P>
<A NAME="IDX4137"></A>


<P>
<STRONG>Author(s):</STRONG> I. Caballero, D. Cabeza, J.M. G&oacute;mez, and M. Hermenegildo, <CODE>clip@dia.fi.upm.es</CODE>, <CODE>http://www.clip.dia.fi.upm.es/</CODE>, The CLIP Group, Facultad de Inform&aacute;tica, Universidad Polit&eacute;cnica de Madrid.


<P>
<STRONG>Version:</STRONG> 1.5#1 (1999/11/29, 17:12:34 MET)


<P>
<STRONG>Version of last change:</STRONG> 0.9#35 (1999/4/6, 13:52:16 MEST)


<P>
The purpose of this library is to implement an instance of the generic concept of 
<A NAME="IDX4138"></A>
persistent predicates, where external 
<A NAME="IDX4139"></A>
relational databases are used for storage (see the documentation of the 
<A NAME="IDX4140"></A>
<CODE>persdb</CODE> library and [CHGT98,Par97] for details). To this end, this library exports SQL persistent versions of the 
<A NAME="IDX4141"></A>
<CODE>assertz_fact/1</CODE>, 
<A NAME="IDX4142"></A>
<CODE>retract_fact/1</CODE> and 
<A NAME="IDX4143"></A>
<CODE>retractall_fact/1</CODE> builtin predicates. Persistent predicates also allow 
<A NAME="IDX4144"></A>
concurrent updates from several programs, since each update is atomic. 


<P>
The notion of persistence provides a very natural and transparent way to access database relations from a Prolog program. Stub definitions are provided for such predicates which access the database when the predicate is called (using the 
<A NAME="IDX4145"></A>
<CODE>db_client</CODE> library). A 
<A NAME="IDX4146"></A>
Prolog to SQL translator is used to generate the required 
<A NAME="IDX4147"></A>
SQL code dynamically (see library 
<A NAME="IDX4148"></A>
<CODE>pl2sql</CODE>). 


<P>
This library also provides facilities for reflecting more complex 
<A NAME="IDX4149"></A>
views of the database relations as Prolog predicates. Such views can be constructed as conjunctions, disjunctions, projections, etc. of database relations. Also, 
<A NAME="IDX4150"></A>
SQL-like 
<A NAME="IDX4151"></A>
aggregation operations are supported. 



<UL>
<LI><A HREF="ciao_112.html#SEC400">Implementation of the Database Interface</A>
<LI><A HREF="ciao_112.html#SEC401">Example(s)</A>
<LI><A HREF="ciao_112.html#SEC402">Usage and interface (persdbrtsql)</A>
<LI><A HREF="ciao_112.html#SEC403">Documentation on exports (persdbrtsql)</A>
<LI><A HREF="ciao_112.html#SEC404">Documentation on multifiles (persdbrtsql)</A>
<LI><A HREF="ciao_112.html#SEC405">Documentation on internals (persdbrtsql)</A>
<LI><A HREF="ciao_112.html#SEC406">Known bugs and planned improvements (persdbrtsql)</A>
</UL>



<H2><A NAME="SEC400" HREF="ciao_toc.html#TOC400">Implementation of the Database Interface</A></H2>

<P>
The architecture of the low-level implementation of the database interface was defined with two goals in mind: 



<UL>
<LI>to simplify the communication between the Prolog system and the relational database engines as much as possible, and

<LI>to give as much flexibility as possible to the overall system. This includes simultaneous access to several databases, allowing both the databases and clients to reside on the same physical machine or different machines, and allowing the clients to reside in Win95/NT or Unix machines.

</UL>

<P>
 
In order to allow the flexibility mentioned above, a client-sever architecture was chosen. The following figure depicts the overall architecture of the system: 


<P>
<IMG SRC="autofigarchitecture.jpg" ALT="Image:autofigarchitecture.jpg"> 


<P>
At the server side, a "database mediator server" connects on one side to the databases using the ODBC interface (this interface is available for the databases of the RadioWeb project, as well as for the majority of the databases running in the Win95/NT operating systems) and on the other it is connected to the network by TCP/IP using a fixed socket number / service (currently fixed to socket number 2020). 


<P>
The mediator server must run on the Windows (NT/95) operating system, on the machine where the databases are also running. The (Prolog) clients which connect to it can be run locally at the server machine. In addition, remote clients running on different machines can also connect to the mediator server by connecting to its socket number (service). Such clients can run on either Unix or Windows systems. 


<P>
After the connection is established a client can send commands to the mediator server which will pass them to the corresponding database server, and then the data will traverse in the opposite direction. These messages include logging on and off from the database, sending SQL queries, and receiving the responses. 


<P>
The low level implementation of the current library is accomplished by providing several abstraction levels over the socket interface library of the Prolog engine. These layers of abstraction implement the persistent predicate view, build the appropriate commands for the database using a translator of Prolog goals to SQL commands, issue such commands using the mediator send/receive procedures, parse the responses, and present such responses to the Prolog engine via backtracking. 




<H2><A NAME="SEC401" HREF="ciao_toc.html#TOC401">Example(s)</A></H2>


<PRE>
:- include(library('persdb_sql/persdb_sql')).
:- use_module(library(format)).

%% ------------------------------------------------- %%
%% First sample database : 'SA 6.0 Sample' %%
%% ------------------------------------------------- %%

%% Declare product/4 a persistent predicate, storage in 'radiowebdb':
:- sql_persistent(product( int,    int, string, string ),
              product( quantity,   id,      name,   size   ),
              sampledb).
sql_persistent_location(sampledb, %% The 'sampledb' descriptor:
         db('ASA 6.0 Sample','dba', 'sql','r2d5.dia.fi.upm.es':2020)).

main0 :-
%% Prints the contents of the relation 'product/4' by backtracking over it:
         format("Printing table:\n",[]),
         product(Quantity, Id, Name, Size), 
         format("Tuple: ~w \t ~w \t ~w \t ~w \n",
                [Quantity, Id, Name, Size]),
         fail.
main0 :-
         format("Done.\n",[]).

%% Generalizing table printing:
%% Prints the contents of Pred by backtracking over it
print_predicate(Pred):- 
        format("Printing relation:\n",[]),
        Pred, %% predicate call
        Pred=..[_|Args],
        format("\t Tuple: ~w \n",[Args]),
        fail.
print_predicate(_Pred):-
        format("Done.~n",[]).

main1 :- %% similar to main0:
%% Prints the contents of the relation 'product/4' by backtracking over it:
        print_predicate(product(_Quantity,_Id,_Name,_Size)).

main2 :- %% Issues a complex query inside a db_findall:
         dbfindall(sampledb,
                   foo(Quantity, Id, Name, Size, Bar),
                   ( product(Quantity, Id, Name, Size),
                     I^N^S^(Bar is avg(Q,product(Q, I, N, S)))
                   ),
                   Results),
         format("Results = ~w~n",[Results]).
main21 :- %% Using db_call
         dbcall(sampledb,
             (product(Quantity, Id, Name, Size),
              product(Quantity, Id1, _Name1, _Size1),Id1&#62;Id)),
%%       product(Quantity, Id, Name, Size),
%%          product(Quantity, Id1, Name1, Size1),
%%          Id1&#62;Id,
         format("Tuple: ~w \t ~w \t ~w \t ~w \n",
                [Quantity, Id, Name, Size]).

main22 :-  % get the set of tables from a database
        sql_get_tables(sampledb,TablesList),
        display(TablesList).

main23 :- % get table attributes and its types 
        sql_table_types(sampledb, 'Customer', AttList),
        display(AttList).
        
%% ------------------------------------------------- %%
%% Second sample database : 'Literature'             %%
%% ------------------------------------------------- %%

:- sql_persistent(authors(string,string,int),
               authors(firstName,lastName,id), %% 'id' is the primary key
               literature_db).
sql_persistent_location(literature_db,
        db('Literature','dba','sql','r2d5.dia.fi.upm.es':2020)).

main3:- %% Prints the contents of authors
         print_predicate(authors(_FirstName,_LastName,_Id)) .

main4:- %% assert a persistent fact
         dbassertz_fact(authors('Pedro','Calderon de la Barca',17)).

main6:- %% retract a persistent fact
         dbretract_fact(authors('Pedro','Calderon de la Barca',17)).

main9:- %% checking if a persistent fact is a current fact
        dbcurrent_fact(authors(_X,_Y,_Z)).

</PRE>



<H2><A NAME="SEC402" HREF="ciao_toc.html#TOC402">Usage and interface (<CODE>persdbrtsql</CODE>)</A></H2>

<div class="cartouche">

<UL>

<LI><STRONG>Library usage:</STRONG>

Typically, this library is used including the 'persdb_sql' package into the package list of the module, or using the 
<A NAME="IDX4152"></A>
<CODE>use_package/1</CODE> declaration: 
<DL COMPACT>

<DT>In a module:
<DD>

<PRE>
	:- module(bar, [main/1], [persdb_sql]).
</PRE>

or 

<PRE>
        :- module(bar, [main/1]).
        :- include(library(persdb_sql)).
</PRE>

<DT>In a <EM>user</EM> file:
<DD>

<PRE>
	:- use_package([persdb_sql]).
</PRE>

or 

<PRE>
        :- include(library(persdb_sql)).
</PRE>

</DL>
This loads the run-time and compile-time versions of the library (<CODE>persdbtr_sql.pl</CODE> and <CODE>persdbrt_sql.pl</CODE>) and includes some needed declarations.

<LI><STRONG>Exports:</STRONG>


<UL>

<LI><EM>Predicates:</EM>

<A NAME="IDX4153"></A>
<CODE>init_sql_persdb/0</CODE>, 
<A NAME="IDX4154"></A>
<CODE>dbassertz_fact/1</CODE>, 
<A NAME="IDX4155"></A>
<CODE>dbretract_fact/1</CODE>, 
<A NAME="IDX4156"></A>
<CODE>dbcurrent_fact/1</CODE>, 
<A NAME="IDX4157"></A>
<CODE>dbretractall_fact/1</CODE>, 
<A NAME="IDX4158"></A>
<CODE>make_sql_persistent/3</CODE>, 
<A NAME="IDX4159"></A>
<CODE>dbfindall/4</CODE>, 
<A NAME="IDX4160"></A>
<CODE>dbcall/2</CODE>, 
<A NAME="IDX4161"></A>
<CODE>sql_query/3</CODE>, 
<A NAME="IDX4162"></A>
<CODE>sql_get_tables/2</CODE>, 
<A NAME="IDX4163"></A>
<CODE>sql_table_types/3</CODE>.

<LI><EM>Multifiles:</EM>

<A NAME="IDX4164"></A>
<CODE>sql_persistent_location/2</CODE>.

</UL>

<LI><STRONG>Other modules used:</STRONG>


<UL>

<LI><EM>System library modules:</EM>

<A NAME="IDX4165"></A>
<CODE>persdb_sql/db_client</CODE>, 
<A NAME="IDX4166"></A>
<CODE>persdb_sql/pl2sql</CODE>, 
<A NAME="IDX4167"></A>
<CODE>persdb_sql/sqltypes</CODE>, 
<A NAME="IDX4168"></A>
<CODE>dynamic</CODE>, 
<A NAME="IDX4169"></A>
<CODE>terms</CODE>, 
<A NAME="IDX4170"></A>
<CODE>metaterms</CODE>, 
<A NAME="IDX4171"></A>
<CODE>messages</CODE>, 
<A NAME="IDX4172"></A>
<CODE>lists</CODE>, 
<A NAME="IDX4173"></A>
<CODE>aggregates</CODE>, 
<A NAME="IDX4174"></A>
<CODE>persdb_sql/insert_compiler/pl2sqlinsert</CODE>.

</UL>

</UL>

</div class="cartouche">



<H2><A NAME="SEC403" HREF="ciao_toc.html#TOC403">Documentation on exports (<CODE>persdbrtsql</CODE>)</A></H2>
<P>
<A NAME="IDX4175"></A>
<A NAME="IDX4176"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>init_sql_persdb/0:</B>
<DD><A NAME="IDX4177"></A>


<P>
<STRONG>Usage:</STRONG> 

<UL>
<LI><EM>Description:</EM> Internal predicate, used to transform predicates statically declared as persistent (see

<A NAME="IDX4178"></A>
<CODE>sql_persistent/3</CODE>) into real persistent predicates.  
</UL>

</DL>

<P>
<A NAME="IDX4179"></A>
<A NAME="IDX4180"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>sql_persistent/3:</B>
<DD><A NAME="IDX4181"></A>


<P>
No further documentation available for this predicate.


</DL>

<P>
<A NAME="IDX4182"></A>
<A NAME="IDX4183"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>dbassertz_fact/1:</B>
<DD><A NAME="IDX4184"></A>


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>dbassertz_fact(+Fact)</CODE>

<UL>
<LI><EM>Description:</EM> Persistent extension of

<A NAME="IDX4185"></A>
<CODE>assertz_fact/1</CODE>: the current instance of <CODE>Fact</CODE> is interpreted as a fact (i.e., a relation tuple) and is added to the end of the definition of the corresponding predicate. If any integrity constraint violation is done (database stored predicates), an error will be displayed. The predicate concerned must be statically (
<A NAME="IDX4186"></A>
<CODE>sql_persistent/3</CODE>) or dinamically (
<A NAME="IDX4187"></A>
<CODE>make_sql_persistent/3</CODE>) declared. Any uninstantiated variables in the <CODE>Fact</CODE> will be replaced by new, private variables. <STRONG>Note:</STRONG> <EM>assertion of facts with uninstantiated variables not implemented at this time.</EM> 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Fact</CODE> is a fact (a term whose main functor is not <CODE>':-'/2</CODE>).
 (<CODE>persdbrtsql:fact/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4188"></A>
<A NAME="IDX4189"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>dbretract_fact/1:</B>
<DD><A NAME="IDX4190"></A>


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>dbretract_fact(+Fact)</CODE>

<UL>
<LI><EM>Description:</EM> Persistent extension of

<A NAME="IDX4191"></A>
<CODE>retract_fact/1</CODE>: deletes on backtracking all the facts which unify with <CODE>Fact</CODE>. The predicate concerned must be statically (
<A NAME="IDX4192"></A>
<CODE>sql_persistent/3</CODE>) or dinamically (
<A NAME="IDX4193"></A>
<CODE>make_sql_persistent/3</CODE>) declared. 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Fact</CODE> is a fact (a term whose main functor is not <CODE>':-'/2</CODE>).
 (<CODE>persdbrtsql:fact/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4194"></A>
<A NAME="IDX4195"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>dbcurrent_fact/1:</B>
<DD><A NAME="IDX4196"></A>


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>dbcurrent_fact(+Fact)</CODE>

<UL>
<LI><EM>Description:</EM> Persistent extension of

<A NAME="IDX4197"></A>
<CODE>current_fact/1</CODE>: the fact <CODE>Fact</CODE> exists in the current database. The predicate concerned must be declared 
<A NAME="IDX4198"></A>
<CODE>sql_persistent/3</CODE>. Provides on backtracking all the facts (tuples) which unify with <CODE>Fact</CODE>. 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Fact</CODE> is a fact (a term whose main functor is not <CODE>':-'/2</CODE>).
 (<CODE>persdbrtsql:fact/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4199"></A>
<A NAME="IDX4200"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>dbretractall_fact/1:</B>
<DD><A NAME="IDX4201"></A>


<P>
The predicate is of type <EM>implicit</EM>.


<P>
<STRONG>Usage:</STRONG> <CODE>dbretractall_fact(+Fact)</CODE>

<UL>
<LI><EM>Description:</EM> Persistent extension of

<A NAME="IDX4202"></A>
<CODE>retractall_fact/1</CODE>: when called deletes all the facts which unify with <CODE>Fact</CODE>. The predicate concerned must be statically (
<A NAME="IDX4203"></A>
<CODE>sql_persistent/3</CODE>) or dinamically (
<A NAME="IDX4204"></A>
<CODE>make_sql_persistent/3</CODE>) declared. 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+Fact</CODE> is a fact (a term whose main functor is not <CODE>':-'/2</CODE>).
 (<CODE>persdbrtsql:fact/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4205"></A>
<A NAME="IDX4206"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>make_sql_persistent/3:</B>
<DD><A NAME="IDX4207"></A>


<P>
<EM>Meta-predicate</EM> of type <EM>implicit</EM> with arguments: <CODE>make_sql_persistent(addmodule,?,?)</CODE>.


<P>
<STRONG>Usage:</STRONG> <CODE>make_sql_persistent(PrologPredTypes,TableAttributes,Keyword)</CODE>

<UL>
<LI><EM>Description:</EM> Dynamic version of the

<A NAME="IDX4208"></A>
<CODE>sql_persistent/3</CODE> declaration. 
<LI><EM>The following properties should hold upon exit:</EM>

<CODE>PrologPredTypes</CODE> is a structure describing a Prolog predicate name with its types.
 (<CODE>persdbrtsql:prologPredTypes/1</CODE>)

<CODE>TableAttributes</CODE> is a structure describing a table name and some attributes.
 (<CODE>persdbrtsql:tableAttributes/1</CODE>)

<CODE>Keyword</CODE> is the name of a persistent storage location.
 (<CODE>persdbrtsql:persLocId/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4209"></A>
<A NAME="IDX4210"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>dbfindall/4:</B>
<DD><A NAME="IDX4211"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>dbfindall(+DBId,+Pattern,+ComplexGoal,-(Results))</CODE>

<UL>
<LI><EM>Description:</EM> Similar to

<A NAME="IDX4212"></A>
<CODE>findall/3</CODE>, but <CODE>Goal</CODE> is executed in database <CODE>DBId</CODE>. Certain restrictions and extensions apply to both <CODE>Pattern</CODE> and <CODE>ComplexGoal</CODE> stemming from the Prolog to SQL translation involved (see the corresponding type definitions for details). 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+DBId</CODE> a unique identifier of a database session connection.
 (<CODE>db_client:dbconnection/1</CODE>)

<CODE>+Pattern</CODE> is a database projection term.
 (<CODE>pl2sql:projterm/1</CODE>)

<CODE>+ComplexGoal</CODE> is a database query goal.
 (<CODE>pl2sql:querybody/1</CODE>)

<CODE>-(Results)</CODE> is a list.
 (<CODE>basic_props:list/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4213"></A>
<A NAME="IDX4214"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>dbcall/2:</B>
<DD><A NAME="IDX4215"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>dbcall(+DBId,+ComplexGoal)</CODE>

<UL>
<LI><EM>Description:</EM> Internal predicate, used by the transformed versions of the persistent predicates. Not meant to be called directly by users. It is exported by the library so that it can be used by the transformed versions of the persistent predicates in the modules in which they reside. Sends <CODE>ComplexGoal</CODE> to database <CODE>DBId</CODE> for evaluation. <CODE>ComplexGoal</CODE> must be a call to a persistent predicate which resides in database <CODE>DBId</CODE>.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+DBId</CODE> a unique identifier of a database session connection.
 (<CODE>db_client:dbconnection/1</CODE>)

<CODE>+ComplexGoal</CODE> is a database query goal.
 (<CODE>pl2sql:querybody/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4216"></A>
<A NAME="IDX4217"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>sql_query/3:</B>
<DD><A NAME="IDX4218"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>sql_query(+DBId,+SQLString,AnswerTableTerm)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>ResultTerm</CODE> is the response from database <CODE>DBId</CODE> to the

<A NAME="IDX4219"></A>
SQL query in <CODE>SQLString</CODE> to database <CODE>DBId</CODE>. <CODE>AnswerTableTerm</CODE> can express a set of tuples, an error answer or a 'ok' response (see 
<A NAME="IDX4220"></A>
<CODE>answertableterm/1</CODE> for details). At the moment, 
<A NAME="IDX4221"></A>
<CODE>sql_query/3</CODE> log in and out for each query. This should be changed to log in only the first time and log out on exit and/or via a timer in the standard way. 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+DBId</CODE> a unique identifier of a database session connection.
 (<CODE>db_client:dbconnection/1</CODE>)

<CODE>+SQLString</CODE> is a string containing SQL code.
 (<CODE>pl2sql:sqlstring/1</CODE>)

<CODE>AnswerTableTerm</CODE> is a response from the ODBC database interface.
 (<CODE>db_client:answertableterm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4222"></A>
<A NAME="IDX4223"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>sql_get_tables/2:</B>
<DD><A NAME="IDX4224"></A>


<P>
<STRONG>Usage 1:</STRONG> <CODE>sql_get_tables(+Location,-(Tables))</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Tables</CODE> contains the tables available in <CODE>Location</CODE>.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>persdbrtsql:persLocation(+Location)</CODE>
 (<CODE>persdbrtsql:persLocation/1</CODE>)

<CODE>-(Tables)</CODE> is a list of <CODE>atm</CODE>s.
 (<CODE>basic_props:list/2</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>sql_get_tables(+DbConnection,-(Tables))</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Tables</CODE> contains the tables available in <CODE>DbConnection</CODE>.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+DbConnection</CODE> a unique identifier of a database session connection.
 (<CODE>db_client:dbconnection/1</CODE>)

<CODE>-(Tables)</CODE> is a list of <CODE>atm</CODE>s.
 (<CODE>basic_props:list/2</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4225"></A>
<A NAME="IDX4226"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>sql_table_types/3:</B>
<DD><A NAME="IDX4227"></A>


<P>
<STRONG>Usage 1:</STRONG> <CODE>sql_table_types(+Location,+Table,-(AttrTypes))</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>AttrTypes</CODE> are the attributes and types of <CODE>Table</CODE> in <CODE>Location</CODE>.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>persdbrtsql:persLocation(+Location)</CODE>
 (<CODE>persdbrtsql:persLocation/1</CODE>)

<CODE>+Table</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>-(AttrTypes)</CODE> is a list.
 (<CODE>basic_props:list/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>sql_table_types(+DbConnection,+Table,-(AttrTypes))</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>AttrTypes</CODE> are the attributes and types of <CODE>Table</CODE> in <CODE>DbConnection</CODE>.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+DbConnection</CODE> a unique identifier of a database session connection.
 (<CODE>db_client:dbconnection/1</CODE>)

<CODE>+Table</CODE> is an atom.
 (<CODE>basic_props:atm/1</CODE>)

<CODE>-(AttrTypes)</CODE> is a list.
 (<CODE>basic_props:list/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4228"></A>
<A NAME="IDX4229"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>socketname/1:</B>
<DD><A NAME="IDX4230"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>socketname(IPP)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>IPP</CODE> is a structure describing a complete TCP/IP port address.

<LI><EM>The following properties should hold globally:</EM>

Defines a regular type.
 (<CODE>basic_props:regtype/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4231"></A>
<A NAME="IDX4232"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>dbname/1:</B>
<DD><A NAME="IDX4233"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>dbname(DBId)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>DBId</CODE> is the identifier of an ODBC database.

<LI><EM>The following properties should hold globally:</EM>

Defines a regular type.
 (<CODE>basic_props:regtype/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4234"></A>
<A NAME="IDX4235"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>user/1:</B>
<DD><A NAME="IDX4236"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>user(User)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>User</CODE> is a user name in the ODBC database.

<LI><EM>The following properties should hold globally:</EM>

Defines a regular type.
 (<CODE>basic_props:regtype/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4237"></A>
<A NAME="IDX4238"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>passwd/1:</B>
<DD><A NAME="IDX4239"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>passwd(Passwd)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Passwd</CODE> is the password for the user name in the ODBC database.

<LI><EM>The following properties should hold globally:</EM>

Defines a regular type.
 (<CODE>basic_props:regtype/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4240"></A>
<A NAME="IDX4241"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>projterm/1:</B>
<DD><A NAME="IDX4242"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>projterm(DBProjTerm)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>DBProjTerm</CODE> is a database projection term.

<LI><EM>The following properties should hold globally:</EM>

Defines a regular type.
 (<CODE>basic_props:regtype/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4243"></A>
<A NAME="IDX4244"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>querybody/1:</B>
<DD><A NAME="IDX4245"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>querybody(DBGoal)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>DBGoal</CODE> is a database query goal.

<LI><EM>The following properties should hold globally:</EM>

Defines a regular type.
 (<CODE>basic_props:regtype/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4246"></A>
<DL>
<DT><span class="define">(UNDOC_REEXPORT):</span> <B>sqltype/1:</B>
<DD><A NAME="IDX4247"></A>


<P>
 Imported from 
<A NAME="IDX4248"></A>
<CODE>sqltypes</CODE> (see the corresponding documentation for details).


</DL>



<H2><A NAME="SEC404" HREF="ciao_toc.html#TOC404">Documentation on multifiles (<CODE>persdbrtsql</CODE>)</A></H2>
<P>
<A NAME="IDX4249"></A>
<A NAME="IDX4250"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>sql_persistent_location/2:</B>
<DD><A NAME="IDX4251"></A>


<P>
Relates names of locations (the <CODE>Keyword</CODE>s) with descriptions of such locations (<CODE>Location</CODE>s).


<P>
The predicate is <EM>multifile</EM> and of type <EM>data</EM>.


<P>
<STRONG>Usage 1:</STRONG> <CODE>sql_persistent_location(Keyword,Location)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>Keyword</CODE> is an identifier for the persistent data location <CODE>Location</CODE>.

<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>Keyword</CODE> is the name of a persistent storage location.
 (<CODE>persdbrtsql:persLocId/1</CODE>)

<CODE>persdbrtsql:persLocation(Location)</CODE>
 (<CODE>persdbrtsql:persLocation/1</CODE>)
</UL>

<P>
<STRONG>Usage 2:</STRONG> <CODE>sql_persistent_location(Keyword,DBLocation)</CODE>

<UL>
<LI><EM>Description:</EM> In this usage, <CODE>DBLocation</CODE> is a <EM>relational database</EM>, in which case the predicate is stored as tuples in the database.

<LI><EM>The following properties should hold upon exit:</EM>

<CODE>Keyword</CODE> is the name of a persistent storage location.
 (<CODE>persdbrtsql:persLocId/1</CODE>)

<CODE>DBLocation</CODE> is a structure describing a database.
 (<CODE>persdbrtsql:database_desc/1</CODE>)
</UL>

</DL>



<H2><A NAME="SEC405" HREF="ciao_toc.html#TOC405">Documentation on internals (<CODE>persdbrtsql</CODE>)</A></H2>
<P>
<A NAME="IDX4252"></A>
<A NAME="IDX4253"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>db_query/4:</B>
<DD><A NAME="IDX4254"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>db_query(+DBId,+ProjTerm,+Goal,ResultTerm)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>ResultTerm</CODE> contains all the

<A NAME="IDX4255"></A>
tuples which are the response from database <CODE>DBId</CODE> to the Prolog query <CODE>Goal</CODE>, projected onto <CODE>ProjTerm</CODE>. Uses 
<A NAME="IDX4256"></A>
<CODE>pl2sqlstring/3</CODE> for the 
<A NAME="IDX4257"></A>
Prolog to SQL translation and 
<A NAME="IDX4258"></A>
<CODE>sql_query/3</CODE> for posing the actual query. 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+DBId</CODE> a unique identifier of a database session connection.
 (<CODE>db_client:dbconnection/1</CODE>)

<CODE>+ProjTerm</CODE> is a database projection term.
 (<CODE>pl2sql:projterm/1</CODE>)

<CODE>+Goal</CODE> is a database query goal.
 (<CODE>pl2sql:querybody/1</CODE>)

<CODE>ResultTerm</CODE> is a tuple of values from the ODBC database interface.
 (<CODE>db_client:tuple/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4259"></A>
<A NAME="IDX4260"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>db_query_one_tuple/4:</B>
<DD><A NAME="IDX4261"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>db_query_one_tuple(+DBId,+ProjTerm,+Goal,ResultTerm)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>ResultTerm</CODE> is one of the

<A NAME="IDX4262"></A>
tuples which are the response from database <CODE>DBId</CODE> to the Prolog query <CODE>Goal</CODE>, projected onto <CODE>ProjTerm</CODE>. Uses 
<A NAME="IDX4263"></A>
<CODE>pl2sqlstring/3</CODE> for the 
<A NAME="IDX4264"></A>
Prolog to SQL translation and 
<A NAME="IDX4265"></A>
<CODE>sql_query_one_tuple/3</CODE> for posing the actual query. After last tuple has been reached, a null tuple is unified with ResultTerm, and the connection to the database finishes. 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+DBId</CODE> a unique identifier of a database session connection.
 (<CODE>db_client:dbconnection/1</CODE>)

<CODE>+ProjTerm</CODE> is a database projection term.
 (<CODE>pl2sql:projterm/1</CODE>)

<CODE>+Goal</CODE> is a database query goal.
 (<CODE>pl2sql:querybody/1</CODE>)

<CODE>ResultTerm</CODE> is a predicate containing a tuple.
 (<CODE>db_client:answertupleterm/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4266"></A>
<A NAME="IDX4267"></A>
<DL>
<DT><span class="define">PREDICATE:</span> <B>sql_query_one_tuple/3:</B>
<DD><A NAME="IDX4268"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>sql_query_one_tuple(+DBId,+SQLString,ResultTuple)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>ResultTuple</CODE> contains an element from the set of tuples which represents the response in <CODE>DBId</CODE> to the

<A NAME="IDX4269"></A>
SQL query <CODE>SQLString</CODE>. If the connection is kept, succesive calls return consecutive tuples, until the last tuple is reached. Then a null tuple is unified with <CODE>ResultTuple</CODE> and the connection is finished (calls to 
<A NAME="IDX4270"></A>
<CODE>db_logoff/1</CODE> and 
<A NAME="IDX4271"></A>
<CODE>odbc_disconnect/1</CODE>). 
<LI><EM>Call and exit should be <EM>compatible</EM> with:</EM>

<CODE>+DBId</CODE> a unique identifier of a database session connection.
 (<CODE>db_client:dbconnection/1</CODE>)

<CODE>+SQLString</CODE> is a string containing SQL code.
 (<CODE>pl2sql:sqlstring/1</CODE>)

<CODE>ResultTuple</CODE> is a tuple of values from the ODBC database interface.
 (<CODE>db_client:tuple/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4272"></A>
<A NAME="IDX4273"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>dbconnection/1:</B>
<DD><A NAME="IDX4274"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>dbconnection(H)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>H</CODE> a unique identifier of a database session connection.

<LI><EM>The following properties should hold globally:</EM>

Defines a regular type.
 (<CODE>basic_props:regtype/1</CODE>)
</UL>

</DL>

<P>
<A NAME="IDX4275"></A>
<A NAME="IDX4276"></A>
<DL>
<DT><span class="define">REGTYPE:</span> <B>tuple/1:</B>
<DD><A NAME="IDX4277"></A>


<P>
<STRONG>Usage:</STRONG> <CODE>tuple(T)</CODE>

<UL>
<LI><EM>Description:</EM> <CODE>T</CODE> is a tuple of values from the ODBC database interface.

<LI><EM>The following properties should hold globally:</EM>

Defines a regular type.
 (<CODE>basic_props:regtype/1</CODE>)
</UL>

</DL>



<H2><A NAME="SEC406" HREF="ciao_toc.html#TOC406">Known bugs and planned improvements (<CODE>persdbrtsql</CODE>)</A></H2>


<UL>

<LI>

At least in the shell, reloading a file after changing the definition of a persistent predicate does not eliminate the old definition...

<LI>

Functionality missing: some questions need to be debugged.

<LI>

Warning: still using kludgey string2term and still using some non-uniquified temp files.

<LI>

Needs to be unified with the file-based library.
</UL>

<P><HR><P>
Go to the <A HREF="ciao_1.html">first</A>, <A HREF="ciao_111.html">previous</A>, <A HREF="ciao_113.html">next</A>, <A HREF="ciao_148.html">last</A> section, <A HREF="ciao_toc.html">table of contents</A>.
</BODY>
</HTML>
