This is Info file ciao.info, produced by Makeinfo version 1.68 from
the input file ciao.texi.

   10000  10000

   *Ciao* is a *public domain* programming environment which supports
the development and efficient compilation of *logic programs*,
*constraint logic programs* (CLP), *functional logic programs*, and
*object-oriented logic programs*. In particular, *Ciao* includes
standard *ISO-Prolog* as a sublanguage and a program development
environment similar to that of traditional Prolog and CLP
implementations. However, *Ciao* extends the Prolog language and
improves on traditional Prolog programming environments in a number
of significant ways:

   * *Ciao* offers support for *programming in the large* with a
     robust module/object system, module-based automatic incremental
     compilation (with no need for makefiles), an assertion language
     for declaring (*optional*) program properties (including types
     and modes), automatic static inference and static/dynamic
     checking of such assertions, etc.

   * *Ciao* also offers support for *programming in the small*
     producing small executables (including only those builtins used
     by the program) and support for writing scripts in Prolog.

   * The *Ciao* compiler generates several forms of
     architecture-independent and stand-alone executables. Library
     modules can be compiled into compact bytecode or C source files,
     and linked statically, dynamically, or autoloaded.

   * *Ciao* supports concurrency (threads), distributed execution,
     and parallel execution.

   * The *Ciao* programming environment includes a large number of
     *libraries* providing a wide range of additional functionality,
     from WWW programming to support for several control rules.

   * The *Ciao* programming environment also includes `lpdoc', a tool
     for generating documentation automatically for Prolog programs
     adorned with (*Ciao*) assertions and special, machine-readable
     comments.

   The *Ciao* language has been designed from the ground up to be
highly extensible (in a modular way) and to allow modular program
development, global program analysis, and static debugging and
optimization via source to source program transformation, including
automatic parallelization. The latter tasks are performed by the
*Ciao preprocessor* ( `ciaopp', distributed separately). The *Ciao*
system also includes a rich `emacs' interface and a number of
execution visualization tools.

   *Ciao* is distributed under the GNU General Public License,
version 2, as published by the Free Software Foundation, Inc., 675
Mass Ave, Cambridge, MA 02139, USA.

   This documentation corresponds to version 1.4 (1999/11/27, 19:0:0
MEST).

   Copyright (C) F. Bueno, D. Cabeza, M. Carro, M. Hermenegildo, P.
L'opez, and G. Puebla

   This document may be freely read, stored, reproduced,
disseminated, translated or quoted by any means and on any medium
provided the following conditions are met:

  1. Every reader or user of this document acknowledges that is aware
     that no guarantee is given regarding its contents, on any
     account, and specifically concerning veracity, accuracy and
     fitness for any purpose.

  2. No modification is made other than cosmetic, change of
     representation format, translation, correction of obvious
     syntactic errors, or as permitted by the clauses below.

  3. Comments and other additions may be inserted, provided they
     clearly appear as such; translations or fragments must clearly
     refer to an original complete version, preferably one that is
     easily accessed whenever possible.

  4. Translations, comments and other additions or modifications must
     be dated and their author(s) must be identifiable (possibly via
     an alias).

  5. This licence is preserved and applies to the whole document with
     modifications and additions (except for brief quotes),
     independently of the representation format.

  6. Any reference to the "official version", "original version" or
     "how to obtain original versions" of the document is preserved
     verbatim. Any copyright notice in the document is preserved
     verbatim. Also, the title and author(s) of the original document
     should be clearly mentioned as such.

  7. In the case of translations, verbatim sentences mentioned in
     (6.) are preserved in the language of the original document
     accompanied by verbatim translations to the language of the
     traslated document. All translations state clearly that the
     author is not responsible for the translated work. This license
     is included, at least in the language in which it is referenced
     in the original version.

  8. Whatever the mode of storage, reproduction or dissemination,
     anyone able to access a digitized version of this document must
     be able to make a digitized copy in a format directly usable,
     and if possible editable, according to accepted, and publicly
     documented, public standards.

  9. Redistributing this document to a third party requires
     simultaneous redistribution of this licence, without
     modification, and in particular without any further condition or
     restriction, expressed or implied, related or not to this
     redistribution. In particular, in case of inclusion in a
     database or collection, the owner or the manager of the database
     or the collection renounces any right related to this inclusion
     and concerning the possible uses of the document after
     extraction from the database or the collection, whether alone or
     in relation with other documents.


   Any incompatibility of the above clauses with legal, contractual
or judiciary decisions or constraints implies a corresponding
limitation of reading, usage, or redistribution rights for this
document, verbatim or modified.

   1


File: ciao.info,  Node: Top,  Next: Summary,  Prev: (dir),  Up: (dir)

The Ciao Prolog System
**********************

   This documentation corresponds to version 1.4 (1999/11/27, 19:0:0
MEST).

* Menu:

* Summary::
* Introduction::
* Getting started::
* *** PART I - The program development environment::
* The stand-alone command-line compiler::
* The interactive top-level shell::
* The interactive debugger::
* Predicates controlling the interactive debugger::
* The script interpreter::
* Customizing library paths and path aliases::
* Using Ciao inside GNU emacs::
* *** PART II - The Ciao basic language (engine)::
* The module system::
* Directives for using code in other files::
* Control constructs/predicates::
* Basic builtin directives::
* Basic data types and properties::
* Extra-logical properties for typing::
* Basic term manipulation::
* Comparing terms::
* Basic predicates handling names of constants::
* Arithmetic::
* Basic input/output::
* Basic file/stream handling::
* Exception handling::
* Fast/concurrent update of facts::
* Changing system behaviour and various flags::
* Concurrency/multithreading primitives::
* Extending the syntax::
* Message printing primitives::
* Attributed variables::
* Gathering some basic internal info::
* *** PART III - ISO-Prolog library (iso)::
* ISO-Prolog package::
* Standard operators::
* All solutions predicates::
* Dynamic predicates::
* iso_byte_char (library)::
* iso_incomplete (library)::
* iso_misc (library)::
* Term input::
* Structured stream handling::
* Term output::
* *** PART IV - Classic Prolog library (classic)::
* Classic Prolog package::
* Definite clause grammars::
* Definite clause grammars (expansion)::
* Quintus-like internal database::
* List processing::
* Sorting lists::
* Dictionaries::
* String processing::
* DEC-10 Prolog file IO::
* Formatted output::
* ttyout (library)::
* dynmods (library)::
* runtime_ops (library)::
* *** PART V - Annotated Prolog library (assertions)::
* The Ciao assertion package::
* Types and properties related to assertions::
* Declaring regular types::
* Properties which are native to analyzers::
* Meta-properties::
* ISO-Prolog modes::
* Classical Prolog modes::
* Run-time checking of assertions::
* *** PART VI - Ciao Prolog library miscellanea::
* Operating system utilities::
* Prolog system internal predicates::
* ctrlcclean (library)::
* errhandle (library)::
* fastrw (library)::
* File name manipulation::
* file_utils (library)::
* file_locks (library)::
* terms (library)::
* tokenize (library)::
* Printing status and error messages::
* A simple pretty-printer for Ciao programs::
* Pretty-printing assertions::
* The Ciao library browser::
* Code translation utilities::
* conc_aggregates (library)::
* *** PART VII - Ciao Prolog extensions::
* Pure Prolog package::
* argnames (library)::
* Independent and-parallel execution::
* functions (library)::
* global (library)::
* Miscellaneous predicates::
* actmods (library)::
* Breadth-first execution::
* Constraint programming over rationals::
* Constraint programming over reals::
* Object oriented programming::
* Declaring classes and interfaces::
* Error reporting when compiling classes and interfaces::
* Using OCIAO objects::
* Error reporting when using objects::
* Run time usage of objects::
* Using classes from the CIAO toplevel shell::
* *** PART VIII - Interfaces to other languages and systems::
* Foreign interface::
* Utilities for on-demand compilation of foreign files::
* The socket interface::
* The tcl/tk interface::
* Connecting with the Web::
* html (library)::
* http (library)::
* Persistent predicate database::
* Using the persdb library::
* SQL persistent database interface::
* Prolog to SQL translator::
* Low-level socket interface to SQL/ODBC databases::
* Low-level Prolog to Java interface::
* Low-level Java to Prolog interface::
* Low-level Prolog to Java socket connection::
* linda (library)::
* *** PART IX - Abstract data types::
* atom2term (library)::
* counters (library)::
* Identity lists::
* Term manipulation::
* Lists of numbers::
* Pattern (regular expression) matching::
* queues (library)::
* Random numbers::
* sets (library)::
* Variable names dictionaries::
* *** PART X - Miscellaneous standalone utilities::
* Printing the declarations and code in a file::
* Printing the contents of a bytecode file::
* Gathering the dependent files for a file::
* Finding differences between two Prolog files::
* The Ciao lpmake scripting facility::
* Find out which architecture we are running on::
* *** PART XI - Appendices::
* Installing Ciao::
* References::
* Library/Module Definition Index::
* Predicate/Method Definition Index::
* Property Definition Index::
* Regular Type Definition Index::
* Declaration Definition Index::
* Concept Definition Index::
* Global Index::


File: ciao.info,  Node: Summary,  Next: Introduction,  Prev: Top,  Up: Top

Summary
*******

   *Ciao* is a *public domain* programming environment which supports
the development and efficient compilation of *logic programs*,
*constraint logic programs* (CLP), *functional logic programs*, and
*object-oriented logic programs*. In particular, *Ciao* includes
standard *ISO-Prolog* as a sublanguage and a program development
environment similar to that of traditional Prolog and CLP
implementations. However, *Ciao* extends the Prolog language and
improves on traditional Prolog programming environments in a number
of significant ways:

   * *Ciao* offers support for *programming in the large* with a
     robust module/object system, module-based automatic incremental
     compilation (with no need for makefiles), an assertion language
     for declaring (*optional*) program properties (including types
     and modes), automatic static inference and static/dynamic
     checking of such assertions, etc.

   * *Ciao* also offers support for *programming in the small*
     producing small executables (including only those builtins used
     by the program) and support for writing scripts in Prolog.

   * The *Ciao* compiler generates several forms of
     architecture-independent and stand-alone executables. Library
     modules can be compiled into compact bytecode or C source files,
     and linked statically, dynamically, or autoloaded.

   * *Ciao* supports concurrency (threads), distributed execution,
     and parallel execution.

   * The *Ciao* programming environment includes a large number of
     *libraries* providing a wide range of additional functionality,
     from WWW programming to support for several control rules.

   * The *Ciao* programming environment also includes `lpdoc', a tool
     for generating documentation automatically for Prolog programs
     adorned with (*Ciao*) assertions and special, machine-readable
     comments.

   The *Ciao* language has been designed from the ground up to be
highly extensible (in a modular way) and to allow modular program
development, global program analysis, and static debugging and
optimization via source to source program transformation, including
automatic parallelization. The latter tasks are performed by the
*Ciao preprocessor* ( `ciaopp', distributed separately). The *Ciao*
system also includes a rich `emacs' interface and a number of
execution visualization tools.

   *Ciao* is distributed under the GNU General Public License,
version 2, as published by the Free Software Foundation, Inc., 675
Mass Ave, Cambridge, MA 02139, USA.


File: ciao.info,  Node: Introduction,  Next: Getting started,  Prev: Summary,  Up: Top

Introduction
************

*NOTE:* *This (semi-automatically generated) manual is still
incomplete. It is however being updated regularly as the
machine-readable documentation of the different libraries is
completed*.

   This is the *Reference Manual* for the Ciao Prolog development
system. It contains basic information on how to install Ciao Prolog
and how to write, debug, and run Ciao Prolog programs, both from the
command line and from inside GNU `emacs'. It also documents all the
libraries available in the standard distribution.

* Menu:

* About the Ciao Prolog development system::
* ISO-Prolog compliance::
* Syntax terminology and notational conventions::
* Acknowledgments::
* Known bugs and planned improvements (ciao)::
* Version/Change Log (ciao)::


File: ciao.info,  Node: About the Ciao Prolog development system,  Next: ISO-Prolog compliance,  Prev: Introduction,  Up: Introduction

About the Ciao Prolog development system
========================================

   The Ciao system comprises Ciao Prolog and its programming
environment, which includes a number of programming tools such as the
Ciao compiler (`ciaoc'), top-level interactive shell (`ciaosh' or
`ciao'), a Prolog-script interpreter (`ciao-shell'), a Prolog `emacs'
mode which helps program developing with support for tasks as
editing, debugging and version/change tracking, a program
preprocessor (`ciaopp'), which supports static debugging and
optimization from program analysis via source to source program
transformation, an automatic documentation generator (`lpdoc')
[Her99b], and a number of execution visualization tools.

   This manual documents the first four of the abovementioned tools
[PART I - The program development environment]), and the Ciao Prolog
language and library [PART II - The Ciao basic language (engine)].
`ciaopp' and `lpdoc' are documented in separated manuals.

   The Ciao language has been designed from the ground up to be
minimal but also highly extensible (in a modular way). The first
objective allows producing small executables (including only those
builtins used by the program), providing basic support for pure logic
programming, and support for writing scripts in Prolog. The second
one allows adding support for standard ISO-Prolog [PART III -
ISO-Prolog library (iso)], as well as extensions such as constraint
logic programming, functional logic programming, and object-oriented
logic programming [PART VII - Ciao Prolog extensions].

   Based on the same motivation for modularity, Ciao design has also
been focused on allowing modular program development, automatic
manipulation and optimization. Ciao includes a robust module system
[CH99a], module-based automatic incremental compilation [CH99b], and
modular global program analysis, debugging and optimization [PH99],
based on a rich assertion language [PART V - Annotated Prolog library
(assertions)] for declaring (optional) program properties (including
types and modes), which can be checked either statically or
dynamically. All program analysis and static debugging and
optimization tasks are performed by the `ciaopp' preprocessor.

   Ciao also includes several other features and utilities, such as
support for several forms of executables, concurrency (threads),
distributed and parallel execution, high-order, WWW programming,
interfaces to other languages like C and Java, etc.


File: ciao.info,  Node: ISO-Prolog compliance,  Next: Syntax terminology and notational conventions,  Prev: About the Ciao Prolog development system,  Up: Introduction

ISO-Prolog compliance
=====================

   Ciao has been designed to subsume *ISO-Prolog* [DEDC96]
(International Standard ISO/IEC 13211-1, PROLOG: Part 1-General
Core), while extending it in many ways. The intention is to ensure
that all ISO-compliant Prolog programs should run correctly under
Ciao. At the same time, Ciao allows selectively avoiding the loading
of most ISO-builtins (and changing some other ISO characteristics)
when not needed, so that it is possible to work with purer subsets of
Prolog, and develop extensions using these purer subsets as a
starting point. Also, Ciao allows the development of libraries which
significantly extend the language both syntactically and semantically.

   Given that the final version of the ISO standard has only been
recently published, total compliance with ISO is still not achieved.
There are some minor deviations in, e.g., the treatment of
characters, the syntax, some of the arithmetic functions, and part of
the error system. However, despite this, Ciao has been reported by
independent sources (members of the standarization body) to be one of
the most conforming Prologs at the moment of this writing, and the
first one to be able to compile all the standard-conforming test
cases.

   Also, Ciao does not offer a strictly conforming mode which rejects
uses of non-ISO features. However, in order to aid programmers who
wish to write standard compliant programs, library predicates that
correspond to those in the ISO-Prolog standard are marked specially
in the manuals, and any differences between the Ciao and the
prescribed ISO-Prolog behaviours, if any, commented appropriately.

   The intention of the Ciao developers is to progressively complete
the compliance of Ciao with the published parts of the ISO standard
as well as with the other parts which are currently in preparation
and may be published in the future.

   Finally, as stated elsewhere, one of the design objectives of Ciao
is to address some shortcomings of previous implementations of Prolog
and logic programming in general. Given this, we also hope that some
of the better ideas present in the Ciao system will make it
eventually into the standard.


File: ciao.info,  Node: Syntax terminology and notational conventions,  Next: Acknowledgments,  Prev: ISO-Prolog compliance,  Up: Introduction

Syntax terminology and notational conventions
=============================================

   In Prolog, procedures are called *predicates* and predicate calls
*literals*. They all have the classical syntax of procedures (and of
logic predications and of mathematical functions). Predicates are
identified in this manual by a keyword 'PREDICATE' at the right
margin of the place where they are documented.

   Prolog instructions are expressions made up of control constructs
(*Note Control constructs/predicates::) and literals, and are called
*goals*. Literals are also (atomic) goals.

   A predicate definition is a sequence of clauses. A clause has the
form `H :- B.' (ending in '`.''), where `H' is syntactically the same
as a literal and is called the clause *head*, and `B' is a goal and
is called the clause *body*. A clause with no body is written `H.'
and is called a *fact*. Clauses with body are also called *rules*. A
Prolog program is a sequence of predicate definitions.

* Menu:

* Characters and character strings::
* Predicate specs::
* Modes::
* Properties and types::
* Declarations::
* Operators::


File: ciao.info,  Node: Characters and character strings,  Next: Predicate specs,  Prev: Syntax terminology and notational conventions,  Up: Syntax terminology and notational conventions

Characters and character strings
--------------------------------

   We adopt the following convention for delineating character
strings in the text of this manual: when a string is being used as a
Prolog atom it is written thus: `user' or `'user''; but in all other
circumstances double quotes are used.

   When referring to keyboard characters, printing characters are
written thus: <a>, while control characters are written like this:
<^A>. Thus <^C> is the character you get by holding down the <CTL>
key while you type <c>. Finally, the special control characters
carriage-return, line-feed and space are often abbreviated to <RET>,
<LFD> and <SPC> respectively.


File: ciao.info,  Node: Predicate specs,  Next: Modes,  Prev: Characters and character strings,  Up: Syntax terminology and notational conventions

Predicate specs
---------------

   Predicates in Prolog are distinguished by their name *and* their
arity. We will call `name/arity' a *predicate spec*. The notation
`name/arity' is therefore used when it is necessary to refer to a
predicate unambiguously. For example, `concatenate/3' specifies the
predicate which is named "concatenate" and which takes 3 arguments.

   (Note that different predicates may have the same name and
different arity. Conversely, of course, they may have the same arity
and different name.)


File: ciao.info,  Node: Modes,  Next: Properties and types,  Prev: Predicate specs,  Up: Syntax terminology and notational conventions

Modes
-----

   When documenting a predicate, we will often describe its usage
with a mode spec which has the form `name(Arg1, ..., ArgN)' where
each `Arg' may be preceded by a *mode*. A mode is a functor which is
wrapped around an argument (or prepended if defined as an operator).
Such a mode allows documenting in a compact way the instantiation
state on call and exit of the argument to which it is applied. The
set of modes which can be used in Ciao is not fixed. Instead,
arbitrary modes can be defined by in programs using the `modedef/1'
declarations of the Ciao *assertion language* (*Note The Ciao
assertion package:: for details). Modes are identified in this manual
by a keyword 'MODE'.

   Herein, we will use the set of modes defined in the Ciao
`isomodes' library, which is essentially the same as those used in the
ISO-Prolog standard (*Note ISO-Prolog modes::).


File: ciao.info,  Node: Properties and types,  Next: Declarations,  Prev: Modes,  Up: Syntax terminology and notational conventions

Properties and types
--------------------

   Although Ciao Prolog is *not* a typed language, it allows writing
(and using) types, as well as (more general) properties. There may be
properties of the states and of the computation. Properties of the
states allow expressing characteristics of the program variables
during computation, like in `sorted(X)' (`X' is a sorted list).
Properties of the computation allow expressing characteristics of a
whole computation, like in `is_det(p(X,Y))' (such calls yield only
one solution). Properties are just a special form of predicates
(*Note Declaring regular types::) and are identified in this manual
by a keyword 'PROPERTY'.

   Ciao types are *regular types* (*Note Declaring regular types::),
which are a special form of properties themselves. They are
identified in this manual by a keyword 'REGTYPE'.


File: ciao.info,  Node: Declarations,  Next: Operators,  Prev: Properties and types,  Up: Syntax terminology and notational conventions

Declarations
------------

   A *declaration* is an instruction to one of the Ciao environment
tools to do something, which is interspersed in the code of a
program. Usually the target tool is either the compiler (telling it
that a predicate is dynamic, or a meta-predicate, etc.) or the
preprocessor (which understands declarations of properties and types,
assertions, etc.).

   A declaration has the form `:- D.' where `D' is syntactically the
same as a literal. Declarations are identified in this manual by a
keyword 'DECLARATION'.


File: ciao.info,  Node: Operators,  Prev: Declarations,  Up: Syntax terminology and notational conventions

Operators
---------

   An *operator* is a functor (or predicate name) which has been
declared as such, thus allowing its use in a prefix, infix, or suffix
fashion, instead of the standard procedure-like fashion. E.g.,
declaring `+' as an infix operator allows writing `X+Y' instead of
`'+'(X,Y)' (which may still, of course, be written).

   Operators in Ciao are local to the module/file where they are
declared. However, some operators are standard and allowed in every
program. See *Note Standard operators::. This manual documents the
operator declarations in each (library) module where they are
included.


File: ciao.info,  Node: Acknowledgments,  Next: Known bugs and planned improvements (ciao),  Prev: Syntax terminology and notational conventions,  Up: Introduction

Acknowledgments
===============

   The Ciao system is a joint effort on one side of the present (
*Francisco Bueno*, *Daniel Cabeza*, *Manuel Carro*, *Manuel
Hermenegildo*, *Pedro L'opez*, and *Germ'an Puebla*) and past (
*Mar'ia Jos'e Garc'ia de la Banda*) members of the *CLIP group* at
the School of Computer Science, *Technical University of Madrid* ,
and on the other side of several colleagues and students that have
collaborated with us over the years of its development. The following
is an (inevitably incomplete) list of those that have contributed to
the development of Ciao:

   * The *Ciao engine*, compiler, libraries and documentation,
     although completely rewritten at this point, have their origins
     in the *&-Prolog* *parallel Prolog* engine and *parallelizing
     compiler*, developed by *Manuel Hermenegildo*, *Kevin Greene*,
     *Kalyan Muthukumar*, and *Roger Nasr* at *MCC* and later at
     *UPM*. The &-Prolog engine and low-level ( *WAM*) compilers in
     turn were derived from early versions (0.5 to 0.7) of *SICStus
     Prolog* [Car88]. SICStus is an excellent, high performance
     Prolog system, developed by *Mats Carlsson* and colleagues at the
     *Swedish Institute of Computer Science* ( *SICS*), that every
     user of Prolog should check out [Swe95,AAF91]. Very special
     thanks are due to *Seif Haridi*, *Mats Carlsson*, and colleagues
     at SICS for allowing the SICStus 0.5-0.7 components in
     *&-Prolog* and its successor, Ciao, to be distributed freely.
     Parts of the parallel abstract machine have been developed in
     collaboration with *Gopal Gupta* and *Enrico Pontelli* ( *New
     Mexico State University*).

   * Many aspects of the analyzers in the *Ciao preprocessor* (
     `ciaopp') have been developed in collaboration with *Peter
     Stuckey* ( *Melbourne U.*), *Kim Marriott* ( *Monash U.*),
     *Maurice Bruynooghe*, *Gerda Janssens*, *Anne Mulkers*, and
     *Veroniek Dumortier* ( *K.U. Leuven*), and *Saumya Debray* ( *U.
     of Arizona*). The assertion system has been developed in
     collaboration with *Jan Maluzynski* and *Wlodek Drabent* (
     *Linkoping U.*) and *Pierre Deransart* ( *INRIA*). The core of
     type inference system derives from the system developed by *John
     Gallagher* [GdW94] ( *Bristol University*) and later adapted to
     CLP(FD) by *Pawel Pietrzak* ( *Linkoping U.*).

   * The constraint solvers for *R* and *Q* are derived from the code
     developed by *Christian Holzbauer* ( *Austrian Research
     Institute for AI* in Vienna) [Hol94,Hol90,Hol92].

   * The Ciao manuals include material from the *DECsystem-10 Prolog
     User's Manual* by *D.L. Bowen* (editor), *L. Byrd*, *F.C.N.
     Pereira*, *L.M. Pereira*, and *D.H.D. Warren* [BBP81]. They also
     contain material from the SICStus Prolog user manuals for
     SICStus versions 0.5-0.7 by *Mats Carlsson* and *Johan Widen*
     [Car88], as well as from the Prolog ISO standard documentation
     [DEDC96].

   * Ciao is designed to be highly extendable in a modular way. Many
     of the libraries distributed with Ciao have been developed by
     other people all of which is impossible to mention here.
     Individual author names are included in the documentation of
     each library.

   * The development of the Ciao system has been supported in part by
     ESPRIT projects ACCLAIM, PARFORCE, and DISCIPL, and by CICYT/MEC
     project ELLA.

   If you feel you have contributed to the development of Ciao and we
have forgotten adding your name, please let us know and we will be
glad to give proper credits.


File: ciao.info,  Node: Known bugs and planned improvements (ciao),  Next: Version/Change Log (ciao),  Prev: Acknowledgments,  Up: Introduction

Known bugs and planned improvements (`ciao')
============================================

   * Although the documentation is acceptable at this point, we are
     still really in beta mode in this regard.


File: ciao.info,  Node: Version/Change Log (ciao),  Prev: Known bugs and planned improvements (ciao),  Up: Introduction

Version/Change Log (`ciao')
===========================

*Version 1.4 (1999/11/27, 19:0:0 MEST)*
        * Documentation greatly improved.

        * Automatic compilation of foreign files.

        * Concurrency primitives revamped; added multiengine
          capability.

        * Windows installation and functioning is now much better.

        * New version of OO library O'Ciao, with improved performance.

        * Added support for "predicate abstractions" in call/N.

        * Implemented reexportation through reexport declarations.

        * Changed precedence of importations, last one is the higher.

        * Modules can now implicitly export all predicates.

        * Many minor bugs fixed.

*Version 1.3 (1999/6/16, 17:5:58 MEST)*
     Development version following even 1.2.

*Version 1.2 (1999/6/14, 16:54:55 MEST)*
     Temporary version.

*Version 1.1 (1999/6/4, 13:30:37 MEST)*
     Development version following even 1.0.

*Version 1.0 (1999/6/4, 13:27:42 MEST)*
        * Added Tcl/Tk interface library.

        * Added push_prolog_flag/2 and pop_prolog_flag/1
          declarations/builtins.

        * Filename processing in Windows improved.

        * Added redefining/1 declaration to avoid redefining warnings.

        * Changed syntax/1 declaration to use_package/1.

        * Added add_clause_trans/1 declaration.

        * Changed format of .itf files such that a '+' stands for all
          the standard imports from engine, which are included in
          c_itf source internally (from engine(builtin_exports)).
          Further changes in itf data handling, so that once read in
          a session an .itf file, the file is cached and next time is
          needed no access to file system is required.

        * Many bugs fixed.

*Version 0.9 (1999/3/10, 17:3:49 CET)*
        * Many bugs fixed.

*Version 0.8 (1998/10/27, 13:12:36 MET)*
        * Changed compiler so that only one pass is done, eliminated
          `.dep' files.

        * New concurrency primitives.

        * Changed assertion comment to #

        * Implemented high-order with call/N.

        * Integrated sql-interface with persistent predicates.

        * First implementation of object oriented programming package.

        * Some bugs fixed.

*Version 0.7 (1998/9/15, 12:12:33 MEST)*
        * Improved debugger capabilities and made easier to use.

        * Simplified assertion format.

        * New arithmetic functions added, which complete all ISO
          functions.

        * Some bugs fixed.

*Version 0.6 (1998/7/16, 21:12:7 MET DST)*
        * Defining other path aliases (in addition to 'library')
          which can be loaded dynamically in executables is now
          possible.

        * Added the posibility to define multifile predicates in the
          shell.

        * Added the posibility to define dynamic predicates
          dynamically.

        * Added addmodule meta-argument type.

        * Implemented persistent data predicates.

        * Implemented WWW library PiLLoW.

        * Implemented active modules.

        * Implemented lazy loading in executables.

        * Modularized engine(builtin).

        * Some bugs fixed.

*Version 0.5 (1998/3/23)*
        * First Windows version.

        * Integrated debugger in toplevel.

        * Implemented DCG's.

        * Builtins renamed to match ISO-Prolog.

        * Made ISO the default syntax.

*Version 0.4 (1998/2/24)*
        * First version with ciao emacs mode.

        * Full integration of concurrent engine and compiler/library.

        * Added new_declaration/1 directive.

        * Added modular syntax enhancements.

        * Shell script interpreter separated from toplevel shell.

        * Added new compilation warnings.

*Version 0.3 (1997/8/20)*
        * Ciao builtins modularized.

        * New prolog flags can be defined by libraries.

        * Standalone comand-line compiler available, with automatic
          "make".

        * Added assertions and regular types.

        * First version using the automatic documentation generator.

*Version 0.2 (1997/4/16)*
        * First module system implemented.

        * Implemented exceptions using catch/3 and throw/1.

        * Added functional & record syntax.

        * Added modular sentence, term, and goal translations.

        * Implemented attributed variables.

        * First CLPQ/CLPR implementation.

        * Added the posibility of linking external .so files.

        * Changes in systax to allow `P(X)' and `"string"||L'.

        * Changed to be more similar to ISO-Prolog.

        * Implemented Prolog shell scripts.

        * Implemented data predicates.

*Version 0.1 (1997/2/13)*
     First Ciao version, based on &-prolog system.


File: ciao.info,  Node: Getting started,  Next: *** PART I - The program development environment,  Prev: Introduction,  Up: Top

Getting started
***************

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)


File: ciao.info,  Node: *** PART I - The program development environment,  Next: The stand-alone command-line compiler,  Prev: Getting started,  Up: Top

PART I - The program development environment
********************************************

   This part documents the components of the basic Ciao program
development environment. They include:

ciaoc:
     the standalone compiler, which creates executables without
     having to enter the interactive top-level.

ciaosh:
     (also invoked simply as `ciao') is an interactive top-level
     shell, similar to the one found on most Prolog systems (with
     some enhancements).

debugger.pl:
     a Byrd box-type debugger, similar to the one found on most
     Prolog systems (also with some enhancements). This is not a
     standalone application, but is rather included in `ciaosh', as
     in other Prolog systems.

ciao-shell:
     an interpreter/compiler for *Prolog scripts* (i.e., files
     containing Prolog code which run without needing explicit
     compilation).

ciao.el:
     a GNU emacs interface, which provides syntax coloring, atomatic
     location of errors, access to on-line manuals, etc. and greatly
     facilitates the interaction with the tools above.

   The Ciao program development environment also includes `ciaopp',
the preprocessor, and `lpdoc', the documentation generator, which are
described in separate manuals.


File: ciao.info,  Node: The stand-alone command-line compiler,  Next: The interactive top-level shell,  Prev: *** PART I - The program development environment,  Up: Top

The stand-alone command-line compiler
*************************************

   *Author(s):* Daniel Cabeza and the CLIP Group.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 0.9#103 (1999/5/30, 19:14:54 MEST)

   `ciaoc' is the Ciao stand-alone command-line compiler.  `ciaoc'
can be used to create executables or to compile individual files to
object code (to be later linked with other files). All these
considerations apply also if the compilation is performed from the
interactive top-level shell.

* Menu:

* Building executables::
* Paths used by the compiler during compilation::
* Running the executables generated by the compiler::
* Types of executables generated::
* Intermediate files in the compilation process::
* Usage (ciaoc)::


File: ciao.info,  Node: Building executables,  Next: Paths used by the compiler during compilation,  Prev: The stand-alone command-line compiler,  Up: The stand-alone command-line compiler

Building executables
====================

   An *executable* can be built from a single file or from a
collection of inter-related files. In the case of only one file, this
file must define the predicate `main/0' or `main/1'. This predicate
is the one which will be called when the executable is started. As an
example, consider the following file, called `hello.pl':

     main :-
          write('Hello world'),
          nl.

It can be compiled using the `ciaoc' standalone compiler as follows:

     /herme@clip:/tmp
     [60]> ciaoc hello
     
     /herme@clip:/tmp
     [61]>

This produces (in Un*x-like systems) an executable called `hello',
which can then run by simply typing its name:

     /herme@clip:/tmp
     [61]> hello
     Hello world

   If the application is composed of several files the process is
identical. Assume `hello.pl' is now:

     :- use_module(aux,[p/1]).
     
     main :-
          p(X),
          write(X),
          nl.

where the file `aux.pl' contains:

     :- module(aux,[p/1]).
     
     p('Hello world').

This can again be compiled using the `ciaoc' standalone compiler as
before:

     /herme@clip:/tmp
     [60]> ciaoc hello
     
     /herme@clip:/tmp
     [61]> hello
     Hello world

The invocation of `ciaoc hello' compiles the file `hello.pl' and all
connected files that may need recompilation - in this case the file
`aux.pl'. Also, if any library files used had not been compiled
previously they would be compiled at this point (See *Note
Intermediate files in the compilation process::). Also, if, say,
`hello.pl' is changed and recompiled, the object code resulting from
the previous compilation of `aux.pl' will be reused. This is all done
without any need for `Makefile's, and considerably accelerates the
development process for large applications. This process can be
observed by selecting the `-v' option when invoking `ciaoc' (which is
equivalent to setting the `verbose_compilation' Prolog flag in the
top-level interpreter).

   If `main/1' is defined instead of `main/0' then when the
executable is started the argument of `main/1' will be instantiated
to a list of atoms, each one of them corresponding to a command line
option. Consider the file `say.pl':

     main(Argv) :-
          write_list(Argv), nl.
     
     write_list([]).
     write_list([Arg|Args]) :-
          write(Arg),
          write(' '),
          write_list(Args).

Compiling it and running it results in the following output:

     /herme@clip:/tmp
     [91]> ciaoc say
     
     /herme@clip:/tmp
     [91]> say hello dolly
     hello dolly

   The name of the generated executable can be controlled with the
`-o' option (See *Note Usage (ciaoc)::).


File: ciao.info,  Node: Paths used by the compiler during compilation,  Next: Running the executables generated by the compiler,  Prev: Building executables,  Up: The stand-alone command-line compiler

Paths used by the compiler during compilation
=============================================

   The compiler will look for files mentioned in commands such as
`use_module/1' or `ensure_loaded/1' in the current directory. Other
paths can be added by including them in a file whose name is given to
`ciaoc' using the `-u' option. This file should contain facts of the
predicates `file_search_path/2' and `library_directory/1' (see the
documentation for these predicates and also *Note Customizing library
paths and path aliases:: for details).


File: ciao.info,  Node: Running the executables generated by the compiler,  Next: Types of executables generated,  Prev: Paths used by the compiler during compilation,  Up: The stand-alone command-line compiler

Running the executables generated by the compiler
=================================================

   What the `ciaoc' compiler generates and how it is started varies
somewhat from OS to OS. In general, the product of compiling an
application with `ciaoc' is a *shell script* that contains the
bytecode (the product of the compilation) and invokes the Ciao engine
on it (see the first lines of the file). To run the generated
executable from a Un*x shell, or from the `bash' shell that comes
with the Cygwin libraries (See *Note Installation and compilation
under Windows::) it suffices to type its name at the shell command
line, as in the examples above. In a raw Win32 system, an additional
`.bat' file is typically needed to start the application from the
command line (or by double-clicking on it). The procedure for
creating this `.bat' file changes somewhat depending on the Win32
operating system used. In Windows NT you can simply copy
`winNT_skel.bat' (located in the `win32' directory of the Ciao Prolog
distribution) to the directory where the application is, and rename
it to the name of the application to run (+ the `.bat' suffix). In
Windows 95/98 you have to use the file `win95_skel.bat' and change
its name as before, but in addition you need to edit it to include
the absolute path to the Ciao executable. We apologize for this
(temporary) inconvenience, which we will try to smooth out in the
near future by generating these `.bat' files automatically.


File: ciao.info,  Node: Types of executables generated,  Next: Intermediate files in the compilation process,  Prev: Running the executables generated by the compiler,  Up: The stand-alone command-line compiler

Types of executables generated
==============================

   While the default options used by `ciaoc' are sufficient for
normal use, by selecting other options `ciaoc' can generate several
different types of executables, which offer interesting tradeoffs
among size of the generated executable, portability, and startup time:

Dynamic executables:
     `ciaoc' produces by default *dynamic* executables. In this case
     the executable produced is a platform-independent file which
     includes in compiled form all the user defined files. On the
     other hand, any system libraries used by the application are
     loaded dynamically at startup. More precisely, any files that
     appear as `library(...)' in `use_module/1' and `ensure_loaded/1'
     declarations will not be included explicitly in the executable
     and will intead be loaded dynamically. Is is also possible to
     mark other path aliases (see the documentation for
     `file_search_path/2') for dynamic loading by using the `-d'
     option. Files accessed through such aliases will also be loaded
     dynamically.

     Dynamic loading allows making smaller executables. Such
     executables may be used directly in the same machine in which
     they were compiled, since suitable paths to the location of the
     libraries will be included as default in the executable by
     `ciaoc' during compilation.

     The executable can also be used in another machine, even if the
     architecture and OS are different. The requirement is that the
     Ciao libraries (which will also include the appropriate Ciao
     engine for that architecture and OS) be installed in the target
     machine, and that the `CIAOLIB' and `CIAOENGINE' environment
     variables are set appropriately for the executable to be able to
     find them (see *Note Environment variables used by Ciao
     executables::). How to do this differs slightly from OS to OS.

Static executables:
     Selecting the `-s' option `ciaoc' produces a *static*
     executable. In this case the executable produced (again a
     platform-independent file) will include in it all the auxiliary
     files and any system libraries needed by the application. Thus,
     such an executable is almost complete, needing in order to run
     only the Ciao engine, which is platform-specific.(1) Again, if
     the executable is run in the same machine in which it was
     compiled then the engine is found automatically. If the
     executable is moved to another machine, the executable only
     needs access to a suitable engine (which can be done by setting
     the `CIAOENGINE' environment variable to point to this engine).

     This type of compilation produces larger executables, but has
     the advantage that these executables can be installed and run in
     a different machine, with different architecture and OS, even if
     Ciao is not installed on that machine. To install (or
     distribute) such an executable, one only needs to copy the
     executable file itself and the appropriate engine for the target
     platform (See *Note Installing Ciao:: and *Note
     Multiarchitecture support::), and to set things so that the
     executable can find the engine. (2)

Dynamic executables, with lazy loading:
     Selecting the `-ll' option is very similar to the case of
     dynamic executables above, except that the code in the library
     modules is not loaded when the program is started but rather it
     is done during execution, the first time a predicate defined in
     that file is called. This is advantageous if a large application
     is composed of many parts but is such that typically only some
     of the parts are used in each invocation. The Ciao preprocessor,
     `ciaopp', is a good example of this: it has many capabilitites
     but typically only some of them are used in a given session. An
     executable with lazy load has the advantage that it starts fast,
     loading a minimal functionality on startup, and then loads the
     different modules automatically as needed.

   ---------- Footnotes ----------

   (1) Currently there is an exception to this related to libraries
which are written in languages other than Prolog, as, e.g., C. C
files are currently always compiled to dynamically loadable object
files (`.so' files), and they thus need to be included manually in a
distribution of an application. This will be automated in upcoming
versions of the Ciao system.

   (2) It is also possible to produce real standalone executables,
i.e., executables that do not need to have an engine around. However,
this is not automated yet, although it is planned for an upcoming
version of the compiler. In particular, the compiler can generate a
`.c' file for each `.pl' file. Then all the `.c' files can be
compiled together into a real executable (the engine is added one
more element during link time) producing a complete executable for a
given architecture. The downside of course is that such an executable
will not be portable to other architectures without recompilation.


File: ciao.info,  Node: Intermediate files in the compilation process,  Next: Usage (ciaoc),  Prev: Types of executables generated,  Up: The stand-alone command-line compiler

Intermediate files in the compilation process
=============================================

   Compiling an individual source (i.e., `.pl') file produces a
`.itf' file and a `.po' file. The `.itf' file contains information of
the *modular interface* of the file, such as information on exported
and imported predicates and on the other modules used by this module.
This information is used to know if a given file should be recompiled
at a given point in time and also to be able to detect more errors
statically including undefined predicates, mismatches on predicate
charaterictics across modules, etc. The `.po' file contains the
platform-independent object code for a file, ready for linking
(statically or dynamically).

   It is also possible to use `ciaoc' to explicitly generate the
`.po' file for one or more `.pl' files by using the `-c' option.


File: ciao.info,  Node: Usage (ciaoc),  Prev: Intermediate files in the compilation process,  Up: The stand-alone command-line compiler

Usage (ciaoc)
=============

   The following provides details on the different command line
options available when invoking `ciaoc':

     ciaoc <MiscOpts> <ExecOpts> [-o <execname>] <file> ...
     
       Make an executable from the listed files.  If there is
       more than one file, they must be non-module, and the
       first one must include the main predicate.  The -o
       option allows generating an arbitrary executable name.
     
     ciaoc <MiscOpts> <ExecOpts> -a <publishmod> <module>
     
       Make an active module executable from <module> with
       address publish module <publishmod>.
     
     ciaoc <MiscOpts> -c  <file> ...
     
       Compile listed files (make .po objects).
     
     <MiscOpts> can be: [-v] [-u <file>]
     
     -v  verbose mode
     
     -u  use <file> for compilation
     
     <ExecOpts> can be: [-s|-e|-l|(-ll <module>)*] (-d <alias>)*
     
     -s  make a static executable (otherwise dynamic files are not included)
     
     -e  make executable with eager load of dynamic files at startup (default)
     
     -l  idem with lazy load of dynamic files (except insecure cases)
     
     -ll force <module> to be loaded lazily,  implies -l
     
     -d  files using this path alias are dynamic (default: library)
     
     default extension for files is '.pl'


File: ciao.info,  Node: The interactive top-level shell,  Next: The interactive debugger,  Prev: The stand-alone command-line compiler,  Up: Top

The interactive top-level shell
*******************************

   *Author(s):* Daniel Cabeza and the CLIP Group.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 1.3#105 (1999/11/18, 12:44:18 MET)

   `ciaosh' is the CIAO interactive top-level shell. It provides the
user an interactive programming environment with tools for
incrementally building programs, debugging programs by following
their executions, and modifying parts of programs without having to
start again from scratch. If available, it is strongly recommended to
use it with the emacs interface provided, as it greatly simplifies
the operation. This chapter documents general operation in the shell.
Subsequent chapters document the relevant exported predicates of the
modules which provide functionalities to the shell.

* Menu:

* Shell invocation and startup::
* Shell interaction::
* Entering recursive (conjunctive) shell levels::
* Usage and interface (ciaosh)::
* Documentation on exports (ciaosh)::
* Documentation on internals (ciaosh)::


File: ciao.info,  Node: Shell invocation and startup,  Next: Shell interaction,  Prev: The interactive top-level shell,  Up: The interactive top-level shell

Shell invocation and startup
============================

   When invoked, the shell responds with a message of identification
and the prompt `?- ' as soon as it is ready to accept input, thus:

     CIAO 0.9 #21: Thu Mar 25 17:20:55 MET 1999
     ?-

   When the shell is initialized it looks for a file `.ciaorc' in the
HOME directory and makes an `include' of it, if it exists. This file
is useful for including `use_module/1' declarations for the modules
one wants to be loaded by default, changing prolog flags, etc. If the
initialization file does not exist, the ISO-Prolog compatibility
package `iso' is included, to provide (almost) all the ISO builtins
by default. Two command-line options control the loading of the
initialization file:

`-f'
     Fast start, do not load any initialization file.

`-l' `File'
     Look for initialization file `File' instead of `~/.ciaorc'. If
     it does not exist, include the compatibility package `iso'.


File: ciao.info,  Node: Shell interaction,  Next: Entering recursive (conjunctive) shell levels,  Prev: Shell invocation and startup,  Up: The interactive top-level shell

Shell interaction
=================

   After the shell outputs the prompt, it is expecting either an
internal command (see the following sections) or a *query* (a goal or
sequence of goals). When typing in the input, which must be a valid
prolog term, if the term does not end in the first line, subsequent
lines are indented. For example:

     ?- X =
        f(a,
        b).
     
     X = f(a,b) ?
     
     yes
     ?-

   The queries are executed by the shell as if they appeared in the
user module. Thus, in addition to builtin predicates, predicates
available to be executed directly are all predicates defined by
loaded user files (files with no module declaration), and imported
predicates from modules by the use of `use_module'.

   The possible answers of the shell, after executing an internal
command or query, are:

   * If the execution failed (or produced an error), the answer is
     `no'.

   * If the execution was successful, and no answer variable (see
     below) was bound (or constraints where imposed on such
     variables), the answer is simply `yes'.

   * If the execution was successful and bindings where made (or
     constraints where imposed) on answer variables, then the shell
     outputs the values of answer variables, as a sequence of
     bindings (or constraints), and then prints a `?' as a prompt. At
     this point it is expecting an input line from the user. By
     entering a carriage-return (<RET>) or any line starting with
     `y', the query terminates and the shell answer `yes'. Entering a
     ``,'' the shell enters a recursive level (see below). Finally,
     any other answer forces the system to backtrack and look for the
     next solution (answering as with the first solution).

   To allow using connection variables in queries without having to
report their results, variables whose name starts with `_' are not
considered in answers, the rest being the *answer variable*s. This
example illustrates the previous points:

     ?- member(a, [b, c]).
     
     no
     ?- member(a, [a, b]).
     
     yes
     ?- member(X, [a|L]).
     
     X = a ? ;
     
     L = [X|_] ?
     
     yes
     ?- atom_codes(ciao, _C), member(L, _C).
     
     L = 99 ? ;
     
     L = 105 ? ;
     
     L = 97 ? ;
     
     L = 111 ? ;
     
     no
     ?-


File: ciao.info,  Node: Entering recursive (conjunctive) shell levels,  Next: Usage and interface (ciaosh),  Prev: Shell interaction,  Up: The interactive top-level shell

Entering recursive (conjunctive) shell levels
=============================================

   As stated before, when the user answers with ``,'' after a
solution is presented, the shell enters a *recursive level*, changing
its prompt to *N* `?- ' (where *N* is the recursion level) and
keeping the bindings or constraints of the solution (this is inspired
by the *LogIn* language developed by *H. Ait-Kaci*, *P. Lincoln* and
*Roger Nasr* [AKNL86]). Thus, the following queries will be executed
within that context, and all variables in the lower level solutions
will be reported in subsequent solutions at this level. To exit a
recursive level, input an <EOF> character or the command `up'. The
last solution after entering the level is repeated, to allow asking
for more solutions. Use command `top' to exit all recursive levels
and return to the top level. Example interaction:

     ?- directory_files('.',_Fs), member(F,_Fs).
     
     F = 'file_utils.po' ? ,
     
     1 ?- file_property(F, mod_time(T)).
     
     F = 'file_utils.po',
     T = 923497679 ?
     
     yes
     1 ?- up.
     
     F = 'file_utils.po' ? ;
     
     F = 'file_utils.pl' ? ;
     
     F = 'file_utils.itf' ? ,
     
     1 ?- file_property(F, mod_time(T)).
     
     F = 'file_utils.itf',
     T = 923497679 ?
     
     yes
     1 ?- ^D
     F = 'file_utils.itf' ?
     
     yes
     ?-


File: ciao.info,  Node: Usage and interface (ciaosh),  Next: Documentation on exports (ciaosh),  Prev: Entering recursive (conjunctive) shell levels,  Up: The interactive top-level shell

Usage and interface (`ciaosh')
==============================

   * *Library usage:*

     The following predicates can be used at the top-level shell
     natively (but see also *Note The interactive debugger::).

   * *Exports:*
        - *Predicates:*

          `use_module/1', `use_module/2', `ensure_loaded/1',
          `include/1', `use_package/1', `consult/1', `compile/1',
          `./2', `make_po/1', `unload/1', `set_debug_mode/1',
          `set_nodebug_mode/1', `make_actmod/2', `force_lazy/1',
          `undo_force_lazy/1', `dynamic_search_path/1', `multifile/1'.

   * *Other modules used:*
        - *Application modules:*

          `toplev'.

        - *System library modules:*

          `libpaths', `compiler/compiler', `compiler/exemaker',
          `compiler/c_itf', `debugger'.



File: ciao.info,  Node: Documentation on exports (ciaosh),  Next: Documentation on internals (ciaosh),  Prev: Usage and interface (ciaosh),  Up: The interactive top-level shell

Documentation on exports (`ciaosh')
===================================

 - PREDICATE: use_module/1:
     *Usage:* `use_module(Module)'
        - *Description:* Load into the top-level the module defined
          in `Module', importing all the predicates it exports.

        - *The following properties should hold at call time:*

          `Module' is a source name.   (`streams_basic:sourcename/1')

 - PREDICATE: use_module/2:
     *Usage:* `use_module(Module,Imports)'
        - *Description:* Load into the top-level the module defined
          in `Module', importing the predicates in `Imports'.

        - *The following properties should hold at call time:*

          `Module' is a source name.   (`streams_basic:sourcename/1')

          `Imports' is a list of `predname's.   (`basic_props:list/2')

 - PREDICATE: ensure_loaded/1:
     *Usage:* `ensure_loaded(File)'
        - *Description:* Load into the top-level the code residing in
          file (or files) `File', which is user (i.e. non-module)
          code.

        - *The following properties should hold at call time:*

          `File' is a source name or a list of source names.
          (`ciaosh_doc:sourcenames/1')

 - PREDICATE: include/1:
     *Usage:* `include(File)'
        - *Description:* The contents of the file `File' are included
          in the top-level shell. For the moment, it only works with
          some directives, which are interpreted by the shell, or
          with normal clauses (which are asserted), if
          library(dynamic) is loaded beforehand.

        - *The following properties should hold at call time:*

          `File' is a source name.   (`streams_basic:sourcename/1')

 - PREDICATE: use_package/1:
     *Usage:* `use_package(Package)'
        - *Description:* Equivalent to issuing an
          include(library(`Package')) for each listed file. By now
          some package contents cannot be handled.

        - *The following properties should hold at call time:*

          `Package' is a source name or a list of source names.
          (`ciaosh_doc:sourcenames/1')

 - PREDICATE: consult/1:
     *Usage:* `consult(File)'
        - *Description:* Provided for backward compatibility. Similar
          to `ensure_loaded/1', but ensuring each listed file is
          loaded in consult mode (see *Note The interactive
          debugger::).

        - *The following properties should hold at call time:*

          `File' is a source name or a list of source names.
          (`ciaosh_doc:sourcenames/1')

 - PREDICATE: compile/1:
     *Usage:* `compile(File)'
        - *Description:* Provided for backward compatibility. Similar
          to `ensure_loaded/1', but ensuring each listed file is
          loaded in compile mode (see *Note The interactive
          debugger::).

        - *The following properties should hold at call time:*

          `File' is a source name or a list of source names.
          (`ciaosh_doc:sourcenames/1')

 - PREDICATE: ./2:
     *Usage:* `[File|Files]'
        - *Description:* Provided for backward compatibility,
          obsoleted by `ensure_loaded/1'.

        - *The following properties should hold at call time:*

          `File' is a source name.   (`streams_basic:sourcename/1')

          `Files' is a list of `sourcename's.   (`basic_props:list/2')

 - (: UNDOC_REEXPORT) MAKE_EXEC/2:
     Imported from `toplev' (see the corresponding documentation for
     details).


 - PREDICATE: make_po/1:
     *Usage:* `make_po(Files)'
        - *Description:* Make object (`.po') files from `Files'.
          Equivalent to executing "`ciaoc -c'" on the files.

        - *The following properties should hold at call time:*

          `Files' is a source name or a list of source names.
          (`ciaosh_doc:sourcenames/1')

 - PREDICATE: unload/1:
     *Usage:* `unload(File)'
        - *Description:* Unloads dynamically loaded file `File'.

        - *The following properties should hold at call time:*

          `File' is a source name.   (`streams_basic:sourcename/1')

 - PREDICATE: set_debug_mode/1:
     *Usage:* `set_debug_mode(File)'
        - *Description:* Set the loading mode of `File' to *consult*.
          See *Note The interactive debugger::.

        - *The following properties should hold at call time:*

          `File' is a source name.   (`streams_basic:sourcename/1')

 - PREDICATE: set_nodebug_mode/1:
     *Usage:* `set_nodebug_mode(File)'
        - *Description:* Set the loading mode of `File' to *compile*.
          See *Note The interactive debugger::.

        - *The following properties should hold at call time:*

          `File' is a source name.   (`streams_basic:sourcename/1')

 - PREDICATE: make_actmod/2:
     *Usage:* `make_actmod(ModuleFile,PublishMod)'
        - *Description:* Make an active module executable from the
          module residing in `ModuleFile', using address publish
          module of name `PublishMod' (which needs to be in the
          library paths).

        - *The following properties should hold at call time:*

          `ModuleFile' is a source name.
          (`streams_basic:sourcename/1')

          `PublishMod' is an atom.   (`basic_props:atm/1')

 - PREDICATE: force_lazy/1:
     *Usage:* `force_lazy(Module)'
        - *Description:* Force module of name `Module' to be loaded
          lazily in the subsequent created executables.

        - *The following properties should hold at call time:*

          `Module' is an atom.   (`basic_props:atm/1')

 - PREDICATE: undo_force_lazy/1:
     *Usage:* `undo_force_lazy(Module)'
        - *Description:* Disable a previous `force_lazy/1' on module
          `Module' (or, if it is uninstantiated, all previous
          `force_lazy/1').

        - *Calls should, and exit will be compatible with:*

          `Module' is an atom.   (`basic_props:atm/1')

 - PREDICATE: dynamic_search_path/1:
     *Usage:* `dynamic_search_path(Name)'
        - *Description:* Asserting a fact to this data predicate,
          files using path alias `Name' will be treated as dynamic in
          the subsequent created executables.

        - *The following properties should hold at call time:*

          `Name' is an atom.   (`basic_props:atm/1')

 - PREDICATE: multifile/1:
     *Usage:* `multifile Pred'
        - *Description:* Dynamically declare predicate `Pred' as
          multifile. This is useful at the top-level shell to be able
          to call multifile predicates of loaded files.

        - *The following properties should hold at call time:*

          `Pred' is a Name/Arity structure denoting a predicate name:
               predname(P/A) :-
                       atm(P),
                       int(A).

          (`basic_props:predname/1')


File: ciao.info,  Node: Documentation on internals (ciaosh),  Prev: Documentation on exports (ciaosh),  Up: The interactive top-level shell

Documentation on internals (`ciaosh')
=====================================

 - PROPERTY: sourcenames/1:
     Is defined as follows:
          sourcenames(File) :-
                  sourcename(File).
          sourcenames(Files) :-
                  list(Files,sourcename).
     See `sourcename/1' in *Note Basic file/stream handling::

     *Usage:* `sourcenames(Files)'
        - *Description:* `Files' is a source name or a list of source
          names.


File: ciao.info,  Node: The interactive debugger,  Next: Predicates controlling the interactive debugger,  Prev: The interactive top-level shell,  Up: Top

The interactive debugger
************************

   The Ciao program development environment includes a number of
advanced debugging tools, such as the `ciaopp' preprocessor and some
execution visualizers. Herein we discuss the interactive debugger
available in the standard top-level, which allows to trace the
control flow of programs, similar to other popular Prolog systems.
This is a classical Byrd 'box-type' *debugger* [Byr80,BBP81], with
some enhancements.

   Byrd's Procedure Box model of debugging execution provides a
simple way of visualising control flow, especially during
backtracking. Control flow is viewed at the predicate level, rather
than at the level of individual clauses. The Ciao debugger has the
ability to mark selected modules and/or files for debugging, rather
than having to exhaustively trace your program. It also allows to
selectively set spy-points. Spy-points allow the programmer to
nominate interesting predicates at which program execution is to
pause so that the programmer can interact with the debugger. There is
a wide choice of control and information options available during
debugging interaction.

* Menu:

* Marking modules and files for debugging::
* The debugging process::
* The procedure box control flow model::
* Format of debugging messages::
* Options available during debugging::


File: ciao.info,  Node: Marking modules and files for debugging,  Next: The debugging process,  Prev: The interactive debugger,  Up: The interactive debugger

Marking modules and files for debugging
=======================================

   Usually, when a program is not working properly, the programmer
has a feeling of which are the modules where the fault may be. Since
full-fledged debugging is only available on *consulted* (interpreted)
modules, which are executed much slower than compiled modules, there
is the posibility of telling the top level which particular modules
are wanted to be loaded in *consult mode*, with the aim of debugging
them. The most simple way of achieving this (appart from using the
Ciao `emacs' mode, which includes special support for debugging) is
executing in the Ciao shell prompt, for each suspicious module
`Module' in the program, a command like this:

     ?- debug_module(Module).

Note that files without module declaration belong to the module user,
so the command to be issued for debugging a user file, say 'foo.pl',
would be `debug_module(user)', and not `debug_module(foo)'.

   The above command performs in fact two related things: on the one
hand, it instructs the compiler to load any file containing a module
of this name in consult mode; on the other, it instructs the debugger
to actually prepare for debugging the code belonging to that module.
After that, the modules which are to be debugged have to be
(re)loaded in any appropriate form. The nice thing is that, if the
modules are part of a bigger application, a command to load the main
application file will automatically force loading the dependent
modules which have changed, including those whose loading mode has
changed, thus allowing the debugging of required files.

   Later, as the bug location is isolated, one would want to restrict
more and more the modules where debugging takes place. To this end,
and without the need of reloading, one can tell the debugger to not
consider a module for debugging issuing a `nodebug_module/1' command,
which counteracts a `debug_module/1' command with the same module
name.

   There exist also the top-level commands `set_debug_mode/1' and
`set_nodebug_mode/1', which accept as argument a file spec (i.e.,
`library(foo)' or `foo', even if it is a user file) to be able to
load a file in consult mode without changing the set of modules the
debugger will try to spy.


File: ciao.info,  Node: The debugging process,  Next: The procedure box control flow model,  Prev: Marking modules and files for debugging,  Up: The interactive debugger

The debugging process
=====================

   Once modules or user files are marked for debugging and reloaded,
the traditional debugging shell commands can be used (the `debugger'
library following this section contains all the commands and their
description), with the same meaning as in other Prolog systems such as
SICStus. The difference in their behavior is that in Ciao debugging
takes place only in the modules in which it was activated, and that
`nospy/1' and `spy/1' accept sequences of predicate specs, and they
will search for those predicates only in the debugging-marked modules.


File: ciao.info,  Node: The procedure box control flow model,  Next: Format of debugging messages,  Prev: The debugging process,  Up: The interactive debugger

The procedure box control flow model
====================================

   During debugging the interpreter prints out a sequence of goals in
various states of instantiation in order to show the state the
program has reached in its execution. However, in order to understand
what is occurring it is necessary to understand when and why the
interpreter prints out goals. As in other programming languages, key
points of interest are procedure entry and return, but in Prolog
there is the additional complexity of backtracking. One of the major
confusions that novice Prolog programmers have to face is the
question of what actually happens when a goal fails and the system
suddenly starts backtracking. The Procedure Box model of Prolog
execution views program control flow in terms of movement about the
program text. This model provides a basis for the debugging mechanism
in the interpreter, and enables the user to view the behaviour of the
program in a consistent way.

   Let us look at an example Prolog procedure:


[Image file: autofigbyrdbox.eps]

   The first clause states that `Y' is a descendant of `X' if `Y' is
an offspring of `X', and the second clause states that `Z' is a
descendant of `X' if `Y' is an offspring of `X' and if `Z' is a
descendant of `Y'. In the diagram a box has been drawn around the
whole procedure and labelled arrows indicate the control flow in and
out of this box. There are four such arrows which we shall look at in
turn.

   * Call

     This arrow represents initial invocation of the procedure. When
     a goal of the form `descendant(X,Y)' is required to be
     satisfied, control passes through the Call port of the
     descendant box with the intention of matching a component clause
     and then satisfying any subgoals in the body of that clause.
     Note that this is independent of whether such a match is
     possible; i.e. first the box is called, and then the attempt to
     match takes place. Textually we can imagine moving to the code
     for descendant when meeting a call to descendant in some other
     part of the code.

   * Exit

     This arrow represents a successful return from the procedure.
     This occurs when the initial goal has been unified with one of
     the component clauses and any subgoals have been satisfied.
     Control now passes out of the Exit port of the descendant box.
     Textually we stop following the code for descendant and go back
     to the place we came from.

   * Redo

     This arrow indicates that a subsequent goal has failed and that
     the system is backtracking in an attempt to find alternatives to
     previous solutions. Control passes through the Redo port of the
     descendant box. An attempt will now be made to resatisfy one of
     the component subgoals in the body of the clause that last
     succeeded; or, if that fails, to completely rematch the original
     goal with an alternative clause and then try to satisfy any
     subgoals in the body of this new clause. Textually we follow the
     code backwards up the way we came looking for new ways of
     succeeding, possibly dropping down on to another clause and
     following that if necessary.

   * Fail

     This arrow represents a failure of the initial goal, which might
     occur if no clause is matched, or if subgoals are never
     satisfied, or if any solution produced is always rejected by
     later processing. Control now passes out of the Fail port of the
     descendant box and the system continues to backtrack. Textually
     we move back to the code which called this procedure and keep
     moving backwards up the code looking for choice points.

   In terms of this model, the information we get about the procedure
box is only the control flow through these four ports. This means
that at this level we are not concerned with which clause matches,
and how any subgoals are satisfied, but rather we only wish to know
the initial goal and the final outcome. However, it can be seen that
whenever we are trying to satisfy subgoals, what we are actually
doing is passing through the ports of *their* respective boxes. If we
were to follow this, then we would have complete information about
the control flow inside the procedure box.

   Note that the box we have drawn around the procedure should really
be seen as an invocation box. That is, there will be a different box
for each different invocation of the procedure. Obviously, with
something like a recursive procedure, there will be many different
Calls and Exits in the control flow, but these will be for different
invocations. Since this might get confusing each invocation box is
given a unique integer identifier.


File: ciao.info,  Node: Format of debugging messages,  Next: Options available during debugging,  Prev: The procedure box control flow model,  Up: The interactive debugger

Format of debugging messages
============================

   This section explains the exact format of the message output by
the debugger at a port. All trace messages are output to the terminal
regardless of where the current output stream is directed (which
allows tracing programs while they are performing file IO). The basic
format is as follows:

     S  13  7  Call: T user:descendant(dani,_123) ?

   `S' is a spy-point indicator. It is printed as '`+'', indicating
that there is a spy-point on `descendant/2' in module `user', or as '
', denoting no spy-point.

   `T' is a subterm trace. This is used in conjunction with the `^'
command (set subterm), described below. If a subterm has been
selected, `T' is printed as the sequence of commands used to select
the subterm. Normally, however, `T' is printed as ' ', indicating
that no subterm has been selected.

   The first number is the unique invocation identifier. It is always
nondecreasing (provided that the debugger is switched on) regardless
of whether or not the invocations are being actually seen. This
number can be used to cross correlate the trace messages for the
various ports, since it is unique for every invocation. It will also
give an indication of the number of procedure calls made since the
start of the execution. The invocation counter starts again for every
fresh execution of a command, and it is also reset when retries (see
later) are performed.

   The number following this is the *current depth*; i.e., the number
of direct *ancestors* this goal has. The next word specifies the
particular port (`Call', `Exit', `Redo' or `Fail'). The goal is then
printed so that its current instantiation state can be inspected. The
final `?' is the prompt indicating that the debugger is waiting for
user interaction. One of the option codes allowed (see below) can be
input at this point.

   Ports can be unleashed. This means that the debugger will not stop
for interaction at the messages for an unleashed port. Obviously, the
`?' prompt will not be shown in such messages, since the user has
specified to not wish to interact at this point.

   Note that not all procedure calls are traced; there are a few
basic predicates which have been made invisible since it is more
convenient not to trace them. These include debugging directives,
basic control structures, and some builtins. This means that messages
will never be printed concerning these predicates during debugging.


File: ciao.info,  Node: Options available during debugging,  Prev: Format of debugging messages,  Up: The interactive debugger

Options available during debugging
==================================

   This section describes the particular options that are available
when the debugger prompts after printing out a debugging message. All
the options are one letter mnemonics, some of which can be optionally
followed by a decimal integer. They are read from the terminal with
any blanks being completely ignored up to the next terminator
(carriage-return, line-feed, or escape). Some options only actually
require the terminator; e.g., the creep option, only requires <RET>.

   The only option which do really needs to be remembered is '`h''
(followed by <RET>). This provides help in the form of the following
list of available options.

     <cr>   creep            c      creep
      l     leap             s      skip
      r     retry            r <i>  retry i
      f     fail             f <i>  fail i
      d     display          p      print
      w     write
      g     ancestors        g <n>  ancestors n
      n     nodebug          =      debugging
      +     spy this         -      nospy this
      a     abort            b      break
      @     command          u      unify
      <     reset printdepth < <n>  set printdepth
      ^     reset subterm    ^ <n>  set subterm
      ?     help             h      help

   * `c' *creep* causes the debugger to single-step to the very next
     port and print a message. Then if the port is leashed the user
     is prompted for further interaction. Otherwise it continues
     creeping. If leashing is off, creep is the same as leap (see
     below) except that a complete trace is printed on the terminal.

   * `l' *leap* causes the interpreter to resume running the program,
     only stopping when a spy-point is reached (or when the program
     terminates). Leaping can thus be used to follow the execution at
     a higher level than exhaustive tracing. All that is needed to do
     is to set spy-points on an evenly spread set of pertinent
     predicates, and then follow the control flow through these by
     leaping from one to the other.

   * `s' *skip* is only valid for Call and Redo ports. It skips over
     the entire execution of the predicate. That is, no message will
     be seen until control comes back to this predicate (at either
     the Exit port or the Fail port). Skip is particularly useful
     while creeping since it guarantees that control will be returned
     after the (possibly complex) execution within the box. With skip
     then no message at all will appear until control returns. This
     includes calls to predicates with spy-points set; they will be
     masked out during the skip. There is a way of overriding this:
     the `t' option after a <^C> interrupt will disable the masking.
     Normally, however, this masking is just what is required!

   * `r' *retry* can be used at any of the four ports (although at
     the Call port it has no effect). It transfers control back to
     the Call port of the box. This allows restarting an invocation
     when, for example, it has left the programmer with some weird
     result. The state of execution is exactly the same as in the
     original call, (unless the invocation has performed side
     effects, which will not be undone). When a retry is performed
     the invocation counter is reset so that counting will continue
     from the current invocation number regardless of what happened
     before the retry. This is in accord with the fact that execution
     has, in operational terms, returned to the state before anything
     else was called.

     If an integer is supplied after the retry command, then this is
     taken as specifying an invocation number and the system tries to
     get to the Call port, not of the current box, but of the
     invocation box specified. It does this by continuously failing
     until it reaches the right place. Unfortunately this process
     cannot be guaranteed: it may be the case that the invocation
     then programmer is looking for has been cut out of the search
     space by cuts in the program. In this case the system fails to
     the latest surviving Call port before the correct one.

   * `f' *fail* can be used at any of the four ports (although at the
     Fail port it has no effect). It transfers control to the Fail
     port of the box, forcing the invocation to fail prematurely. If
     an integer is supplied after the command, then this is taken as
     specifying an invocation number and the system tries to get to
     the Fail port of the invocation box specified. It does this by
     continuously failing until it reaches the right place.
     Unfortunately, as before, this process cannot be guaranteed.

   * `d' displays the current goal using `display/1'. See write
     (below).

   * `p' re-prints the current goal using `print/1'. Nested
     structures will be printed to the specified *printdepth* (below).

   * `w' writes the current goal on the terminal using `write/1'.

   * `g' provides a list of ancestors to the current goal, i.e., all
     goals that are hierarchically above the current goal in the
     calling sequence. It is always possible to jump to any goal in
     the ancestor list (by using retry, etc.). If an integer `n' is
     supplied, then only `n' ancestors will be printed. That is to
     say, the last `n' ancestors will be printed counting back from
     the current goal. Each entry in the list is preceded by the
     invocation number followed by the depth number (as would be
     given in a trace message).

   * `n' switches the debugger off. Note that this is the correct way
     to switch debugging off at a trace point. The `@' or `b' options
     cannot be used because they always return to the debugger.

   * `=' outputs information concerning the status of the current
     debugging session.

   * `+' *spy* sets a spy-point on the current goal.

   * `-' *nospy* removes the spy-point from the current goal.

   * `a' *abort* causes an abort of the current execution. All the
     execution states built so far are destroyed and the system is
     put right back at the top-level of the interpreter. (This is the
     same as the built-in predicate `abort/0'.)

   * `b' *break* introduces an interpreter break-point: current
     execution flow is suspended, and a new interpreter top-level
     started 'on top' of the previous execution, which is 'sitting
     underneath' it. When the break-point is ended (with <^D>)
     previous execution is resumed, and the user will be reprompted
     at the port at which execution broke. The new execution is
     completely separate from the suspended one; the invocation
     numbers will start again from 1 during the break. The debugger
     is temporarily switched off as the break-point is called and
     will be re-switched on when the break is finished. However, any
     changes to the leashing or to spy-points will remain in effect.
     (This option might not be temporarily available.)

   * `@' *command* allows calling arbitrary goals. It is effectively
     a one-off break (see above). The initial message `| :- ' will be
     output on the terminal, and a command is then read from the
     terminal and executed as if it was at top-level.

   * `u' *unify* is available at the Call port and gives the option
     of providing a solution to the goal from the terminal rather
     than executing the goal. This is convenient, e.g., for providing
     a "stub" for a predicate that has not yet been written. A prompt
     `|: ' will be output on the terminal, and the solution is then
     read from the terminal and unified with the goal. (This option
     might not be temporarily available.)

   * `<' *printdepth* sets a limit for the subterm nesting level that
     is printed in messages. While in the debugger, a printdepth is
     in effect for limiting the subterm nesting level when printing
     the current goal. When displaying or writing the current goal,
     all nesting levels are shown. The limit is initially 10. This
     command, without arguments, resets the limit to 10. With an
     argument of `n' the limit is set to `n'.

   * `^' *subterm* sets the subterm to be printed in messages. While
     at a particular port, a current subterm of the current goal is
     maintained. It is the current subterm which is displayed,
     printed, or written when prompting for a debugger command. Used
     in combination with the printdepth, this provides a means for
     navigating in the current goal for focusing on the part which is
     of interest. The current subterm is set to the current goal when
     arriving at a new port. This command, without arguments, resets
     the current subterm to the current goal. With an argument of `n'
     (greater than 0 and less or equal to the number of subterms of
     the current subterm), the current subterm is replaced by its
     `n''th subterm. With an argument of `0', the current subterm is
     replaced by its parent term.

   * `?' or `h' displays the table of options given above.


File: ciao.info,  Node: Predicates controlling the interactive debugger,  Next: The script interpreter,  Prev: The interactive debugger,  Up: Top

Predicates controlling the interactive debugger
***********************************************

   *Author(s):* A. Ciepielewski, M. Carlsson, T. Chikayama, K. Shen,
D. Cabeza.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 1.3#104 (1999/11/17, 22:5:53 MET)

   This library implements predicates which are normally used in the
interactive top-level shell to debug programs.

* Menu:

* Usage and interface (debugger)::
* Documentation on exports (debugger)::
* Documentation on internals (debugger)::


File: ciao.info,  Node: Usage and interface (debugger),  Next: Documentation on exports (debugger),  Prev: Predicates controlling the interactive debugger,  Up: Predicates controlling the interactive debugger

Usage and interface (`debugger')
================================

   * *Library usage:*

     `:- use_module(library(debugger)).'

   * *Exports:*
        - *Predicates:*

          `debug_module/1', `nodebug_module/1', `debug/0',
          `nodebug/0', `trace/0', `notrace/0', `spy/1', `nospy/1',
          `nospyall/0', `debugging/0', `leash/1', `maxdepth/1',
          `call_in_module/2'.

   * *Other modules used:*
        - *System library modules:*

          `format', `ttyout', `read', `write', `aggregates', `sort',
          `prolog_sys'.



File: ciao.info,  Node: Documentation on exports (debugger),  Next: Documentation on internals (debugger),  Prev: Usage and interface (debugger),  Up: Predicates controlling the interactive debugger

Documentation on exports (`debugger')
=====================================

 - PREDICATE: debug_module/1:
     *Usage:* `debug_module(Module)'
        - *Description:* The debugger will take into acount module
          `Module' (assuming it is is loaded in consult mode). When
          issuing this command at the toplevel shell, the compiler is
          instructed also to set to *consult* the loading mode of
          files defining that module.

        - *The following properties should hold at call time:*

          `Module' is an atom.   (`basic_props:atm/1')

 - PREDICATE: nodebug_module/1:
     *Usage:* `nodebug_module(Module)'
        - *Description:* The debugger will not take into acount
          module `Module'. When issuing this command at the toplevel
          shell, the compiler is instructed also to set to *compile*
          the loding mode of files defining that module.

        - *The following properties should hold at call time:*

          `Module' is an atom.   (`basic_props:atm/1')

 - PREDICATE: debug/0:
     *Usage:*
        - *Description:* Switches the debugger on. The interpreter
          will stop at all ports of procedure boxes of spied
          predicates.

 - PREDICATE: nodebug/0:
     *Usage:*
        - *Description:* Switches the debugger off. If there are any
          spy-points set then they will be kept but disabled.

 - PREDICATE: trace/0:
     *Usage:*
        - *Description:* Start tracing, switching the debugger on if
          needed. The interpreter will stop at all leashed ports of
          procedure boxes of predicates either belonging to debugged
          modules or called from clauses of debugged modules. A
          message is printed at each stop point, expecting input from
          the user (write `h' to see the available options).

 - PREDICATE: notrace/0:
     *Usage:*
        - *Description:* Equivalent to `nodebug/0'.

 - PREDICATE: spy/1:
     *Usage:* `spy(PredSpec)'
        - *Description:* Set spy-points on predicates belonging to
          debugged modules which match `PredSpec', switching the
          debugger on if needed. This predicate is defined as a
          prefix operator by the toplevel.

        - *The following properties should hold at call time:*

          `PredSpec' is a sequence of `multpredspec's.
          (`basic_props:sequence/2')

 - PREDICATE: nospy/1:
     *Usage:* `nospy(PredSpec)'
        - *Description:* Remove spy-points on predicates belonging to
          debugged modules which match `PredSpec'. This predicate is
          defined as a prefix operator by the toplevel.

        - *The following properties should hold at call time:*

          `PredSpec' is a sequence of `multpredspec's.
          (`basic_props:sequence/2')

 - PREDICATE: nospyall/0:
     *Usage:*
        - *Description:* Remove all spy-points.

 - PREDICATE: debugging/0:
     *Usage:*
        - *Description:* Display debugger state.

 - PREDICATE: leash/1:
     *Usage:* `leash(Ports)'
        - *Description:* Leash on ports `Ports', some of `call',
          `exit', `redo', `fail'.

        - *The following properties should hold at call time:*

          `Ports' is a list of `atm's.   (`basic_props:list/2')

 - PREDICATE: maxdepth/1:
     *Usage:* `maxdepth(MaxDepth)'
        - *Description:* Set maximum invocation depth in debugging to
          `MaxDepth'. Calls to compiled predicates are not included
          in the computation of the depth.

        - *The following properties should hold at call time:*

          `MaxDepth' is an integer.   (`basic_props:int/1')

 - PREDICATE: call_in_module/2:
     *Usage:* `call_in_module(Module,Predicate)'
        - *Description:* Calls predicate `Predicate' belonging to
          module `Module', even if that module does not export the
          predicate.

        - *The following properties should hold at call time:*

          `Module' is an atom.   (`basic_props:atm/1')

          `Predicate' is a term which represents a goal, i.e., an
          atom or a structure.   (`basic_props:callable/1')


File: ciao.info,  Node: Documentation on internals (debugger),  Prev: Documentation on exports (debugger),  Up: Predicates controlling the interactive debugger

Documentation on internals (`debugger')
=======================================

 - PROPERTY: multpredspec/1:
     A property, defined as follows:
               multpredspec(Mod:Spec) :-
                       atm(Mod),
                       multpredspec(Spec).
               multpredspec(Name/Low-High) :-
                       atm(Name),
                       int(Low),
                       int(High).
               multpredspec(Name/(Low-High)) :-
                       atm(Name),
                       int(Low),
                       int(High).
               multpredspec(Name/Arity) :-
                       atm(Name),
                       int(Arity).
               multpredspec(Name) :-
                       atm(Name).



File: ciao.info,  Node: The script interpreter,  Next: Customizing library paths and path aliases,  Prev: Predicates controlling the interactive debugger,  Up: Top

The script interpreter
**********************

   *Author(s):* Daniel Cabeza, Manuel Hermenegildo.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 1.3#106 (1999/11/18, 12:48:54 MET)

   `ciao-shell' is the Ciao script interpreter. It can be used to
write *Prolog shell scripts* (see [Her96,CHV96b]), that is,
executable files containing source code, which are compiled on demand.

   Writing Prolog scripts can sometimes be advantageous with respect
to creating binary executables for small- to medium-sized programs
that are modified often and perform relatively simple tasks. The
advantage is that no compilation is necessary, and thus changes and
updates to the program imply only editing the source file. The
disadvantage is that startup of the script (the first time after it
is modified) is slower than for an application that has been compiled
previously.

   An area of application is, for example, writing *CGI executables*:
the slow speed of the network connection in comparison with that of
executing a program makes program execution speed less important has
made scripting languages very popular for writing these scripts.
Logic languages are, a priori, excellent candidates to be used as
scripting languages. For example, the built-in grammars and databases
can sometimes greatly simplify many typical script-based applications.

* Menu:

* How it works::
* Command line arguments in scripts::


File: ciao.info,  Node: How it works,  Next: Command line arguments in scripts,  Prev: The script interpreter,  Up: The script interpreter

How it works
============

   Essentially, `ciao-shell' is a smaller version of the Ciao
top-level, which starts by loading the file given to it as the first
argument and then starts execution at `main/1' (the argument is
instantiated to a list containing the command line options, in the
usual way). However, while doing this, `ciao-shell' changes the
prolog flag `quiet' so that no informational or warning messages are
printed (error messages will be reported to `user_error', however).
The operation of `ciao-shell' in Unix-like systems is based in a
special compiler feature: when the first character of a file is
'`#'', the compiler skips the first lines until an empty line is
found.

   For example, in a Linux/Unix system, assume a file called `hello'
contains the following program:

     #!/bin/sh
     exec ciao-shell $0 "$@" # -*- mode: ciao; -*-
     
     main(_) :-
          write('Hello world'), nl.

   Then, the file `hello' can be *run* by simply making it executable
and invoking it from the command line:

     /herme@clip:/tmp
     [86]> chmod +x hello
     
     /herme@clip:/tmp
     [87]> hello
     Hello world

   The line:
     #!/bin/sh

invokes the `/bin/sh' shell which will interpret the following line:
     exec ciao-shell $0 "$@" # -*- mode: ciao; -*-

and invoke `ciao-shell', instructing it to read this same file
(`$0'), passing it the rest of the arguments to `hello' as arguments
to the prolog program. The second part of the line `# -*- mode: ciao;
-*-' is simply a comment which is seen by `emacs' and instructs it to
edit this file in Ciao mode (this is needed because these script
files typically do not have a `.pl' ending). When `ciao-shell'
starts, if it is the first time, it compiles the program (skipping
the first lines, as explained above), or else at successive runs
loads the `.po' object file, and then calls `main/1'.

   Note that the process of creating Prolog scripts is made very
simple by the Ciao emacs mode, which automatically inserts the header
and makes the file executable (See *Note Using Ciao inside GNU
emacs::).


File: ciao.info,  Node: Command line arguments in scripts,  Prev: How it works,  Up: The script interpreter

Command line arguments in scripts
=================================

The following example illustrates the use of command-line arguments
in scripts. Assume that a file called `say' contains the following
lines:

     #!/bin/sh
     exec ciao-shell $0 "$@" # -*- mode: ciao; -*-
     
     main(Argv) :-
          write_list(Argv), nl.
     
     write_list([]).
     write_list([Arg|Args]) :-
          write(Arg),
          write(' '),
          write_list(Args).

An example of use is:

     /herme@clip:/tmp
     [91]> say hello dolly
     hello dolly


File: ciao.info,  Node: Customizing library paths and path aliases,  Next: Using Ciao inside GNU emacs,  Prev: The script interpreter,  Up: Top

Customizing library paths and path aliases
******************************************

   This library provides means for customizing, from environment
variables, the libraries and path aliases known by an executable.
Many applications of CIAO, including `ciaoc', `ciaosh', and
`ciao-shell' make use of this library. Note that if an executable is
created dynamic, it will try to load its components at startup,
before the procedures of this module can be invoked, so in this case
all the components should be in standard locations.

* Menu:

* Usage and interface (libpaths)::
* Documentation on exports (libpaths)::
* Documentation on multifiles (libpaths)::


File: ciao.info,  Node: Usage and interface (libpaths),  Next: Documentation on exports (libpaths),  Prev: Customizing library paths and path aliases,  Up: Customizing library paths and path aliases

Usage and interface (`libpaths')
================================

   * *Library usage:*

     `:- use_module(library(libpaths)).'

   * *Other modules used:*
        - *System library modules:*

          `system', `lists'.



File: ciao.info,  Node: Documentation on exports (libpaths),  Next: Documentation on multifiles (libpaths),  Prev: Usage and interface (libpaths),  Up: Customizing library paths and path aliases

Documentation on exports (`libpaths')
=====================================

 - PREDICATE: get_alias_path/0:
     `get_alias_path'

     Consult the environment variable 'CIAOALIASPATH' and add facts
     to predicates `library_directory/1' and `file_search_path/2' to
     define new library paths and path aliases. The format of
     'CIAOALIASPATH' is a sequence of paths or alias assignments
     separated by colons, an alias assignment is the name of the
     alias, an '=' and the path represented by that alias (no blanks
     allowed). For example, given
             CIAOALIASPATH=/home/bardo/ciao:contrib=/usr/local/lib/ciao
     the predicate will define /home/bardo/ciao as a library path and
     /usr/local/lib/ciao as the path represented by 'contrib'.



File: ciao.info,  Node: Documentation on multifiles (libpaths),  Prev: Documentation on exports (libpaths),  Up: Customizing library paths and path aliases

Documentation on multifiles (`libpaths')
========================================

 - PREDICATE: file_search_path/2:
     See *Note Basic file/stream handling::.

     The predicate is *multifile* and of type *dynamic*.


 - PREDICATE: library_directory/1:
     See *Note Basic file/stream handling::.

     The predicate is *multifile* and of type *dynamic*.



File: ciao.info,  Node: Using Ciao inside GNU emacs,  Next: *** PART II - The Ciao basic language (engine),  Prev: Customizing library paths and path aliases,  Up: Top

Using Ciao inside GNU emacs
***************************

   *Author(s):* Manuel Hermenegildo and the CLIP Group.

   The Ciao/Prolog emacs interface (or *mode* in `emacs' terms)
provides a rich, integrated user interface to the Ciao *program
development environment* components, including the `ciaosh'
interactive top level and the `ciaopp' preprocessor. While most
features of the Ciao development environment are available from the
command line of the preprocessor and the top-level shell, using Ciao
inside `emacs' is highly recommended. The facilities that this mode
provides include:

   * *Syntax highlighting* and syntax coloring, *auto-indentation*,
     *auto-fill*, etc. of code. This includes the assertions used by
     the preprocessor and the documentation strings used by the Ciao
     auto-documenter, `lpdoc'.

   * Providing automatic access to on-line help for all predicates by
     accessing the Ciao system manuals in `info' format.

   * Starting and communicating with `ciaopp', the *Ciao
     preprocessor*, running in its own sub-shell. This allows easily
     performing certain kinds of *static checks* (useful for finding
     errors in programs before running them), program analysis tasks,
     and *program transformations* on source programs.

   * Starting and communicating with the *Ciao top-level*, running in
     its own sub-shell. This facilitates loading programs, checking
     the *syntax* of programs (and of *assertions* within programs),
     marking and unmarking modules for interactive debugging, making
     stand-alone executables, compiling modules to dynamically
     linkable Prolog objects, compiling modules to active objects,
     etc.

   * Syntax highlighting and coloring of the error and warning
     messages produced by the top level, preprocessor, or any other
     tool using the same message format (such as the `lpdoc'
     auto-documenter), and *locating automatically the points in the
     source files where such errors occur*.

   * Performing automatic *version control* and keeping a *change
     log* of individual files or whole applications. This is done by
     automatically including change log entries in source files,
     which can then be processed by the `lpdoc' auto-documenter.

   This chapter explains how to use the Ciao/Prolog `emacs' interface
and how to set up your `emacs' environment for correct operation. The
Ciao `emacs' interface can also be used to work with other Prolog or
CLP systems.

* Menu:

* Installation of the Ciao/Prolog emacs interface::
* Functionality and associated key sequences (bindings)::
* Commands available in toplevel and preprocessor buffers::
* Using Ciao/Prolog mode capabilities in standard shells::
* Coexistence with other Prolog interfaces::
* Version information::
* Acknowledgments (ciao.el)::


File: ciao.info,  Node: Installation of the Ciao/Prolog emacs interface,  Next: Functionality and associated key sequences (bindings),  Prev: Using Ciao inside GNU emacs,  Up: Using Ciao inside GNU emacs

Installation of the Ciao/Prolog emacs interface
===============================================

   It may be possible that a complete pre-installation of the
Ciao/Prolog `emacs' interface was already completed during Ciao
installation. To check this, open a file with a `.pl' ending. You
should see that `emacs' enters Ciao/Prolog mode: the mode is
identified in the status bar below the buffer and, if the emacs menu
bar is enabled, you should see the Ciao/Prolog menu. You should be
able from the menu-bar, for example, to go to the Ciao manuals in the
info or load the `.pl' file that you just opened into a ciao top
level.

   If opening a file ending with `.pl' puts emacs in another mode
(such as `perl' mode, which is the -arguably incorrect- default
setting in some `emacs' distributions), then you can set things so
that the Ciao/Prolog mode is loaded by default in your system. This
can be done by including in your `.emacs' file a line such as:

   `(load <CIAOLIBDIR>/DOTemacs)'

This loads the above mentioned file from the Ciao library, which
contains the following lines (except that the paths are changed
during installation to appropriate values for your system):

     ;; Ciao / &-Prolog / Prolog mode
     ;; (can be used for SICStus, and coexist with SICStus Prolog prolog.el)
     ;;
     (setq load-path (cons "<CIAOLIBDIR>" load-path))
     (autoload 'run-ciao-toplevel "ciao"
               "Start a Ciao / &-Prolog / Prolog top-level sub-process." t)
     (autoload 'run-ciao-preprocessor "ciao"
               "Start a Ciao / &-Prolog / Prolog preprocessor sub-process." t)
     (autoload 'ciao-mode "ciao"
               "Major mode for edit/run Ciao, Prolog, &-Prolog" t)
     (autoload 'ciao-inferior-mode "ciao"
               "Major mode for running Ciao, Prolog, lpdoc, etc." t)
     (setq auto-mode-alist (cons '("\\.pl$" . ciao-mode) auto-mode-alist))
     (setq auto-mode-alist (cons '("\\.pls$" . ciao-mode) auto-mode-alist))
     (setq auto-mode-alist (cons '("\\.lpdoc$" . ciao-mode) auto-mode-alist))
     (setq completion-ignored-extensions
           (append '(".dep" ".itf" ".po" ".asr" ".cpx")
                   completion-ignored-extensions))
     ;; ------------------------------------------------------------------------
     ;; In Un*x, the following (or similar) lines should be included in your
     ;; .cshrc or .profile to find the manuals (the Ciao installation leaves
     ;; in the Ciao library directory 'DOTcshrc' and 'DOTprofile' files with
     ;; the right paths which can be included directly in your startup scripts):
     ;;
     ;; setenv INFOPATH /usr/local/info:/usr/info:<LPDOCDIR>
     ;; ------------------------------------------------------------------------

   If you would like to configure things in a different way, you can
also copy the contents of this file to your `.emacs' file and make
the appropriate changes. For example, if you do not want `.pl' files
to be put automatically in Ciao/Prolog mode, then comment out (or
remove) the line:

   `(setq auto-mode-alist' ... `)'

You will then need to switch manually to Ciao/Prolog mode by typing
`M-x ciao-mode' after opening a Prolog file.

   If you are able to open the Ciao/Prolog menu but the Ciao manuals
are not found or the `ciao' command (the top-level) is not found when
loading `.pl' files, the probable cause is that you do not have the
Ciao paths in the `INFOPATH' and `MANPATH' *environment variables*
(whether these variables are set automatically or not for users
depends on how the Ciao system was installed). You can add these
paths easily by including the line:

   `source <CIAOLIBDIR>/DOTcshrc'

in your `.login' or `.cshrc' files if you are using `csh' (or `tcsh',
etc.), or, alternatively, the line:

   `. <CIAOLIBDIR>/DOTprofile'

in your `.login' or `.profile' files if you are using `sh' (or
`bash', etc.). See the Ciao installation instructions (*Note
Installing Ciao::) for details.


File: ciao.info,  Node: Functionality and associated key sequences (bindings),  Next: Commands available in toplevel and preprocessor buffers,  Prev: Installation of the Ciao/Prolog emacs interface,  Up: Using Ciao inside GNU emacs

Functionality and associated key sequences (bindings)
=====================================================

   The following is a summary of the capabilities of the Ciao/Prolog
emacs interface and the (default) *key sequences* used to access
those capabilities. Most of these functions are accessible also from
the menu bar.

* Menu:

* Getting on-line help::
* Loading debugging and compiling programs::
* Locating errors and checking the syntax of assertions::
* Commands which help in typing in programs::
* Preprocessing programs::
* Version control::
* Setting the top-level and preprocessor executables::
* Traditional Prolog Mode Commands::
* Other commands::
* Getting the Ciao/Prolog mode version::


File: ciao.info,  Node: Getting on-line help,  Next: Loading debugging and compiling programs,  Prev: Functionality and associated key sequences (bindings),  Up: Functionality and associated key sequences (bindings)

Getting on-line help
--------------------

   The following commands are useful for getting on-line help. This
is done by accessing the `info' version of the Ciao manuals or the
`emacs' built-in help strings. Note also that the `info' standard
`search' command (generally bound to <s>) can be used inside `info'
buffers to search for a given string.
<^C> <TAB>
     Find help for the symbol (e.g., predicate, directive,
     declaration, type, etc.) that is currently under the cursor.
     Opens a (hopefully) relevant part of the Ciao manuals in `info'
     mode. Requires that the Ciao manuals in `info' format be
     installed and that they accessible to emacs (i.e., they should
     appear somewhere in the info directory when typing `M-x info').
     It also requires `word-help.el', which is provided with Ciao.

<^C> </>
     Find a completion for the symbol (e.g., predicate, directive,
     declaration, type, etc.) that is currently under the cursor.
     Uses for completion the contents of the indices of the Ciao
     manuals. Same requirements as for finding help for the symbol.

<^C> <^M>
     Go to the part of the info directory containing the Ciao manuals.

<^H> <m>
     Show a short description of the Ciao/Prolog emacs mode,
     including all key bindings.


File: ciao.info,  Node: Loading debugging and compiling programs,  Next: Locating errors and checking the syntax of assertions,  Prev: Getting on-line help,  Up: Functionality and associated key sequences (bindings)

Loading debugging and compiling programs
----------------------------------------

   These commands allow *loading programs*, marking modules for
*debugging*, *creating executables*, etc. by issuing the appropriate
commands to a Ciao/Prolog top level shell, running in its own buffer
as a subprocess. See *Note The interactive top-level shell:: for
details. The following commands implement the communication with the
Ciao/Prolog top level:
<^C> <l>
     Load the current buffer (and any auxiliary files it may use)
     into the top level. The type of compilation performed (
     *compiling* or *consulting*) is selected automatically depending
     on whether the buffer has been marked for debugging or not - see
     below.

<^C> <m>
     Mark the current buffer for debugging. Note that if the buffer
     has already been loaded while it was unmarked for debugging (and
     has therefore been loaded in "compile" mode) it has to be loaded
     again.

<^C> <u>
     Unmarks the current buffer for debugging. Note that if the
     buffer has already been loaded while it was marked for debugging
     (and has therefore been loaded in "consult" mode) it has to be
     loaded again.

<^C> <r>
     Load the current region (between the cursor and a previous mark)
     into the top level for debugging. Since loading a region of a
     file is typically done for debugging and/or testing purposes,
     this command always loads the region in debugging mode (consult).

<^C> <p>
     Load the predicate around the cursor into the top level. Since
     loading a single predicate is typically done for debugging
     and/or testing purposes, this command always loads the predicate
     in debugging mode (consult).

<^C> <x>
     Make an executable from the code in the current buffer. The
     buffer must contain a `main/0' or `main/1' predicate. Note that
     compiler options can be set to determine whether the libraries
     and auxiliary files used by the executable will be statically
     linked, dynamically linked, auto-loaded, etc.

<^C> <o>
     Make a Prolog object (.po) file from the code in the current
     buffer. This is very useful during debugging or program
     development, when only one or a few files of a large application
     are modified. If the application executable is dynamically
     linked, i.e., the component .po files are loaded dynamically
     during startup of the application, then this command can be used
     to recompile only the file or files which have changed, and the
     correct version will be loaded dynamically the next time the
     application is started. However, note that this only works if
     the inter-module interfaces have not changed. A safer, but
     possibly slower way is to generate the executable again, letting
     the Ciao compiler, which is inherently incremental, determine
     what needs to be recompiled.

<^C> <a>
     Make an active module executable from the code in the current
     buffer. An active module is a remote procedure call server (see
     the `activemod' library documentation for details).

<^C> <t>
     Ensure that an inferior Ciao/Prolog top-level process is
     running. Normally, it is not necessary to use this function
     since execution of any of the other functions related to the top
     level ensures that a top level is started (starting one if
     required). This function is useful when one would like to start
     a top level in order to type a command directly by hand into it.


File: ciao.info,  Node: Locating errors and checking the syntax of assertions,  Next: Commands which help in typing in programs,  Prev: Loading debugging and compiling programs,  Up: Functionality and associated key sequences (bindings)

Locating errors and checking the syntax of assertions
-----------------------------------------------------

   These commands allow several syntactic checks of assertions, and
locating quickly the point in the source code corresponding to errors
flagged by the compiler or preprocessor:
<^C> <`>
     Go to location in source file containing next error reported by
     the last Ciao/Prolog subprocess (preprocessor or toplevel) which
     was run.

<^C> <E>
     Check the syntax of the code and assertions in the current
     buffer, as well as imports and exports. Note that full
     (semantic) assertion checking must be done with the preprocessor.


File: ciao.info,  Node: Commands which help in typing in programs,  Next: Preprocessing programs,  Prev: Locating errors and checking the syntax of assertions,  Up: Functionality and associated key sequences (bindings)

Commands which help in typing in programs
-----------------------------------------

   The following commands are intended to help in the process of
writing programs:
<^C> <I> <S>
     Insert a (Unix) header at the top of the current buffer so that
     the ciao script interpreter will be called on this file if *run*
     from the command line. It also makes the file 'executable'
     (e.g., '`chmod +x <file>'' in Unix). See *Note The script
     interpreter:: for details.


File: ciao.info,  Node: Preprocessing programs,  Next: Version control,  Prev: Commands which help in typing in programs,  Up: Functionality and associated key sequences (bindings)

Preprocessing programs
----------------------

   These commands allow *preprocessing programs* with `ciaopp', the
*Ciao preprocessor*.

   `ciaopp' is the precompiler of the CIAO Prolog development
environment.  `ciaopp' can perform a number of program debugging,
analysis and source-to-source transformation tasks on (CIAO) Prolog
programs. These tasks include:

   * *Inference of properties* of the predicates and literals of the
     progam, including *types*, *modes* and other *variable
     instantiation* properties, *non-failure*, *determinacy*, bounds
     on *computational cost*, bounds on *sizes of terms* in the
     program, etc.

   * Certain kinds of *static debugging*, finding errors before
     running the program. This includes checking the ways in which
     programs call the system library predicates and also *checking
     the assertions* present in the program or in other modules used
     by the program. Such assertions essentially represent partial
     *specifications* of the program.

   * Several kinds of source to source *program transformations* such
     as *program specialization*, *program parallelization* (including
     *granularity control*), inclusion of *run-time tests* for
     assertions which cannot be checked completely at compile-time,
     etc.

   The information generated by analysis, the assertions in the
system libraries, and the assertions optionally included in user
programs as specifications are all written in the same *assertion
language*, which is in turn also used by the CIAO system
documentation generator, `lpdoc'.

   `ciaopp' is distributed under the GNU general public license.

   See the preprocessor manual for details. The following commands
implement the communication with the Ciao preprocessor:

<^C> <M>
     Preprocess the buffer, selecting options. Instructs the
     preprocessor to load the current buffer and start an interactive
     dialog in which the different options available in the
     preprocessor can be set.

<^C> <P>
     Preprocess the buffer, using the previously selected options. If
     no options were set previously, then the preprocessor defaults
     are used.

<^C> <^V>
     Show last output file produced by Ciao preprocessor. The
     preprocessor works by producing a file which is a transformed
     and/or adorned (with assertions) version of the input file. This
     is often used after running the preprocessor in order to see
     such results.

<^C> <V>
     Preprocess the buffer, selecting options. Instructs the
     preprocessor to load the current buffer and start an interactive
     dialog in which the different options available in the
     preprocessor can be set.

<^C> <^R>
     Ensure that an inferior Ciao preprocessor process is running


File: ciao.info,  Node: Version control,  Next: Setting the top-level and preprocessor executables,  Prev: Preprocessing programs,  Up: Functionality and associated key sequences (bindings)

Version control
---------------

   The following commands can be used to carry out a simple form of
version control by keeping a log of changes on a file or a group of
related files. This log is kept in a format that is understood by
`lpdoc', the Ciao documenter [Her99a]. As a result, if these version
comments are present, then `lpdoc' will be able to automatically
assign up to date version numbers to the manuals that it generates.
This way it is always possible to identify to which version of the
software a manual corresponds. Also, `lpdoc' can create automatically
sections describing the changes made since previous versions, which
are extracted from the comments in the changelog entries.

   The main effect of these commands is automatically associate the
following information to a set of changes performed in the file
and/or in a set of related files:

   * a *version number* (such as, e.g., `1.2', where `1' is the major
     version number and `2' is the minor version number),

   * a patch number (such as, e.g., the `4' in `1.2#4'),

   * a time stamp (such as, e.g., `1998/12/14,17:20*28+MET'),

   * the author of the change, and

   * a comment explaining the change.

   The version numbering used can be local to a single file or common
to a number of related files. A simple version numbering policy is
implemented: when a relevant change is made, the user typically
inserts a changelog entry for it, using the appropriate command (or
selecting the corresponding option when prompted while saving a
file). This will cause the *patch number* for the file (or for the
whole system that the file is part of) to be incremented
automatically and the corresponding machine-readable comment to be
inserted in the file. Major and minor version numbers can also be
changed, but this is always invoked by hand (see below).

   The changelog entry is written in the form of a `comment/2'
declaration. As mentioned before, the advantage of using this kind of
changelog entries is that these declarations can be processed by the
`lpdoc' automatic documenter (see the `lpdoc' reference manual
[Her99a] or the `assertions' library documentation for more details
on these declarations).

   Whether the user is asked or not to introduce such changelog
entries, and how the patch and version numbers should be increased is
controlled by the presence in the file of a `comment/2' declaration
of the type:

   `:- comment(version_maintenance,<type>).'

(note that this requires including the `assertions' library in the
source file). These declarations themselves are also typically
introduced automatically when using this mode (see below).

   The version maintenance mode can also be set alternatively by
inserting a comment such as:

     %% Local Variables:
     %% mode: Ciao/Prolog
     %% update-version-comments: ""off""
     %% End:

   The lines above instruct emacs to put the buffer visiting the file
in emacs Ciao/Prolog mode and to turn version maintenance off.
Setting the version maintenance mode in this way has the disadvantage
that `lpdoc', the auto-documenter, and other related tools will not
be aware of the type of version maintenance being performed (the
lines above are comments for Prolog). However, this can be useful in
fact for setting the *version maintenance mode for packages* and
other files meant for inclusion in other files, since that way the
settings will not affect the file in which the package is included.

   The following commands implement the version control support:

<^X> <^S>
     This is the standard `emacs' command that saves a buffer by
     writing the contents into the associated `.pl' file. However, in
     Ciao/Prolog mode this command can be set to ask the user before
     saving whether to introduce a change log entry documenting the
     changes performed.

     If the buffer does not already contain a comment specifying the
     type of version control to be performed, and before saving the
     buffer, the Ciao/Prolog mode prompts the user to choose among
     the following options:

    <q>
          Turn off prompting for the introduction of change log
          entries for now.  `emacs' will not ask again while the
          buffer is loaded, but it will ask again next time you load
          the buffer.

    <n>
          Turn off version control for this file. A version control
          comment such as:

          `:- comment(version_maintenance,off).'

          is added to the buffer and the file is saved.  `emacs' will
          not perform any version control on this file until the line
          above is removed or modified (i.e., from now on C-x C-s
          simply saves the buffer).

    <y>
          Turn version control on for this file.

     If <y> is selected, then the system prompts again regarding how
     and where the version and patch number information is to be
     maintained. The following options are available:

    `on'
          All version control information will be contained within
          this file. When saving a buffer (C-x C-s) emacs will ask if
          a change log entry should be added to the file before
          saving. If a comment is entered by the user, a new patch
          number is assigned to it and the comment is added to the
          file. This patch number will be the one that follows the
          most recent change log entry already in the file. This is
          obviously useful when maintaining version numbers
          individually for each file.

    `<directory_name>'
          Global version control will be performed coherently on
          several files. When saving a buffer (C-x C-s) emacs will
          ask if a change log entry should be added to the file
          before saving. If a comment is given, the global patch
          number (which will be kept in the file:
          `<directory_name>/GlobalPatch') is atomically incremented
          and the change log entry is added to the current file,
          associated to that patch number. Also, a small entry is
          added to a file `<directory_name>/GlobalChangeLog' which
          points to the current file. This allows inspecting all
          changes sequentially by visiting all the files where the
          changes were made (see C-c `). This is obviously useful
          when maintaining a single thread of version and patch
          numbers for a set of files.

    `off'
          Turns off version control: C-x C-s then simply saves the
          file as usual.

     *Some useful tips:*

        * If a change log entry is in fact introduced, the cursor is
          left at the point in the file where the comment was
          inserted and the mark is left at the original file point.
          This allows inspecting (and possibly modifying) the change
          log entry, and then returning to the original point in the
          file by simply typing C-x C-x.

        * The first change log entry is entered by default at the end
          of the buffer. Later, the change log entries can be moved
          anywhere else in the file. New change log entries are
          always inserted just above the first change log entry which
          appears in the file.

        * The comments in change log entries can be edited at any
          time.

        * If a change log entry is moved to another file, and version
          numbers are shared by several files through a directory,
          the corresponding file pointer in the
          `<directory_name>/GlobalChangeLog' file needs to be changed
          also, for the entry to be locatable later using C-c C-n.

<^C> <^S>
     Same as C-x C-s except that it forces prompting for inclusion of
     a changelog entry even if the buffer is unmodified.

<^C> <n>
     Force a move to a new major/minor version number (the user will
     be prompted for the new numbers). Only applicable if using
     directory-based version maintenance. Note that otherwise it
     suffices with introducing a change log entry in the file and
     changing its version number by hand.

<^C> <^N>
     When a unique version numbering is being maintained across
     several files, this command allows inspecting all changes
     sequentially by visiting all the files in which the changes were
     made:

        * If in a source file, find the next changelog entry in the
          source file, open in another window the corresponding
          `GlobalChangeLog' file, and position the cursor at the
          corresponding entry. This allows browsing the previous and
          following changes made, which may perhaps reside in other
          files in the system.

        * If in a `GlobalChangeLog' file, look for the next entry in
          the file, and open in another window the source file in
          which the corresponding comment resides, positioning the
          corresponding comment at the top of the screen. This allows
          going through a section of the `GlobalChangeLog' file
          checking all the corresponding comments in the different
          files in which they occur.


File: ciao.info,  Node: Setting the top-level and preprocessor executables,  Next: Traditional Prolog Mode Commands,  Prev: Version control,  Up: Functionality and associated key sequences (bindings)

Setting the top-level and preprocessor executables
--------------------------------------------------

   These commands allow *changing the executables used* when starting
a Prolog top-level or the preprocessor, changing the arguments that
these executables take, and changing the path where the Prolog
libraries reside. This should be done only by users which understand
the implications, but is very useful if several versions of
Ciao/Prolog are available in the system:
<^C> <S> <C>
     Change the Ciao/Prolog executable used to run the Prolog-like
     top level. It is set by default to `ciao' or, to the environment
     variable `CIAO' if it is defined.

<^C> <S> <^C>
     Change the arguments passed to the Ciao/Prolog executable. They
     are set by default to none or, to the environment variable
     `CIAOARGS' if it is defined.

<^C> <S> <P>
     Change the executable used to run the Ciao Preprocessor
     toplevel. It is set by default to `ciaopp' or, to the
     environment variable `CIAOPP' if it is defined.

<^C> <S> <^P>
     Change the arguments parssed to the Ciao preprocessor
     executable. They are set by default to none or, to the
     environment variable `CIAOPPARGS' if it is defined.

<^C> <S> <L>
     Change the location of the Ciao/Prolog library paths (changes
     the environment variable CIAOLIB).


File: ciao.info,  Node: Traditional Prolog Mode Commands,  Next: Other commands,  Prev: Setting the top-level and preprocessor executables,  Up: Functionality and associated key sequences (bindings)

Traditional Prolog Mode Commands
--------------------------------

   These commands provide some bindings and facilities for loading
programs, which are present in emacs Prolog modes of other Prolog
systems (e.g., SICStus). This is useful mainly if the Ciao/Prolog
emacs mode is used with such Prolog systems. Note that the behavior
of these commands in Ciao is slightly different from that of SICStus.
<^C> <K>
     Compile the entire buffer.

<^C> <k>
     Compile a given region.

<^C> <^K>
     Compile the predicate around point.

<^C> <C>
     Consult the entire buffer.

<^C> <c>
     Consult a given region.

<^C> <^C>
     Consult the predicate around point.


File: ciao.info,  Node: Other commands,  Next: Getting the Ciao/Prolog mode version,  Prev: Traditional Prolog Mode Commands,  Up: Functionality and associated key sequences (bindings)

Other commands
--------------

   Some other commands which are active in the Ciao/Prolog mode:
<TAB>
     Indent current line as Ciao/Prolog code. With argument, indent
     any additional lines of the same clause rigidly along with this
     one.

<^C> <^L>
     Recenter the most recently used Ciao/Prolog inferior process
     buffer (top-level or preprocessor).


File: ciao.info,  Node: Getting the Ciao/Prolog mode version,  Prev: Other commands,  Up: Functionality and associated key sequences (bindings)

Getting the Ciao/Prolog mode version
------------------------------------

<^C> <v>
     Report the version of the emacs Ciao/Prolog mode.


File: ciao.info,  Node: Commands available in toplevel and preprocessor buffers,  Next: Using Ciao/Prolog mode capabilities in standard shells,  Prev: Functionality and associated key sequences (bindings),  Up: Using Ciao inside GNU emacs

Commands available in toplevel and preprocessor buffers
=======================================================

   The interactive top level and the preprocessor both are typically
run in an iteractive buffer, in which it is possible to communicate
with them in the same way as is they had been started from a standard
shell. In addition, the commands and key bindings available in
buffers containing source code are also available in these
interactive buffers, when applicable.


File: ciao.info,  Node: Using Ciao/Prolog mode capabilities in standard shells,  Next: Coexistence with other Prolog interfaces,  Prev: Commands available in toplevel and preprocessor buffers,  Up: Using Ciao inside GNU emacs

Using Ciao/Prolog mode capabilities in standard shells
======================================================

   The capabilities (commands, coloring, ...) which are active in the
Ciao/Prolog "inferior" mode (the mode of the buffers in which the top
level and the preprocessor run) can also be made available in any
standard command line shell which is being run within emacs. This can
be enabled by going to the buffer in which the shell is running and
typing "<M-x> `ciao-inferior-mode'". This is very useful for example
when running the stand-alone compiler, the `lpdoc' documenter, or
even certain user applications (those that use the standard error
message library) in an emacs sub-shell. Turning the Ciao/Prolog
inferior mode on on that sub-shell will highlight and color the error
messages (type <^L>), and automatically find and visit the locations
in the files in which the errors are reported.


File: ciao.info,  Node: Coexistence with other Prolog interfaces,  Next: Version information,  Prev: Using Ciao/Prolog mode capabilities in standard shells,  Up: Using Ciao inside GNU emacs

Coexistence with other Prolog interfaces
========================================

   As mentioned previously, the Ciao/Prolog `emacs' interface can
also be used to work with other Prolog or CLP systems. Also, the
Ciao/Prolog `emacs' interface (*mode*) can coexist with other
Prolog-related `emacs' interfaces (*modes*) (such as, e.g., the
`SICStus' Prolog interface). Only one of the interfaces can be active
at a time for a given buffer (i.e., for each given file opened inside
`emacs'). In order the change a buffer to a given interface, move the
cursor to that buffer and type `M-x ...-mode' (e.g., for the
Ciao/Prolog mode, `M-x ciao-mode').

   If several Prolog-related `emacs' interfaces are loaded, then
typically the *last* one to be loaded takes precedence, in the sense
that this will be the interface in which `emacs' will be set when
opening files which have a `.pl' ending (this depends a bit on how
things are set up in your `.emacs' file).


File: ciao.info,  Node: Version information,  Next: Acknowledgments (ciao.el),  Prev: Coexistence with other Prolog interfaces,  Up: Using Ciao inside GNU emacs

Version information
===================

   This documentation corresponds to Ciao/Prolog emacs mode version
*5.55*. This mode is currently being developed within `GNU emacs'
version 20.2. It should also work with all other 20.XX and later
19.XX versions.


File: ciao.info,  Node: Acknowledgments (ciao.el),  Prev: Version information,  Up: Using Ciao inside GNU emacs

Acknowledgments (ciao.el)
=========================

   This code is derived from the 1993 version of the emacs interface
for &-Prolog, itself derived from the original `prolog.el' by
*Masanobu Umeda* with changes by *Johan Andersson*, *Peter Olin*,
*Mats Carlsson*, and *Johan Bevemyr* of *SICS*, Sweden. Other changes
also by Daniel Cabeza.


File: ciao.info,  Node: *** PART II - The Ciao basic language (engine),  Next: The module system,  Prev: Using Ciao inside GNU emacs,  Up: Top

PART II - The Ciao basic language (engine)
******************************************

   This part documents the *Ciao engine builtins*, i.e., those that
are contained in the `engine' directory within the `lib' library.
The rest of the library predicates, including the packages that
provide most of the ISO-Prolog builtins, are documented in subsequent
parts.


File: ciao.info,  Node: The module system,  Next: Directives for using code in other files,  Prev: *** PART II - The Ciao basic language (engine),  Up: Top

The module system
*****************

   *Author(s):* Daniel Cabeza and the CLIP Group.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   Modularity is a basic notion in a modern computer language.
Modules allow dividing programs in several parts, which have its own
independent name spaces. The module system in CIAO, as in many other
Prolog implementations, is procedure based. This means that predicate
names are local to a module, but functor/atom names in data are
shared.

   The predicates visible in a module are the predicates defined in
that module, plus the predicates imported from other modules. Only
predicates exported by a module can be imported from other modules.
The default module of a given predicate name is the local one if the
predicate is defined locally, else the last module from which the
predicate is imported, having explicit imports priority. To refer to
a predicate from a module which is not the default for that predicate
the name has to be module qualified. A module qualified predicate
name has the form `Module':`Predicate' as in the call
`debugger:debug_module(M)'. Note that this does not allow having
access to predicates not imported, nor defining clauses of other
modules.

   All predicates defined in files with no module declaration belong
to a special module called `user', and all are implicitly exported.
This allows dividing programs in several files without being aware of
the module system at all. Note that this feature is only supported
for compatibility reasons, being its use discouraged. Many attractive
compilation features of CIAO cannot be performed in `user' modules.

   The case of multifile predicates (defined with the declaration
`multifile/1') is also special. Multifile predicates can be defined
by clauses distributed in several modules, and all modules which
define a predicate as multifile can use that predicate. The name
space of multifile predicates is independent, as if they belonged to
special module `multifile'.

   Every `user' or module file imports implicitly a number of modules
called builtin modules. They are imported before all other
importations of the module, allowing thus redefining any of their
predicates (with the exception of `true/0') by defining local
versions or importing them from other modules. Importing explicitly
from a builtin module, however, disables the implicit importation of
the rest (this feature is used by package `library(pure)' to define
pure prolog code).

* Menu:

* Usage and interface (modules)::
* Documentation on internals (modules)::


File: ciao.info,  Node: Usage and interface (modules),  Next: Documentation on internals (modules),  Prev: The module system,  Up: The module system

Usage and interface (`modules')
===============================

   * *Library usage:*

     Modules are an intrinsic feature of CIAO, so nothing special has
     to be done to use them.


File: ciao.info,  Node: Documentation on internals (modules),  Prev: Usage and interface (modules),  Up: The module system

Documentation on internals (`modules')
======================================

 - DECLARATION: module/3:
     *Usage:* :- `module(Name,Exports,Packages)'.
        - *Description:* Declares a module of name `Name' which
          exports the predicates in `Exports', and uses the packages
          in `Packages'. `Name' must match with the name of the file
          where the module resides, without extension. For each
          source in `Packages', a package file is included, as if by
          an `include/1' declaration. If the source is specified with
          a path alias, this is the file included, if it is an atom,
          the library paths are searched. Package files provide
          functionalities by declaring imports from other modules,
          defining operators, new declarations, translations of code,
          etc.

          This directive must appear the first in the file.

          Also, if the compiler finds an unknown declaration as the
          first term in a file, the name of the declaration is
          regarded as a package library to be included, and the
          arguments of the declaration (if present) are interpreted
          like the arguments of `module/3'.

        - *The following properties hold at call time:*

          `Name' is a module name (an atom).
          (`modules:modulename/1')

          `Exports' is a list of `predname's.   (`basic_props:list/2')

          `Packages' is a list of `sourcename's.
          (`basic_props:list/2')

 - DECLARATION: module/2:
     *Usage:* :- `module(Name,Exports)'.
        - *Description:* Same as directive `module/3', with an
          implicit package `iso', which enables to include ISO-Prolog
          compatible code (compatibility not 100% yet).

        - *The following properties hold at call time:*

          `Name' is a module name (an atom).
          (`modules:modulename/1')

          `Exports' is a list of `predname's.   (`basic_props:list/2')

 - DECLARATION: export/1:
     *Usage 1:* :- `export(Pred)'.
        - *Description:* Adds `Pred' to the set of exported
          predicates.

        - *The following properties hold at call time:*

          `Pred' is a Name/Arity structure denoting a predicate name:
               predname(P/A) :-
                       atm(P),
                       int(A).

          (`basic_props:predname/1')

     *Usage 2:* :- `export(Exports)'.
        - *Description:* Adds `Exports' to the set of exported
          predicates.

        - *The following properties hold at call time:*

          `Exports' is a list of `predname's.   (`basic_props:list/2')

 - DECLARATION: use_module/2:
     *Usage:* :- `use_module(Module,Imports)'.
        - *Description:* Specifies that this code imports from the
          module defined in `Module' the predicates in `Imports'. The
          imported predicates must be exported by the other module.

        - *The following properties hold at call time:*

          `Module' is a source name.   (`streams_basic:sourcename/1')

          `Imports' is a list of `predname's.   (`basic_props:list/2')

 - DECLARATION: use_module/1:
     *Usage:* :- `use_module(Module)'.
        - *Description:* Specifies that this code imports from the
          module defined in `Module' all the predicates exported by
          it. The previous version with the explicit import list is
          preferred to this as it minimizes the chances to have to
          recompile this code if the other module changes.

        - *The following properties hold at call time:*

          `Module' is a source name.   (`streams_basic:sourcename/1')

 - DECLARATION: import/2:
     *Usage:* :- `import(Module,Imports)'.
        - *Description:* Declares that this code imports from the
          module with name `Module' the predicates in `Imports'.

          *Important note:* this declaration is intended to be used
          when the current module or the imported module is going to
          be dynamically loaded, and so the compiler does not include
          the code of the imported module in the current executable
          (if only because the compiler cannot know the location of
          the module file at the time of compilation). For the same
          reason the predicates imported are not checked to be
          exported by `Module'. Its use in other cases is strongly
          discouraged, as it disallows many compiler optimizations.

        - *The following properties hold at call time:*

          `Module' is a module name (an atom).
          (`modules:modulename/1')

          `Imports' is a list of `predname's.   (`basic_props:list/2')

 - DECLARATION: reexport/2:
     *Usage:* :- `reexport(Module,Preds)'.
        - *Description:* Specifies that this code reexports from the
          module defined in `Module' the predicates in `Preds'. This
          implies that this module imports from the module defined in
          `Module' the predicates in `Preds', an also that this
          module exports the predicates in `Preds' .

        - *The following properties hold at call time:*

          `Module' is a source name.   (`streams_basic:sourcename/1')

          `Preds' is a list of `predname's.   (`basic_props:list/2')

 - DECLARATION: reexport/1:
     *Usage:* :- `reexport(Module)'.
        - *Description:* Specifies that this code reexports from the
          module defined in `Module' all the predicates exported by
          it. This implies that this module imports from the module
          defined in `Module' all the predicates exported by it, an
          also that this module exports all such predicates .

        - *The following properties hold at call time:*

          `Module' is a source name.   (`streams_basic:sourcename/1')

 - DECLARATION: meta_predicate/1:
     *Usage:* :- `meta_predicate MetaSpecs'.
        - *Description:* Specifies that the predicates in `MetaSpecs'
          have arguments which represent predicates and thus have to
          be module expanded. The directive is not mandatory in
          programs which do not use modules. This directive is
          defined as a prefix operator in the compiler.

        - *The following properties hold at call time:*

          `MetaSpecs' is a sequence of `metaspec's.
          (`basic_props:sequence/2')

 - REGTYPE: modulename/1:
     *Usage:* `modulename(M)'
        - *Description:* `M' is a module name (an atom).

        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: metaspec/1:
     A meta-predicate specification for a predicate is the functor of
     that predicate applied to atoms which represent the kind of
     module expansion that should be done with the arguments.
     Possible contents are represented as:

    `goal'
          This argument will be a term denoting a goal (either a
          simple or complex one) which will be called. For
          commpatibility reasons it can be named as `:' as well.

    `clause'
          This argument will be a term denoting a clause.

    `fact'
          This argument should be instantiated to a term denoting a
          fact (head-only clause).

    `spec'
          This argument should be instantiated to a predicate name,
          as Functor/Arity.

    `pred(*N*)'
          This argument should be instantiated to a predicate
          construct to be called by means of a `call/*N*' predicate
          call (see `call/2'). Thus, it should be an atom equal to
          the name of a predicate of arity *N*, or a structure with
          functor the name of a predicate of arity *M* (greater than
          *N*) and with *M*-*N* arguments.

    `?,+,-,_'
          These other values denote that this argument is not module
          expanded.

     *Usage:* `metaspec(M)'
        - *Description:* `M' is a meta-predicate specification.

        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')


File: ciao.info,  Node: Directives for using code in other files,  Next: Control constructs/predicates,  Prev: The module system,  Up: Top

Directives for using code in other files
****************************************

   *Author(s):* Daniel Cabeza.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 1.3#107 (1999/11/18, 13:6:14 MET)

* Menu:

* Usage and interface (loading_code)::
* Documentation on internals (loading_code)::


File: ciao.info,  Node: Usage and interface (loading_code),  Next: Documentation on internals (loading_code),  Prev: Directives for using code in other files,  Up: Directives for using code in other files

Usage and interface (`loading_code')
====================================

   * *Library usage:*

     These directives are builtin in CIAO, so nothing special has to
     be done to use them.


File: ciao.info,  Node: Documentation on internals (loading_code),  Prev: Usage and interface (loading_code),  Up: Directives for using code in other files

Documentation on internals (`loading_code')
===========================================

 - DECLARATION: ensure_loaded/1:
     *Usage:* :- `ensure_loaded(File)'.  < * ISO * >
        - *Description:* Specifies that the code present in `File'
          will be included in the executable being prepared, in the
          `user' module. The file `File' cannot have a module
          declaration. This directive is intended to be used by
          programs not divided in modules. Dividing programs into
          modules is however strongly encouraged, since most of the
          attractive features of CIAO (such as static debugging and
          global optimization) are only partially available for
          `user' modules.

        - *The following properties should hold at call time:*

          `File' is a source name.   (`streams_basic:sourcename/1')

 - DECLARATION: include/1:
     *Usage:* :- `include(File)'.  < * ISO * >
        - *Description:* The contents of the file `File' are included
          in the current program text exactly as if they had been
          written in place of this directive.

        - *The following properties should hold at call time:*

          `File' is a source name.   (`streams_basic:sourcename/1')

 - DECLARATION: use_package/1:
     :- `use_package(Package)'.

     Specifies the use in this file of the packages defined in
     `Package'. See the description of the third argument of
     `module/3' for an explanation of package files.

     This directive must appear the first in the file, or just after a
     `module/3' declaration. A file with no module declaration, in
     the absence of this directive, uses an implicit package `iso',
     which enables to include ISO-Prolog compatible code
     (compatibility not 100% yet).

     *Usage 1:* :- `use_package(Package)'.
        - *The following properties should hold at call time:*

          `Package' is a source name.   (`streams_basic:sourcename/1')

     *Usage 2:* :- `use_package(Package)'.
        - *The following properties should hold at call time:*

          `Package' is a list of `sourcename's.
          (`basic_props:list/2')


File: ciao.info,  Node: Control constructs/predicates,  Next: Basic builtin directives,  Prev: Directives for using code in other files,  Up: Top

Control constructs/predicates
*****************************

   *Author(s):* Daniel Cabeza, Manuel Hermenegildo.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 1.3#99 (1999/11/12, 16:28:6 MET)

   This module contains the set of basic control predicates, except
the predicates dealing with exceptions, which are in *Note Exception
handling::.

* Menu:

* Usage and interface (basiccontrol)::
* Documentation on exports (basiccontrol)::
* Documentation on internals (basiccontrol)::


File: ciao.info,  Node: Usage and interface (basiccontrol),  Next: Documentation on exports (basiccontrol),  Prev: Control constructs/predicates,  Up: Control constructs/predicates

Usage and interface (`basiccontrol')
====================================

   * *Library usage:*

     These predicates/constructs are builtin in CIAO, so nothing
     special has to be done to use them. In fact, as they are
     hardwired in some parts of the system, most of them cannot be
     redefined.

   * *Exports:*
        - *Predicates:*

          `,/2', `;/2', `->/2', `!/0', `\+/1', `if/3', `true/0',
          `fail/0', `repeat/0', `call/1'.



File: ciao.info,  Node: Documentation on exports (basiccontrol),  Next: Documentation on internals (basiccontrol),  Prev: Usage and interface (basiccontrol),  Up: Control constructs/predicates

Documentation on exports (`basiccontrol')
=========================================

 - PREDICATE: ,/2:
     `P , Q'

     Conjunction (`P' *and* `Q').

     *Usage:* `+callable , +callable' < * ISO * >

 - PREDICATE: ;/2:
     `P ; Q'

     Disjunction (`P' *or* `Q').

     *Usage:* `+callable ; +callable' < * ISO * >

 - PREDICATE: ->/2:
     `P -> Q'

     If `P' then `Q' else fail, using first solution of `P' only.
     Also, `('`P' `->' `Q' `;' `R'`)', if `P' then `Q' else `R',
     using first solution of `P' only. No cuts are allowed in `P'.

     *Usage:* `+callable -> +callable' < * ISO * >

 - PREDICATE: !/0:
     *Usage:* < * ISO * >
        - *Description:* Commit to any choices taken in the current
          predicate.

 - PREDICATE: \+/1:
     `\+ P'

     Goal `P' is not provable (negation by failure). Fails if `P' has
     a solution, and succeeds otherwise. No cuts are allowed in `P'.

     *Usage:* `\+ +callable' < * ISO * >

 - PREDICATE: if/3:
     `if(P,Q,R)'

     If `P' then `Q' else `R', exploring all solutions of `P'. No
     cuts are allowed in `P'.

     *Usage:* `if(+callable,+callable,+callable)'

 - PREDICATE: true/0:
     The predicate is of type *implicit*.

     *Usage:* < * ISO * >
        - *Description:* Succeed (noop).

 - PREDICATE: fail/0:
     The predicate is of type *implicit*.

     *Usage:* < * ISO * >
        - *Description:* Fail, backtrack immediately.

 - PREDICATE: repeat/0:
     The predicate is of type *implicit*.

     *Usage:* < * ISO * >
        - *Description:* Generates an infinite sequence of
          backtracking choices.

 - PREDICATE: call/1:
     `call(G)'

     Executes goal `G', restricting the scope of the cuts to the
     execution of `G'. Writing a variable `G' in a goal position is
     equivalent.

     *Meta-predicate* of type *implicit* with arguments: `call(goal)'.

     *Usage:* `call(+callable)' < * ISO * >


File: ciao.info,  Node: Documentation on internals (basiccontrol),  Prev: Documentation on exports (basiccontrol),  Up: Control constructs/predicates

Documentation on internals (`basiccontrol')
===========================================

 - PREDICATE: |/2:
     An alias for disjunction (when appearing outside a list). The
     alias is performed when terms are read in.


 - PREDICATE: call/2:
     `call(Pred,Arg1)'

     There exists a set of builtin predicates of the form `call/N'
     such that execute predicate `Pred' given arguments `Arg1' ...
     `ArgX', if `Pred' has already arguments the new ones are added
     to the start. This predicate can be written using the special
     Ciao syntax `Pred(Arg1,...,ArgX)'.

     *Usage:* `call(+callable,?)'


File: ciao.info,  Node: Basic builtin directives,  Next: Basic data types and properties,  Prev: Control constructs/predicates,  Up: Top

Basic builtin directives
************************

   *Author(s):* Daniel Cabeza.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 0.9#11 (1999/3/18, 21:28:24 MET)

   This chapter documents the basic builtin directives in CIAO,
additional to the documented in other chapters. These directives are
natively interpreted by the CIAO compiler ( `ciaoc').

   Unlike in other Prolog systems, directives in CIAO are not goals
to be *executed* by the compiler or top level. Instead, they are
*read* and acted upon by these programs. The advantage of this is
that the effect of the directives is consistent for executables, code
loaded in the top level, code analyzed by the preprocessor, etc.

   As a result, by default only the builtin directives or
declarations defined in this manual can be used in user programs.
However, it is possible to define new declarations by using the
`new_declaration/1' and `new_declaration/2' directives documented in
*Note Extending the syntax::.

* Menu:

* Usage and interface (builtin_directives)::
* Documentation on internals (builtin_directives)::


File: ciao.info,  Node: Usage and interface (builtin_directives),  Next: Documentation on internals (builtin_directives),  Prev: Basic builtin directives,  Up: Basic builtin directives

Usage and interface (`builtin_directives')
==========================================

   * *Library usage:*

     These directives are builtin in CIAO, so nothing special has to
     be done to use them.


File: ciao.info,  Node: Documentation on internals (builtin_directives),  Prev: Usage and interface (builtin_directives),  Up: Basic builtin directives

Documentation on internals (`builtin_directives')
=================================================

 - DECLARATION: multifile/1:
     *Usage:* :- `multifile Predicates'.  < * ISO * >
        - *Description:* Specifies that each predicate in
          `Predicates' may have clauses in more than one file. Each
          file that contains clauses for a multifile predicate must
          contain a directive multifile for the predicate. The
          directive should precede all clauses of the affected
          predicates. This directive is defined as a prefix operator
          in the compiler.

        - *The following properties should hold at call time:*

          `Predicates' is a sequence or list of `predname's.
          (`basic_props:sequence_or_list/2')

 - DECLARATION: discontiguous/1:
     *Usage:* :- `discontiguous Predicates'.  < * ISO * >
        - *Description:* Specifies that each predicate in
          `Predicates' may be defined in this file by clauses which
          are not in consecutive order. Otherwise, a warning is
          signaled by the compiler when clauses of a predicate are
          not consecutive (this behavior is controllable by the
          prolog flag *discontiguous_warnings*). The directive should
          precede all clauses of the affected predicates. This
          directive is defined as a prefix operator in the compiler.

        - *The following properties should hold at call time:*

          `Predicates' is a sequence or list of `predname's.
          (`basic_props:sequence_or_list/2')

 - DECLARATION: impl_defined/1:
     *Usage:* :- `impl_defined(Predicates)'.
        - *Description:* Specifies that each predicate in
          `Predicates' is *impl*icitly *defined* in the current
          prolog source, either because it is a builtin predicate or
          because it is defined in a C file. Otherwise, a warning is
          signaled by the compiler when an exported predicate is not
          defined in the module or imported from other module.

        - *The following properties should hold at call time:*

          `Predicates' is a sequence or list of `predname's.
          (`basic_props:sequence_or_list/2')

 - DECLARATION: redefining/1:
     *Usage:* :- `redefining(Predicate)'.
        - *Description:* Specifies that this module redefines
          predicate `Predicate', also imported from other module, or
          imports it from more than one module. This prevents the
          compiler giving warnings about redefinitions of that
          predicate. `Predicate' can be partially (or totally)
          uninstantiated, to allow disabling those warnings for
          several (or all) predicates at once.

        - *The following properties should hold at call time:*

          `Predicate' is *compatible* with `predname'
          (`basic_props:compat/2')

 - DECLARATION: initialization/1:
     *Usage:* :- `initialization(Goal)'.  < * ISO * >
        - *Description:* `Goal' will be executed at the start of the
          execution of any program containing the current code.

        - *The following properties should hold at call time:*

          `Goal' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')

 - DECLARATION: on_abort/1:
     *Usage:* :- `on_abort(Goal)'.
        - *Description:* `Goal' will be executed after an abort of
          the execution of any program containing the current code.

        - *The following properties should hold at call time:*

          `Goal' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')


File: ciao.info,  Node: Basic data types and properties,  Next: Extra-logical properties for typing,  Prev: Basic builtin directives,  Up: Top

Basic data types and properties
*******************************

   *Author(s):* Daniel Cabeza, Manuel Hermenegildo.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 1.3#100 (1999/11/12, 17:14:25 MET)

   This library contains the set of basic properties used by the
builtin predicates, and which constitute the basic data types and
properties of the language. They can be used both as type testing
builtins within programs (by calling them explicitly) and as
properties in assertions.

* Menu:

* Usage and interface (basic_props)::
* Documentation on exports (basic_props)::


File: ciao.info,  Node: Usage and interface (basic_props),  Next: Documentation on exports (basic_props),  Prev: Basic data types and properties,  Up: Basic data types and properties

Usage and interface (`basic_props')
===================================

   * *Library usage:*

     `:- use_module(library(basic_props)).'

   * *Exports:*
        - *Properties:*

          `member/2', `compat/2', `iso/1', `not_further_inst/2',
          `regtype/1'.

        - *Regular Types:*

          `term/1', `int/1', `nnegint/1', `flt/1', `num/1', `atm/1',
          `struct/1', `gnd/1', `constant/1', `callable/1',
          `operator_specifier/1', `list/1', `list/2', `sequence/2',
          `sequence_or_list/2', `character_code/1', `string/1',
          `predname/1', `atm_or_atm_list/1'.



File: ciao.info,  Node: Documentation on exports (basic_props),  Prev: Usage and interface (basic_props),  Up: Basic data types and properties

Documentation on exports (`basic_props')
========================================

 - REGTYPE: term/1:
     The most general type (includes all possible terms).

     *Usage:* `term(X)'
        - *Description:* `X' is any term.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: int/1:
     The type of integers. The range of integers is `[-2^2147483616,
     2^2147483616)'. Thus for all practical purposes, the range of
     integers can be considered infinite.

     *Usage:* `int(T)'
        - *Description:* `T' is an integer.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: nnegint/1:
     The type of non-negative integers, i.e., natural numbers.

     *Usage:* `nnegint(T)'
        - *Description:* `T' is a non-negative integer.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: flt/1:
     The type of floating-point numbers. The range of floats is the
     one provided by the C `double' type, typically `[4.9e-324,
     1.8e+308]' (plus or minus).

     *Usage:* `flt(T)'
        - *Description:* `T' is a float.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: num/1:
     The type of numbers, that is, integer or floating-point.

     *Usage:* `num(T)'
        - *Description:* `T' is a number.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: atm/1:
     The type of atoms, or non-numeric constants. The name of an atom
     must be of less than 512 characters.

     *Usage:* `atm(T)'
        - *Description:* `T' is an atom.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: struct/1:
     The type of compound terms, or terms with non-zeroary functors.

     *Usage:* `struct(T)'
        - *Description:* `T' is a compound term.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: gnd/1:
     The type of all terms without variables.

     *Usage:* `gnd(T)'
        - *Description:* `T' is ground.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: constant/1:
     *Usage:* `constant(T)'
        - *Description:* `T' is an atomic term (an atom or a number).

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: callable/1:
     *Usage:* `callable(T)'
        - *Description:* `T' is a term which represents a goal, i.e.,
          an atom or a structure.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: operator_specifier/1:
     The type and associativity of an operator is described by the
     following mnemonic atoms:

    `xfx'
          Infix, non-associative: it is a requirement that both of
          the two subexpressions which are the arguments of the
          operator must be of *lower* precedence than the operator
          itself.

    `xfy'
          Infix, right-associative: only the first (left-hand)
          subexpression must be of lower precedence; the right-hand
          subexpression can be of the *same* precedence as the main
          operator.

    `xfx'
          Infix, left-associative: same as above, but the other way
          around.

    `fx'
          Prefix, non-associative: the subexpression must be of
          *lower* precedence than the operator.

    `fy'
          Prefix, associative: the subexpression can be of the *same*
          precedence as the operator.

    `xf'
          Postfix, non-associative: the subexpression must be of
          *lower* precedence than the operator.

    `yf'
          Postfix, associative: the subexpression can be of the
          *same* precedence as the operator.

     *Usage:* `operator_specifier(X)'
        - *Description:* `X' specifies the type and associativity of
          an operator.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: list/1:
     A list is formed with successive applications of the functor
     `'.'/2', and its end is the atom `[]'

     *Usage:* `list(L)'
        - *Description:* `L' is a list.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: list/2:
     *Meta-predicate* with arguments: `list(?,pred(1))'.

     *Usage:* `list(L,T)'
        - *Description:* `L' is a list of `T's.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - PROPERTY: member/2:
     *Usage:* `member(X,L)'
        - *Description:* `X' is an element of `L'.

 - REGTYPE: sequence/2:
     A sequence is formed with zero, one or more occurrences of the
     operator `','/2'. For example, `a, b, c' is a sequence of three
     atoms, `a' is a sequence of one atom.

     *Meta-predicate* with arguments: `sequence(?,pred(1))'.

     *Usage:* `sequence(S,T)'
        - *Description:* `S' is a sequence of `T's.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: sequence_or_list/2:
     *Meta-predicate* with arguments: `sequence_or_list(?,pred(1))'.

     *Usage:* `sequence_or_list(S,T)'
        - *Description:* `S' is a sequence or list of `T's.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: character_code/1:
     *Usage:* `character_code(T)'
        - *Description:* `T' is an integer which is a character code.

        - *The following properties hold upon exit:*

          `T' is an integer.   (`basic_props:int/1')

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: string/1:
     *Usage:* `string(T)'
        - *Description:* `T' is a string (a list of character codes).

        - *The following properties hold upon exit:*

          `T' is a list of `character_code's.   (`basic_props:list/2')

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: predname/1:
     *Usage:* `predname(P)'
        - *Description:* `P' is a Name/Arity structure denoting a
          predicate name:
               predname(P/A) :-
                       atm(P),
                       int(A).

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: atm_or_atm_list/1:
     *Usage:* `atm_or_atm_list(T)'
        - *Description:* `T' is an atom or a list of atoms.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - PROPERTY: compat/2:
     This property captures the notion of type or property
     compatibility. The instantiation or constraint state of the term
     is compatible with the given property, in the sense that
     assuming that imposing that property on the term does not render
     the store inconsistent. For example, terms `X' (i.e., a free
     variable), `[Y|Z]', and `[Y,Z]' are all compatible with the
     regular type `list/1', whereas the terms `f(a)' and `[1|2]' are
     not.

     *Meta-predicate* with arguments: `compat(?,pred(1))'.

     *Usage:* `compat(Term,Prop)'
        - *Description:* `Term' is *compatible* with `Prop'

 - PROPERTY: iso/1:
     The predicate is of type *implicit*.

     *Usage:* `iso(G)'
        - *Description:* *Complies with the ISO-Prolog standard.*

 - PROPERTY: not_further_inst/2:
     The predicate is of type *implicit*.

     *Usage:* `not_further_inst(G,V)'
        - *Description:* `V' is not further instantiated.

 - PROPERTY: regtype/1:
     The predicate is of type *implicit*.

     *Usage:* `regtype(G)'
        - *Description:* Defines a regular type.


File: ciao.info,  Node: Extra-logical properties for typing,  Next: Basic term manipulation,  Prev: Basic data types and properties,  Up: Top

Extra-logical properties for typing
***********************************

   *Author(s):* Daniel Cabeza, Manuel Hermenegildo.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 0.7#8 (1998/9/23, 19:21:44 MEST)

   This library contains traditional Prolog predicates for testing
types. They depend on the state of instantiation of their arguments,
thus being of extra-logical nature.

* Menu:

* Usage and interface (term_typing)::
* Documentation on exports (term_typing)::


File: ciao.info,  Node: Usage and interface (term_typing),  Next: Documentation on exports (term_typing),  Prev: Extra-logical properties for typing,  Up: Extra-logical properties for typing

Usage and interface (`term_typing')
===================================

   * *Library usage:*

     These predicates are builtin in CIAO, so nothing special has to
     be done to use them.

   * *Exports:*
        - *Properties:*

          `var/1', `nonvar/1', `atom/1', `integer/1', `float/1',
          `number/1', `atomic/1', `ground/1', `type/2'.



File: ciao.info,  Node: Documentation on exports (term_typing),  Prev: Usage and interface (term_typing),  Up: Extra-logical properties for typing

Documentation on exports (`term_typing')
========================================

 - PROPERTY: var/1:
     *Usage:* `var(X)'
        - *Description:* `X' is a free variable.

        - *The following properties hold globally:*

          `X' is not further instantiated.
          (`basic_props:not_further_inst/2')

 - PROPERTY: nonvar/1:
     *Usage:* `nonvar(T)'
        - *Description:* `T' is currently a term which is not a free
          variable.

        - *The following properties hold globally:*

          `T' is not further instantiated.
          (`basic_props:not_further_inst/2')

 - PROPERTY: atom/1:
     *Usage:* `atom(X)'
        - *Description:* `X' is currently instantiated to an atom.

        - *The following properties hold globally:*

          `X' is not further instantiated.
          (`basic_props:not_further_inst/2')

 - PROPERTY: integer/1:
     *Usage:* `integer(X)'
        - *Description:* `X' is currently instantiated to an integer.

        - *The following properties hold globally:*

          `X' is not further instantiated.
          (`basic_props:not_further_inst/2')

 - PROPERTY: float/1:
     *Usage:* `float(X)'
        - *Description:* `X' is currently instantiated to a float.

        - *The following properties hold globally:*

          `X' is not further instantiated.
          (`basic_props:not_further_inst/2')

 - PROPERTY: number/1:
     *Usage:* `number(X)'
        - *Description:* `X' is currently instantiated to a number.

        - *The following properties hold globally:*

          `X' is not further instantiated.
          (`basic_props:not_further_inst/2')

 - PROPERTY: atomic/1:
     *Usage:* `atomic(X)'
        - *Description:* `X' is currently instantiated to an atom or
          a number.

        - *The following properties hold globally:*

          `X' is not further instantiated.
          (`basic_props:not_further_inst/2')

 - PROPERTY: ground/1:
     *Usage:* `ground(X)'
        - *Description:* `X' is currently ground (it contains no
          variables).

        - *The following properties hold globally:*

          `X' is not further instantiated.
          (`basic_props:not_further_inst/2')

 - PROPERTY: type/2:
     *Usage:* `type(X,Y)'
        - *Description:* `X' is internally of type `Y' (`var',
          `attv', `float', `integer', `structure', `atom' or `list').

        - *The following properties hold upon exit:*

          `Y' is an atom.   (`basic_props:atm/1')


File: ciao.info,  Node: Basic term manipulation,  Next: Comparing terms,  Prev: Extra-logical properties for typing,  Up: Top

Basic term manipulation
***********************

   *Author(s):* Daniel Cabeza, Manuel Hermenegildo.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

* Menu:

* Usage and interface (term_basic)::
* Documentation on exports (term_basic)::


File: ciao.info,  Node: Usage and interface (term_basic),  Next: Documentation on exports (term_basic),  Prev: Basic term manipulation,  Up: Basic term manipulation

Usage and interface (`term_basic')
==================================

   * *Library usage:*

     These predicates are builtin in CIAO, so nothing special has to
     be done to use them.

   * *Exports:*
        - *Predicates:*

          `arg/3', `functor/3', `=../2', `copy_term/2', `C/3'.

        - *Properties:*

          `=/2'.



File: ciao.info,  Node: Documentation on exports (term_basic),  Prev: Usage and interface (term_basic),  Up: Basic term manipulation

Documentation on exports (`term_basic')
=======================================

 - PROPERTY: =/2:
     *Usage:* `X = Y' < * ISO * >
        - *Description:* Unify `X' and `Y'.

 - PREDICATE: arg/3:
     *Usage:* `arg(+ArgNo,+Term,?(Arg))' < * ISO * >
        - *Description:* Argument `ArgNo' of the term `Term' is `Arg'.

        - *The following properties should hold at call time:*

          `ArgNo' is currently instantiated to an integer.
          (`term_typing:integer/1')

 - PREDICATE: functor/3:
     *Usage:* `functor(?(Term),?(Name),?(Arity))' < * ISO * >
        - *Description:* The principal functor of the term `Term' has
          name `Name' and arity `Arity'.

 - PREDICATE: =../2:
     *Usage:* `?(Term) =.. ?(List)' < * ISO * >
        - *Description:* The functor and arguments of the term `Term'
          comprise the list `List'.

 - PREDICATE: copy_term/2:
     The predicate is of type *implicit*.

     *Usage:* `copy_term(Term,Copy)' < * ISO * >
        - *Description:* `Copy' is a renaming of `Term', such that
          brand new variables have been substituted for all variables
          in `Term'. If any of the variables of `Term' have
          attributes, the copied variables will have copies of the
          attributes as well. It behaves as if defined by:

               :- data 'copy of'/1.
               
               copy_term(X, Y) :-
                       asserta_fact('copy of'(X)),
                       retract_fact('copy of'(Y)).


 - PREDICATE: C/3:
     *Usage:* `C(?(S1),?(Terminal),?(S2))'
        - *Description:* `S1' is connected by the terminal `Terminal'
          to `S2'. Used in *DCG grammar rules*. Defined as if by the
          single clause: `'C'([X|S], X, S).'


File: ciao.info,  Node: Comparing terms,  Next: Basic predicates handling names of constants,  Prev: Basic term manipulation,  Up: Top

Comparing terms
***************

   *Author(s):* Daniel Cabeza, Manuel Hermenegildo.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   These built-in predicates are extra-logical. They treat
uninstantiated variables as objects with values which may be
compared, and they never instantiate those variables. They should
*not* be used when what you really want is arithmetic comparison or
unification.

   The predicates make reference to a *standard total ordering* of
terms, which is as follows:

   * Variables, by age (roughly, oldest first - the order is *not*
     related to the names of variables).

   * Floats, in numeric order (e.g. -1.0 is put before 1.0).

   * Integers, in numeric order (e.g. -1 is put before 1).

   * Atoms, in alphabetical (i.e. character code) order.

   * Compound terms, ordered first by arity, then by the name of the
     principal functor, then by the arguments in left-to-right order.
     Recall that lists are equivalent to compound terms with
     principal functor `'.'/2'.

   For example, here is a list of terms in standard order:

     [ X, -1.0, -9, 1, bar, foo, [1], X = Y, foo(0,2), bar(1,1,1) ]

* Menu:

* Usage and interface (term_compare)::
* Documentation on exports (term_compare)::


File: ciao.info,  Node: Usage and interface (term_compare),  Next: Documentation on exports (term_compare),  Prev: Comparing terms,  Up: Comparing terms

Usage and interface (`term_compare')
====================================

   * *Library usage:*

     These predicates are builtin in CIAO, so nothing special has to
     be done to use them.

   * *Exports:*
        - *Predicates:*

          `compare/3'.

        - *Properties:*

          `==/2', `\==/2', `@</2', `@=</2', `@>/2', `@>=/2'.



File: ciao.info,  Node: Documentation on exports (term_compare),  Prev: Usage and interface (term_compare),  Up: Comparing terms

Documentation on exports (`term_compare')
=========================================

 - PROPERTY: ==/2:
     *Usage:* `Term1 == Term2'
        - *Description:* The terms `Term1' and `Term2' are strictly
          identical.

        - *The following properties should hold globally:*

          `Term1' is not further instantiated.
          (`basic_props:not_further_inst/2')

          `Term2' is not further instantiated.
          (`basic_props:not_further_inst/2')

 - PROPERTY: \==/2:
     *Usage:* `Term1 \== Term2'
        - *Description:* The terms `Term1' and `Term2' are not
          strictly identical.

        - *The following properties should hold globally:*

          `Term1' is not further instantiated.
          (`basic_props:not_further_inst/2')

          `Term2' is not further instantiated.
          (`basic_props:not_further_inst/2')

 - PROPERTY: @</2:
     *Usage:* `@<(Term1,Term2)'
        - *Description:* The term `Term1' precedes the term `Term2'
          in the standard order.

        - *The following properties should hold globally:*

          `Term1' is not further instantiated.
          (`basic_props:not_further_inst/2')

          `Term2' is not further instantiated.
          (`basic_props:not_further_inst/2')

 - PROPERTY: @=</2:
     *Usage:* `@=<(Term1,Term2)'
        - *Description:* The term `Term1' precedes or is identical to
          the term `Term2' in the standard order.

        - *The following properties should hold globally:*

          `Term1' is not further instantiated.
          (`basic_props:not_further_inst/2')

          `Term2' is not further instantiated.
          (`basic_props:not_further_inst/2')

 - PROPERTY: @>/2:
     *Usage:* `@>(Term1,Term2)'
        - *Description:* The term `Term1' follows the term `Term2' in
          the standard order.

        - *The following properties should hold globally:*

          `Term1' is not further instantiated.
          (`basic_props:not_further_inst/2')

          `Term2' is not further instantiated.
          (`basic_props:not_further_inst/2')

 - PROPERTY: @>=/2:
     *Usage:* `@>=(Term1,Term2)'
        - *Description:* The term `Term1' follows or is identical to
          the term `Term2' in the standard order.

        - *The following properties should hold globally:*

          `Term1' is not further instantiated.
          (`basic_props:not_further_inst/2')

          `Term2' is not further instantiated.
          (`basic_props:not_further_inst/2')

 - PREDICATE: compare/3:
     `compare(Op,Term1,Term2)'

     `Op' is the result of comparing the terms `Term1' and `Term2'.

     *Usage:* `compare(?(atm),@(term),@(term))'
        - *The following properties should hold upon exit:*

          `?(atm)' is an element of `[=,>,<]'.
          (`basic_props:member/2')

          `@(term)' is any term.   (`basic_props:term/1')

          `@(term)' is any term.   (`basic_props:term/1')


File: ciao.info,  Node: Basic predicates handling names of constants,  Next: Arithmetic,  Prev: Comparing terms,  Up: Top

Basic predicates handling names of constants
********************************************

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   The CIAO system provides builtin predicates which allow dealing
with names of constants (atoms or numbers). As an atom name must be
of less than 512 characters, to handle sequences of more characters,
strings (character code lists) must be used.

* Menu:

* Usage and interface (atomic_basic)::
* Documentation on exports (atomic_basic)::


File: ciao.info,  Node: Usage and interface (atomic_basic),  Next: Documentation on exports (atomic_basic),  Prev: Basic predicates handling names of constants,  Up: Basic predicates handling names of constants

Usage and interface (`atomic_basic')
====================================

   * *Library usage:*

     These predicates are builtin in CIAO, so nothing special has to
     be done to use them.

   * *Exports:*
        - *Predicates:*

          `name/2', `atom_codes/2', `number_codes/2',
          `number_codes/3', `atom_length/2', `atom_concat/3',
          `sub_atom/4'.



File: ciao.info,  Node: Documentation on exports (atomic_basic),  Prev: Usage and interface (atomic_basic),  Up: Basic predicates handling names of constants

Documentation on exports (`atomic_basic')
=========================================

 - PREDICATE: name/2:
     `name(Const,String)'

     `String' is the list of the ASCII codes of the characters
     comprising the name of `Const'. Note that if `Const' is an atom
     whose name can be interpreted as a number (e.g. '96'), the
     predicate is not reversible, as that atom will not be
     constructed when `Const' is uninstantiated. Thus it is
     recommended that new programs use the ISO-compliant predicates
     `atom_codes/2' or `number_codes/2', as these predicates do not
     have this inconsistency.

     The predicate is of type *implicit*.

     *Usage 1:* `name(+constant,?(string))'
     *Usage 2:* `name(-(constant),+string)'
        - *Description:* If `String' can be interpreted as a number,
          `Const' is unified with that number, otherwise with the
          atom whose name is `String'.

 - PREDICATE: atom_codes/2:
     `atom_codes(Atom,String)'

     `String' is the list of the ASCII codes of the characters
     comprising the name of `Atom'.

     The predicate is of type *implicit*.

     *Usage 1:* `atom_codes(+atm,?(string))' < * ISO * >
     *Usage 2:* `atom_codes(-(atm),+string)' < * ISO * >

 - PREDICATE: number_codes/2:
     `number_codes(Number,String)'

     `String' is the list of the ASCII codes of the characters
     comprising a representation of `Number'.

     The predicate is of type *implicit*.

     *Usage 1:* `number_codes(+num,?(string))' < * ISO * >
     *Usage 2:* `number_codes(-(num),+string)' < * ISO * >

 - PREDICATE: number_codes/3:
     `number_codes(Number,String,Base)'

     `String' is the list of the ASCII codes of the characters
     comprising a representation of `Number' in base `Base'.

     *Usage 1:* `number_codes(+num,?(string),+int)'
     *Usage 2:* `number_codes(-(num),+string,+int)'

 - PREDICATE: atom_length/2:
     `atom_length(Atom,Length)'

     `Length' is the number of characters forming the name of `Atom'.

     The predicate is of type *implicit*.

     *Usage:* `atom_length(+atm,?(int))' < * ISO * >

 - PREDICATE: atom_concat/3:
     `atom_concat(Atom_1,Atom_2,Atom_12)'

     `Atom_12' is the result of concatenating `Atom_1' followed by
     `Atom_2'.

     The predicate is of type *implicit*.

     *Usage 1:* `atom_concat(+atom,+atom,?(atom))' < * ISO * >
        - *Description:* Concatenate two atoms.

     *Usage 2:* `atom_concat(-(atom),-(atom),+atom)' < * ISO * >
        - *Description:* Non-deterministically split an atom.

     *Usage 3:* `atom_concat(-(atom),+atom,+atom)' < * ISO * >
        - *Description:* Take out of an atom a certain suffix (or
          fail if it cannot be done).

     *Usage 4:* `atom_concat(+atom,-(atom),+atom)' < * ISO * >
        - *Description:* Take out of an atom a certain prefix (or
          fail if it cannot be done).

 - PREDICATE: sub_atom/4:
     `sub_atom(Atom,Before,Length,Sub_atom)'

     `Sub_atom' is formed with `Length' consecutive characters of
     `Atom' after the `Before' character.

     The predicate is of type *implicit*.

     *Usage:* `sub_atom(+atm,+integer,+integer,?(atm))'


File: ciao.info,  Node: Arithmetic,  Next: Basic input/output,  Prev: Basic predicates handling names of constants,  Up: Top

Arithmetic
**********

   *Author(s):* Daniel Cabeza, Manuel Hermenegildo.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 0.9#18 (1999/3/23, 21:6:13 MET)

   Arithmetic is performed by built-in predicates which take as
arguments arithmetic expressions (see `arithexpression/1') and
evaluate them. Terms representing arithmetic expressions can be
created dynamically, but at the time of evaluation, each variable in
an arithmetic expression must be bound to a non-variable expression
(the term must be ground). For example, given the code in the first
line a possible shell interaction follows:
     evaluate(Expression, Answer) :- Answer is Expression.
     
     ?- _X=24*9, evaluate(_X+6, Ans).
     
     Ans = 222 ?
     
     yes

* Menu:

* Usage and interface (arithmetic)::
* Documentation on exports (arithmetic)::


File: ciao.info,  Node: Usage and interface (arithmetic),  Next: Documentation on exports (arithmetic),  Prev: Arithmetic,  Up: Arithmetic

Usage and interface (`arithmetic')
==================================

   * *Library usage:*

     These predicates are builtin in Ciao, so nothing special has to
     be done to use them.

   * *Exports:*
        - *Predicates:*

          `is/2', `</2', `=</2', `>/2', `>=/2', `=:=/2', `=\=/2'.

        - *Regular Types:*

          `arithexpression/1'.



File: ciao.info,  Node: Documentation on exports (arithmetic),  Prev: Usage and interface (arithmetic),  Up: Arithmetic

Documentation on exports (`arithmetic')
=======================================

 - PREDICATE: is/2:
     `Val is Exp'

     The arithmetic expression `Exp' is evaluated and the result is
     unified with `Val'

     *Usage:* `?(term) is +arithexpression' < * ISO * >

 - PREDICATE: </2:
     `Exp1 < Exp2'

     The numeric value of `Exp1' is less than the numeric value of
     `Exp2' when both are evaluated as arithmetic expressions.

     *Usage:* `+arithexpression < +arithexpression' < * ISO * >

 - PREDICATE: =</2:
     `Exp1 =< Exp2'

     The numeric value of `Exp1' is less than or equal to the numeric
     value of `Exp2' when both are evaluated as arithmetic
     expressions.

     *Usage:* `+arithexpression =< +arithexpression' < * ISO * >

 - PREDICATE: >/2:
     `Exp1 > Exp2'

     The numeric value of `Exp1' is greater than the numeric value of
     `Exp2' when both are evaluated as arithmetic expressions.

     *Usage:* `+arithexpression > +arithexpression' < * ISO * >

 - PREDICATE: >=/2:
     `Exp1 >= Exp2'

     The numeric value of `Exp1' is greater than or equal to the
     numeric value of `Exp2' when both are evaluated as arithmetic
     expressions.

     *Usage:* `+arithexpression >= +arithexpression' < * ISO * >

 - PREDICATE: =:=/2:
     `Exp1 =:= Exp2'

     The numeric values of `Exp1' and `Exp2' are equal when both are
     evaluated as arithmetic expressions.

     *Usage:* `+arithexpression =:= +arithexpression' < * ISO * >

 - PREDICATE: =\=/2:
     `Exp1 =\= Exp2'

     The numeric values of `Exp1' and `Exp2' are not equal when both
     are evaluated as arithmetic expressions.

     *Usage:* `+arithexpression =\= +arithexpression' < * ISO * >

 - REGTYPE: arithexpression/1:
     An arithmetic expression is a term built from numbers and
     evaluable functors that represent arithmetic functions. An
     arithmetic expression evaluates to a number, which may be an
     integer ( `int/1') or a float ( `flt/1'). The evaluable functors
     allowed in an arithmetic expression are listed below, together
     with an indication of the functions they represent. All
     evaluable functors defined in ISO-Prolog are implemented, as
     well as some other useful or traditional. Unless stated
     otherwise, an expression evaluates to a float if any of its
     arguments is a float, otherwise to an integer.

        * `- /1': sign reversal.  < * ISO * >

        * `+ /1': identity.

        * `-- /1': decrement by one.

        * `++ /1': increment by one.

        * `+ /2': addition.  < * ISO * >

        * `- /2': subtraction.  < * ISO * >

        * `* /2': multiplication.  < * ISO * >

        * `// /2': integer division. Float arguments are truncated to
          integers, result always integer.  < * ISO * >

        * `/ /2': division. Result always float.  < * ISO * >

        * `rem/2': integer remainder. The result is always an
          integer, its sign is the sign of the first argument.  < *
          ISO * >

        * `mod/2': modulo. The result is always a positive integer.
          < * ISO * >

        * `abs/1': absolute value.  < * ISO * >

        * `sign/1': sign of.  < * ISO * >

        * `float_integer_part/1': float integer part. Result always
          float.  < * ISO * >

        * `float_fractional_part/1': float fractional part. Result
          always float.  < * ISO * >

        * `truncate/1': The result is the integer equal to the
          integer part of the argument.  < * ISO * >

        * `integer/1': same as `truncate/1'.

        * `float/1': conversion to float.  < * ISO * >

        * `floor/1': largest integer not greater than.  < * ISO * >

        * `round/1': integer nearest to.  < * ISO * >

        * `ceiling/1': smallest integer not smaller than.  < * ISO * >

        * `** /2': exponentiation. Result always float.  < * ISO * >

        * `>> /2': integer bitwise right shift.  < * ISO * >

        * `<< /2': integer bitwise left shift.  < * ISO * >

        * `/\ /2': integer bitwise and.  < * ISO * >

        * `\/ /2': integer bitwise or.  < * ISO * >

        * `\ /1': integer bitwise complement.  < * ISO * >

        * `# /2': integer bitwise exclusive or (xor).

        * `exp/1': exponential (*e* to the power of). Result always
          float.  < * ISO * >

        * `log/1': natural logarithm (base *e*). Result always float.
          < * ISO * >

        * `sqrt/1': square root. Result always float.  < * ISO * >

        * `sin/1': sine. Result always float.  < * ISO * >

        * `cos/1': cosine. Result always float.  < * ISO * >

        * `atan/1': arc tangent. Result always float.  < * ISO * >

        * `gcd/2': Greatest common divisor. Arguments must evaluate
          to integers, result always integer.

     In addition to these functors, a list of just a number evaluates
     to this number. Since a quoted string is just a list of
     integers, this allows a quoted character to be used in place of
     its ASCII code; e.g. `"A"' behaves within arithmetic expressions
     as the integer 65. Note that this is not ISO-compliant, and that
     can be achieved by using the notation `0'A' (which is ISO).

     Arithmetic expressions, as described above, are just data
     structures. If you want one evaluated you must pass it as an
     argument to one of the arithmetic predicates defined here.

     *Usage:* `arithexpression(E)'
        - *Description:* `E' is an arithmetic expression.

        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')


File: ciao.info,  Node: Basic input/output,  Next: Basic file/stream handling,  Prev: Arithmetic,  Up: Top

Basic input/output
******************

   *Author(s):* Daniel Cabeza, Mats Carlsson.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   This module provides predicates for character input/output and for
canonical term output. From the ISO-Prolog predicates for character
input/output, only the `_code' versions are provided, the rest are
given by `library(iso_byte_char)', using these. Most predicates are
provided in two versions: one that specifies the input or output
stream as the first argument and a second which omits this argument
and uses the current input or output stream.

* Menu:

* Usage and interface (io_basic)::
* Documentation on exports (io_basic)::


File: ciao.info,  Node: Usage and interface (io_basic),  Next: Documentation on exports (io_basic),  Prev: Basic input/output,  Up: Basic input/output

Usage and interface (`io_basic')
================================

   * *Library usage:*

     These predicates are builtin in CIAO, so nothing special has to
     be done to use them.

   * *Exports:*
        - *Predicates:*

          `get_code/2', `get_code/1', `get1_code/2', `get1_code/1',
          `peek_code/2', `peek_code/1', `skip_code/2', `skip_code/1',
          `put_code/2', `put_code/1', `nl/1', `nl/0', `tab/2',
          `tab/1', `code_class/2', `getct/2', `getct1/2', `display/2',
          `display/1', `displayq/2', `displayq/1'.



File: ciao.info,  Node: Documentation on exports (io_basic),  Prev: Usage and interface (io_basic),  Up: Basic input/output

Documentation on exports (`io_basic')
=====================================

 - PREDICATE: get_code/2:
     `get_code(Stream,Code)'

     Reads from `Stream' the next character and unifies `Code' with
     its character code. At end of stream, unifies `Code' with the
     integer -1.

     The predicate is of type *implicit*.

     *Usage:* `get_code(+stream,?(int))' < * ISO * >

 - PREDICATE: get_code/1:
     `get_code(Code)'

     Behaves like `current_input(S), get_code(S,Code)'.

     The predicate is of type *implicit*.

     *Usage:* `get_code(?(int))' < * ISO * >

 - PREDICATE: get1_code/2:
     `get1_code(Stream,Code)'

     Reads from `Stream' the next non-layout character (see
     `code_class/2') and unifies `Code' with its character code. At
     end of stream, unifies `Code' with the integer -1.

     The predicate is of type *implicit*.

     *Usage:* `get1_code(+stream,?(int))'

 - PREDICATE: get1_code/1:
     `get1_code(Code)'

     Behaves like `current_input(S), get1_code(S,Code)'.

     The predicate is of type *implicit*.

     *Usage:* `get1_code(?(int))'

 - PREDICATE: peek_code/2:
     `peek_code(Stream,Code)'

     Unifies `Code' with the character code of the next character of
     `Stream', leaving the stream position unaltered. At end of
     stream, unifies `Code' with the integer -1.

     The predicate is of type *implicit*.

     *Usage:* `peek_code(+stream,?(int))' < * ISO * >

 - PREDICATE: peek_code/1:
     `peek_code(Code)'

     Behaves like `current_input(S), peek_code(S,Code)'.

     The predicate is of type *implicit*.

     *Usage:* `peek_code(?(int))' < * ISO * >

 - PREDICATE: skip_code/2:
     `skip_code(Stream,Code)'

     Skips just past the next character code `Code' from `Stream'.

     The predicate is of type *implicit*.

     *Usage:* `skip_code(+stream,+int)'

 - PREDICATE: skip_code/1:
     `skip_code(Code)'

     Behaves like `current_input(S), skip_code(S,Code)'.

     The predicate is of type *implicit*.

     *Usage:* `skip_code(+int)'

 - PREDICATE: put_code/2:
     `put_code(Stream,Code)'

     Outputs to `Stream' the character corresponding to character
     code `Code'.

     The predicate is of type *implicit*.

     *Usage:* `put_code(+stream,+int)' < * ISO * >

 - PREDICATE: put_code/1:
     `put_code(Code)'

     Behaves like `current_output(S), put_code(S,Code)'.

     The predicate is of type *implicit*.

     *Usage:* `put_code(+int)' < * ISO * >

 - PREDICATE: nl/1:
     `nl(Stream)'

     Outputs a newline character to `Stream'. Equivalent to
     `put_code(Stream, 0'\n)'.

     The predicate is of type *implicit*.

     *Usage:* `nl(+stream)' < * ISO * >

 - PREDICATE: nl/0:
     `nl'

     Behaves like `current_output(S), nl(S)'.

     The predicate is of type *implicit*.

     *Usage:* < * ISO * >

 - PREDICATE: tab/2:
     `tab(Stream,Num)'

     Outputs `Num' spaces to `Stream'.

     The predicate is of type *implicit*.

     *Usage:* `tab(+stream,+int)'

 - PREDICATE: tab/1:
     `tab(Num)'

     Behaves like `current_output(S), tab(S,Num)'.

     The predicate is of type *implicit*.

     *Usage:* `tab(+int)'

 - PREDICATE: code_class/2:
     `code_class(Code,Class)'

     Unifies `Class' with an integer corresponding to the lexical
     class of the character whose code is `Code', with the following
     correspondence:
              0 - layout (includes space, newline, tab)
              1 - small letter
              2 - capital letter (including '_')
              3 - digit
              4 - graphic (includes #$&*+-./:<=>?@^\`~ )
              5 - punctuation (includes !;"'%(),[]{|} )
     Note that in ISO-Prolog the back quote ``' is a punctuation
     character, whereas in CIAO it is a graphic character. Thus, if
     compatibility with ISO-Prolog is desired, the programmer should
     not use this character in unquoted names.

     The predicate is of type *implicit*.

     *Usage:* `code_class(+int,?(int))'

 - PREDICATE: getct/2:
     `getct(Code,Type)'

     Reads from the current input stream the next character, unifying
     `Code' with its character code, and `Type' with its lexical
     class. At end of stream, unifies both `Code' and `Type' with the
     integer -1. Equivalent to
             get(Code), (Code = -1 -> Type = -1 ; code_class(Code,Type))

     The predicate is of type *implicit*.

     *Usage:* `getct(?(int),?(int))'

 - PREDICATE: getct1/2:
     `getct1(Code,Type)'

     Reads from the current input stream the next non-layout
     character, unifying `Code' with its character code, and `Type'
     with its lexical class (which will be nonzero). At end of
     stream, unifies both `Code' and `Type' with the integer -1.
     Equivalent to
             get1(Code), (Code = -1 -> Type = -1 ; code_class(Code,Type))

     The predicate is of type *implicit*.

     *Usage:* `getct1(?(int),?(int))'

 - PREDICATE: display/2:
     `display(Stream,Term)'

     Displays `Term' onto `Stream'. Lists are output using list
     notation, the other compound terms are output in functional
     notation. Similar to `write_term(Stream, Term,
     [ignore_ops(ops)])', except that curly bracketed notation is not
     used with `{}/1', and the `write_strings' flag is not honored.

     The predicate is of type *implicit*.

     *Usage:* `display(+stream,@(term))'

 - PREDICATE: display/1:
     `display(Term)'

     Behaves like `current_output(S), display(S,Term)'.

     The predicate is of type *implicit*.

     *Usage:* `display(@(term))'

 - PREDICATE: displayq/2:
     `displayq(Stream,Term)'

     Similar to `display(Stream, Term)', but atoms and functors that
     can't be read back by `read_term/3' are quoted. Thus, similar to
     `write_term(Stream, Term, [quoted(true), ignore_ops(ops)])',
     with the same exceptions as `display/2'.

     The predicate is of type *implicit*.

     *Usage:* `displayq(+stream,@(term))'

 - PREDICATE: displayq/1:
     `displayq(Term)'

     Behaves like `current_output(S), displayq(S,Term)'.

     The predicate is of type *implicit*.

     *Usage:* `displayq(@(term))'


File: ciao.info,  Node: Basic file/stream handling,  Next: Exception handling,  Prev: Basic input/output,  Up: Top

Basic file/stream handling
**************************

   *Author(s):* Daniel Cabeza, Mats Carlsson.

   *Version:* 1.3#121 (1999/11/26, 20:23:11 MET)

   This module provides basic predicates for handling files and
streams, in order to make input/output on them.

* Menu:

* Usage and interface (streams_basic)::
* Documentation on exports (streams_basic)::
* Documentation on multifiles (streams_basic)::


File: ciao.info,  Node: Usage and interface (streams_basic),  Next: Documentation on exports (streams_basic),  Prev: Basic file/stream handling,  Up: Basic file/stream handling

Usage and interface (`streams_basic')
=====================================

   * *Library usage:*

     These predicates are builtin in CIAO, so nothing special has to
     be done to use them.

   * *Exports:*
        - *Predicates:*

          `open/3', `close/1', `set_input/1', `current_input/1',
          `set_output/1', `current_output/1', `character_count/2',
          `line_count/2', `line_position/2', `flush_output/1',
          `flush_output/0', `clearerr/1', `current_stream/3',
          `stream_code/2', `absolute_file_name/2',
          `absolute_file_name/7'.

        - *Regular Types:*

          `sourcename/1', `stream/1', `io_mode/1'.

        - *Multifiles:*

          `file_search_path/2', `library_directory/1'.



File: ciao.info,  Node: Documentation on exports (streams_basic),  Next: Documentation on multifiles (streams_basic),  Prev: Usage and interface (streams_basic),  Up: Basic file/stream handling

Documentation on exports (`streams_basic')
==========================================

 - PREDICATE: open/3:
     `open(File,Mode,Stream)'

     Open `File' with mode `Mode' and return in `Stream' the stream
     associated with the file. No extension is implicit in `File'.

     *Usage 1:* `open(+sourcename,+io_mode,?(stream))' < * ISO * >
        - *Description:* Normal use.

     *Usage 2:* `open(+int,+io_mode,?(stream))'
        - *Description:* In the special case that `File' is an
          integer, it is assumed to be a file descriptor passed to
          Prolog from a foreign function call. The file descriptor is
          connected to a Prolog stream (invoking the UNIX function
          `fdopen') which is unified with `Stream'.

 - PREDICATE: close/1:
     `close(Stream)'

     Close the stream `Stream'.

     The predicate is of type *implicit*.

     *Usage:* `close(+stream)' < * ISO * >

 - PREDICATE: set_input/1:
     `set_input(Stream)'

     Set the current input stream to `Stream'. A notion of *current
     input stream* is maintained by the system, so that input
     predicates with no explicit stream operate on the current input
     stream. Initially it is set to `user_input'.

     The predicate is of type *implicit*.

     *Usage:* `set_input(+stream)' < * ISO * >

 - PREDICATE: current_input/1:
     `current_input(Stream)'

     Unify `Stream' with the current input stream.

     The predicate is of type *implicit*.

     *Usage:* `current_input(?(stream))' < * ISO * >

 - PREDICATE: set_output/1:
     `set_output(Stream)'

     Set the current output stream to `Stream'. A notion of *current
     output stream* is maintained by the system, so that output
     predicates with no explicit stream operate on the current output
     stream. Initially it is set to `user_output'.

     The predicate is of type *implicit*.

     *Usage:* `set_output(+stream)' < * ISO * >

 - PREDICATE: current_output/1:
     `current_output(Stream)'

     Unify `Stream' with the current output stream.

     The predicate is of type *implicit*.

     *Usage:* `current_output(?(stream))' < * ISO * >

 - PREDICATE: character_count/2:
     `character_count(Stream,Count)'

     `Count' characters have been read from or written to `Stream'.

     The predicate is of type *implicit*.

     *Usage:* `character_count(+stream,?(int))'

 - PREDICATE: line_count/2:
     `line_count(Stream,Count)'

     `Count' lines have been read from or written to `Stream'.

     The predicate is of type *implicit*.

     *Usage:* `line_count(+stream,?(int))'

 - PREDICATE: line_position/2:
     `line_position(Stream,Count)'

     `Count' characters have been read from or written to the current
     line of `Stream'.

     The predicate is of type *implicit*.

     *Usage:* `line_position(+stream,?(int))'

 - PREDICATE: flush_output/1:
     `flush_output(Stream)'

     Flush any buffered data to output stream `Stream'.

     The predicate is of type *implicit*.

     *Usage:* `flush_output(+stream)' < * ISO * >

 - PREDICATE: flush_output/0:
     `flush_output'

     Behaves like `current_output(S), flush_output(S)'

     The predicate is of type *implicit*.

     *Usage:* < * ISO * >

 - PREDICATE: clearerr/1:
     `clearerr(Stream)'

     Clear the end-of-file and error indicators for input stream
     `Stream'.

     The predicate is of type *implicit*.

     *Usage:* `clearerr(+stream)'

 - PREDICATE: current_stream/3:
     `current_stream(Filename,Mode,Stream)'

     `Stream' is a stream which was opened in mode `Mode' and which
     is connected to the absolute file name `Filename' (an atom) or
     to the file descriptor `Filename' (an integer). This predicate
     can be used for enumerating all currently open streams through
     backtracking.

     The predicate is of type *implicit*.

     *Usage 1:* `current_stream(?(atm),?(io_mode),?(stream))'
     *Usage 2:* `current_stream(?(int),?(io_mode),?(stream))'

 - PREDICATE: stream_code/2:
     `stream_code(Stream,StreamCode)'

     `StreamCode' is the file descriptor (an integer) corresponding
     to the Prolog stream `Stream'.

     The predicate is of type *implicit*.

     *Usage 1:* `stream_code(+stream,?(int))'
     *Usage 2:* `stream_code(-(stream),+int)'

 - PREDICATE: absolute_file_name/2:
     `absolute_file_name(RelFileSpec,AbsFileSpec)'

     If `RelFileSpec' is an absolute pathname then do an absolute
     lookup. If `RelFileSpec' is a relative pathname then prefix the
     name with the name of the current directory and do an absolute
     lookup. If `RelFileSpec' is a path alias, perform the lookup
     following the path alias rules (see `sourcename/1'). In all
     cases: if a matching file with suffix `.pl' exists, then
     `AbsFileSpec' will be unified with this file. Failure to open a
     file normally causes an exception. The behaviour can be
     controlled by the `fileerrors' prolog flag.

     *Usage:* `absolute_file_name(+RelFileSpec,-(AbsFileSpec))'
        - *Description:* `AbsFileSpec' is the absolute name (with
          full path) of `RelFileSpec'.

        - *Calls should, and exit will be compatible with:*

          `+RelFileSpec' is a source name.
          (`streams_basic:sourcename/1')

          `-(AbsFileSpec)' is an atom.   (`basic_props:atm/1')

 - PREDICATE: absolute_file_name/7:



     `absolute_file_name(Spec,Opt,Suffix,CurrDir,AbsFile,AbsBase,AbsDir)'

     `AbsFile' is the absolute name (with full path) of `Spec', which
     has an optional first suffix `Opt' and an optional second suffix
     `Suffix', when the current directory is `CurrDir'. `AbsBase' is
     the same as `AbsFile', but without the second suffix, and
     `AbsDir' is the absolute path of the directory where `AbsFile'
     is. The Ciao compiler invokes this predicate with `Opt'='_opt'
     and `Suffix'='.pl' when searching source files.

     *Usage:*




     `absolute_file_name(+sourcename,+atm,+atm,+atm,-(atm),-(atm),-(atm))'

 - REGTYPE: sourcename/1:
     A source name is a flexible way of referring to a concrete file.
     A source name is either a relative or absolute filename given as:

        * an atom, or

        * a unary functor (which represents a *path alias*, see
          below) applied to a *relative* path, the latter being given
          as an atom.

     In all cases certain filename extensions (e.g., `.pl') can be
     implicit. In the first form above, file names can be relative to
     the current directory. Also, file names beginning with `~' or
     `$' are treated specially. For example,

    `'~/ciao/sample.pl''
          is equivalent to `'/home/staff/herme/ciao/sample.pl'', if
          `/home/staff/herme' is the user's home directory. (This is
          also equivalent to `'$HOME/ciao/sample.pl'' as explained
          below.)

    `'~bardo/prolog/sample.pl''
          is equivalent to `'/home/bardo/prolog/sample.pl'', if
          `/home/bardo' is bardo's home directory.

    `'$UTIL/sample.pl''
          is equivalent to `'/usr/local/src/utilities/sample.pl'', if
          `/usr/local/src/utilities' is the value of the environment
          variable `UTIL'.

     The second form allows using path aliases. Such aliases allow
     refering to files not with absolute file system paths but with
     paths which are relative to predefined (or user-defined)
     abstract names. For example, given the path alias `myutils'
     which has been defined to refer to path
     `'/home/bardo/utilities'', if that directory contains the file
     `stuff.pl' then the term `myutils(stuff)' in a `use_module/1'
     declaration would refer to the file
     `'/home/bardo/utilities/stuff.pl'' (the `.pl' extension is
     implicit in the `use_module/1' declaration). As a special case,
     if that directory contains a subdirectory named `stuff' which in
     turn contains the file `stuff.pl', the same term would refer to
     the file `'/home/bardo/utilities/stuff/stuff.pl''. If a path
     alias is related to several paths, all paths are scanned in
     sequence until a match is found. For information on predefined
     path aliases or how to define new path aliases, see
     `file_search_path/2'.

     *Usage:* `sourcename(F)'
        - *Description:* `F' is a source name.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: stream/1:
     Streams correspond to the file pointers used at the operating
     system level, and usually represent opened files. There are four
     special streams which correspond with the operating system
     standard streams:
    `user_input'
          The standard input stream, i.e. the terminal, usually.

    `user_output'
          The standard output stream, i.e. the terminal, usually.

    `user_error'
          The standard error stream.

    `user'
          The standard input or output stream, depending on context.

     *Usage:* `stream(S)'
        - *Description:* `S' is an open stream.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: io_mode/1:
     Can have the following values:
    `read'
          Open the file for input.

    `write'
          Open the file for output. The file is created if it does
          not already exist, the file will otherwise be truncated.

    `append'
          Open the file for output. The file is created if it does
          not already exist, the file will otherwise be appended to.

     *Usage:* `io_mode(M)'
        - *Description:* `M' is an opening mode ('read', 'write' or
          'append').

        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')


File: ciao.info,  Node: Documentation on multifiles (streams_basic),  Prev: Documentation on exports (streams_basic),  Up: Basic file/stream handling

Documentation on multifiles (`streams_basic')
=============================================

 - PREDICATE: file_search_path/2:
     `file_search_path(Alias,Path)'

     The path alias `Alias' is linked to path `Path'. Both arguments
     must be atoms. New facts (or clauses) of this predicate can be
     asserted to define new path aliases. Predefined path aliases in
     CIAO are:

    `library'
          Initially points to all CIAO library paths. See
          `library_directory/1'.

    `engine'
          The path of the CIAO engine builtins.

    `.'
          The current path (`'.'').

     The predicate is *multifile* and of type *dynamic*.


 - PREDICATE: library_directory/1:
     `library_directory(Path)'

     `Path' is a library path (a path represented by the path alias
     `library'). Predefined library paths in CIAO are
     `'$CIAOLIB/lib'', `'$CIAOLIB/library'', and
     `'$CIAOLIB/contrib'', given that `$CIAOLIB' is the path of the
     root ciao library directory. More library paths can be defined
     by asserting new facts (or clauses) of this predicate.

     The predicate is *multifile* and of type *dynamic*.



File: ciao.info,  Node: Exception handling,  Next: Fast/concurrent update of facts,  Prev: Basic file/stream handling,  Up: Top

Exception handling
******************

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   This module includes predicates related to exceptions, which alter
the normal flow of Prolog.

* Menu:

* Usage and interface (exceptions)::
* Documentation on exports (exceptions)::


File: ciao.info,  Node: Usage and interface (exceptions),  Next: Documentation on exports (exceptions),  Prev: Exception handling,  Up: Exception handling

Usage and interface (`exceptions')
==================================

   * *Library usage:*

     These predicates are builtin in CIAO, so nothing special has to
     be done to use them.

   * *Exports:*
        - *Predicates:*

          `catch/3', `intercept/3', `throw/1', `halt/0', `halt/1'.



File: ciao.info,  Node: Documentation on exports (exceptions),  Prev: Usage and interface (exceptions),  Up: Exception handling

Documentation on exports (`exceptions')
=======================================

 - PREDICATE: catch/3:
     `catch(Goal,Error,Handler)'

     Executes `Goal'. If an exception is raised during its execution,
     `Error' is unified with the exception, and if the unification
     succeeds, the entire execution derived from `Goal' is aborted,
     and `Handler' is executed. The execution resumes with the
     continuation of the catch/3 call. For example, given the code
          p(X) :- throw(error), display('---').
          p(X) :- display(X).
     the execution of "`catch(p(0), E, display(E)), display(.),
     fail.'" results in the output "`error.'".

     *Meta-predicate* with arguments: `catch(goal,?,goal)'.

     *Usage:* `catch(+callable,?(term),+callable)' < * ISO * >

 - PREDICATE: intercept/3:
     `intercept(Goal,Error,Handler)'

     Executes `Goal'. If an exception is raised during its execution,
     `Error' is unified with the exception, and if the unification
     succeeds, `Handler' is executed and then the execution resumes
     after the predicate which produced the exception. Note the
     difference with builtin `catch/3', given the same code defined
     there, the execution of "`intercept(p(0), E, display(E)),
     display(.), fail.'" results in the output "`error---.0.'".

     *Meta-predicate* with arguments: `intercept(goal,?,goal)'.

     *Usage:* `intercept(+callable,?(term),+callable)'

 - PREDICATE: throw/1:
     `throw(Ball)'

     Raises an error, throwing the exception `Ball', to be caught by
     an ancestor `catch/3' or `intercept/3'. The closest matching
     ancestor is chosen. Exceptions are also thrown by other builtins
     in case of error.

     *Usage:* < * ISO * >
        - *Calls should, and exit will be compatible with:*

          `Ball' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')

 - PREDICATE: halt/0:
     `halt'

     Halt the system, exiting to the invoking shell.

     *Usage:* < * ISO * >

 - PREDICATE: halt/1:
     `halt(Code)'

     Halt the system, exiting to the invoking shell, returning exit
     code `Code'.

     *Usage:* `halt(+int)' < * ISO * >

 - PREDICATE: abort/0:
     `abort'

     Abort the current execution.



File: ciao.info,  Node: Fast/concurrent update of facts,  Next: Changing system behaviour and various flags,  Prev: Exception handling,  Up: Top

Fast/concurrent update of facts
*******************************

   *Author(s):* Daniel Cabeza, Manuel Carro.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   Prolog implementations traditionally implement the concept of
dynamic predicates: predicates which can be inspected or modified at
run-time, adding or deleting individual clauses. The powerfulness of
this feature brings also a great disadvantage: as new clause bodies
can be arbitrarily added to the program, new unknown predicate calls
can arise, thus preventing any global analysis or optimization of the
code. But it is the case that most of the time what the programmer
wants is simply to store data, with the purpose of sharing it between
search branches, predicates, or even execution threads. In CIAO the
concept of data predicate serves this purpose: a data predicate is a
predicate composed exclusively by facts, which can be inspected, and
dynamically added or deleted, at run-time. Using data predicates
instead of normal dynamic predicates brings benefits in terms of
speed, but above all turns the code automatically analyzable.  There
is also a special kind of data predicates, called concurrent
predicates, which can be used to communicate/synchronize among
different execution threads (see *Note Concurrency/multithreading
primitives::).

* Menu:

* Usage and interface (data_facts)::
* Documentation on exports (data_facts)::
* Documentation on internals (data_facts)::


File: ciao.info,  Node: Usage and interface (data_facts),  Next: Documentation on exports (data_facts),  Prev: Fast/concurrent update of facts,  Up: Fast/concurrent update of facts

Usage and interface (`data_facts')
==================================

   * *Library usage:*

     These predicates are builtin in CIAO, so nothing special has to
     be done to use them.

   * *Exports:*
        - *Predicates:*

          `asserta_fact/1', `asserta_fact/2', `assertz_fact/1',
          `assertz_fact/2', `current_fact/1', `current_fact/2',
          `retract_fact/1', `retractall_fact/1', `current_fact_nb/1',
          `retract_fact_nb/1', `close_predicate/1',
          `open_predicate/1', `set_fact/1', `erase/1'.



File: ciao.info,  Node: Documentation on exports (data_facts),  Next: Documentation on internals (data_facts),  Prev: Usage and interface (data_facts),  Up: Fast/concurrent update of facts

Documentation on exports (`data_facts')
=======================================

 - PREDICATE: asserta_fact/1:
     `asserta_fact(Fact)'

     `Fact' is added to the corresponding data predicate. The fact
     becomes the first clause of the predicate concerned.

     *Meta-predicate* with arguments: `asserta_fact(fact)'.

     *Usage:* `asserta_fact(+callable)'

 - PREDICATE: asserta_fact/2:
     `asserta_fact(Fact,Ref)'

     Same as `asserta_fact/1', instantiating `Ref' to a unique
     identifier of the asserted fact.

     *Meta-predicate* with arguments: `asserta_fact(fact,?)'.

     *Usage:* `asserta_fact(+callable,-(reference))'

 - PREDICATE: assertz_fact/1:
     `assertz_fact(Fact)'

     `Fact' is added to the corresponding data predicate. The fact
     becomes the last clause of the predicate concerned.

     *Meta-predicate* with arguments: `assertz_fact(fact)'.

     *Usage:* `assertz_fact(+callable)'

 - PREDICATE: assertz_fact/2:
     `assertz_fact(Fact,Ref)'

     Same as `assertz_fact/1', instantiating `Ref' to a unique
     identifier of the asserted fact.

     *Meta-predicate* with arguments: `assertz_fact(fact,?)'.

     *Usage:* `assertz_fact(+callable,-(reference))'

 - PREDICATE: current_fact/1:
     `current_fact(Fact)'

     Gives on backtracking all the facts defined as data or
     concurrent which unify with `Fact'. It is faster than calling
     the predicate explicitly, which do invoke the meta-interpreter.
     If the `Fact' has been defined as concurrent and has not been
     closed, `current_fact/1' will wait (instead of failing) for more
     clauses to appear after the last clause of `Fact' is returned.

     *Meta-predicate* with arguments: `current_fact(fact)'.

     *Usage:* `current_fact(+callable)'

 - PREDICATE: current_fact/2:
     `current_fact(Fact,Ref)'

     `Fact' is a fact of a data predicate and `Ref' is its reference
     identifying it uniquely.

     *Meta-predicate* with arguments: `current_fact(fact,?)'.

     *Usage 1:* `current_fact(+callable,-(reference))'
        - *Description:* Gives on backtracking all the facts defined
          as data which unify with `Fact', instantiating `Ref' to a
          unique identifier for each fact.

     *Usage 2:* `current_fact(?(callable),+reference)'
        - *Description:* Given `Ref', unifies `Fact' with the fact
          identified by it.

 - PREDICATE: retract_fact/1:
     `retract_fact(Fact)'

     Unifies `Fact' with the first matching fact of a data predicate,
     and then erases it. On backtracking successively unifies with
     and erases new matching facts. If `Fact' is declared as
     concurrent and is non- closed, `retract_fact/1' will wait for
     more clauses or for the closing of the predicate after the last
     matching clause has been removed.

     *Meta-predicate* with arguments: `retract_fact(fact)'.

     *Usage:* `retract_fact(+callable)'

 - PREDICATE: retractall_fact/1:
     `retractall_fact(Fact)'

     Erase all the facts of a data predicate unifying with `Fact'.
     Even if all facts are removed, the predicate continues to exist.

     *Meta-predicate* with arguments: `retractall_fact(fact)'.

     *Usage:* `retractall_fact(+callable)'

 - PREDICATE: current_fact_nb/1:
     `current_fact_nb(Fact)'

     Behaves as `current_fact/1' but a fact is never waited on even
     if it is concurrent and non- closed.

     *Meta-predicate* with arguments: `current_fact_nb(fact)'.

     *Usage:* `current_fact_nb(+callable)'

 - PREDICATE: retract_fact_nb/1:
     `retract_fact_nb(Fact)'

     Behaves as `retract_fact/1', but never waits on a fact, even if
     it has been declared as concurrent and is non- closed.

     *Meta-predicate* with arguments: `retract_fact_nb(fact)'.

     *Usage:* `retract_fact_nb(+callable)'

 - PREDICATE: close_predicate/1:
     `close_predicate(Pred)'

     Changes the behavior of the predicate `Pred' if it has been
     declared as a concurrent predicate: calls to this predicate will
     fail (instead of wait) if no more clauses of `Pred' are
     available.

     *Meta-predicate* with arguments: `close_predicate(fact)'.

     *Usage:* `close_predicate(+callable)'

 - PREDICATE: open_predicate/1:
     `open_predicate(Pred)'

     Reverts the behavior of concurrent predicate `Pred' to waiting
     instead of failing if no more clauses of `Pred' are available.

     *Meta-predicate* with arguments: `open_predicate(fact)'.

     *Usage:* `open_predicate(+callable)'

 - PREDICATE: set_fact/1:
     `set_fact(Fact)'

     Sets `Fact' as the unique fact of the corresponding data
     predicate.

     *Meta-predicate* with arguments: `set_fact(fact)'.

     *Usage:* `set_fact(+callable)'

 - PREDICATE: erase/1:
     `erase(Ref)'

     Deletes the clause referenced by `Ref'.

     *Usage:* `erase(+reference)'


File: ciao.info,  Node: Documentation on internals (data_facts),  Prev: Documentation on exports (data_facts),  Up: Fast/concurrent update of facts

Documentation on internals (`data_facts')
=========================================

 - REGTYPE: fact/1:
     *Usage:* `fact(F)'
        - *Description:* `F' is a fact (an atom or a structure).

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: reference/1:
     *Usage:* `reference(R)'
        - *Description:* `R' is a reference of a dynamic or data
          clause.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')


File: ciao.info,  Node: Changing system behaviour and various flags,  Next: Concurrency/multithreading primitives,  Prev: Fast/concurrent update of facts,  Up: Top

Changing system behaviour and various flags
*******************************************

   *Author(s):* Daniel Cabeza, Mats Carlsson.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   Flags define some parameters of the system and control the
behavior of system or library predicates. Each flag has a name and an
associated predefined value, and except some system flags which are
fixed in general their associated value is changeable. Predefined
flags in the system are:

`fileerrors'
     If `on', predicates handling files give errors when a file is
     inexistent or an operation is not allowed. If `off', fail in
     that conditions. Initially `on'.

`unknown'
     Controls action on calls to undefined predicates. The possible
     states of the flag are:

    `error'
          An error is thrown with the error term
          `existence_error(procedure, F/A)'.

    `fail'
          The call simply fails.

    `warning'
          A warning is written and the call fails.

     The state is initially `error'. < * ISO * >

`quiet'
     Controls which messages issued using `io_aux' are actually
     written. As the system uses that library to report its messages,
     this flag controls the *verbosity* of the system. Possible
     states of the flag are:

    `on'
          No messages are reported.

    `error'
          Only error messages are reported.

    `warning'
          Only error and warning messages are reported.

    `off'
          All messages are reported, except debug messages. This is
          the default state.

    `debug'
          All messages, including debug messages, are reported. This
          is only intended for the system implementators.

`argv'
     Value is a list of atoms representing the program arguments
     supplied when the current executable was invoked. This is the
     value to which is instantiated the argument of the `main/1'
     predicate at executable startup. Unchangeable.

`bounded'
     It is `false', to denote that the range of integers can be
     considered infinite (but see `int/1'). Unchangeable. < * ISO * >

`integer_rounding_function'
     It is `toward_zero', so that `-1 =:= -3//2' succeeds.
     Unchangeable. < * ISO * >

`max_arity'
     It is 255, so that no compound term (or predicate) can have more
     than this number of arguments. Unchangeable. < * ISO * >

`gc'
     Controls whether garbage collection is done. May be `on'
     (default) or `off'.

`gc_margin'
     An integer `Margin'. If less than `Margin' kilobytes are
     reclaimed in a garbage collection then the size of the garbage
     collected area should be increased. Also, no garbage collection
     is attempted unless the garbage collected area has at least
     `Margin' kilobytes. Initially 500.

`gc_trace'
     Governs garbage collection trace messages. An element off
     `[on,off,terse,verbose]'. Initially `off'.

* Menu:

* Usage and interface (prolog_flags)::
* Documentation on exports (prolog_flags)::
* Documentation on multifiles (prolog_flags)::


File: ciao.info,  Node: Usage and interface (prolog_flags),  Next: Documentation on exports (prolog_flags),  Prev: Changing system behaviour and various flags,  Up: Changing system behaviour and various flags

Usage and interface (`prolog_flags')
====================================

   * *Library usage:*

     These predicates are builtin in CIAO, so nothing special has to
     be done to use them.

   * *Exports:*
        - *Predicates:*

          `set_prolog_flag/2', `current_prolog_flag/2',
          `prolog_flag/3', `push_prolog_flag/2', `pop_prolog_flag/1',
          `prompt/2', `gc/0', `nogc/0', `fileerrors/0',
          `nofileerrors/0'.

        - *Multifiles:*

          `define_flag/3'.



File: ciao.info,  Node: Documentation on exports (prolog_flags),  Next: Documentation on multifiles (prolog_flags),  Prev: Usage and interface (prolog_flags),  Up: Changing system behaviour and various flags

Documentation on exports (`prolog_flags')
=========================================

 - PREDICATE: set_prolog_flag/2:
     `set_prolog_flag(FlagName,Value)'

     Set existing flag `FlagName' to `Value'.

     *Usage:* `set_prolog_flag(+atm,+term)' < * ISO * >

 - PREDICATE: current_prolog_flag/2:
     `current_prolog_flag(FlagName,Value)'

     `FlagName' is an existing flag and `Value' is the value
     currently associated with it.

     *Usage:* `current_prolog_flag(?(atm),?(term))' < * ISO * >

 - PREDICATE: prolog_flag/3:
     `prolog_flag(FlagName,OldValue,NewValue)'

     `FlagName' is an existing flag, unify `OldValue' with the value
     associated with it, and set it to new value `NewValue'.

     *Usage 1:* `prolog_flag(?(atm),?(term),+term)'
     *Usage 2:* `prolog_flag(?(FlagName),-(OldValue),-(NewValue))'
        - *Description:* Same as `current_prolog_flag(`FlagName',
          `OldValue')'

        - *The following properties should hold at call time:*

          `FlagName' is an atom.   (`basic_props:atm/1')

          The terms `OldValue' and `NewValue' are strictly identical.
          (`term_compare:== /2')

 - PREDICATE: push_prolog_flag/2:
     `push_prolog_flag(Flag,NewValue)'

     Same as `set_prolog_flag/2', but storing current value of `Flag'
     to restore it with `pop_prolog_flag/1'.

     *Usage:* `push_prolog_flag(+atm,+term)'

 - PREDICATE: pop_prolog_flag/1:
     `pop_prolog_flag(Flag)'

     Restore the value of `Flag' previous to the last non-canceled
     `push_prolog_flag/2' on it.

     *Usage:* `pop_prolog_flag(+atm)'

 - PREDICATE: prompt/2:
     `prompt(Old,New)'

     Unify `Old' with the current prompt for reading, change it to
     `New'.

     *Usage 1:* `prompt(?(atm),+atm)'
     *Usage 2:* `prompt(Old,New)'
        - *Description:* Unify `Old' with the current prompt for
          reading without changing it.

        - *The following properties should hold at call time:*

          `Old' is a free variable.   (`term_typing:var/1')

          `New' is a free variable.   (`term_typing:var/1')

          The terms `Old' and `New' are strictly identical.
          (`term_compare:== /2')

        - *The following properties hold upon exit:*

          `Old' is an atom.   (`basic_props:atm/1')

          `New' is an atom.   (`basic_props:atm/1')

 - PREDICATE: gc/0:
     *Usage:*
        - *Description:* Enable garbage collection. Equivalent to
          `set_prolog_flag(gc, on)'

 - PREDICATE: nogc/0:
     *Usage:*
        - *Description:* Disable garbage collection. Equivalent to
          `set_prolog_flag(gc, off)'

 - PREDICATE: fileerrors/0:
     *Usage:*
        - *Description:* Enable reporting of file errors. Equivalent
          to `set_prolog_flag(fileerrors, on)'

 - PREDICATE: nofileerrors/0:
     *Usage:*
        - *Description:* Disable reporting of file errors. Equivalent
          to `set_prolog_flag(fileerrors, off)'


File: ciao.info,  Node: Documentation on multifiles (prolog_flags),  Prev: Documentation on exports (prolog_flags),  Up: Changing system behaviour and various flags

Documentation on multifiles (`prolog_flags')
============================================

 - PREDICATE: define_flag/3:
     `define_flag(Flag,Values,Default)'

     New flags can be defined by writing facts of this predicate.
     `Flag' is the name of the new flag, `Values' defines the posible
     values for the flag (see below) and `Default' defines the
     predefined value associated with the flag (which should be
     compatible with `Values').

     The predicate is *multifile*.

     *Usage 1:*
        - *Description:* Posible values for the flag are atoms.

          Example:
               :- multifile define_flag/3.
               define_flag(tmpdir, atom, '/tmp').

        - *Call and exit should be *compatible* with:*

          `Flag' is an atom.   (`basic_props:atm/1')

          Unify `Values' and `atom'.   (`term_basic:= /2')

          `Default' is an atom.   (`basic_props:atm/1')

     *Usage 2:*
        - *Description:* Posible values for the flag are integers.

          Example:
               :- multifile define_flag/3.
               define_flag(max_connections, integer, 10).

        - *Call and exit should be *compatible* with:*

          `Flag' is an atom.   (`basic_props:atm/1')

          Unify `Values' and `integer'.   (`term_basic:= /2')

          `Default' is an integer.   (`basic_props:int/1')

     *Usage 3:* `define_flag(Flag,Values,Default)'
        - *Description:* Posible values for the flag are the elements
          of `Values'.

          Example:
               :- multifile define_flag/3.
               define_flag(debug, [on,debug,trace,off], off).

        - *Call and exit should be *compatible* with:*

          `Flag' is an atom.   (`basic_props:atm/1')

          `Values' is a list.   (`basic_props:list/1')

          `Default' is any term.   (`basic_props:term/1')

        - *The following properties should hold at call time:*

          `Default' is an element of `Values'.
          (`basic_props:member/2')


File: ciao.info,  Node: Concurrency/multithreading primitives,  Next: Extending the syntax,  Prev: Changing system behaviour and various flags,  Up: Top

Concurrency/multithreading primitives
*************************************

   *Author(s):* Manuel Carro.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 1.3#118 (1999/11/25, 19:28:6 MET)

   This module provides basic mechanisms for using concurrency and
implementing multi-goal applications.  Goals can be specified to be
run in a separate stack set; in that case, they are assigned a goal
identifier with which further accesses (e.g., asking for more
solutions) to the goal can be made. Additionally, in some
architectures, these goals can be assigned an O.S. thread, separate
from the one which made the initial call. On the architectures for
which we were not able to implement it yet, the original thread
switches to the new stack set, executes the goal there, and returns
after it has completed.

   As for now, the memory space of the threads (c.f., stack sets) is
separate in the sense that goals are copied to the new stack set, and
bindings of variables are not seen among stack sets which allows
forward and backward execution to proceed independently in each stack
set, at the cost of the initial goal copy. However, the program space
(including, specially, the concurrent predicates) are shared and seen
by all the goals and threads.

   Additionally, a small set of lock-related predicates are provided:
locks are associated with atom names. Whereas the concurrent database
facilities are enough to implement locks, semaphores, messages, etc.,
the predicates implementing atom-based locks are faster than the ones
accessing the concurrent database.

* Menu:

* Usage and interface (concurrency)::
* Documentation on exports (concurrency)::
* Known bugs and planned improvements (concurrency)::


File: ciao.info,  Node: Usage and interface (concurrency),  Next: Documentation on exports (concurrency),  Prev: Concurrency/multithreading primitives,  Up: Concurrency/multithreading primitives

Usage and interface (`concurrency')
===================================

   * *Library usage:*

     These predicates are builtin in CIAO, so nothing special has to
     be done to use them.

   * *Exports:*
        - *Predicates:*

          `eng_call/4', `eng_call/3', `eng_backtrack/2', `eng_cut/1',
          `eng_release/1', `eng_wait/1', `eng_kill/1',
          `eng_killothers/0', `eng_self/1', `eng_status/0',
          `lock_atom/1', `unlock_atom/1', `atom_lock_state/2'.



File: ciao.info,  Node: Documentation on exports (concurrency),  Next: Known bugs and planned improvements (concurrency),  Prev: Usage and interface (concurrency),  Up: Concurrency/multithreading primitives

Documentation on exports (`concurrency')
========================================

 - PREDICATE: eng_call/4:
     *Meta-predicate* with arguments: `eng_call(goal,?,?,?)'.

     *Usage:*
     `eng_call(+Goal,+EngineCreation,+ThreadCreation,-(GoalId))'
        - *Description:* Calls `Goal' in a new engine (stack set),
          possibly using a new thread, and returns a `GoalId' to
          designate this new goal henceforth. `EngineCreation' can be
          either `wait' or `create'; the distinction is not yet
          meaningful. `ThreadCreation' can be one of `self', `wait',
          or `create'. In the first case the creating thread is used
          to execute `Goal', and thus it has to wait until its first
          result or failure. In the other two cases, a new thread for
          the `Goal' is created and assigned the new engine. Some
          details still have to be woked out.  `eng_call/4' always
          succeeds and executes a copy (with new variables) of the
          original goal, so local and remote backtracking and
          execution do not affect each other.

        - *The following properties should hold at call time:*

          `+Goal' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')

          `+EngineCreation' is an atom.   (`basic_props:atm/1')

          `+ThreadCreation' is an atom.   (`basic_props:atm/1')

          `-(GoalId)' is an integer.   (`basic_props:int/1')

 - PREDICATE: eng_call/3:
     *Meta-predicate* with arguments: `eng_call(goal,?,?)'.

     *Usage:* `eng_call(+Goal,+EngineCreation,+ThreadCreation)'
        - *Description:* Similar to `eng_call/4', but the thread (if
          created) and stack areas are automatically released upon
          success or failure of the goal. No `GoalId' is provided for
          further interaction with the goal.

        - *The following properties should hold at call time:*

          `+Goal' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')

          `+EngineCreation' is an atom.   (`basic_props:atm/1')

          `+ThreadCreation' is an atom.   (`basic_props:atm/1')

 - PREDICATE: eng_backtrack/2:
     The predicate is of type *implicit*.

     *Usage:* `eng_backtrack(+GoalId,+ThreadCreation)'
        - *Description:* Performs backtracking on the goal designed
          by `GoalId', maybe using a new thread, according to
          `ThreadCreation' (same as in `eng_call/4'). Fails if the
          goal is backtracked over by the local thread, and there are
          no more solutions. Always succeeds if executed by a remote
          thread. The engine is automatically released and cleaned up
          upon failure.

        - *The following properties should hold at call time:*

          `+GoalId' is an integer.   (`basic_props:int/1')

          `+ThreadCreation' is an atom.   (`basic_props:atm/1')

 - PREDICATE: eng_cut/1:
     The predicate is of type *implicit*.

     *Usage:* `eng_cut(+GoalId)'
        - *Description:* Performs a *cut* in the execution of the
          goal `GoalId'. The next call to `eng_backtrack/2' will
          therefore fail.

        - *The following properties should hold at call time:*

          `+GoalId' is an integer.   (`basic_props:int/1')

 - PREDICATE: eng_release/1:
     The predicate is of type *implicit*.

     *Usage:* `eng_release(+GoalId)'
        - *Description:* Cleans up and releases the engine executing
          the goal designed by `GoalId'. The engine must be in
          `WAITING' state.

        - *The following properties should hold at call time:*

          `+GoalId' is an integer.   (`basic_props:int/1')

 - PREDICATE: eng_wait/1:
     The predicate is of type *implicit*.

     *Usage:* `eng_wait(+GoalId)'
        - *Description:* Waits for the engine executing the goal
          denoted by `GoalId' to be in waiting state (i.e., it has
          finished searching for a solution, either with success or
          failure).

        - *The following properties should hold at call time:*

          `+GoalId' is an integer.   (`basic_props:int/1')

 - PREDICATE: eng_kill/1:
     The predicate is of type *implicit*.

     *Usage:* `eng_kill(+GoalId)'
        - *Description:* Kills the thread executing `GoalId' (if
          any), and frees the memory used up by the stack set.
          Usually one should wait ( `eng_wait/1') for a goal, and
          then release it, but killing the thread explicitly allows
          recovering from error states, or imposing timeouts to a
          task. A goal can kill itself; use this feature with caution.

        - *The following properties should hold at call time:*

          `+GoalId' is an integer.   (`basic_props:int/1')

 - PREDICATE: eng_killothers/0:
     The predicate is of type *implicit*.

     *Usage:*
        - *Description:* Kills threads and releases stack sets of all
          active goals, but the one calling `eng_killothers'. Again,
          a safety measure.

 - PREDICATE: eng_self/1:
     The predicate is of type *implicit*.

     *Usage:* `eng_self(?(GoalId))'
        - *Description:* `GoalId' is unified with the identifier of
          the goal within which `eng_self/1' is executed.

        - *The following properties should hold at call time:*

          `?(GoalId)' is an integer.   (`basic_props:int/1')

 - PREDICATE: eng_status/0:
     The predicate is of type *implicit*.

     *Usage:*
        - *Description:* Prints to standard output the current status
          of the stack sets.

 - PREDICATE: lock_atom/1:
     The predicate is of type *implicit*.

     *Usage:* `lock_atom(+Atom)'
        - *Description:* The semaphore associated to `Atom' is
          accessed; if its value is nonzero, it is atomically
          decremented and the execution of this thread proceeds.
          Otherwise, the goal waits until a nonzero value is reached.
          The semaphore is then atomically decremented and the
          execution of this thread proceeds.

        - *The following properties should hold at call time:*

          `+Atom' is an atom.   (`basic_props:atm/1')

 - PREDICATE: unlock_atom/1:
     The predicate is of type *implicit*.

     *Usage:* `unlock_atom(+Atom)'
        - *Description:* The semaphore associated to `Atom' is
          atomically incremented.

        - *The following properties should hold at call time:*

          `+Atom' is an atom.   (`basic_props:atm/1')

 - PREDICATE: atom_lock_state/2:
     The predicate is of type *implicit*.

     *Usage 1:* `atom_lock_state(+Atom,+Value)'
        - *Description:* Sets the semaphore associated to `Atom' to
          `Value'. This is usually done at the beginning of the
          execution, but can be executed at any time. If not called,
          semaphore associated to atoms are by default inited to 1.
          It should be used with caution: arbitrary use can transform
          programs using locks in a mess of internal relations. The
          change of a semaphore value in a place other than the
          initialization stage of a program is *not* among the
          allowed operations as defined by Dijkstra [Dij65,BA82].

        - *The following properties should hold at call time:*

          `+Atom' is an atom.   (`basic_props:atm/1')

          `+Value' is an integer.   (`basic_props:int/1')

     *Usage 2:* `atom_lock_state(+Atom,-(Value))'
        - *Description:* Consults the `Value' of the semaphore
          associated to `Atom'. Use sparingly and mainly as a medium
          to check state correctness. Not among the operations on
          semaphore by Djikstra.

        - *The following properties should hold at call time:*

          `+Atom' is an atom.   (`basic_props:atm/1')

          `-(Value)' is an integer.   (`basic_props:int/1')


File: ciao.info,  Node: Known bugs and planned improvements (concurrency),  Prev: Documentation on exports (concurrency),  Up: Concurrency/multithreading primitives

Known bugs and planned improvements (`concurrency')
===================================================

   * Not fully available in all architectures yet.

   * Some implementation of threads have a limit on the total number
     of threads that can be created by a process (not only threads
     active at a time, but threads created at all). Thread creation,
     in this case, just hangs. A better solution is planned for the
     future.

   * The thread-related part of the library is not yet final, an some
     characteristics may be revised in a near future. A higher level
     library for concurrency and distribution based on the low-level
     primitives in this module is being implemented.


File: ciao.info,  Node: Extending the syntax,  Next: Message printing primitives,  Prev: Concurrency/multithreading primitives,  Up: Top

Extending the syntax
********************

   *Author(s):* Daniel Cabeza.

   This chapter documents the builtin directives in Ciao for
extending the syntax of source files. Note that the ISO-Prolog
directive `char_conversion/2' is not implemented, since Ciao does not
(yet) have a character conversion table.

* Menu:

* Usage and interface (syntax_extensions)::
* Documentation on internals (syntax_extensions)::


File: ciao.info,  Node: Usage and interface (syntax_extensions),  Next: Documentation on internals (syntax_extensions),  Prev: Extending the syntax,  Up: Extending the syntax

Usage and interface (`syntax_extensions')
=========================================

   * *Library usage:*

     These directives are builtin in Ciao, so nothing special has to
     be done to use them.


File: ciao.info,  Node: Documentation on internals (syntax_extensions),  Prev: Usage and interface (syntax_extensions),  Up: Extending the syntax

Documentation on internals (`syntax_extensions')
================================================

 - DECLARATION: op/3:
     *Usage:* :- `op(Priority,Op_spec,Operator)'.  < * ISO * >
        - *Description:* Updates the operator table for reading the
          terms in the rest of the current text, in the same way as
          the builtin `op/3' does. Its scope is local to the current
          text. Usually included in package files

        - *The following properties hold at call time:*

          `Priority' is an integer.   (`basic_props:int/1')

          `Op_spec' specifies the type and associativity of an
          operator.   (`basic_props:operator_specifier/1')

          `Operator' is an atom or a list of atoms.
          (`basic_props:atm_or_atm_list/1')

 - DECLARATION: new_declaration/1:
     *Usage:* :- `new_declaration(Predicate)'.
        - *Description:* Declares `Predicate' to be a valid
          declaration in the rest of the current text. Such
          declarations are simply ignored by the compiler or top
          level, but can be used by other code processing programs
          such as an automatic documentator. Also, they can easily
          translated into standard code (a set of facts and/or rules)
          by defining a suitable expansion (e.g., by
          `add_sentence_trans/1', etc.). This is tipically done in
          package files.

          Equivalent to `new_declaration(Predicate, off)'.

        - *The following properties hold at call time:*

          `Predicate' is a Name/Arity structure denoting a predicate
          name:
               predname(P/A) :-
                       atm(P),
                       int(A).

          (`basic_props:predname/1')

 - DECLARATION: new_declaration/2:
     *Usage:* :- `new_declaration(Predicate,In_Itf)'.
        - *Description:* Declares `Predicate' to be a valid
          declaration in the rest of the current text. Such
          declarations will be included in the interface file for
          this file if `In_Itf' is 'on', not if it is 'off'.
          Including such declarations in interface files makes them
          visible while processing other modules which make use of
          this one.

        - *The following properties hold at call time:*

          `Predicate' is a Name/Arity structure denoting a predicate
          name:
               predname(P/A) :-
                       atm(P),
                       int(A).

          (`basic_props:predname/1')

          `In_Itf' is 'on' or 'off'  (`syntax_extensions:switch/1')

 - DECLARATION: load_compilation_module/1:
     *Usage:* :- `load_compilation_module(Module)'.
        - *Description:* Loads code defined in `Module' into the
          compiler, usually including predicates which define
          translations of terms, for use with the declarations
          `add_sentence_trans/1' and similar ones. Normally included
          in package files.

        - *The following properties hold at call time:*

          `Module' is a source name.   (`streams_basic:sourcename/1')

 - DECLARATION: add_sentence_trans/1:
     *Usage:* :- `add_sentence_trans(Predicate)'.
        - *Description:* Starts a translation, defined by
          `Predicate', of the terms read by the compiler in the rest
          of the current text. For each subsequent term read by the
          compiler, the translation predicate is called to obtain a
          new term which will be used by the compiler as if it where
          the term present in the file. `Predicate' must be exported
          by a module previously loaded with a
          `load_compilation_module/1' declaration. Normally included
          in package files.

        - *The following properties hold at call time:*

          `Predicate' is a translation predicate spec (has arity 2 or
          3).   (`syntax_extensions:translation_predname/1')

 - DECLARATION: add_term_trans/1:
     *Usage:* :- `add_term_trans(P)'.
        - *Description:* Starts a translation, defined by
          `Predicate', of the terms and sub-terms read by the
          compiler in the rest of the current text. This translation
          is performed after all translations defined by
          `add_sentence_trans/1' are done. For each subsequent term
          read by the compiler, and recursively any subterm included,
          the translation predicate is called to possibly obtain a
          new term to replace the old one. Care must be taken of not
          introducing an endless loop of translations. `Predicate'
          must be exported by a module previously loaded with a
          `load_compilation_module/1' declaration. Normally included
          in package files.

        - *The following properties hold at call time:*

          `P' is a translation predicate spec (has arity 2 or 3).
          (`syntax_extensions:translation_predname/1')

 - DECLARATION: add_goal_trans/1:
     *Usage:* :- `add_goal_trans(Predicate)'.
        - *Description:* Declares a translation, defined by
          `Predicate', of the goals present in the clauses of the
          current text. This translation is performed after all
          translations defined by `add_sentence_trans/1' and
          `add_term_trans/1' are done. For each clause read by the
          compiler, the translation predicate is called with each
          goal present in the clause to possibly obtain other goal to
          substitute the original one, and the translation is
          subsequently applied to the resulting goal. Care must be
          taken of not introducing an endless loop of translations.
          `Predicate' must be exported by a module previously loaded
          with a `load_compilation_module/1' declaration. Bear in
          mind that this type of translation noticeably slows down
          compilation. Normally included in package files.

        - *The following properties hold at call time:*

          `Predicate' is a translation predicate spec (has arity 2 or
          3).   (`syntax_extensions:translation_predname/1')

 - DECLARATION: add_clause_trans/1:
     *Usage:* :- `add_clause_trans(Predicate)'.
        - *Description:* Declares a translation, defined by
          `Predicate', of the clauses of the current text. The
          translation is performed before `add_goal_trans/1'
          translations but after `add_sentence_trans/1' and
          `add_term_trans/1' translations. The usefulness of this
          translation is that information of the interface of related
          modules is available when it is performed. For each clause
          read by the compiler, the translation predicate is called
          with the first argument instantiated to a structure
          `clause(Head,Body)', and the predicate must return in the
          second argument a similar structure, without changing the
          functor in `Head'. Before executing the translation
          predicate with actual clauses it is called with an input of
          `clause(0,0)' (output is discarded).

        - *The following properties hold at call time:*

          `Predicate' is a translation predicate spec (has arity 2 or
          3).   (`syntax_extensions:translation_predname/1')

 - REGTYPE: translation_predname/1:
     A translation predicate is a predicate of arity 2 or 3 used to
     make compile-time translations. The compiler invokes a
     translation predicate instantiating its first argument with the
     item to be translated, and if the predicate is of arity 3 its
     third argument with the name of the module where the translation
     is done. If the call is successful, the second argument is used
     as if that item were in the place of the original, else the
     original item is used.

     *Usage:* `translation_predname(P)'
        - *Description:* `P' is a translation predicate spec (has
          arity 2 or 3).

        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')


File: ciao.info,  Node: Message printing primitives,  Next: Attributed variables,  Prev: Extending the syntax,  Up: Top

Message printing primitives
***************************

   *Author(s):* Daniel Cabeza.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   This module provides predicates for printing in a unified way
informational messages, and also for printing some terms in a
specific way.

* Menu:

* Usage and interface (io_aux)::
* Documentation on exports (io_aux)::
* Known bugs and planned improvements (io_aux)::


File: ciao.info,  Node: Usage and interface (io_aux),  Next: Documentation on exports (io_aux),  Prev: Message printing primitives,  Up: Message printing primitives

Usage and interface (`io_aux')
==============================

   * *Library usage:*

     These predicates are builtin in CIAO, so nothing special has to
     be done to use them.

   * *Exports:*
        - *Predicates:*

          `message/2', `message_lns/4', `display_string/1'.



File: ciao.info,  Node: Documentation on exports (io_aux),  Next: Known bugs and planned improvements (io_aux),  Prev: Usage and interface (io_aux),  Up: Message printing primitives

Documentation on exports (`io_aux')
===================================

 - PREDICATE: message/2:
     `message(Type,Message)'

     Output to standard error `Message', which is of type `Type'. The
     `quiet' *prolog flag* (see *Note Changing system behaviour and
     various flags::) controls which messages are actually output,
     depending on its type. Also, for 'error', 'warning' and 'note'
     messages, a prefix is output which denotes the severity of the
     message. `Message' is an item or a list of items from this list:
    `$$(String)'
          `String' is a string, which is output with
          `display_string/1'.

    `''(Term)'
          `Term' is output quoted. If the module `write' is loaded,
          the term is output with `writeq/1', else with `displayq/1'.

    `~~(Term)'
          `Term' is output unquoted. If the module `write' is loaded,
          the term is output with `write/1', else with `display/1'.

    `[](Term)'
          `Term' is output as a message, can be an item or a list of
          items from this list.

    `Term'
          Any other term is output with `display/1'.

     *Usage:* `message(Type,Message)'
        - *The following properties should hold at call time:*

          `Type' is an atom.   (`basic_props:atm/1')

          `Type' is an element of
          `[error,warning,note,message,debug]'.
          (`basic_props:member/2')

 - PREDICATE: message_lns/4:
     `message_lns(Type,L0,L1,Message)'

     Output to standard error `Message', which is of type `Type', and
     occurs between lines `L0' and `L1'. This is the same as
     `message/2', but printing the lines where the message occurs in
     a unified way.

     *Usage:* `message_lns(Type,L0,L1,Message)'
        - *The following properties should hold at call time:*

          `Type' is an atom.   (`basic_props:atm/1')

          `Type' is an element of
          `[error,warning,note,message,debug]'.
          (`basic_props:member/2')

 - PREDICATE: error/1:
     Defined as
          error(Message) :-
                  message(error,Message).
     .


 - PREDICATE: warning/1:
     Defined as
          warning(Message) :-
                  message(warning,Message).
     .


 - PREDICATE: note/1:
     Defined as
          note(Message) :-
                  message(note,Message).
     .


 - PREDICATE: message/1:
     Defined as
          message(Message) :-
                  message(message,Message).
     .


 - PREDICATE: debug/1:
     Defined as
          debug(Message) :-
                  message(debug,Message).
     .


 - PREDICATE: inform_user/1:
     `inform_user(Message)'

     Similar to `message/1', but `Message' is output with
     `display_list/1'. This predicate is obsolete, and may disappear
     in future versions.


 - PREDICATE: display_string/1:
     `display_string(String)'

     Output `String' as the sequence of characters it represents.

     *Usage:* `display_string(String)'
        - *The following properties should hold at call time:*

          `String' is a string (a list of character codes).
          (`basic_props:string/1')

 - PREDICATE: display_list/1:
     `display_list(List)'

     Outputs `List'. If `List' is a list, do `display/1' on each of
     its elements, else do `display/1' on `List'.


 - PREDICATE: display_term/1:
     `display_term(Term)'

     Output `Term' in a way that a `read/1' will be able to read it
     back, even if operators change.



File: ciao.info,  Node: Known bugs and planned improvements (io_aux),  Prev: Documentation on exports (io_aux),  Up: Message printing primitives

Known bugs and planned improvements (`io_aux')
==============================================

   *  `message/2' assumes that a module with name 'write' is
     library(write).


File: ciao.info,  Node: Attributed variables,  Next: Gathering some basic internal info,  Prev: Message printing primitives,  Up: Top

Attributed variables
********************

   *Author(s):* Christian Holzbaur, Daniel Cabeza, Manuel Carro.

   *Version:* 1.3#121 (1999/11/26, 20:23:11 MET)

   This library implements *attributed variables*, which provide a
mechanism for extensible unification.

* Menu:

* Usage and interface (attributes)::
* Documentation on exports (attributes)::


File: ciao.info,  Node: Usage and interface (attributes),  Next: Documentation on exports (attributes),  Prev: Attributed variables,  Up: Attributed variables

Usage and interface (`attributes')
==================================

   * *Library usage:*

     These predicates are builtin in CIAO, so nothing special has to
     be done to use them.

   * *Exports:*
        - *Predicates:*

          `attach_attribute/2', `get_attribute/2',
          `update_attribute/2', `detach_attribute/1'.



File: ciao.info,  Node: Documentation on exports (attributes),  Prev: Usage and interface (attributes),  Up: Attributed variables

Documentation on exports (`attributes')
=======================================

 - PREDICATE: attach_attribute/2:
     *Usage:* `attach_attribute(Var,Attr)'
        - *Description:* Attach attribute `Attr' to `Var'.

        - *The following properties should hold at call time:*

          `Var' is a free variable.   (`term_typing:var/1')

          `Attr' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')

 - PREDICATE: get_attribute/2:
     *Usage:* `get_attribute(Var,Attr)'
        - *Description:* Unify `Attr' with the attribute of `Var', or
          fail if `Var' has no attribute.

        - *The following properties should hold at call time:*

          `Var' is a free variable.   (`term_typing:var/1')

        - *The following properties should hold upon exit:*

          `Attr' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')

 - PREDICATE: update_attribute/2:
     *Usage:* `update_attribute(Var,Attr)'
        - *Description:* Change the attribute of attributed variable
          `Var' to `Attr'.

        - *The following properties should hold at call time:*

          `Var' is a free variable.   (`term_typing:var/1')

          `Attr' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')

 - PREDICATE: detach_attribute/1:
     *Usage:* `detach_attribute(Var)'
        - *Description:* Take out the attribute from the attributed
          variable `Var'.

        - *The following properties should hold at call time:*

          `Var' is a free variable.   (`term_typing:var/1')


File: ciao.info,  Node: Gathering some basic internal info,  Next: *** PART III - ISO-Prolog library (iso),  Prev: Attributed variables,  Up: Top

Gathering some basic internal info
**********************************

   *Author(s):* Daniel Cabeza, Manuel Carro.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 1.3#13 (1999/7/2, 18:49:49 MEST)

   ............... In development ...............

* Menu:

* Usage and interface (system_info)::
* Documentation on exports (system_info)::
* Documentation on internals (system_info)::


File: ciao.info,  Node: Usage and interface (system_info),  Next: Documentation on exports (system_info),  Prev: Gathering some basic internal info,  Up: Gathering some basic internal info

Usage and interface (`system_info')
===================================

   * *Library usage:*

     These predicates are builtin in CIAO, so nothing special has to
     be done to use them.

   * *Exports:*
        - *Predicates:*

          `get_arch/1', `get_os/1', `this_module/1',
          `current_module/1', `ciaolibdir/1'.



File: ciao.info,  Node: Documentation on exports (system_info),  Next: Documentation on internals (system_info),  Prev: Usage and interface (system_info),  Up: Gathering some basic internal info

Documentation on exports (`system_info')
========================================

 - PREDICATE: get_arch/1:
     This predicate will describe the computer architecture wich is
     currently executing the predicate.

     Computer architectures are identified by a simple atom. This
     atom is implementation-defined, and may suffer any change from
     one CIAO Prolog version to another.

     For example,CIAO Prolog running on an Intel-based machine will
     retrieve:
          ?- get_arch(I).
          
          I = i86 ? ;
          
          no
          ?-

     The predicate is of type *implicit*.

     *Usage:* `get_arch(?(ArchDescriptor))'
        - *Description:* Unifies `ArchDescriptor' with a simple atom
          which describes the computer architecture currently
          executing the predicate.

        - *Calls should, and exit will be compatible with:*

          `?(ArchDescriptor)' is an atom.   (`basic_props:atm/1')

 - PREDICATE: get_os/1:
     This predicate will describe the Operating System which is
     running on the machine currently executing the Prolog program.

     Operating Systems are identified by a simple atom. This atom is
     implementation-defined, and may suffer any change from one CIAO
     Prolog version to another.

     For example,CIAO Prolog running on Linux will retrieve:
          ?- get_os(I).
          
          I = 'LINUX' ? ;
          
          no
          ?-

     The predicate is of type *implicit*.

     *Usage:* `get_os(?(OsDescriptor))'
        - *Description:* Unifies `OsDescriptor' with a simple atom
          which describes the running Operating System when predicate
          was called.

        - *Calls should, and exit will be compatible with:*

          `?(OsDescriptor)' is an atom.   (`basic_props:atm/1')

 - PREDICATE: this_module/1:
     *Meta-predicate* of type *implicit* with arguments:
     `this_module(addmodule)'.

     *Usage:*
        - *Description:* `Module' is the internal module identifier
          for current module.

        - *Call and exit should be *compatible* with:*

          `Arg1' is an internal module identifier
          (`system_info:internal_module_id/1')

 - PREDICATE: current_module/1:
     This predicate will successively unify its argument with all
     module names currently loaded. Module names will be simple atoms.

     When called using a free variable as argument, it will retrieve
     on backtracking all modules currently loaded. This is usefull
     when called from the CIAO `toplevel'.

     When called using a module name as argument it will check
     whether the given module is loaded or not. This is usefull when
     called from user programs.

     The predicate is of type *implicit*.

     *Usage:* `current_module(Module)'
        - *Description:* Retrieves (on backtracking) all currently
          loaded modules into your application.

        - *Call and exit should be *compatible* with:*

          `Module' is an atom.   (`basic_props:atm/1')

 - PREDICATE: ciaolibdir/1:
     The predicate is of type *implicit*.

     *Usage:* `ciaolibdir(CiaoPath)'
        - *Description:* `CiaoPath' is the path to the root of the
          Ciao libraries. Inside this directory, there are the
          directories 'lib', 'library' and 'contrib', which contain
          library modules.

        - *Call and exit should be *compatible* with:*

          `CiaoPath' is an atom.   (`basic_props:atm/1')


File: ciao.info,  Node: Documentation on internals (system_info),  Prev: Documentation on exports (system_info),  Up: Gathering some basic internal info

Documentation on internals (`system_info')
==========================================

 - PROPERTY: internal_module_id/1:
     For a user file it is a term user/1 with an argument different
     for each user file, for other modules is just the name of the
     module (as an atom).

     *Usage:* `internal_module_id(M)'
        - *Description:* `M' is an internal module identifier


File: ciao.info,  Node: *** PART III - ISO-Prolog library (iso),  Next: ISO-Prolog package,  Prev: Gathering some basic internal info,  Up: Top

PART III - ISO-Prolog library (iso)
***********************************

   This part documents the *iso* package which provides (most of) the
ISO-Prolog functionality to Ciao programs, including most of the
*ISO-Prolog builtins*.


File: ciao.info,  Node: ISO-Prolog package,  Next: Standard operators,  Prev: *** PART III - ISO-Prolog library (iso),  Up: Top

ISO-Prolog package
******************

   This library package allows the use of the ISO-Prolog predicates
in Ciao programs. It is included by default in modules starting with a
`module/2' declaration or user files without a starting
`use_package/1' declaration.

* Menu:

* Usage and interface (iso)::


File: ciao.info,  Node: Usage and interface (iso),  Prev: ISO-Prolog package,  Up: ISO-Prolog package

Usage and interface (`iso')
===========================

   * *Library usage:*

     `:- use_package(iso).'

     or

     `:- module(...,...,[iso]).'

   * *Other modules used:*
        - *System library modules:*

          `aggregates', `dynamic', `iso_misc', `iso_byte_char',
          `iso_incomplete', `operators', `read', `streams', `write'.



File: ciao.info,  Node: Standard operators,  Next: All solutions predicates,  Prev: ISO-Prolog package,  Up: Top

Standard operators
******************

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 0.9#7 (1999/3/17, 17:29:23 MET)

   Standard operators are defined by this predicate:
     standard_ops :-
             op(1200,xfx,[:-]),
             op(1200,fx,[:-,?-]),
             op(1100,xfy,[;]),
             op(1050,xfy,[->]),
             op(1000,xfy,[',']),
             op(950,xfy,[&,\&]),
             op(950,xf,[&]),
             op(900,fy,[\+]),
             op(700,xfx,[=,\=,==,\==,@<,@>,@=<,@>=,=..,is,=:=,=\=,<,=<,>,>=]),
             op(550,xfx,[:]),
             op(500,yfx,[+,-,/\,\/,#]),
             op(500,fy,[++,--]),
             op(400,yfx,[*,/,//,rem,mod,<<,>>]),
             op(200,fy,[+,-,\]),
             op(200,xfx,[**]),
             op(200,xfy,[^]),
             op(25,fy,[^]).

* Menu:

* Usage and interface (operators)::
* Documentation on exports (operators)::


File: ciao.info,  Node: Usage and interface (operators),  Next: Documentation on exports (operators),  Prev: Standard operators,  Up: Standard operators

Usage and interface (`operators')
=================================

   * *Library usage:*

     `:- use_module(library(operators)).'

   * *Exports:*
        - *Predicates:*

          `op/3', `current_op/3'.

   * *Other modules used:*
        - *System library modules:*

          `assertions/doc_props'.



File: ciao.info,  Node: Documentation on exports (operators),  Prev: Usage and interface (operators),  Up: Standard operators

Documentation on exports (`operators')
======================================

 - PREDICATE: op/3:
     *Usage:* `op(+Precedence,+Type,+Name)'
        - *Description:* Declares the atom `Name' to be an operator
          of the stated `Type' and `Precedence'. `Name' may also be a
          list of atoms in which case all of them are declared to be
          operators. If `Precedence' is 0 then the operator
          properties of `Name' (if any) are cancelled.

        - *The following properties hold globally:*

          Documentation is still incomplete:
          `op(+Precedence,+Type,+Name)' may not conform the
          functionality documented.   (`doc_props:doc_incomplete/1')

 - PREDICATE: current_op/3:
     *Usage:* `current_op(?(Precedence),?(Type),?(Op))'
        - *Description:* The atom `Op' is currently an operator of
          type `Type' and precedence `Precedence'. Neither `Op' nor
          the other arguments need be instantiated at the time of the
          call; i.e., this predicate can be used to generate as well
          as to test.

        - *The following properties hold globally:*

          Documentation is still incomplete:
          `current_op(?(Precedence),?(Type),?(Op))' may not conform
          the functionality documented.
          (`doc_props:doc_incomplete/1')

 - PREDICATE: current_prefixop/3:
     No further documentation available for this predicate.


 - PREDICATE: current_infixop/4:
     No further documentation available for this predicate.


 - PREDICATE: current_postfixop/3:
     No further documentation available for this predicate.



File: ciao.info,  Node: All solutions predicates,  Next: Dynamic predicates,  Prev: Standard operators,  Up: Top

All solutions predicates
************************

   *Author(s):* First version by Richard A. O'Keefe and David H.D.
Warren. Changes by Mats Carlsson, Daniel Cabeza, and Manuel
Hermenegildo.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 0.7#9 (1998/9/23, 19:34:28 MEST)

   This module implements the standard solution aggregation
predicates.

   When there are many solutions to a problem, and when all those
solutions are required to be collected together, this can be achieved
by repeatedly backtracking and gradually building up a list of the
solutions. The following built-in predicates are provided to automate
this process.

* Menu:

* Usage and interface (aggregates)::
* Documentation on exports (aggregates)::


File: ciao.info,  Node: Usage and interface (aggregates),  Next: Documentation on exports (aggregates),  Prev: All solutions predicates,  Up: All solutions predicates

Usage and interface (`aggregates')
==================================

   * *Library usage:*

     `:- use_module(library(aggregates)).'

   * *Exports:*
        - *Predicates:*

          `setof/3', `bagof/3', `findall/3', `^/2'.

   * *Other modules used:*
        - *System library modules:*

          `sort', `lists'.



File: ciao.info,  Node: Documentation on exports (aggregates),  Prev: Usage and interface (aggregates),  Up: All solutions predicates

Documentation on exports (`aggregates')
=======================================

 - PREDICATE: setof/3:
     *Meta-predicate* with arguments: `setof(?,goal,?)'.

     *Usage:* `setof(@(Template),+Generator,?(Set))' < * ISO * >
        - *Description:* Finds the `Set' of instances of the
          `Template' satisfying `Generator'. The set is in ascending
          order (see *Note Comparing terms:: for a definition of this
          order) without duplicates, and is non-empty. If there are
          no solutions, `setof' fails. `setof' may succeed in more
          than one way, binding free variables in `Generator' to
          different values. This can be avoided by using existential
          quantifiers on the free variables in front of `Generator',
          using `^/2'. For example, given the clauses:
               father(bill, tom).
               father(bill, ann).
               father(bill, john).
               father(harry, july).
               father(harry, daniel).

          The following query produces two alternative solutions via
          backtracking:
               ?- setof(X,father(F,X),Sons).
               
               F = bill,
               Sons = [ann,john,tom] ? ;
               
               F = harry,
               Sons = [daniel,july] ? ;
               
               no
               ?-

        - *The following properties should hold upon exit:*

          `Template' is any term.   (`basic_props:term/1')

          `Generator' is a term which represents a goal, i.e., an
          atom or a structure.   (`basic_props:callable/1')

          `Set' is a list.   (`basic_props:list/1')

 - PREDICATE: bagof/3:
     *Meta-predicate* with arguments: `bagof(?,goal,?)'.

     *Usage:* `bagof(@(Template),+Generator,?(Bag))' < * ISO * >
        - *Description:* Finds all the instances of the `Template'
          produced by the `Generator', and returns them in the `Bag'
          in the order in which they were found. If the `Generator'
          contains free variables which are not bound in the
          `Template', it assumes that this is like any other Prolog
          question and that you want bindings for those variables.
          This can be avoided by using existential quantifiers on the
          free variables in front of the `Generator', using `^/2'.

 - PREDICATE: findall/3:
     *Meta-predicate* with arguments: `findall(?,goal,?)'.

     *Usage:* `findall(?(Template),+Generator,?(List))' < * ISO * >
        - *Description:* A special case of bagof, where all free
          variables in the `Generator' are taken to be existentially
          quantified. Faster than the other aggregation predicates.

 - PREDICATE: findall/4:
     No further documentation available for this predicate.

     *Meta-predicate* with arguments: `findall(?,goal,?,?)'.


 - PREDICATE: ^/2:
     *Usage:* `X ^ P'
        - *Description:* Existential quantification: `X' is
          existentially quantified in `P'. E.g., in `A^p(A,B)', `A'
          is existentially quantified. Used only within aggregation
          predicates. In all other contexts, simply, execute the
          procedure call `P'.


File: ciao.info,  Node: Dynamic predicates,  Next: iso_byte_char (library),  Prev: All solutions predicates,  Up: Top

Dynamic predicates
******************

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 0.5#30 (1998/6/30, 14:23:37 MET DST)

   This module implements the assert/retract family of predicates to
manipulate dynamic predicates.

   The predicates defined in this module allow modification of the
program as it is actually running. Clauses can be added to the
program (*asserted*) or removed from the program (*retracted*). For
these predicates, the argument which corresponds to the clause head
must be instantiated to an atom or a compound term. The argument
corresponding to the clause must be instantiated either to a term
`Head :- Body' or, if the body part is empty, to `Head'. An empty
body part is represented as `true'.

* Menu:

* Usage and interface (dynamic)::
* Documentation on exports (dynamic)::
* Documentation on multifiles (dynamic)::


File: ciao.info,  Node: Usage and interface (dynamic),  Next: Documentation on exports (dynamic),  Prev: Dynamic predicates,  Up: Dynamic predicates

Usage and interface (`dynamic')
===============================

   * *Library usage:*

     `:- use_module(library(dynamic)).'

   * *Exports:*
        - *Predicates:*

          `asserta/1', `asserta/2', `assertz/1', `assertz/2',
          `assert/1', `assert/2', `retract/1', `retractall/1',
          `abolish/1', `clause/2', `clause/3', `current_predicate/1'.

        - *Multifiles:*

          `do_on_abolish/1'.

   * *Other modules used:*
        - *System library modules:*

          `assertions/doc_props'.



File: ciao.info,  Node: Documentation on exports (dynamic),  Next: Documentation on multifiles (dynamic),  Prev: Usage and interface (dynamic),  Up: Dynamic predicates

Documentation on exports (`dynamic')
====================================

 - PREDICATE: asserta/1:
     *Meta-predicate* with arguments: `asserta(clause)'.

     *Usage:* `asserta(+Clause)'
        - *Description:* The current instance of `Clause' is
          interpreted as a clause and is added to the current
          program. The predicate concerned must be dynamic. The new
          clause becomes the *first* clause for the predicate
          concerned. Any uninstantiated variables in the `Clause'
          will be replaced by new private variables.

        - *The following properties should hold globally:*

          Documentation is still incomplete: `asserta(+Clause)' may
          not conform the functionality documented.
          (`doc_props:doc_incomplete/1')

 - PREDICATE: asserta/2:
     *Meta-predicate* with arguments: `asserta(clause,?)'.

     *Usage:* `asserta(+Clause,-(Ref))'
        - *Description:* Like `asserta/1'. `Ref' is a unique
          identifier of the asserted clause.

        - *The following properties should hold globally:*

          Documentation is still incomplete:
          `asserta(+Clause,-(Ref))' may not conform the functionality
          documented.   (`doc_props:doc_incomplete/1')

 - PREDICATE: assertz/1:
     *Meta-predicate* with arguments: `assertz(clause)'.

     *Usage:* `assertz(+Clause)'
        - *Description:* Like `asserta/1', except that the new clause
          becomes the *last* clause for the predicate concerned.

        - *The following properties should hold globally:*

          Documentation is still incomplete: `assertz(+Clause)' may
          not conform the functionality documented.
          (`doc_props:doc_incomplete/1')

 - PREDICATE: assertz/2:
     *Meta-predicate* with arguments: `assertz(clause,?)'.

     *Usage:* `assertz(+Clause,-(Ref))'
        - *Description:* Like `assertz/1'. `Ref' is a unique
          identifier of the asserted clause.

        - *The following properties should hold globally:*

          Documentation is still incomplete:
          `assertz(+Clause,-(Ref))' may not conform the functionality
          documented.   (`doc_props:doc_incomplete/1')

 - PREDICATE: assert/1:
     *Meta-predicate* with arguments: `assert(clause)'.

     *Usage:* `assert(+Clause)'
        - *Description:* Identical to `assertz/1'. Included for
          compatibility.

        - *The following properties should hold globally:*

          Documentation is still incomplete: `assert(+Clause)' may
          not conform the functionality documented.
          (`doc_props:doc_incomplete/1')

 - PREDICATE: assert/2:
     *Meta-predicate* with arguments: `assert(clause,?)'.

     *Usage:* `assert(+Clause,-(Ref))'
        - *Description:* Identical to `assertz/2'. Included for
          compatibility.

        - *The following properties should hold globally:*

          Documentation is still incomplete: `assert(+Clause,-(Ref))'
          may not conform the functionality documented.
          (`doc_props:doc_incomplete/1')

 - PREDICATE: retract/1:
     *Meta-predicate* with arguments: `retract(clause)'.

     *Usage:* `retract(+Clause)'
        - *Description:* The first clause in the program that matches
          `Clause' is erased. The predicate concerned must be dynamic.

          The predicate `retract/1' may be used in a non-determinate
          fashion, i.e., it will successively retract clauses
          matching the argument through backtracking. If reactivated
          by backtracking, invocations of the predicate whose clauses
          are being retracted will proceed unaffected by the
          retracts. This is also true for invocations of `clause' for
          the same predicate. The space occupied by a retracted
          clause will be recovered when instances of the clause are
          no longer in use.

        - *The following properties should hold globally:*

          Documentation is still incomplete: `retract(+Clause)' may
          not conform the functionality documented.
          (`doc_props:doc_incomplete/1')

 - PREDICATE: retractall/1:
     *Meta-predicate* with arguments: `retractall(fact)'.

     *Usage:* `retractall(+Head)'
        - *Description:* Erase all clauses whose head matches `Head',
          where `Head' must be instantiated to an atom or a compound
          term. The predicate concerned must be dynamic. The
          predicate definition is retained.

        - *The following properties should hold globally:*

          Documentation is still incomplete: `retractall(+Head)' may
          not conform the functionality documented.
          (`doc_props:doc_incomplete/1')

 - PREDICATE: abolish/1:
     *Meta-predicate* with arguments: `abolish(spec)'.

     *Usage:* `abolish(+Spec)'
        - *Description:* Erase all clauses of the predicate specified
          by the predicate spec, or list of predicate specs, `Spec'.
          The predicate definition itself is also erased (the
          predicate is deemed undefined after execution of the
          abolish). The predicates concerned must all be user defined.

        - *The following properties should hold globally:*

          Documentation is still incomplete: `abolish(+Spec)' may not
          conform the functionality documented.
          (`doc_props:doc_incomplete/1')

 - PREDICATE: clause/2:
     *Meta-predicate* with arguments: `clause(fact,?)'.

     *Usage:* `clause(+Head,?(Body))'
        - *Description:* The clause '`Head' `:-' `Body'' exists in
          the current program. The predicate concerned must be
          dynamic.

        - *The following properties should hold globally:*

          Documentation is still incomplete: `clause(+Head,?(Body))'
          may not conform the functionality documented.
          (`doc_props:doc_incomplete/1')

 - PREDICATE: clause/3:
     `clause(Head,Body,Ref)'

     Like `clause(Head,Body)', plus the clause is uniquely identified
     by `Ref'.

     *Meta-predicate* with arguments: `clause(fact,?,?)'.

     *Usage 1:* `clause(+Head,?(Body),?(Ref))'
        - *Description:* `Head' must be instantiated to an atom or a
          compound term.

        - *The following properties should hold globally:*

          Documentation is still incomplete:
          `clause(+Head,?(Body),?(Ref))' may not conform the
          functionality documented.   (`doc_props:doc_incomplete/1')

     *Usage 2:* `clause(?(Head),?(Body),+Ref)'
        - *Description:* `Ref' must be instantiated to a valid
          identifier.

        - *The following properties should hold globally:*

          Documentation is still incomplete:
          `clause(?(Head),?(Body),+Ref)' may not conform the
          functionality documented.   (`doc_props:doc_incomplete/1')

 - PREDICATE: current_predicate/1:
     *Usage:* `current_predicate(?(Spec))'
        - *Description:* A user defined predicate is named `Spec'.

        - *The following properties should hold globally:*

          Documentation is still incomplete:
          `current_predicate(?(Spec))' may not conform the
          functionality documented.   (`doc_props:doc_incomplete/1')

 - PREDICATE: dynamic/1:
     No further documentation available for this predicate.


 - PREDICATE: data/1:
     No further documentation available for this predicate.


 - PREDICATE: wellformed_body/3:
     `wellformed_body(BodyIn,Env,BodyOut)'

     `BodyIn' is a well-formed clause body. `BodyOut' is its
     counterpart with no single-variable meta-goals (i.e., with
     `call(X)' for `X'). `Env' denotes if global cuts are admissible
     in `BodyIn' (`+' if they are, `-' if they are not).



File: ciao.info,  Node: Documentation on multifiles (dynamic),  Prev: Documentation on exports (dynamic),  Up: Dynamic predicates

Documentation on multifiles (`dynamic')
=======================================

 - PREDICATE: do_on_abolish/1:
     `do_on_abolish(Head)'

     A hook predicate which will be called when the definition of the
     predicate of `Head' is abolished.

     The predicate is *multifile*.



File: ciao.info,  Node: iso_byte_char (library),  Next: iso_incomplete (library),  Prev: Dynamic predicates,  Up: Top

iso_byte_char (library)
***********************

* Menu:

* Usage and interface (iso_byte_char)::
* Documentation on exports (iso_byte_char)::


File: ciao.info,  Node: Usage and interface (iso_byte_char),  Next: Documentation on exports (iso_byte_char),  Prev: iso_byte_char (library),  Up: iso_byte_char (library)

Usage and interface (`iso_byte_char')
=====================================

   * *Library usage:*

     `:- use_module(library(iso_byte_char)).'


File: ciao.info,  Node: Documentation on exports (iso_byte_char),  Prev: Usage and interface (iso_byte_char),  Up: iso_byte_char (library)

Documentation on exports (`iso_byte_char')
==========================================

 - PREDICATE: char_code/2:
     No further documentation available for this predicate.


 - PREDICATE: atom_chars/2:
     No further documentation available for this predicate.


 - PREDICATE: number_chars/2:
     No further documentation available for this predicate.


 - PREDICATE: get_byte/1:
     No further documentation available for this predicate.


 - PREDICATE: get_byte/2:
     No further documentation available for this predicate.


 - PREDICATE: peek_byte/1:
     No further documentation available for this predicate.


 - PREDICATE: peek_byte/2:
     No further documentation available for this predicate.


 - PREDICATE: put_byte/1:
     No further documentation available for this predicate.


 - PREDICATE: put_byte/2:
     No further documentation available for this predicate.


 - PREDICATE: get_char/1:
     No further documentation available for this predicate.


 - PREDICATE: get_char/2:
     No further documentation available for this predicate.


 - PREDICATE: peek_char/1:
     No further documentation available for this predicate.


 - PREDICATE: peek_char/2:
     No further documentation available for this predicate.


 - PREDICATE: put_char/1:
     No further documentation available for this predicate.


 - PREDICATE: put_char/2:
     No further documentation available for this predicate.



File: ciao.info,  Node: iso_incomplete (library),  Next: iso_misc (library),  Prev: iso_byte_char (library),  Up: Top

iso_incomplete (library)
************************

* Menu:

* Usage and interface (iso_incomplete)::
* Documentation on exports (iso_incomplete)::


File: ciao.info,  Node: Usage and interface (iso_incomplete),  Next: Documentation on exports (iso_incomplete),  Prev: iso_incomplete (library),  Up: iso_incomplete (library)

Usage and interface (`iso_incomplete')
======================================

   * *Library usage:*

     `:- use_module(library(iso_incomplete)).'


File: ciao.info,  Node: Documentation on exports (iso_incomplete),  Prev: Usage and interface (iso_incomplete),  Up: iso_incomplete (library)

Documentation on exports (`iso_incomplete')
===========================================

 - PREDICATE: open/4:
     No further documentation available for this predicate.


 - PREDICATE: close/2:
     No further documentation available for this predicate.


 - PREDICATE: stream_property/2:
     No further documentation available for this predicate.



File: ciao.info,  Node: iso_misc (library),  Next: Term input,  Prev: iso_incomplete (library),  Up: Top

iso_misc (library)
******************

   *Version:* 0.4#5 (1998/2/24)

* Menu:

* Usage and interface (iso_misc)::
* Documentation on exports (iso_misc)::


File: ciao.info,  Node: Usage and interface (iso_misc),  Next: Documentation on exports (iso_misc),  Prev: iso_misc (library),  Up: iso_misc (library)

Usage and interface (`iso_misc')
================================

   * *Library usage:*

     `:- use_module(library(iso_misc)).'

   * *Other modules used:*
        - *System library modules:*

          `between'.



File: ciao.info,  Node: Documentation on exports (iso_misc),  Prev: Usage and interface (iso_misc),  Up: iso_misc (library)

Documentation on exports (`iso_misc')
=====================================

 - PREDICATE: \=/2:
     No further documentation available for this predicate.


 - PREDICATE: once/1:
     No further documentation available for this predicate.

     *Meta-predicate* with arguments: `once(goal)'.


 - PREDICATE: compound/1:
     No further documentation available for this predicate.


 - PREDICATE: sub_atom/5:
     No further documentation available for this predicate.


 - PREDICATE: unify_with_occurs_check/2:
     No further documentation available for this predicate.



File: ciao.info,  Node: Term input,  Next: Structured stream handling,  Prev: iso_misc (library),  Up: Top

Term input
**********

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 0.8#10 (1998/11/24, 17:52:5 MET)

* Menu:

* Usage and interface (read)::
* Documentation on exports (read)::


File: ciao.info,  Node: Usage and interface (read),  Next: Documentation on exports (read),  Prev: Term input,  Up: Term input

Usage and interface (`read')
============================

   * *Library usage:*

     `:- use_module(library(read)).'

   * *Exports:*
        - *Predicates:*

          `read/2'.

   * *Other modules used:*
        - *System library modules:*

          `tokenize', `operators', `lists', `assertions/doc_props'.



File: ciao.info,  Node: Documentation on exports (read),  Prev: Usage and interface (read),  Up: Term input

Documentation on exports (`read')
=================================

 - PREDICATE: read/1:
     `read(Term)'

     Like `read(Stream,Term)' with `Stream' associated to the current
     standard input.


 - PREDICATE: read/2:
     *Usage:* `read(+Stream,?(Term))'
        - *Description:* The next term, delimited by a full-stop
          (i.e., a `.' followed by either a space or a control
          character), is read from `Stream' and is unified with
          `Term'. The syntax of the term must agree with current
          operator declarations. If the end of `Stream' has been
          reached, `Term' is unified with the term `end_of_file'.
          Further calls to `read/2' for the same stream will then
          cause an error, unless the stream is connected to the
          terminal (in which case a prompt is opened on the terminal).

        - *The following properties should hold globally:*

          Documentation is still incomplete: `read(+Stream,?(Term))'
          may not conform the functionality documented.
          (`doc_props:doc_incomplete/1')

 - PREDICATE: read_term/2:
     No further documentation available for this predicate.


 - PREDICATE: read_term/3:
     No further documentation available for this predicate.


 - PREDICATE: read_top_level/3:
     No further documentation available for this predicate.


 - PREDICATE: second_prompt/2:
     No further documentation available for this predicate.



File: ciao.info,  Node: Structured stream handling,  Next: Term output,  Prev: Term input,  Up: Top

Structured stream handling
**************************

   *Version:* 0.5#15 (1998/6/9, 16:30:53 MET DST)

* Menu:

* Usage and interface (streams)::
* Documentation on exports (streams)::


File: ciao.info,  Node: Usage and interface (streams),  Next: Documentation on exports (streams),  Prev: Structured stream handling,  Up: Structured stream handling

Usage and interface (`streams')
===============================

   * *Library usage:*

     `:- use_module(library(streams)).'


File: ciao.info,  Node: Documentation on exports (streams),  Prev: Usage and interface (streams),  Up: Structured stream handling

Documentation on exports (`streams')
====================================

 - PREDICATE: open_null_stream/1:
     No further documentation available for this predicate.


 - PREDICATE: open_input/2:
     No further documentation available for this predicate.


 - PREDICATE: close_input/1:
     No further documentation available for this predicate.


 - PREDICATE: open_output/2:
     No further documentation available for this predicate.


 - PREDICATE: close_output/1:
     No further documentation available for this predicate.



File: ciao.info,  Node: Term output,  Next: *** PART IV - Classic Prolog library (classic),  Prev: Structured stream handling,  Up: Top

Term output
***********

   *Author(s):* Adapted from shared code written by Richard A.
O'Keefe. Changes by Mats Carlsson, Daniel Cabeza, and Manuel
Hermenegildo..

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 0.5#49 (1998/7/14, 20:3:29 MET DST)

   This library provides different predicates for term output,
additional to the kernel predicates `display/1'- `display/2' and
`displayq/1'-`displayq/2'. All the predicates defined in ISO-Prolog
are included, plus other traditionally provided by Prolog
Implementations. Output predicates are provided in two versions: one
that uses the current output stream and other in which the stream is
specified explicitly, as an additional first argument.

* Menu:

* Usage and interface (write)::
* Documentation on exports (write)::
* Documentation on multifiles (write)::


File: ciao.info,  Node: Usage and interface (write),  Next: Documentation on exports (write),  Prev: Term output,  Up: Term output

Usage and interface (`write')
=============================

   * *Library usage:*

     `:- use_module(library(write)).'

   * *Exports:*
        - *Predicates:*

          `write_term/3', `write_term/2', `write/2', `write/1',
          `write_list1/1', `writeq/2', `writeq/1',
          `write_canonical/2', `write_canonical/1', `print/2',
          `print/1', `portray_clause/2', `portray_clause/1',
          `numbervars/3', `prettyvars/1'.

        - *Properties:*

          `write_option/1'.

        - *Multifiles:*

          `define_flag/3', `portray_attribute/2', `portray/1'.

   * *Other modules used:*
        - *System library modules:*

          `operators', `sort'.



File: ciao.info,  Node: Documentation on exports (write),  Next: Documentation on multifiles (write),  Prev: Usage and interface (write),  Up: Term output

Documentation on exports (`write')
==================================

 - PREDICATE: write_term/3:
     *Usage:* `write_term(@(Stream),?(Term),+OptList)' < * ISO * >
        - *Description:* Outputs the term `Term' to the stream
          `Stream', with the list of write-options `OptList'. See
          `write_option/1' type for default options.

        - *The following properties should hold upon exit:*

          `@(Stream)' is an open stream.   (`streams_basic:stream/1')

          `?(Term)' is any term.   (`basic_props:term/1')

          `+OptList' is a list of `write_option's.
          (`basic_props:list/2')

 - PREDICATE: write_term/2:
     *Usage:* `write_term(?(Term),+OptList)' < * ISO * >
        - *Description:* Behaves like `current_output(S),
          write_term(S,Term,OptList)'.

        - *The following properties should hold upon exit:*

          `?(Term)' is any term.   (`basic_props:term/1')

          `+OptList' is a list of `write_option's.
          (`basic_props:list/2')

 - PROPERTY: write_option/1:
     `Opt' is a valid write option which affects the predicate
     `write_term/3' and similar ones. Possible write_options are:
        * *quoted(**bool**):* If *bool* is `true', atoms and functors
          that can't be read back by `read_term/3' are quoted, if it
          is `false', each atom and functor is written as its name.
          Default value is `false'.

        * *ignore_ops(**flag**):* If *flag* is `true', each compound
          term is output in functional notation, if it is `ops',
          curly bracketed notation and list notation is enabled when
          outputing compound terms, if it is `false', also operator
          notation is enabled when outputing compound terms. Default
          value is `false'.

        * *numbervars(**bool**):* If *bool* is `true', a term of the
          form `'$VAR'(N)' where `N' is an integer, is output as a
          variable name consisting of a capital letter possibly
          followed by an integer, a term of the form `'$VAR'(Atom)'
          where `Atom' is an atom, as this atom (without quotes), and
          a term of the form `'$VAR'(String)' where `String' is a
          character string, as the atom corresponding to this
          character string. See predicates `numbervars/3' and
          `prettyvars/1'. If *bool* is `false' this cases are not
          treated in any special way. Default value is `false'.

        * *portrayed(**bool**):* If *bool* is `true', then call
          multifile predicates `portray/1' and `portray_attribute/1',
          to provide the user handlers for pretty printing some
          terms. `portray_attribute/1' is called whenever an
          attributed variable is to be printed, `portray/1' is called
          whenever a non-variable term is to be printed. If either
          call succeeds, then it is assumed that the term has been
          output, else it is printed as usual. If *bool* is `false',
          these predicates are not called. Default value is `false'.
          This option is set by the toplevel when writting the final
          values of variables, and by the debugging package when
          writting the goals in the tracing messages. Thus you can
          vary the forms of these messages if you wish.

        * *max_depth(**depth**):* *depth* is a positive integer or
          cero. If it is positive, it denotes the depth limit on
          printing compound terms. If it is cero, there is no limit.
          Default value is `0' (no limit).

        * *priority(**prio**):* *prio* is an integer between 1 and
          1200. If the term to be printed has higher priority than
          *prio*, it will be printed parenthesized. Default value is
          1200 (no term parenthesized).

     .

     *Usage:* `write_option(Opt)'
        - *Description:* `Opt' is a valid write option.

 - PREDICATE: write/2:
     *Usage:* `write(@(Stream),?(Term))' < * ISO * >
        - *Description:* Behaves like `write_term(Stream, Term,
          [numbervars(true)])'.

        - *The following properties should hold upon exit:*

          `@(Stream)' is an open stream.   (`streams_basic:stream/1')

          `?(Term)' is any term.   (`basic_props:term/1')

 - PREDICATE: write/1:
     *Usage:* `write(?(Term))' < * ISO * >
        - *Description:* Behaves like `current_output(S),
          write(S,Term)'.

        - *The following properties should hold upon exit:*

          `?(Term)' is any term.   (`basic_props:term/1')

 - PREDICATE: write_list1/1:
     *Usage:*
        - *Description:* Writes a list to current output one element
          in each line.

        - *The following properties should hold at call time:*

          `Arg1' is a list.   (`basic_props:list/1')

        - *The following properties should hold upon exit:*

          `Arg1' is a list.   (`basic_props:list/1')

 - PREDICATE: writeq/2:
     *Usage:* `writeq(@(Stream),?(Term))' < * ISO * >
        - *Description:* Behaves like `write_term(Stream, Term,
          [quoted(true), numbervars(true)])'.

        - *The following properties should hold upon exit:*

          `@(Stream)' is an open stream.   (`streams_basic:stream/1')

          `?(Term)' is any term.   (`basic_props:term/1')

 - PREDICATE: writeq/1:
     *Usage:* `writeq(?(Term))' < * ISO * >
        - *Description:* Behaves like `current_output(S),
          writeq(S,Term)'.

        - *The following properties should hold upon exit:*

          `?(Term)' is any term.   (`basic_props:term/1')

 - PREDICATE: write_canonical/2:
     *Usage:* `write_canonical(@(Stream),?(Term))' < * ISO * >
        - *Description:* Behaves like `write_term(Stream, Term,
          [quoted(true), ignore_ops(true)])'. The output of this
          predicate can always be parsed by `read_term/2' even if the
          term contains special characters or if operator
          declarations have changed.

        - *The following properties should hold upon exit:*

          `@(Stream)' is an open stream.   (`streams_basic:stream/1')

          `?(Term)' is any term.   (`basic_props:term/1')

 - PREDICATE: write_canonical/1:
     *Usage:* `write_canonical(?(Term))' < * ISO * >
        - *Description:* Behaves like `current_output(S),
          write_canonical(S,Term)'.

        - *The following properties should hold upon exit:*

          `?(Term)' is any term.   (`basic_props:term/1')

 - PREDICATE: print/2:
     *Usage:* `print(@(Stream),?(Term))'
        - *Description:* Behaves like `write_term(Stream, Term,
          [numbervars(true), portrayed(true)])'.

        - *The following properties should hold upon exit:*

          `@(Stream)' is an open stream.   (`streams_basic:stream/1')

          `?(Term)' is any term.   (`basic_props:term/1')

 - PREDICATE: print/1:
     *Usage:* `print(?(Term))'
        - *Description:* Behaves like `current_output(S),
          print(S,Term)'.

        - *The following properties should hold upon exit:*

          `?(Term)' is any term.   (`basic_props:term/1')

 - PREDICATE: portray_clause/2:
     *Usage:* `portray_clause(@(Stream),?(Clause))'
        - *Description:* Outputs the clause `Clause' onto `Stream',
          pretty printing its variables and using indentation,
          including a period at the end. This predicate is used by
          `listing/0'.

        - *The following properties should hold upon exit:*

          `@(Stream)' is an open stream.   (`streams_basic:stream/1')

          `?(Clause)' is any term.   (`basic_props:term/1')

 - PREDICATE: portray_clause/1:
     *Usage:* `portray_clause(?(Clause))'
        - *Description:* Behaves like `current_output(S),
          portray_clause(S,Term)'.

        - *The following properties should hold upon exit:*

          `?(Clause)' is any term.   (`basic_props:term/1')

 - PREDICATE: numbervars/3:
     *Usage:* `numbervars(?(Term),+N,?(M))'
        - *Description:* Unifies each of the variables in term `Term'
          with a term of the form `'$VAR'(I)' where `I' is an integer
          from `N' onwards. `M'-1 is unified with the last integer
          used. If the resulting term is output with a write option
          `numbervars(true)', in the place of the variables in the
          original term will be printed a variable name consisting of
          a capital letter possibly followed by an integer. When `N'
          is 0 you will get the variable names A, B, ..., Z, A1, B1,
          etc.

        - *The following properties should hold upon exit:*

          `?(Term)' is any term.   (`basic_props:term/1')

          `+N' is currently instantiated to an integer.
          (`term_typing:integer/1')

          `?(M)' is currently instantiated to an integer.
          (`term_typing:integer/1')

 - PREDICATE: prettyvars/1:
     *Usage:* `prettyvars(?(Term))'
        - *Description:* Similar to `numbervars(Term,0,_)', except
          that singleton variables in `Term' are unified with
          `'$VAR'('_')', so that when the resulting term is output
          with a write option `numbervars(true)', in the place of
          singleton variables `_' is written. This predicate is used
          by `portray_clause/2'.

        - *The following properties should hold upon exit:*

          `?(Term)' is any term.   (`basic_props:term/1')

 - PREDICATE: printable_char/1:
     No further documentation available for this predicate.



File: ciao.info,  Node: Documentation on multifiles (write),  Prev: Documentation on exports (write),  Up: Term output

Documentation on multifiles (`write')
=====================================

 - PREDICATE: define_flag/3:
     Defines flags as follows:
          define_flag(write_strings,[on,off],off).
     (See *Note Changing system behaviour and various flags::)

     The predicate is *multifile*.


 - PREDICATE: portray_attribute/2:
     No further documentation available for this predicate.

     The predicate is *multifile*.


 - PREDICATE: portray/1:
     The predicate is *multifile*.

     *Usage:* `portray(?(Term))'
        - *Description:* *A user defined predicate.* This should
          either print the `Term' and succeed, or do nothing and
          fail. In the latter case, the default printer (`write/1')
          will print the `Term'.


File: ciao.info,  Node: *** PART IV - Classic Prolog library (classic),  Next: Classic Prolog package,  Prev: Term output,  Up: Top

PART IV - Classic Prolog library (classic)
******************************************

   This part documents some Ciao libraries which provide Prolog
predicates and Prolog functionalities that are classical in the
Prolog community, like DEC-10 Prolog input/output, definite clause
grammars, dynamic loading of modules, etc.


File: ciao.info,  Node: Classic Prolog package,  Next: Definite clause grammars,  Prev: *** PART IV - Classic Prolog library (classic),  Up: Top

Classic Prolog package
**********************

   This library package allows the use of certain Prolog features
which have become sort of 'classical' from many Prolog
implementations. These include definite clause grammars and some
classical predicates like `append/3'. The libraries listed below
define these predicates, and the following chapters describe them.

* Menu:

* Usage and interface (classic)::


File: ciao.info,  Node: Usage and interface (classic),  Prev: Classic Prolog package,  Up: Classic Prolog package

Usage and interface (`classic')
===============================

   * *Library usage:*

     `:- use_package(classic).'

     or

     `:- module(...,...,[classic]).'

   * *New operators defined:*

     `-->/2' [1200,xfx].

   * *Other modules used:*
        - *System library modules:*

          `operators', `old_database', `lists', `sort', `dict',
          `strings', `dec10_io', `format', `ttyout', `dynmods'.



File: ciao.info,  Node: Definite clause grammars,  Next: Definite clause grammars (expansion),  Prev: Classic Prolog package,  Up: Top

Definite clause grammars
************************

   This library package allows the use of DCGs (Definite Clause
Grammars) [Col78,PW80] in a Ciao module/program.

   Definite clause grammars are an extension of the well-known
context-free grammars. Prolog's grammar rules provide a convenient
notation for expressing definite clause grammars. A DCG rule in
Prolog takes the general form

     `head' --> `body'.

meaning "a possible form for `head' is `body'". Both `body' and
`head' are sequences of one or more items linked by the standard
Prolog conjunction operator `,'.

   Definite clause grammars extend context-free grammars in the
following ways:

  1. A non-terminal symbol may be any Prolog term (other than a
     variable or number).

  2. A terminal symbol may be any Prolog term. To distinguish
     terminals from non-terminals, a sequence of one or more terminal
     symbols is written within a grammar rule as a Prolog list. An
     empty sequence is written as the empty list `[]'. If the
     terminal symbols are ASCII character codes, such lists can be
     written (as elsewhere) as strings. An empty sequence is written
     as the empty list, `[]' or `""'.

  3. Extra conditions, in the form of Prolog procedure calls, may be
     included in the right-hand side of a grammar rule. Such
     procedure calls are written enclosed in `{}' brackets.

  4. The left-hand side of a grammar rule consists of a non-terminal,
     optionally followed by a sequence of terminals (again written as
     a Prolog list).

  5. Alternatives may be stated explicitly in the right-hand side of
     a grammar rule, using the disjunction operator `;' or `|' as in
     Prolog.

  6. The cut symbol may be included in the right-hand side of a
     grammar rule, as in a Prolog clause. The cut symbol does not
     need to be enclosed in `{}' brackets.

   As an example, here is a simple grammar which parses an arithmetic
expression (made up of digits and operators) and computes its value.

     expr(Z) --> term(X), "+", expr(Y), {Z is X + Y}.
     expr(Z) --> term(X), "-", expr(Y), {Z is X - Y}.
     expr(X) --> term(X).
     
     term(Z) --> number(X), "*", term(Y), {Z is X * Y}.
     term(Z) --> number(X), "/", term(Y), {Z is X / Y}.
     term(Z) --> number(Z).
     
     number(C) --> "+", number(C).
     number(C) --> "-", number(X), {C is -X}.
     number(X) --> [C], {"0"=<C, C=<"9", X is C - "0"}.

   In the last rule, `C' is the ASCII code of some digit.

   The query

     | ?- expr(Z, "-2+3*5+1", []).

will compute `Z'=14. The two extra arguments are explained below.

   Now, in fact, grammar rules are merely a convenient "syntactic
sugar" for ordinary Prolog clauses. Each grammar rule takes an input
string, analyses some initial portion, and produces the remaining
portion (possibly enlarged) as output for further analysis. The
arguments required for the input and output strings are not written
explicitly in a grammar rule, but the syntax implicitly defines them.
We now show how to translate grammar rules into ordinary clauses by
making explicit the extra arguments.

   A rule such as

     p(X) --> q(X).

translates into

     p(X, S0, S) :- q(X, S0, S).

   If there is more than one non-terminal on the right-hand side, as
in

     p(X, Y) -->
             q(X),
             r(X, Y),
             s(Y).

then corresponding input and output arguments are identified, as in

     p(X, Y, S0, S) :-
             q(X, S0, S1),
             r(X, Y, S1, S2),
             r(Y, S2, S).

   Terminals are translated using the built-in predicate
`term_basic:'C'/3' (this predicate is not normally useful in itself;
it has been given the name `'C'' simply to avoid using up a more
useful name). Then, for instance

     p(X) --> [go,to], q(X), [stop].

is translated by

     p(X, S0, S) :-
             'C'(S0, go, S1),
             'C'(S1, to, S2),
             q(X, S2, S3),
             'C'(S3, stop, S).

   Extra conditions expressed as explicit procedure calls naturally
translate as themselves, e.g.

     p(X) --> [X], {integer(X), X>0}, q(X).

translates to

     p(X, S0, S) :-
             'C'(S0, X, S1),
             integer(X),
             X>0,
             q(X, S1, S).

   Similarly, a cut is translated literally.

   Terminals on the left-hand side of a rule translate into an
explicit list in the output argument of the main non-terminal, e.g.

     is(N), [not] --> [aint].

becomes

     is(N, S0, [not|S]) :- 'C'(S0, aint, S).

   Disjunction has a fairly obvious translation, e.g.

     args(X, Y) -->
             (   dir(X), [to], indir(Y)
             ;   indir(Y), dir(X)
             ).

translates to

     args(X, Y, S0, S) :-
             (   dir(X, S0, S1),
                 'C'(S1, to, S2),
                 indir(Y, S2, S)
             ;   indir(Y, S0, S1),
                 dir(X, S1, S)
             ).

* Menu:

* Usage and interface (dcg)::


File: ciao.info,  Node: Usage and interface (dcg),  Prev: Definite clause grammars,  Up: Definite clause grammars

Usage and interface (`dcg')
===========================

   * *Library usage:*

     `:- use_package(dcg).'

     or

     `:- module(...,...,[dcg]).'


File: ciao.info,  Node: Definite clause grammars (expansion),  Next: Quintus-like internal database,  Prev: Definite clause grammars,  Up: Top

Definite clause grammars (expansion)
************************************

   *Version:* 0.4#5 (1998/2/24)

* Menu:

* Usage and interface (dcg_expansion)::
* Documentation on exports (dcg_expansion)::


File: ciao.info,  Node: Usage and interface (dcg_expansion),  Next: Documentation on exports (dcg_expansion),  Prev: Definite clause grammars (expansion),  Up: Definite clause grammars (expansion)

Usage and interface (`dcg_expansion')
=====================================

   * *Library usage:*

     `:- use_module(library(dcg_expansion)).'

   * *Exports:*
        - *Predicates:*

          `phrase/3'.

   * *Other modules used:*
        - *System library modules:*

          `terms', `assertions/doc_props'.



File: ciao.info,  Node: Documentation on exports (dcg_expansion),  Prev: Usage and interface (dcg_expansion),  Up: Definite clause grammars (expansion)

Documentation on exports (`dcg_expansion')
==========================================

 - PREDICATE: phrase/2:
     `phrase(Phrase,List)'

     Like `phrase(Phrase,List,[])'.

     *Meta-predicate* with arguments: `phrase(goal,?)'.


 - PREDICATE: phrase/3:
     *Meta-predicate* with arguments: `phrase(goal,?,?)'.

     *Usage:* `phrase(+Phrase,?(List),?(Remainder))'
        - *Description:* The list `List' is a phrase of type `Phrase'
          (according to the current grammar rules), where `Phrase' is
          either a non-terminal or more generally a grammar rule
          body. `Remainder' is what remains of the list after a
          phrase has been found.

        - *The following properties should hold globally:*

          Documentation is still incomplete:
          `phrase(+Phrase,?(List),?(Remainder))' may not conform the
          functionality documented.   (`doc_props:doc_incomplete/1')

 - PREDICATE: dcg_translation/2:
     Performs the code expansion of source clauses that use DCGs.



File: ciao.info,  Node: Quintus-like internal database,  Next: List processing,  Prev: Definite clause grammars (expansion),  Up: Top

Quintus-like internal database
******************************

   *Version:* 0.4#5 (1998/2/24)

   The predicates described in this section were introduced in early
implementations of Prolog to provide efficient means of performing
operations on large quantities of data. The introduction of indexed
dynamic predicates have rendered these predicates obsolete, and the
sole purpose of providing them is to support existing code. There is
no reason whatsoever to use them in new code.

   These predicates store arbitrary terms in the database without
interfering with the clauses which make up the program. The terms
which are stored in this way can subsequently be retrieved via the
key on which they were stored. Many terms may be stored on the same
key, and they can be individually accessed by pattern matching.
Alternatively, access can be achieved via a special identifier which
uniquely identifies each recorded term and which is returned when the
term is stored.

* Menu:

* Usage and interface (old_database)::
* Documentation on exports (old_database)::


File: ciao.info,  Node: Usage and interface (old_database),  Next: Documentation on exports (old_database),  Prev: Quintus-like internal database,  Up: Quintus-like internal database

Usage and interface (`old_database')
====================================

   * *Library usage:*

     `:- use_module(library(old_database)).'


File: ciao.info,  Node: Documentation on exports (old_database),  Prev: Usage and interface (old_database),  Up: Quintus-like internal database

Documentation on exports (`old_database')
=========================================

 - PREDICATE: recorda/3:
     `recorda(+Key,?(Term),-(Ref))'

     The term `Term' is recorded in the internal database as the
     first item for the key `Key', where `Ref' is its
     implementation-defined identifier. The key must be given, and
     only its principal functor is significant. Any uninstantiated
     variables in the `Term' will be replaced by new private
     variables, along with copies of any subgoals blocked on these
     variables.


 - PREDICATE: recordz/3:
     `recordz(+Key,?(Term),-(Ref))'

     Like `recorda/3', except that the new term becomes the *last*
     item for the key `Key'.


 - PREDICATE: recorded/3:
     `recorded(?(Key),?(Term),?(Ref))'

     The internal database is searched for terms recorded under the
     key `Key'. These terms are successively unified with `Term' in
     the order they occur in the database. At the same time, `Ref' is
     unified with the implementation-defined identifier uniquely
     identifying the recorded item. If the key is instantiated to a
     compound term, only its principal functor is significant. If the
     key is uninstantiated, all terms in the database are
     successively unified with `Term' in the order they occur.


 - PREDICATE: current_key/2:
     `current_key(?(KeyName),?(KeyTerm))'

     `KeyTerm' is the most general form of the key for a currently
     recorded term, and `KeyName' is the name of that key. This
     predicate can be used to enumerate in undefined order all keys
     for currently recorded terms through backtracking.



File: ciao.info,  Node: List processing,  Next: Sorting lists,  Prev: Quintus-like internal database,  Up: Top

List processing
***************

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 0.9#63 (1999/4/28, 16:11:31 MEST)

   This module provides a set of predicates for list processing.

* Menu:

* Usage and interface (lists)::
* Documentation on exports (lists)::


File: ciao.info,  Node: Usage and interface (lists),  Next: Documentation on exports (lists),  Prev: List processing,  Up: List processing

Usage and interface (`lists')
=============================

   * *Library usage:*

     `:- use_module(library(lists)).'

   * *Exports:*
        - *Predicates:*

          `nonsingle/1', `append/3', `reverse/2', `delete/3',
          `select/3', `length/2', `nth/3', `add_after/4', `dlist/3',
          `list_concat/2', `list_insert/2', `insert_last/3',
          `contains_ro/2', `nocontainsx/2', `last/2', `list_lookup/4',
          `intersection/3', `union/3', `difference/3',
          `equal_lists/2', `list_to_list_of_lists/2', `powerset/2'.

        - *Properties:*

          `list1/2', `sublist/2'.



File: ciao.info,  Node: Documentation on exports (lists),  Prev: Usage and interface (lists),  Up: List processing

Documentation on exports (`lists')
==================================

 - PREDICATE: nonsingle/1:
     *Usage:* `nonsingle(X)'
        - *Description:* `X' is not a singleton.

 - PREDICATE: append/3:
     *Usage:* `append(Xs,Ys,Zs)'
        - *Description:* `Zs' is `Ys' appended to `Xs'.

 - PREDICATE: reverse/2:
     *Usage:* `reverse(Xs,Ys)'
        - *Description:* Reverses the order of elements in `Xs'.

        - *The following properties should hold at call time:*

          `Xs' is a list.   (`basic_props:list/1')

          `Ys' is a free variable.   (`term_typing:var/1')

        - *The following properties should hold upon exit:*

          `Xs' is a list.   (`basic_props:list/1')

          `Ys' is a list.   (`basic_props:list/1')

 - PREDICATE: reverse/3:
     No further documentation available for this predicate.


 - PREDICATE: delete/3:
     *Usage:* `delete(L1,E,L2)'
        - *Description:* `L2' is `L1' without the ocurrences of `E'.

 - PREDICATE: select/3:
     *Usage:* `select(X,Xs,Ys)'
        - *Description:* `Xs' and `Ys' have the same elements except
          for one occurrence of `X'.

 - PREDICATE: length/2:
     *Usage 1:* `length(L,N)'
        - *Description:* Computes the length of `L'.

        - *The following properties should hold at call time:*

          `L' is a list.   (`basic_props:list/1')

          `N' is a free variable.   (`term_typing:var/1')

        - *The following properties should hold upon exit:*

          `L' is a list.   (`basic_props:list/1')

          `N' is currently instantiated to an integer.
          (`term_typing:integer/1')

     *Usage 2:* `length(L,N)'
        - *Description:* Outputs `L' of length `N'.

        - *The following properties should hold at call time:*

          `L' is a free variable.   (`term_typing:var/1')

          `N' is currently instantiated to an integer.
          (`term_typing:integer/1')

        - *The following properties should hold upon exit:*

          `L' is a list.   (`basic_props:list/1')

          `N' is currently instantiated to an integer.
          (`term_typing:integer/1')

     *Usage 3:* `length(L,N)'
        - *Description:* Checks that `L' is of length `N'.

        - *The following properties should hold at call time:*

          `L' is a list.   (`basic_props:list/1')

          `N' is currently instantiated to an integer.
          (`term_typing:integer/1')

        - *The following properties should hold upon exit:*

          `L' is a list.   (`basic_props:list/1')

          `N' is currently instantiated to an integer.
          (`term_typing:integer/1')

 - PREDICATE: nth/3:
     `nth(N,List,Elem)'

     `N' is the position in `List' of `Elem'. `N' counts from one.

     *Usage 1:* `nth(+int,?(list),?(term))'
        - *Description:* Unifies `Elem' and the `N'th element of
          `List'.

     *Usage 2:* `nth(-(int),?(list),?(term))'
        - *Description:* Finds the positions where `Elem' is in
          `List'. Positions are found in ascending order.

 - PREDICATE: add_after/4:
     *Usage:* `add_after(+L0,+E0,+E,-(L))'
        - *Description:* Adds element `E' after element `E0' (or at
          end) to list `L0' returning in `L' the new list (uses term
          comparison).

 - PREDICATE: add_before/4:
     No further documentation available for this predicate.


 - PROPERTY: list1/2:
     *Meta-predicate* with arguments: `list1(?,pred(1))'.

     *Usage:* `list1(X,Y)'
        - *Description:* `X' is a list of `Y's of at least one
          element.

 - PREDICATE: dlist/3:
     *Usage:* `dlist(List,DList,Tail)'
        - *Description:* `List' is the result of removing `Tail' from
          the end of `DList' (makes a difference list from a list).

 - PREDICATE: list_concat/2:
     *Usage:* `list_concat(LL,L)'
        - *Description:* `L' is the concatenation of all the lists in
          `LL'.

        - *Call and exit should be *compatible* with:*

          `LL' is a list of `list's.   (`basic_props:list/2')

          `L' is a list.   (`basic_props:list/1')

 - PREDICATE: list_insert/2:
     *Usage:* `list_insert(-(List),+Term)'
        - *Description:* Adds `Term' to the end of `List' if there is
          no element in `List' identical to `Term'.

 - PREDICATE: insert_last/3:
     *Usage:* `insert_last(+L0,+E,-(L))'
        - *Description:* Adds element `E' at end of list `L0'
          returning `L'.

 - PREDICATE: contains_ro/2:
     *Usage:*
        - *Description:* Impure membership (does not instantiate a
          variable in its first argument.

 - PREDICATE: contains1/2:
     No further documentation available for this predicate.


 - PREDICATE: nocontainsx/2:
     *Usage:* `nocontainsx(L,X)'
        - *Description:* `X' is not identical to any element of `L'.

 - PREDICATE: last/2:
     *Usage:* `last(L,X)'
        - *Description:* Adds element `X' to incomplete (i.e., ended
          in a variable) list `L'.

 - PREDICATE: list_lookup/3:
     No further documentation available for this predicate.


 - PREDICATE: list_lookup/4:
     *Usage:* `list_lookup(List,Functor,Key,Value)'
        - *Description:* Look up `Functor'(`Key',`Value') pair in
          variable ended key-value pair list `L' or else add it at
          the end.

 - PREDICATE: intset_insert/3:
     No further documentation available for this predicate.


 - PREDICATE: intset_delete/3:
     No further documentation available for this predicate.


 - PREDICATE: intset_in/2:
     No further documentation available for this predicate.


 - PREDICATE: intset_sequence/3:
     No further documentation available for this predicate.


 - PREDICATE: intersection/3:
     *Usage:* `intersection(+List1,+List2,-(List))'
        - *Description:* `List' has the elements which are both in
          `List1' and `List2'.

 - PREDICATE: union/3:
     *Usage:* `union(+List1,+List2,-(List))'
        - *Description:* `List' has the elements which are in `List1'
          followed by the elements which are in `List2' but not in
          `List1'.

 - PREDICATE: difference/3:
     *Usage:* `difference(+List1,+List2,-(List))'
        - *Description:* `List' has the elements which are in `List1'
          but not in `List2'.

 - PROPERTY: sublist/2:
     *Usage:* `sublist(List1,List2)'
        - *Description:* `List2' contains all the elements of `List1'.

        - *If the following properties should hold at call time:*

          `List2' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')

 - PREDICATE: equal_lists/2:
     *Usage:* `equal_lists(+List1,+List2)'
        - *Description:* `List1' has all the elements of `List2', and
          vice versa.

 - PREDICATE: list_to_list_of_lists/2:
     *Usage:* `list_to_list_of_lists(+List,-(LList))'
        - *Description:* `LList' is the list of one element lists
          with elements of `List'.

 - PREDICATE: powerset/2:
     *Usage:* `powerset(+List,-(LList))'
        - *Description:* `LList' is the powerset of `List', i.e., the
          list of all lists which have elements of `List'. If `List'
          is ordered, `LList' and all its elements are ordered.


File: ciao.info,  Node: Sorting lists,  Next: Dictionaries,  Prev: List processing,  Up: Top

Sorting lists
*************

   *Author(s):* Richard A. O'Keefe. All changes by UPM CLIP Group..

   *Version:* 0.4#5 (1998/2/24)

* Menu:

* Usage and interface (sort)::
* Documentation on exports (sort)::
* Documentation on internals (sort)::


File: ciao.info,  Node: Usage and interface (sort),  Next: Documentation on exports (sort),  Prev: Sorting lists,  Up: Sorting lists

Usage and interface (`sort')
============================

   * *Library usage:*

     `:- use_module(library(sort)).'

   * *Exports:*
        - *Predicates:*

          `sort/2', `keysort/2'.



File: ciao.info,  Node: Documentation on exports (sort),  Next: Documentation on internals (sort),  Prev: Usage and interface (sort),  Up: Sorting lists

Documentation on exports (`sort')
=================================

 - PREDICATE: sort/2:
     `sort(List1,List2)'

     The elements of `List1' are sorted into the standard order (see
     *Note Comparing terms::) and any identical elements are merged,
     yielding `List2'. The time and space complexity of this
     operation is at worst `O(N lg N)' where `N' is the length of
     `List1'.

     *Usage:* `sort(+list,?(list))'
        - *Description:* `List2' is the sorted list corresponding to
          `List1'.

 - PREDICATE: keysort/2:
     `keysort(List1,List2)'

     `List1' is sorted into order according to the value of the
     *keys* of its elements, yielding the list `List2'. No merging
     takes place. This predicate is *stable*, i.e., if an element `A'
     occurs before another element `B' *with the same key* in the
     input, then `A' will occur before `B' also in the output. The
     time and space complexity of this operation is at worst `O(N lg
     N)' where `N' is the length of `List1'.

     *Usage:* `keysort(+keylist,?(keylist))'
        - *Description:* `List2' is the (key-)sorted list
          corresponding to `List1'.


File: ciao.info,  Node: Documentation on internals (sort),  Prev: Documentation on exports (sort),  Up: Sorting lists

Documentation on internals (`sort')
===================================

 - REGTYPE: keypair/1:
     *Usage:* `keypair(P)'
        - *Description:* `P' is a pair of the form `K-_', where `K'
          is considered the *key*.

        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')


File: ciao.info,  Node: Dictionaries,  Next: String processing,  Prev: Sorting lists,  Up: Top

Dictionaries
************

   *Version:* 0.4#5 (1998/2/24)

   This module provides predicates for implementing dictionaries.
Such dictionaries are currently implemented as ordered binary trees.

* Menu:

* Usage and interface (dict)::
* Documentation on exports (dict)::


File: ciao.info,  Node: Usage and interface (dict),  Next: Documentation on exports (dict),  Prev: Dictionaries,  Up: Dictionaries

Usage and interface (`dict')
============================

   * *Library usage:*

     `:- use_module(library(dict)).'


File: ciao.info,  Node: Documentation on exports (dict),  Prev: Usage and interface (dict),  Up: Dictionaries

Documentation on exports (`dict')
=================================

 - PREDICATE: dic_node/2:
     No further documentation available for this predicate.


 - PREDICATE: dic_lookup/3:
     No further documentation available for this predicate.


 - PREDICATE: dic_lookup/4:
     No further documentation available for this predicate.


 - PREDICATE: dic_get/3:
     No further documentation available for this predicate.


 - PREDICATE: dic_replace/4:
     No further documentation available for this predicate.



File: ciao.info,  Node: String processing,  Next: DEC-10 Prolog file IO,  Prev: Dictionaries,  Up: Top

String processing
*****************

   *Author(s):* Daniel Cabeza.

   *Version:* 0.4#5 (1998/2/24)

   This module provides predicates for doing input/output with
strings (character code lists) and for including in grammars defining
strings.

* Menu:

* Usage and interface (strings)::
* Documentation on exports (strings)::


File: ciao.info,  Node: Usage and interface (strings),  Next: Documentation on exports (strings),  Prev: String processing,  Up: String processing

Usage and interface (`strings')
===============================

   * *Library usage:*

     `:- use_module(library(strings)).'

   * *Exports:*
        - *Predicates:*

          `get_line/2', `get_line/1', `write_string/2',
          `write_string/1', `whitespace/2', `whitespace0/2',
          `string/3'.



File: ciao.info,  Node: Documentation on exports (strings),  Prev: Usage and interface (strings),  Up: String processing

Documentation on exports (`strings')
====================================

 - PREDICATE: get_line/2:
     `get_line(Stream,Line)'

     Reads from `Stream' a line of text and unifies `Line' with it.
     The end of the line can have UNIX [10] or MS-DOS [13 10]
     termination, which is not included in `Line'.

     *Usage:* `get_line(+stream,?(string))'

 - PREDICATE: get_line/1:
     `get_line(Line)'

     Behaves like `current_input(S), get_line(S,Line)'.

     *Usage:* `get_line(?(string))'

 - PREDICATE: write_string/2:
     `write_string(Stream,String)'

     Writes `String' onto `Stream'.

     *Usage:* `write_string(+stream,+string)'

 - PREDICATE: write_string/1:
     `write_string(String)'

     Behaves like `current_input(S), write_string(S, String)'.

     *Usage:* `write_string(+string)'

 - PREDICATE: whitespace/2:
     `whitespace(String,Rest)'

     In a grammar rule, as `whitespace/0', represents whitespace (a
     positive number of space (32), tab (9), newline (10) or return
     (13) characters). Thus, `Rest' is a proper suffix of `String'
     with one or more whitespace characters removed. An example of
     use would be:
             attrs([]) --> ""
             attrs([N|Ns]) -->
                 whitespace,
                 attr(N),
                 attrs(Ns).

     *Usage:* `whitespace(+string,?(string))'

 - PREDICATE: whitespace0/2:
     `whitespace0(String,Rest)'

     In a grammar rule, as `whitespace0/0', represents possible
     whitespace (any number of space (32), tab (9), newline (10) or
     return (13) characters). Thus, `Rest' is `String' or a proper
     suffix of `String' with one or more whitespace characters
     removed. An example of use would be:

             assignment(N,V) -->
                 variable_name(N), whitespace0, "=", whitespace0, value(V).

     *Usage:* `whitespace0(+string,?(string))'

 - PREDICATE: string/3:
     `string(String,Head,Tail)'

     In a grammar rule, as `string/1', represents literally `String'.
     An example of use would be:

          double(A) -->
                  string(A),
                  string(A).

     *Usage:* `string(?(string),?(string),?(string))'


File: ciao.info,  Node: DEC-10 Prolog file IO,  Next: Formatted output,  Prev: String processing,  Up: Top

DEC-10 Prolog file IO
*********************

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 0.4#5 (1998/2/24)

   This module implements the support for DEC-10 Prolog style file
I/O.

* Menu:

* Usage and interface (dec10_io)::
* Documentation on exports (dec10_io)::


File: ciao.info,  Node: Usage and interface (dec10_io),  Next: Documentation on exports (dec10_io),  Prev: DEC-10 Prolog file IO,  Up: DEC-10 Prolog file IO

Usage and interface (`dec10_io')
================================

   * *Library usage:*

     `:- use_module(library(dec10_io)).'

   * *Other modules used:*
        - *System library modules:*

          `streams'.



File: ciao.info,  Node: Documentation on exports (dec10_io),  Prev: Usage and interface (dec10_io),  Up: DEC-10 Prolog file IO

Documentation on exports (`dec10_io')
=====================================

 - PREDICATE: see/1:
     No further documentation available for this predicate.


 - PREDICATE: seeing/1:
     No further documentation available for this predicate.


 - PREDICATE: seen/0:
     No further documentation available for this predicate.


 - PREDICATE: tell/1:
     No further documentation available for this predicate.


 - PREDICATE: telling/1:
     No further documentation available for this predicate.


 - PREDICATE: told/0:
     No further documentation available for this predicate.


 - PREDICATE: close_file/1:
     No further documentation available for this predicate.



File: ciao.info,  Node: Formatted output,  Next: ttyout (library),  Prev: DEC-10 Prolog file IO,  Up: Top

Formatted output
****************

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 1.3#27 (1999/7/9, 20:25:50 MEST)

   The `format' family of predicates is due to Quintus Prolog. They
act as a Prolog interface to the C `stdio' function `printf()',
allowing formatted output.

   Output is formatted according to an output pattern which can have
either a format control sequence or any other character, which will
appear verbatim in the output. Control sequences act as place-holders
for the actual terms that will be output. Thus
             | ?- format("Hello ~q!",world).

will print `Hello world!'.

   If there is only one item to print it may be supplied alone. If
there are more they have to be given as a list. If there are none
then an empty list should be supplied. There has to be as many items
as control characters.

   The character `~' introduces a control sequence. To print a `~'
verbatim just repeat it:
             | ?- format("Hello ~~world!", []).

will result in `Hello ~world!'.

   A format may be spread over several lines. The control sequence `'
followed by a <LFD> will translate to the empty string:
             | ?- format("Hello world!", []).

will result in `Hello world!'.

* Menu:

* Usage and interface (format)::
* Documentation on exports (format)::


File: ciao.info,  Node: Usage and interface (format),  Next: Documentation on exports (format),  Prev: Formatted output,  Up: Formatted output

Usage and interface (`format')
==============================

   * *Library usage:*

     `:- use_module(library(format)).'

   * *Exports:*
        - *Predicates:*

          `format/2', `format/3'.

        - *Regular Types:*

          `format_control/1'.

   * *Other modules used:*
        - *System library modules:*

          `write', `assertions/doc_props'.



File: ciao.info,  Node: Documentation on exports (format),  Prev: Usage and interface (format),  Up: Formatted output

Documentation on exports (`format')
===================================

 - PREDICATE: format/2:
     *Usage:* `format(Format,Arguments)'
        - *Description:* Print `Arguments' onto current output stream
          according to format `Format'.

        - *Call and exit should be *compatible* with:*

          `Format' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')

 - PREDICATE: format/3:
     *Usage:* `format(+Stream,Format,Arguments)'
        - *Description:* Print `Arguments' onto `Stream' according to
          format `Format'.

        - *Call and exit should be *compatible* with:*

          `Format' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')

 - REGTYPE: format_control/1:
     The general format of a control sequence is `~`N'`C''. The
     character `C' determines the type of the control sequence. `N'
     is an optional numeric argument. An alternative form of `N' is
     `*'. `*' implies that the next argument in `Arguments' should be
     used as a numeric argument in the control sequence. Example:

          | ?- format("Hello~4cworld!", [0'x]).

     and

          | ?- format("Hello~*cworld!", [4,0'x]).

     both produce

          Helloxxxxworld!

     The following control sequences are available.

        * ~a The argument is an atom. The atom is printed without
          quoting.

        * ~`N'c (Print character.) The argument is a number that will
          be interpreted as an ASCII code. `N' defaults to one and is
          interpreted as the number of times to print the character.

        * ~`N'e

        * ~`N'E

        * ~`N'f

        * ~`N'g

        * ~`N'G (Print float). The argument is a float. The float and
          `N' will be passed to the C `printf()' function as

               printf("%.`N'e", `Arg')
               printf("%.`N'E", `Arg')
               printf("%.`N'f", `Arg')
               printf("%.`N'g", `Arg')
               printf("%.`N'G", `Arg')

          If `N' is not supplied the action defaults to

               printf("%e", `Arg')
               printf("%E", `Arg')
               printf("%f", `Arg')
               printf("%g", `Arg')
               printf("%G", `Arg')

        * ~`N'd (Print decimal.) The argument is an integer. `N' is
          interpreted as the number of digits after the decimal
          point. If `N' is 0 or missing, no decimal point will be
          printed. Example:

               | ?- format("Hello ~1d world!", [42]).
               | ?- format("Hello ~d world!", [42]).

          will print as

               Hello 4.2 world!
               Hello 42 world!

          respectively.

        * ~`N'D (Print decimal.) The argument is an integer.
          Identical to `~`N'd' except that `,' will separate groups
          of three digits to the left of the decimal point. Example:

               | ?- format("Hello ~1D world!", [12345]).

          will print as

               Hello 1,234.5 world!

        * ~`N'r (Print radix.) The argument is an integer. `N' is
          interpreted as a radix. `N' should be >= 2 and <= 36. If
          `N' is missing the radix defaults to 8. The letters `a-z'
          will denote digits larger than 9. Example:

               | ?- format("Hello ~2r world!", [15]).
               | ?- format("Hello ~16r world!", [15]).

          will print as

               Hello 1111 world!
               Hello f world!

          respectively.

        * ~`N'R (Print radix.) The argument is an integer. Identical
          to `~`N'r' except that the letters `A-Z' will denote digits
          larger than 9. Example:

               | ?- format("Hello ~16R world!", [15]).

          will print as

               Hello F world!

        * ~`N's (Print string.) The argument is a list of ASCII
          codes. Exactly `N' characters will be printed. `N' defaults
          to the length of the string. Example:

               | ?- format("Hello ~4s ~4s!", ["new","world"]).
               | ?- format("Hello ~s world!", ["new"]).

          will print as

               Hello new  worl!
               Hello new world!

          respectively.

        * ~i (Ignore argument.) The argument may be of any type. The
          argument will be ignored. Example:

               | ?- format("Hello ~i~s world!", ["old","new"]).

          will print as

               Hello new world!

        * ~k (Print canonical.) The argument may be of any type. The
          argument will be passed to `write_canonical/2' (*Note Term
          output::). Example:

               | ?- format("Hello ~k world!", [[a,b,c]]).

          will print as

               Hello .(a,.(b,.(c,[]))) world!

        * ~p (print.) The argument may be of any type. The argument
          will be passed to `print/2' (*Note Term output::). Example:

               | ?- assert((portray([X|Y]) :- print(cons(X,Y)))).
               | ?- format("Hello ~p world!", [[a,b,c]]).

          will print as

               Hello cons(a,cons(b,cons(c,[]))) world!

        * ~q (Print quoted.) The argument may be of any type. The
          argument will be passed to `writeq/2' (*Note Term
          output::). Example:

               | ?- format("Hello ~q world!", [['A','B']]).

          will print as

               Hello ['A','B'] world!

        * ~w (write.) The argument may be of any type. The argument
          will be passed to `write/2' (*Note Term output::). Example:

               | ?- format("Hello ~w world!", [['A','B']]).

          will print as

               Hello [A,B] world!

        * ~`N'n (Print newline.) Print `N' newlines. `N' defaults to
          1. Example:

               | ?- format("Hello ~n world!", []).

          will print as

               Hello
                world!

        * ~N (Fresh line.) Print a newline, if not already at the
          beginning of a line.

     The following control sequences are also available for
     compatibility, but do not perform any useful functions.

        * ~`N'| (Set tab.) Set a tab stop at position `N', where `N'
          defaults to the current position, and advance the current
          position there.

        * ~`N'+ (Advance tab.) Set a tab stop at `N' positions past
          the current position, where `N' defaults to 8, and advance
          the current position there.

        * ~`N't (Set fill character.) Set the fill character to be
          used in the next position movement to `N', where `N'
          defaults to <SPC>.

     *Usage:* `format_control(C)'
        - *Description:* `C' is an atom or string describing how the
          arguments should be formatted. If it is an atom it will be
          converted into a string with `name/2'.

        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

          Documentation is still incomplete: `format_control(C)' may
          not conform the functionality documented.
          (`doc_props:doc_incomplete/1')


File: ciao.info,  Node: ttyout (library),  Next: dynmods (library),  Prev: Formatted output,  Up: Top

ttyout (library)
****************

   *Version:* 0.4#5 (1998/2/24)

* Menu:

* Usage and interface (ttyout)::
* Documentation on exports (ttyout)::


File: ciao.info,  Node: Usage and interface (ttyout),  Next: Documentation on exports (ttyout),  Prev: ttyout (library),  Up: ttyout (library)

Usage and interface (`ttyout')
==============================

   * *Library usage:*

     `:- use_module(library(ttyout)).'


File: ciao.info,  Node: Documentation on exports (ttyout),  Prev: Usage and interface (ttyout),  Up: ttyout (library)

Documentation on exports (`ttyout')
===================================

 - PREDICATE: ttyget/1:
     No further documentation available for this predicate.


 - PREDICATE: ttyget1/1:
     No further documentation available for this predicate.


 - PREDICATE: ttynl/0:
     No further documentation available for this predicate.


 - PREDICATE: ttyput/1:
     No further documentation available for this predicate.


 - PREDICATE: ttyskip/1:
     No further documentation available for this predicate.


 - PREDICATE: ttytab/1:
     No further documentation available for this predicate.


 - PREDICATE: ttyflush/0:
     No further documentation available for this predicate.


 - PREDICATE: ttydisplay/1:
     No further documentation available for this predicate.


 - PREDICATE: ttydisplayq/1:
     No further documentation available for this predicate.


 - PREDICATE: ttyskipeol/0:
     No further documentation available for this predicate.


 - PREDICATE: ttydisplay_string/1:
     No further documentation available for this predicate.



File: ciao.info,  Node: dynmods (library),  Next: runtime_ops (library),  Prev: ttyout (library),  Up: Top

dynmods (library)
*****************

* Menu:

* Usage and interface (dynmods)::
* Documentation on exports (dynmods)::


File: ciao.info,  Node: Usage and interface (dynmods),  Next: Documentation on exports (dynmods),  Prev: dynmods (library),  Up: dynmods (library)

Usage and interface (`dynmods')
===============================

   * *Library usage:*

     `:- use_module(library(dynmods)).'

   * *Other modules used:*
        - *System library modules:*

          `aggregates', `dynamic', `iso_misc', `iso_byte_char',
          `iso_incomplete', `operators', `read', `streams', `write',
          `compiler/compiler'.



File: ciao.info,  Node: Documentation on exports (dynmods),  Prev: Usage and interface (dynmods),  Up: dynmods (library)

Documentation on exports (`dynmods')
====================================

 - PREDICATE: use_module/1:
     No further documentation available for this predicate.

     *Meta-predicate* of type *implicit* with arguments:
     `use_module(addmodule)'.



File: ciao.info,  Node: runtime_ops (library),  Next: *** PART V - Annotated Prolog library (assertions),  Prev: dynmods (library),  Up: Top

runtime_ops (library)
*********************

* Menu:

* Usage and interface (runtime_ops)::


File: ciao.info,  Node: Usage and interface (runtime_ops),  Prev: runtime_ops (library),  Up: runtime_ops (library)

Usage and interface (`runtime_ops')
===================================

   * *Library usage:*

     `:- use_package(runtime_ops).'

     or

     `:- module(...,...,[runtime_ops]).'

   * *Other modules used:*
        - *System library modules:*

          `operators', `aggregates', `dynamic', `iso_misc',
          `iso_byte_char', `iso_incomplete', `read', `streams',
          `write'.



File: ciao.info,  Node: *** PART V - Annotated Prolog library (assertions),  Next: The Ciao assertion package,  Prev: runtime_ops (library),  Up: Top

PART V - Annotated Prolog library (assertions)
**********************************************

   Ciao allows to annotate the program code with *assertions*, much
in the style of the *literate programming*. Assertions can be used to
document predicates (and modules and whole applications) and will be
used by the Ciao preprocessor to debug and optimize the program, and
by the Ciao documenter to build the program manual.


File: ciao.info,  Node: The Ciao assertion package,  Next: Types and properties related to assertions,  Prev: *** PART V - Annotated Prolog library (assertions),  Up: Top

The Ciao assertion package
**************************

   *Author(s):* Manuel Hermenegildo, Francisco Bueno, German Puebla.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   The `assertions' package adds a number of new declaration
definitions and new operator definitions which allow including
program assertions in user programs. Such assertions can be used to
describe predicates, properties, modules, applications, etc. These
descriptions can be formal specifications (such as preconditions and
post-conditions) or machine-readable textual comments.

   This module is part of the `assertions' library. It defines the
basic code-related assertions, i.e., those intended to be used mainly
by compilation-related tools, such as the static analyzer or the
run-time test generator.

   Giving specifications for predicates and other program elements is
the main functionality documented here. The exact syntax of comments
is described in the autodocumenter ( `lpdoc' [Knu84,Her99a]) manual,
although some support for adding machine-readable comments in
assertions is also mentioned here.

   There are two kinds of assertions: predicate assertions and
program point assertions. All predicate assertions are currently
placed as directives in the source code, i.e., preceded by "`:-'".
Program point assertions are placed as goals in clause bodies.

* Menu:

* More info::
* Some attention points::
* Usage and interface (assertions)::
* Documentation on new declarations (assertions)::
* Documentation on exports (assertions)::


File: ciao.info,  Node: More info,  Next: Some attention points,  Prev: The Ciao assertion package,  Up: The Ciao assertion package

More info
=========

   The facilities provided by the library are documented in the
description of its component modules. This documentation is intended
to provide information only at a "reference manual" level. For a more
tutorial introduction to the subject and some more examples please
see the document "An Assertion Language for Debugging of Constraint
Logic Programs (Technical Report CLIP2/97.1)". The assertion language
implemented in this library is modeled after this design document,
although, due to implementation issues, it may differ in some
details. The purpose of this manual is to document precisely what the
implementation of the library supports at any given point in time.


File: ciao.info,  Node: Some attention points,  Next: Usage and interface (assertions),  Prev: More info,  Up: The Ciao assertion package

Some attention points
=====================

   * *Formatting commands within text strings:* many of the
     predicates defined in these modules include arguments intended
     for providing textual information. This includes titles,
     descriptions, comments, etc. The type of this argument is a
     character string. In order for the automatic generation of
     documentation to work correctly, this character string should
     adhere to certain conventions. See the description of the
     `docstring/1' type/grammar for details.

   * *Referring to variables:* In order for the automatic
     documentation system to work correctly, variable names (for
     example, when referring to arguments in the head patterns of
     *pred* declarations) must be surrounded by an `@var' command.
     For example, `@var{VariableName}' should be used for referring
     to the variable "VariableName", which will appear then formatted
     as follows: `VariableName'. See the description of the
     `docstring/1' type/grammar for details.


File: ciao.info,  Node: Usage and interface (assertions),  Next: Documentation on new declarations (assertions),  Prev: Some attention points,  Up: The Ciao assertion package

Usage and interface (`assertions')
==================================

   * *Library usage:*

     The recommended procedure in order to make use of assertions in
     user programs is to include the `assertions' syntax library,
     using one of the following declarations, as appropriate:

             :- module(...,...,[assertions]).
             :- include(library(assertions)).
             :- use_package([assertions]).

   * *Exports:*
        - *Predicates:*

          `check/1', `trust/1', `true/1', `false/1'.

   * *New operators defined:*

     `=>/2' [975,xfx], `::/2' [978,xfx], `decl/1' [1150,fx], `decl/2'
     [1150,xfx], `pred/1' [1150,fx], `pred/2' [1150,xfx], `prop/1'
     [1150,fx], `prop/2' [1150,xfx], `modedef/1' [1150,fx], `calls/1'
     [1150,fx], `calls/2' [1150,xfx], `success/1' [1150,fx],
     `success/2' [1150,xfx], `comp/1' [1150,fx], `comp/2' [1150,xfx],
     `entry/1' [1150,fx].

   * *New declarations defined:*

     `pred/1', `pred/2', `calls/1', `calls/2', `success/1',
     `success/2', `comp/1', `comp/2', `prop/1', `prop/2', `entry/1',
     `modedef/1', `decl/1', `decl/2', `comment/2'.

   * *Other modules used:*
        - *System library modules:*

          `assertions/assertions_props'.



File: ciao.info,  Node: Documentation on new declarations (assertions),  Next: Documentation on exports (assertions),  Prev: Usage and interface (assertions),  Up: The Ciao assertion package

Documentation on new declarations (`assertions')
================================================

 - DECLARATION: pred/1:
     This assertion provides information on a predicate. The body of
     the assertion (its only argument) contains properties or
     comments in the formats defined by `assrt_body/1'.

     More than one of these assertions may appear per predicate, in
     which case each one represents a possible " mode" of use (
     usage) of the predicate. The exact scope of the usage is defined
     by the properties given for calls in the body of each assertion
     (which should thus distinguish the different usages intended).
     All of them together cover all possible modes of usage.

     For example, the following assertions describe (all the and the
     only) modes of usage of predicate `length/2' (see *Note List
     processing::):
          :- pred length(L,N) : list * var => list * integer
          	# "Computes the length of `L'.".
          :- pred length(L,N) : var * integer => list * integer
          	# "Outputs `L' of length `N'.".
          :- pred length(L,N) : list * integer => list * integer
          	# "Checks that `L' is of length `N'.".

     *Usage:* :- `pred(AssertionBody)'.
        - *The following properties should hold at call time:*

          `AssertionBody' is an assertion body.
          (`assertions_props:assrt_body/1')

 - DECLARATION: pred/2:
     This assertion is similar to a `pred/1' assertion but it is
     explicitely qualified. Non-qualified `pred/1' assertions are
     assumed the qualifier `check'.

     *Usage:* :- `pred(AssertionStatus,AssertionBody)'.
        - *The following properties should hold at call time:*

          `AssertionStatus' is an acceptable status for an assertion.
          (`assertions_props:assrt_status/1')

          `AssertionBody' is an assertion body.
          (`assertions_props:assrt_body/1')

 - DECLARATION: calls/1:
     This assertion is similar to a `pred/1' assertion but it only
     provides information about the calls to a predicate. If one or
     several calls assertions are given they are understood to
     describe all possible calls to the predicate.

     For example, the following assertion describes all possible
     calls to predicate `is/2' (see *Note Arithmetic::):
          :- calls is(term,arithexpression).

     *Usage:* :- `calls(AssertionBody)'.
        - *The following properties should hold at call time:*

          `AssertionBody' is a call assertion body.
          (`assertions_props:c_assrt_body/1')

 - DECLARATION: calls/2:
     This assertion is similar to a `calls/1' assertion but it is
     explicitely qualified. Non-qualified `calls/1' assertions are
     assumed the qualifier `check'.

     *Usage:* :- `calls(AssertionStatus,AssertionBody)'.
        - *The following properties should hold at call time:*

          `AssertionStatus' is an acceptable status for an assertion.
          (`assertions_props:assrt_status/1')

          `AssertionBody' is a call assertion body.
          (`assertions_props:c_assrt_body/1')

 - DECLARATION: success/1:
     This assertion is similar to a `pred/1' assertion but it only
     provides information about the answers to a predicate. The
     described answers might be conditioned to a particular way of
     calling the predicate.

     For example, the following assertion specifies the answers of
     the `length/2' predicate *if* it is called as in the first mode
     of usage above (note that the previous pred assertion already
     conveys such information, however it also compelled the
     predicate calls, while the success assertion does not):
          :- success length(L,N) : list * var => list * integer.

     *Usage:* :- `success(AssertionBody)'.
        - *The following properties should hold at call time:*

          `AssertionBody' is a predicate assertion body.
          (`assertions_props:s_assrt_body/1')

 - DECLARATION: success/2:
     This assertion is similar to a `success/1' assertion but it is
     explicitely qualified. Non-qualified `success/1' assertions are
     assumed the qualifier `check'.

     *Usage:* :- `success(AssertionStatus,AssertionBody)'.
        - *The following properties should hold at call time:*

          `AssertionStatus' is an acceptable status for an assertion.
          (`assertions_props:assrt_status/1')

          `AssertionBody' is a predicate assertion body.
          (`assertions_props:s_assrt_body/1')

 - DECLARATION: comp/1:
     This assertion is similar to a `pred/1' assertion but it only
     provides information about the global execution properties of a
     predicate (note that such kind of information is also conveyed
     by pred assertions). The described properties might be
     conditioned to a particular way of calling the predicate.

     For example, the following assertion specifies that the
     computation of `append/3' (see *Note List processing::) will not
     fail *if* it is called as described (but does not compel the
     predicate to be called that way):
          :- comp append(Xs,Ys,Zs) : var * var * var + not_fail.

     *Usage:* :- `comp(AssertionBody)'.
        - *The following properties should hold at call time:*

          `AssertionBody' is a comp assertion body.
          (`assertions_props:g_assrt_body/1')

 - DECLARATION: comp/2:
     This assertion is similar to a `comp/1' assertion but it is
     explicitely qualified. Non-qualified `comp/1' assertions are
     assumed the qualifier `check'.

     *Usage:* :- `comp(AssertionStatus,AssertionBody)'.
        - *The following properties should hold at call time:*

          `AssertionStatus' is an acceptable status for an assertion.
          (`assertions_props:assrt_status/1')

          `AssertionBody' is a comp assertion body.
          (`assertions_props:g_assrt_body/1')

 - DECLARATION: prop/1:
     This assertion is similar to a `pred/1' assertion but it flags
     that the predicate being documented is also a " property."

     Properties are standard predicates, but which are *guaranteed to
     terminate for any possible instantiation state of their
     argument(s)*, do not perform side-effects which may interfere
     with the program behaviour, and do not further instantiate their
     arguments or add new constraints.

     Provided the above holds, properties can thus be safely used as
     run-time checks. The program transformation used in `ciaopp' for
     run-time checking guarantees the third requirement. It also
     performs some basic checks on properties which in most cases are
     enough for the second requirement. However, it is the user's
     responsibility to guarantee termination of the properties
     defined. (See also *Note Declaring regular types:: for some
     considerations applicable to writing properties.)

     The set of properties is thus a strict subset of the set of
     predicates. Note that properties can be used to describe
     characteristics of arguments in assertions and they can also be
     executed (called) as any other predicates.

     *Usage:* :- `prop(AssertionBody)'.
        - *The following properties should hold at call time:*

          `AssertionBody' is an assertion body.
          (`assertions_props:assrt_body/1')

 - DECLARATION: prop/2:
     This assertion is similar to a `prop/1' assertion but it is
     explicitely qualified. Non-qualified `prop/1' assertions are
     assumed the qualifier `check'.

     *Usage:* :- `prop(AssertionStatus,AssertionBody)'.
        - *The following properties should hold at call time:*

          `AssertionStatus' is an acceptable status for an assertion.
          (`assertions_props:assrt_status/1')

          `AssertionBody' is an assertion body.
          (`assertions_props:assrt_body/1')

 - DECLARATION: entry/1:
     This assertion provides information about the *external* calls
     to a predicate. It is identical syntactically to a `calls/1'
     assertion. However, they describe only external calls, i.e.,
     calls to the exported predicates of a module from outside the
     module, or calls to the predicates in a non-modular file from
     other files (or the user).

     These assertions are *trusted* by the compiler. As a result, if
     their descriptions are erroneous they can introduce bugs in
     programs. Thus, `entry/1' assertions should be written with care.

     An important use of these assertions is in providing information
     to the compiler which it may not be able to infer from the
     program. The main use is in providing information on the ways in
     which exported predicates of a module will be called from
     outside the module. This will greatly improve the precision of
     the analyzer, which otherwise has to assume that the arguments
     that exported predicates receive are any arbitrary term.

     *Usage:* :- `entry(AssertionBody)'.
        - *The following properties should hold at call time:*

          `AssertionBody' is a call assertion body.
          (`assertions_props:c_assrt_body/1')

 - DECLARATION: modedef/1:
     This assertion is used to define modes. A mode defines in a
     compact way a set of call and success properties. Once defined,
     modes can be applied to predicate arguments in assertions. The
     meaning of this application is that the call and success
     properties defined by the mode hold for the argument to which
     the mode is applied. Thus, a mode is conceptually a "property
     macro".

     The syntax of mode definitions is similar to that of pred
     declarations. For example, the following set of assertions:

          :- modedef +A : nonvar(A) # "`A' is bound upon predicate entry.".
          
          :- pred p(+A,B) : integer(A) =>  ground(B).

     is equivalent to:

          :- pred p(A,B) : (nonvar(A),integer(A)) =>  ground(B)
             # "`A' is bound upon predicate entry.".

     *Usage:* :- `modedef(AssertionBody)'.
        - *The following properties should hold at call time:*

          `AssertionBody' is an assertion body.
          (`assertions_props:assrt_body/1')

 - DECLARATION: decl/1:
     This assertion is similar to a `pred/1' assertion but it is used
     for declarations instead than for predicates.

     *Usage:* :- `decl(AssertionBody)'.
        - *The following properties should hold at call time:*

          `AssertionBody' is an assertion body.
          (`assertions_props:assrt_body/1')

 - DECLARATION: decl/2:
     This assertion is similar to a `decl/1' assertion but it is
     explicitely qualified. Non-qualified `decl/1' assertions are
     assumed the qualifier `check'.

     *Usage:* :- `decl(AssertionStatus,AssertionBody)'.
        - *The following properties should hold at call time:*

          `AssertionStatus' is an acceptable status for an assertion.
          (`assertions_props:assrt_status/1')

          `AssertionBody' is an assertion body.
          (`assertions_props:assrt_body/1')

 - DECLARATION: comment/2:
     *Usage:* :- `comment(Pred,Comment)'.
        - *Description:* This assertion gives a text `Comment' for a
          given predicate `Pred'.

        - *The following properties should hold at call time:*

          `Pred' is a head pattern.
          (`assertions_props:head_pattern/1')

          `Comment' is a text comment with admissible documentation
          commands. The usual formatting commands that are applicable
          in comment strings are defined by `stringcommand/1'. See the
          `lpdoc' manual for documentation on comments.
          (`assertions_props:docstring/1')


File: ciao.info,  Node: Documentation on exports (assertions),  Prev: Documentation on new declarations (assertions),  Up: The Ciao assertion package

Documentation on exports (`assertions')
=======================================

 - PREDICATE: check/1:
     *Usage:* `check(PropertyConjunction)'
        - *Description:* This assertion provides information on a
          clause program point (position in the body of a clause).
          Calls to a `check/1' assertion can appear in the body of a
          clause in any place where a literal can normally appear.
          The property defined by `PropertyConjunction' should hold
          in all the run-time stores corresponding to that program
          point. See also *Note Run-time checking of assertions::.

        - *The following properties should hold at call time:*

          `PropertyConjunction' is either a term or a *conjunction*
          of terms. The main functor and arity of each of those terms
          corresponds to the definition of a property. The first
          argument of each such term is a variable which appears as a
          head argument.   (`assertions_props:property_conjunction/1')

 - PREDICATE: trust/1:
     *Usage:* `trust(PropertyConjunction)'
        - *Description:* This assertion also provides information on
          a clause program point. It is identical syntactically to a
          `check/1' assertion. However, the properties stated are not
          taken as something to be checked but are instead *trusted*
          by the compiler. While the compiler may in some cases
          detect an inconsistency between a `trust/1' assertion and
          the program, in all other cases the information given in
          the assertion will be taken to be true. As a result, if
          these assertions are erroneous they can introduce bugs in
          programs. Thus, `trust/1' assertions should be written with
          care.

          An important use of these assertions is in providing
          information to the compiler which it may not be able to
          infer from the program (either because the information is
          not present or because the analyzer being used is not
          precise enough). In particular, providing information on
          external predicates which may not be accessible at the time
          of compiling the module can greatly improve the precision
          of the analyzer. This can be easily done with trust
          assertion.

        - *The following properties should hold at call time:*

          `PropertyConjunction' is either a term or a *conjunction*
          of terms. The main functor and arity of each of those terms
          corresponds to the definition of a property. The first
          argument of each such term is a variable which appears as a
          head argument.   (`assertions_props:property_conjunction/1')

 - PREDICATE: true/1:
     *Usage:* `true(PropertyConjunction)'
        - *Description:* This assertion is identical syntactically to
          a `check/1' assertion. However, the properties stated have
          been proved to hold by the analyzer. Thus, these assertions
          often represent the analyzer output.

        - *The following properties should hold at call time:*

          `PropertyConjunction' is either a term or a *conjunction*
          of terms. The main functor and arity of each of those terms
          corresponds to the definition of a property. The first
          argument of each such term is a variable which appears as a
          head argument.   (`assertions_props:property_conjunction/1')

 - PREDICATE: false/1:
     *Usage:* `false(PropertyConjunction)'
        - *Description:* This assertion is identical syntactically to
          a `check/1' assertion. However, the properties stated have
          been proved not to hold by the analyzer. Thus, these
          assertions often represent the analyzer output.

        - *The following properties should hold at call time:*

          `PropertyConjunction' is either a term or a *conjunction*
          of terms. The main functor and arity of each of those terms
          corresponds to the definition of a property. The first
          argument of each such term is a variable which appears as a
          head argument.   (`assertions_props:property_conjunction/1')


File: ciao.info,  Node: Types and properties related to assertions,  Next: Declaring regular types,  Prev: The Ciao assertion package,  Up: Top

Types and properties related to assertions
******************************************

   *Author(s):* Manuel Hermenegildo.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 0.9#98 (1999/5/25, 17:1:28 MEST)

   This module is part of the `assertions' library. It defines types
and properties related to assertions.

* Menu:

* Usage and interface (assertions_props)::
* Documentation on exports (assertions_props)::


File: ciao.info,  Node: Usage and interface (assertions_props),  Next: Documentation on exports (assertions_props),  Prev: Types and properties related to assertions,  Up: Types and properties related to assertions

Usage and interface (`assertions_props')
========================================

   * *Library usage:*

     `:- use_module(library(assertions_props)).'

   * *Exports:*
        - *Properties:*

          `head_pattern/1', `docstring/1'.

        - *Regular Types:*

          `assrt_body/1', `complex_arg_property/1',
          `property_conjunction/1', `property_starterm/1',
          `complex_goal_property/1', `c_assrt_body/1',
          `s_assrt_body/1', `g_assrt_body/1', `assrt_status/1',
          `assrt_type/1', `predfunctor/1', `propfunctor/1'.

   * *Other modules used:*
        - *System library modules:*

          `dcg_expansion'.



File: ciao.info,  Node: Documentation on exports (assertions_props),  Prev: Usage and interface (assertions_props),  Up: Types and properties related to assertions

Documentation on exports (`assertions_props')
=============================================

 - REGTYPE: assrt_body/1:
     This predicate defines the different types of syntax admissible
     in the bodies of `pred/1', `func/1', etc. assertions. Such a
     body is of the form:

                Pr [:: DP] [: CP] [=> AP] [+ GP] [# CO]

     where (fields between [...] are optional):

        * `Pr' is a head pattern ( `head_pattern/1') which describes
          the predicate or property and possibly gives some implicit
          call/answer information.

        * `DP' is a (possibly empty) complex argument property (
          `complex_arg_property/1') which expresses properties which
          are compatible with the predicate, i.e., instantiations
          made by the predicate are *compatible* with the properties
          in the sense that applying the property at any point to
          would not make it fail.

        * `CP' is a (possibly empty) complex argument property (
          `complex_arg_property/1') which applies to the *calls* to
          the predicate.

        * `AP' is a (possibly empty) complex argument property (
          `complex_arg_property/1') which applies to the *answers* to
          the predicate (if the predicate succeeds). These only apply
          if the (possibly empty) properties given for calls in the
          assertion hold.

        * `GP' is a (possibly empty) complex goal property (
          `complex_goal_property/1') which applies to the *whole
          execution* of a call to the predicate. These only apply if
          the (possibly empty) properties given for calls in the
          assertion hold.

        * `CO' is a comment string ( `docstring/1'). This comment
          only applies if the (possibly empty) properties given for
          calls in the assertion hold. The usual formatting commands
          that are applicable in comment strings can be used (see
          `stringcommand/1').

          See the `lpdoc' manual for documentation on assertion
          comments.

     *Usage:* `assrt_body(X)'
        - *Description:* `X' is an assertion body.

        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - PROPERTY: head_pattern/1:
     A head pattern can be a predicate name (functor/arity) (
     `predname/1') or a term. Thus, both `p/3' and `p(A,B,C)' are
     valid head patterns. In the case in which the head pattern is a
     term, each argument of such a term can be:

        * A variable. This is useful in order to be able to refer to
          the corresponding argument positions by name within
          properties and in comments. Thus,
          `p(Input,Parameter,Output)' is a valid head pattern.

        * A ground term. In this case this term determines a property
          of the corresponding argument. The actual property referred
          to is that given by the term but with one more argument
          added at the beginning, which is a new variable which, in a
          rewriting of the head pattern, appears at the argument
          position occupied by the term. Unless otherwise stated (see
          below), the property built this way is understood to hold
          for both calls and answers. For example, the head pattern
          `p(Input,list(integer),Output)' is valid and equivalent for
          example to having the head pattern `p(Input,A,Output)' and
          stating that the property `list(A,integer)' holds for the
          calls and successes of the predicate.

        * Finally, it can also be a variable or a ground term, as
          above, but preceded by a " mode." This mode determines in a
          compact way certain call or answer properties. For example,
          the head pattern `p(Input,+list(integer),Output)' is valid,
          as long as `+/1' is declared as a mode.

          Acceptable modes are documented in `library(modes)'. User
          defined modes are documented in `modedef/1'.

     *Usage:* `head_pattern(Pr)'
        - *Description:* `Pr' is a head pattern.

 - REGTYPE: complex_arg_property/1:
     `complex_arg_property(Props)'

     `Props' is a (possibly empty) complex argument property. Such
     properties can appear in two formats, which are defined by
     `property_conjunction/1' and `property_starterm/1' respectively.
     The two formats can be mixed provided they are not in the same
     field of an assertion. I.e., the following is a valid assertion:

     `:- pred foo(X,Y) : nonvar * var => (ground(X),ground(Y)).'

     *Usage:* `complex_arg_property(Props)'
        - *Description:* `Props' is a (possibly empty) complex
          argument property

        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: property_conjunction/1:
     This type defines the first, unabridged format in which
     properties can be expressed in the bodies of assertions. It is
     essentially a conjunction of properties which refer to
     variables. The following is an example of a complex property in
     this format:

        * `(integer(X),list(Y,integer))': `X' has the property
          `integer/1' and `Y' has the property `list/2', with second
          argument `integer'.

     *Usage:* `property_conjunction(Props)'
        - *Description:* `Props' is either a term or a *conjunction*
          of terms. The main functor and arity of each of those terms
          corresponds to the definition of a property. The first
          argument of each such term is a variable which appears as a
          head argument.

        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: property_starterm/1:
     This type defines a second, compact format in which properties
     can be expressed in the bodies of assertions. A
     `property_starterm/1' is a term whose main functor is `*/2' and,
     when it appears in an assertion, the number of terms joined by
     `*/2' is exactly the arity of the predicate it refers to. A
     similar series of properties as in `property_conjunction/1'
     appears, but the arity of each property is one less: the
     argument position to which they refer (first argument) is left
     out and determined by the position of the property in the
     `property_starterm/1'. The idea is that each element of the
     `*/2' term corresponds to a head argument position. Several
     properties can be assigned to each argument position by grouping
     them in curly brackets. The following is an example of a complex
     property in this format:

        * ` integer * list(integer)': the first argument of the
          procedure (or function, or ...) has the property
          `integer/1' and the second one has the property `list/2',
          with second argument `integer'.

        * ` {integer,var} * list(integer)': the first argument of the
          procedure (or function, or ...) has the properties
          `integer/1' and `var/1' and the second one has the property
          `list/2', with second argument `integer'.

     *Usage:* `property_starterm(Props)'
        - *Description:* `Props' is either a term or several terms
          separated by `*/2'. The main functor of each of those terms
          corresponds to that of the definition of a property, and
          the arity should be one less than in the definition of such
          property. All arguments of each such term are ground.

        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: complex_goal_property/1:
     `complex_goal_property(Props)'

     `Props' is a (possibly empty) complex goal property. Such
     properties can be either a term or a *conjunction* of terms. The
     main functor and arity of each of those terms corresponds to the
     definition of a property. Such properties apply to all
     executions of all goals of the predicate which comply with the
     assertion in which the `Props' appear.

     The arguments of the terms in `Props' are implicitely augmented
     with a first argument which corresponds to a goal of the
     predicate of the assertion in which the `Props' appear. For
     example, the assertion
               :- comp var(A) + not_further_inst(A).
     has property `not_further_inst/1' as goal property, and
     establishes that in all executions of `var(A)' it should hold
     that `not_further_inst(var(A),A)'.

     *Usage:* `complex_goal_property(Props)'
        - *Description:* `Props' is either a term or a *conjunction*
          of terms. The main functor and arity of each of those terms
          corresponds to the definition of a property. A first
          implicit argument in such terms identifies goals to which
          the properties apply.

        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: c_assrt_body/1:
     This predicate defines the different types of syntax admissible
     in the bodies of `call/1', `entry/1', etc. assertions. The
     following are admissible:

                Pr : CP [# CO]

     where (fields between [...] are optional):

        * `CP' is a (possibly empty) complex argument property (
          `complex_arg_property/1') which applies to the *calls* to
          the predicate.

        * `CO' is a comment string ( `docstring/1'). This comment
          only applies if the (possibly empty) properties given for
          calls in the assertion hold. The usual formatting commands
          that are applicable in comment strings can be used (see
          `stringcommand/1').

     The format of the different parts of the assertion body are
     given by `n_assrt_body/5' and its auxiliary types.

     *Usage:* `c_assrt_body(X)'
        - *Description:* `X' is a call assertion body.

        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: s_assrt_body/1:
     This predicate defines the different types of syntax admissible
     in the bodies of `pred/1', `func/1', etc. assertions. The
     following are admissible:

                Pr : CP => AP # CO
                Pr : CP => AP
                Pr => AP # CO
                Pr => AP

     where:

        * `Pr' is a head pattern ( `head_pattern/1') which describes
          the predicate or property and possibly gives some implicit
          call/answer information.

        * `CP' is a (possibly empty) complex argument property (
          `complex_arg_property/1') which applies to the *calls* to
          the predicate.

        * `AP' is a (possibly empty) complex argument property (
          `complex_arg_property/1') which applies to the *answers* to
          the predicate (if the predicate succeeds). These only apply
          if the (possibly empty) properties given for calls in the
          assertion hold.

        * `CO' is a comment string ( `docstring/1'). This comment
          only applies if the (possibly empty) properties given for
          calls in the assertion hold. The usual formatting commands
          that are applicable in comment strings can be used (see
          `stringcommand/1').

     The format of the different parts of the assertion body are
     given by `n_assrt_body/5' and its auxiliary types.

     *Usage:* `s_assrt_body(X)'
        - *Description:* `X' is a predicate assertion body.

        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: g_assrt_body/1:
     This predicate defines the different types of syntax admissible
     in the bodies of `comp/1' assertions. The following are
     admissible:

                Pr : CP + GP # CO
                Pr : CP + GP
                Pr + GP # CO
                Pr + GP

     where:

        * `Pr' is a head pattern ( `head_pattern/1') which describes
          the predicate or property and possibly gives some implicit
          call/answer information.

        * `CP' is a (possibly empty) complex argument property (
          `complex_arg_property/1') which applies to the *calls* to
          the predicate.

        * `GP' contains (possibly empty) complex goal property (
          `complex_goal_property/1') which applies to the *whole
          execution* of a call to the predicate. These only apply if
          the (possibly empty) properties given for calls in the
          assertion hold.

        * `CO' is a comment string ( `docstring/1'). This comment
          only applies if the (possibly empty) properties given for
          calls in the assertion hold. The usual formatting commands
          that are applicable in comment strings can be used (see
          `stringcommand/1').

     The format of the different parts of the assertion body are
     given by `n_assrt_body/5' and its auxiliary types.

     *Usage:* `g_assrt_body(X)'
        - *Description:* `X' is a comp assertion body.

        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: assrt_status/1:
     The types of assertion status. They have the same meaning as the
     program-point assertions, and are as follows:
          assrt_status(true).
          assrt_status(false).
          assrt_status(check).
          assrt_status(checked).
          assrt_status(trust).

     *Usage:* `assrt_status(X)'
        - *Description:* `X' is an acceptable status for an assertion.

        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: assrt_type/1:
     The admissible kinds of assertions:
          assrt_type(pred).
          assrt_type(prop).
          assrt_type(decl).
          assrt_type(func).
          assrt_type(calls).
          assrt_type(success).
          assrt_type(comp).
          assrt_type(entry).
          assrt_type(modedef).

     *Usage:* `assrt_type(X)'
        - *Description:* `X' is an admissible kind of assertion.

        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: predfunctor/1:
     *Usage:* `predfunctor(X)'
        - *Description:* `X' is a type of assertion which defines a
          predicate.

        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: propfunctor/1:
     *Usage:* `propfunctor(X)'
        - *Description:* `X' is a type of assertion which defines a
          *property*.

        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - PROPERTY: docstring/1:
     *Usage:* `docstring(String)'
        - *Description:* `String' is a text comment with admissible
          documentation commands. The usual formatting commands that
          are applicable in comment strings are defined by
          `stringcommand/1'. See the `lpdoc' manual for documentation
          on comments.


File: ciao.info,  Node: Declaring regular types,  Next: Properties which are native to analyzers,  Prev: Types and properties related to assertions,  Up: Top

Declaring regular types
***********************

   *Author(s):* Manuel Hermenegildo, Pedro Lopez, Francisco Bueno.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   This library package adds some new declaration definitions and new
operator definitions to user programs. These new declarations and
operators provide some very simple syntactic sugar to support regular
type definitions in source code. Regular types are just properties
which have the additional characteristic of being regular types (
`basic_props:regtype/1').

   For example, this library package allows writing:
        :- regtype tree(X) # "`X' is a tree.".
   instead of the more combersome:
        :- prop tree(X) + regtype # "`X' is a tree.".

   Regular types can be used as properties to describe predicates and
play an essential role in program debugging (see the Ciao Prolog
preprocessor (`ciaopp') manual).

   In this chapter we explain some general considerations worth
taking into account when writing properties in general, not just
regular types. The exact syntax of regular types is also described.

* Menu:

* Defining properties::
* Usage and interface (regtypes)::
* Documentation on new declarations (regtypes)::


File: ciao.info,  Node: Defining properties,  Next: Usage and interface (regtypes),  Prev: Declaring regular types,  Up: Declaring regular types

Defining properties
===================

   Given the classes of assertions in the Ciao assertion language,
there are two fundamental classes of properties. Properties used in
assertions which refer to execution states (i.e., `calls/1',
`success/1', and the like) are called *properties of execution
states*. Properties used in assertions related to computations (i.e.,
`comp/1') are called *properties of computations*. Different
considerations apply when writing a property of the former or of the
later kind.

   Consider a definition of the predicate `string_concat/3' which
concatenates two character strings (represented as lists of ASCII
codes):
     string_concat([],L,L).
     string_concat([X|Xs],L,[X|NL]):- string_concat(Xs,L,NL).

   Assume that we would like to state in an assertion that each
argument "is a list of integers." However, we must decide which one
of the following two possibilities we mean exactly: "the argument is
*instantiated* to a list of integers" (let us call this property
`instantiated_to_intlist/1'), or "if any part of the argument is
instantiated, this instantiation must be compatible with the argument
being a list of integers" (we will call this property
`compatible_with_intlist/1'). For example,
`instantiated_to_intlist/1' should be true for the terms `[]' and
`[1,2]', but should not for `X', `[a,2]', and `[X,2]'. In turn,
`compatible_with_intlist/1' should be true for `[]', `X', `[1,2]',
and `[X,2]', but should not be for `[X|1]', `[a,2]', and `1'. We
refer to properties such as `instantiated_to_intlist/1' above as
*instantiation properties* and to those such as
`compatible_with_intlist/1' as *compatibility properties*
(corresponding to the traditional notions of "instantiation types"
and "compatibility types").

   It turns out that both of these notions are quite useful in
practice. In the example above, we probably would like to use
`compatible_with_intlist/1' to state that on success of
`string_concat/3' all three argument must be compatible with lists of
integers in an assertion like:

     :- success string_concat(A,B,C) => ( compatible_with_intlist(A),
                                          compatible_with_intlist(B),
                                          compatible_with_intlist(C) ).

   With this assertion, no error will be flagged for a call to
`string_concat/3' such as `string_concat([20],L,R)', which on success
produces the resulting atom `string_concat([20],L,[20|L])', but a
call `string_concat([],a,R)' would indeed flag an error.

   On the other hand, and assuming that we are running on a Prolog
system, we would probably like to use `instantiated_to_intlist/1' for
`sumlist/2' as follows:

     :- calls sumlist(L,N) : instantiated_to_intlist(L).
     
     sumlist([],0).
     sumlist([X|R],S) :- sumlist(R,PS), S is PS+X.

to describe the type of calls for which the program has been
designed, i.e., those in which the first argument of `sumlist/2' is
indeed a list of integers.

   The property `instantiated_to_intlist/1' might be written as in
the following (Prolog) definition:

     :- prop instantiated_to_intlist/1.
     
     instantiated_to_intlist(X) :-
            nonvar(X), instantiated_to_intlist_aux(X).
     
     instantiated_to_intlist_aux([]).
     instantiated_to_intlist_aux([X|T]) :-
            integer(X), instantiated_to_intlist(T).

   (Recall that the Prolog builtin `integer/1' itself implements an
instantiation check, failing if called with a variable as the
argument.)

   The property `compatible_with_intlist/1' might in turn be written
as follows (also in Prolog):

     :- prop compatible_with_intlist/1.
     
     compatible_with_intlist(X) :- var(X).
     compatible_with_intlist(X) :-
            nonvar(X), compatible_with_intlist_aux(X).
     
     compatible_with_intlist_aux([]).
     compatible_with_intlist_aux([X|T]) :-
            int_compat(X), compatible_with_intlist(T).
     
     int_compat(X) :- var(X).
     int_compat(X) :- nonvar(X), integer(X).

   Note that these predicates meet the criteria for being properties
and thus the `prop/1' declaration is correct.

   Ensuring that a property meets the criteria for "not affecting the
computation" can sometimes make its coding somewhat tedious. In some
ways, one would like to be able to write simply:

     intlist([]).
     intlist([X|R]) :- int(X), intlist(R).

(Incidentally, note that the above definition, provided that it suits
the requirements for being a property and that `int/1' is a regular
type, meets the criteria for being a regular type. Thus, it could be
declared `:- regtype intlist/1'.)

   But note that (independently of the definition of `int/1') the
definition above is not the correct instantiation check, since it
would succeed for a call such as `intlist(X)'. In fact, it is not
strictly correct as a compatibility property either, because, while
it would fail or succeed as expected, it would perform instantiations
(e.g., if called with `intlist(X)' it would bind `X' to `[]'). In
practice, it is convenient to provide some run-time support to aid in
this task.

   The run-time support of the Ciao system (see *Note Run-time
checking of assertions::) ensures that the execution of properties is
performed in such a way that properties written as above can be used
directly as instantiation checks. Thus, writing:

     :- calls sumlist(L,N) : intlist(L).

has the desired effect. Also, the same properties can often be used
as compatibility checks by writing them in the assertions as
`compat(Property)' (`basic_props:compat/1'). Thus, writing:

     :- success string_concat(A,B,C) => ( compat(intlist(A)),
                                          compat(intlist(B)),
                                          compat(intlist(C)) ).

also has the desired effect.

   As a general rule, the properties that can be used directly for
checking for compatibility should be *downwards closed*, i.e., once
they hold they will keep on holding in every state accessible in
forwards execution. There are certain predicates which are inherently
*instantiation* checks and should not be used as *compatibility*
properties nor appear in the definition of a property that is to be
used with `compat'. Examples of such predicates (for Prolog) are
`==', `ground', `nonvar', `integer', `atom', `>', etc. as they
require a certain instantiation degree of their arguments in order to
succeed.

   In contrast with properties of execution states, *properties of
computations* refer to the entire execution of the call(s) that the
assertion relates to. One such property is, for example, `not_fail/1'
(note that although it has been used as in `:- comp append(Xs,Ys,Zs)
+ not_fail', it is in fact read as `not_fail(append(Xs,Ys,Zs))'; see
`assertions_props:complex_goal_property/1'). For this property, which
should be interpreted as "execution of the predicate either succeeds
at least once or loops," we can use the following predicate
`not_fail/1' for run-time checking:

     not_fail(Goal):-
           if( call(Goal),
               true,            %% then
               warning(Goal) ). %% else

where the `warning/1' (library) predicate simply prints a warning
message.

   In this simple case, implementation of the predicate is not very
difficult using the (non-standard) `if/3' builtin predicate present
in many Prolog systems.

   However, it is not so easy to code predicates which check other
properties of the computation and we may in general need to program a
meta-interpreter for this purpose.


File: ciao.info,  Node: Usage and interface (regtypes),  Next: Documentation on new declarations (regtypes),  Prev: Defining properties,  Up: Declaring regular types

Usage and interface (`regtypes')
================================

   * *Library usage:*

     `:- use_package(regtypes).'

     or

     `:- module(...,...,[regtypes]).'

   * *New operators defined:*

     `regtype/1' [1150,fx], `regtype/2' [1150,xfx].

   * *New declarations defined:*

     `regtype/1', `regtype/2'.

   * *Other modules used:*
        - *System library modules:*

          `assertions/assertions_props'.



File: ciao.info,  Node: Documentation on new declarations (regtypes),  Prev: Usage and interface (regtypes),  Up: Declaring regular types

Documentation on new declarations (`regtypes')
==============================================

 - DECLARATION: regtype/1:
     This assertion is similar to a pred assertion but it flags that
     the predicate being documented is also a " regular type." This
     allows for example checking whether it is in the class of types
     supported by the type checking and inference modules. Currently,
     types are properties whose definitions are *regular programs*.

     A regular program is defined by a set of clauses, each of the
     form:
          p(x, v_1, ..., v_n)  :- body_1, ..., body_k.
     where:
       1. `x' is a term whose variables (which are called *term
          variables*) are unique, i.e., it is not allowed to
          introduce equality constraints between the variables of `x'.

          For example, `p(f(X, Y)) :- ...' is valid, but `p(f(X, X))
          :- ...' is not.

       2. in all clauses defining `p/n+1' the terms `x' do not unify
          except maybe for one single clause in which `x' is a
          variable.

       3. `n' >= 0 and `p/n' is a *parametric type functor* (whereas
          the predicate defined by the clauses is `p/n'+1).

       4. `v_1', ..., `v_n' are unique variables, which are called
          *parametric variables*.

       5. Each `body_i' is of the form:

            1. `t(z)' where `z' is one of the *term variables* and
               `t' is a *regular type expression*;

            2. `q(y, t_1, ..., t_m)' where `m' >= 0, `q/m' is a
               *parametric type functor*, not in the set of functors
               `=/2', `^/2', `./3'.

               `t_1, ..., t_m' are *regular type expressions*, and
               `y' is a *term variable*.

       6. Each term variable occurs at most once in the clause's body
          (and should be as the first argument of a literal).
          A *regular type expression* is either a parametric variable
     or a parametric type functor applied to some of the parametric
     variables (but regular type abstractions might also be used in
     some cases, see *Note Meta-properties::).

     A parametric type functor is a regular type, defined by a
     regular program, or a basic type. Basic types are defined in
     *Note Basic data types and properties::.

     The set of types is thus a well defined subset of the set of
     properties. Note that types can be used to describe
     characteristics of arguments in assertions and they can also be
     executed (called) as any other predicates.

     *Usage:* :- `regtype(AssertionBody)'.
        - *The following properties should hold at call time:*

          `AssertionBody' is an assertion body.
          (`assertions_props:assrt_body/1')

 - DECLARATION: regtype/2:
     This assertion is similar to a `regtype/1' assertion but it is
     explicitely qualified. Non-qualified `regtype/1' assertions are
     assumed the qualifier `check'. Note that checking regular type
     definitions should be done with the `ciaopp' preprocessor.

     *Usage:* :- `regtype(AssertionStatus,AssertionBody)'.
        - *The following properties should hold at call time:*

          `AssertionStatus' is an acceptable status for an assertion.
          (`assertions_props:assrt_status/1')

          `AssertionBody' is an assertion body.
          (`assertions_props:assrt_body/1')


File: ciao.info,  Node: Properties which are native to analyzers,  Next: Meta-properties,  Prev: Declaring regular types,  Up: Top

Properties which are native to analyzers
****************************************

   *Author(s):* Francisco Bueno, Manuel Hermenegildo, Pedro Lopez.

   This library contains a set of properties which are natively
understood by the different program analyzers of `ciaopp'. They are
used by `ciaopp' on output and they can also be used as properties in
assertions.

* Menu:

* Usage and interface (native_props)::
* Documentation on exports (native_props)::


File: ciao.info,  Node: Usage and interface (native_props),  Next: Documentation on exports (native_props),  Prev: Properties which are native to analyzers,  Up: Properties which are native to analyzers

Usage and interface (`native_props')
====================================

   * *Library usage:*

     `:- use_module(library('assertions/native_props'))'

     or also as a package `:- use_package(nativeprops)'.

     Note the different names of the library and the package.

   * *Exports:*
        - *Properties:*

          `linear/1', `mshare/1', `fails/1', `not_fail/1',
          `possible_fail/1', `covered/1', `not_covered/1', `is_det/1',
          `possible_nondet/1', `disjoint/1', `not_disjoint/1',
          `lower_size/2', `upper_size/2', `lower_time/2',
          `upper_time/2', `pure/1', `soft/1', `hard/1'.

   * *Other modules used:*
        - *System library modules:*

          `andprolog/andprolog'.



File: ciao.info,  Node: Documentation on exports (native_props),  Prev: Usage and interface (native_props),  Up: Properties which are native to analyzers

Documentation on exports (`native_props')
=========================================

 - PROPERTY: linear/1:
     `linear(X)'

     `X' is bound to a term which is linear, i.e., if it contains any
     variables, such variables appear only once in the term. For
     example, `[1,2,3]' and `f(A,B)' are linear terms, while `f(A,A)'
     is not.

     *Usage:* `linear(X)'
        - *Description:* `X' is instantiated to a linear term.

 - PROPERTY: mshare/1:
     `mshare(X)'

     `X' contains all *sharing sets* [JL88,MH89] which specify the
     possible variable occurrences in the terms to which the
     variables involved in the clause may be bound. Sharing sets are
     a compact way of representing groundness of variables and
     dependencies between variables. This representation is however
     generally difficult to read for humans. For this reason, this
     information is often translated to `ground/1', `indep/1' and
     `indep/2' properties, which are easier to read.

     *Usage:* `mshare(X)'
        - *Description:* The sharing pattern is ``X''.

 - PROPERTY: fails/1:
     `fails(X)'

     Calls of the form `X' fail.

     *Usage:* `fails(X)'
        - *Description:* Calls of the form `X' fail.

 - PROPERTY: not_fail/1:
     `not_fail(X)'

     Calls of the form `X' produce at least one solution, or not
     terminate [DLH97].

     *Usage:* `not_fail(X)'
        - *Description:* All the calls of the form `X' do not fail.

 - PROPERTY: possible_fail/1:
     `possible_fail(X)'

     Non-failure is not ensured for any call of the form `X' [DLH97].
     In other words, nothing can be ensured about non-failure nor
     termination of such calls.

     *Usage:* `possible_fail(X)'
        - *Description:* Non-failure is not ensured for calls of the
          form `X'.

 - PROPERTY: covered/1:
     `covered(X)'

     For any call of the form `X' there is at least one clause whose
     test succeeds (i.e. all the calls of the form `X' are covered.)
     [DLH97].

     *Usage:* `covered(X)'
        - *Description:* All the calls of the form `X' are covered.

 - PROPERTY: not_covered/1:
     `not_covered(X)'

     There is some call of the form `X' for which there is not any
     clause whose test succeeds [DLH97].

     *Usage:* `not_covered(X)'
        - *Description:* Not all of the calls of the form `X' are
          covered.

 - PROPERTY: is_det/1:
     `is_det(X)'

     All calls of the form `X' are deterministic, i.e. produce at
     most one solution, or not terminate.

     *Usage:* `is_det(X)'
        - *Description:* All calls of the form `X' are deterministic.

 - PROPERTY: possible_nondet/1:
     `possible_nondet(X)'

     Non-determinism is not ensured for all calls of the form `X'. In
     other words, nothing can be ensured about determinacy nor
     termination of such calls.

     *Usage:* `possible_nondet(X)'
        - *Description:* Non-determinism is not ensured for calls of
          the form `X'.

 - PROPERTY: disjoint/1:
     `disjoint(X)'

     For any call of the form `X' at most one clause succeeds, i.e.
     clauses are pairwise exclusive.

     *Usage:* `disjoint(X)'
        - *Description:* For any call of the form `X' at most one
          clause succeeds.

 - PROPERTY: not_disjoint/1:
     `not_disjoint(X)'

     Not for all calls of the form `X' at most one clause succeeds.
     I.e. clauses are not disjoint for some call.

     *Usage:* `not_disjoint(X)'
        - *Description:* Not for all calls of the form `X' at most
          one clause succeeds.

 - PROPERTY: lower_size/2:
     `lower_size(X,Y)'

     The minimum size of the terms to which the argument `Y' is bound
     to is given by the expression `Y'. Various measures can be used
     to determine the size of an argument, e.g., list-length,
     term-size, term-depth, integer-value, etc. [DL93].

     *Usage:* `lower_size(X,Y)'
        - *Description:* `Y' is a lower bound on the size of argument
          `X'.

 - PROPERTY: upper_size/2:
     `upper_size(X,Y)'

     The maximum size of the terms to which the argument `Y' is bound
     to is given by the expression `Y'. Various measures can be used
     to determine the size of an argument, e.g., list-length,
     term-size, term-depth, integer-value, etc. [DL93].

     *Usage:* `upper_size(X,Y)'
        - *Description:* `Y' is a upper bound on the size of argument
          `X'.

 - PROPERTY: lower_time/2:
     `lower_time(X,Y)'

     The minimum computation time (in resolution steps) spent by any
     call of the form `X' is given by the expression `Y'
     [DLHL97,GHD96]

     *Usage:* `lower_time(X,Y)'
        - *Description:* `Y' is a lower bound on the cost of any call
          of the form `X'.

 - PROPERTY: upper_time/2:
     `upper_time(X,Y)'

     The maximum computation time (in resolution steps) spent by any
     call of the form `X' is given by the expression `Y' [DL93,GHD96]

     *Usage:* `upper_time(X,Y)'
        - *Description:* `Y' is a upper bound on the cost of any call
          of the form `X'.

 - PROPERTY: pure/1:
     *Usage:* `pure(X)'
        - *Description:* `X' is pure, i.e., has no side-effects.

 - PROPERTY: soft/1:
     *Usage:* `soft(X)'
        - *Description:* `X' has *soft side-effects*, i.e., those not
          affecting program execution (e.g., input/output).

 - PROPERTY: hard/1:
     *Usage:* `hard(X)'
        - *Description:* `X' has *hard side-effects*, i.e., those
          that might affect program execution (e.g., assert/retract).

 - PROPERTY: indep/1:
     *Usage:* `indep(X)'
        - *Description:* The variables in pairs in ``X'' are pairwise
          independent.

 - PROPERTY: indep/2:
     *Usage:* `indep(X,Y)'
        - *Description:* `X' and `Y' do not have variables in common.


File: ciao.info,  Node: Meta-properties,  Next: ISO-Prolog modes,  Prev: Properties which are native to analyzers,  Up: Top

Meta-properties
***************

   *Author(s):* Francisco Bueno.

   This library allows the use of some meta-constructs which provide
for specifying properties of terms which are unknown at the time of
the specification, or expressed with a shorthand for the property
definition, i.e., without really defining it.

   An example of such use is an assertion which specifies that any
property holding upon call will also hold upon exit:
              :- pred p(X) : Prop(X) => Prop(X).

   Another example is using shorthands for properties when
documenting:
              :- pred p(X) : regtype(X,(^(list;list);list)).

   (See below for an explanation of such a regular type.)

* Menu:

* Usage and interface (meta_props)::
* Documentation on exports (meta_props)::
* Documentation on multifiles (meta_props)::
* Documentation on internals (meta_props)::
* Known bugs and planned improvements (meta_props)::


File: ciao.info,  Node: Usage and interface (meta_props),  Next: Documentation on exports (meta_props),  Prev: Meta-properties,  Up: Meta-properties

Usage and interface (`meta_props')
==================================

   * *Library usage:*

     `:- use_module(library('assertions/meta_props'))'

     or also as a package `:- use_package(metaprops)'.

     Note the different names of the library and the package.

   * *Exports:*
        - *Properties:*

          `call/2', `prop/2', `regtype/2'.

        - *Multifiles:*

          `callme/2'.



File: ciao.info,  Node: Documentation on exports (meta_props),  Next: Documentation on multifiles (meta_props),  Prev: Usage and interface (meta_props),  Up: Meta-properties

Documentation on exports (`meta_props')
=======================================

 - PROPERTY: call/2:
     `call(P,A)'

     `A' has property `P' (provided that `P' is a property).
     Equivalent to `P(A)'.

     The predicate is of type *implicit*.

     *Usage:* `call(P,A)'
        - *Description:* `A' has property `P'.

        - *If the following properties hold at call time:*

          `P' is a term which represents a goal, i.e., an atom or a
          structure.   (`basic_props:callable/1')

 - PROPERTY: prop/2:
     *Usage:* `prop(A,P)'
        - *Description:* `A' has property `P'.

        - *If the following properties hold at call time:*

          `P' has property `^ (callable;prop_abs)'.
          (`meta_props:prop/2')

 - PROPERTY: regtype/2:
     *Usage:* `regtype(A,T)'
        - *Description:* `A' is of type `T'.

        - *If the following properties hold at call time:*

          `T' has property `^ (regtype;prop_abs)'.
          (`meta_props:prop/2')


File: ciao.info,  Node: Documentation on multifiles (meta_props),  Next: Documentation on internals (meta_props),  Prev: Documentation on exports (meta_props),  Up: Meta-properties

Documentation on multifiles (`meta_props')
==========================================

 - PREDICATE: callme/2:
     (User defined.) A hook predicate you have to define as
     `callme(P,X):- P(X), !.' in the program that uses this library.
     This is done automatically if the package is used instead of the
     library module (but then you *should not* define `callme/2' in
     your program).

     The predicate is *multifile*.



File: ciao.info,  Node: Documentation on internals (meta_props),  Next: Known bugs and planned improvements (meta_props),  Prev: Documentation on multifiles (meta_props),  Up: Meta-properties

Documentation on internals (`meta_props')
=========================================

 - PROPERTY: prop_abs/1:
     `prop_abs(Prop)'

     `Prop' is a *property abstraction*, i.e., a *parametric
     property*, or a term formed of property abstractions, where the
     functors used in the term are escaped by `^'.

     One particular case of property abstractions are *parametric
     regular type abstractions*, i.e., a parametric type functor or a
     `^'-escaped term formed of regular type abstractions.

     Such abstractions are a short-hand for a corresponding regular
     type (correspondingly, property). For example, the following
     abstraction:
                   ^(list;list);list
     denotes terms of the form `(X;Y)' where `list(X)' and `list(Y)'
     hold and also terms `T' such that `list(T)' holds. It is
     equivalent to the regular type:
                   abstract_type((X;Y)):- list(X), list(Y).
                   abstract_type(T):- list(T).

     The predicate is of type *implicit*.

     *Usage:* `prop_abs(Prop)'
        - *Description:* `Prop' is a property abstraction.


File: ciao.info,  Node: Known bugs and planned improvements (meta_props),  Prev: Documentation on internals (meta_props),  Up: Meta-properties

Known bugs and planned improvements (`meta_props')
==================================================

   * Using a hook predicate is not very elegant. Need something else.

   * The cut in the hook prevents backtracking (enough for most uses
     of properties but not quite ok).


File: ciao.info,  Node: ISO-Prolog modes,  Next: Classical Prolog modes,  Prev: Meta-properties,  Up: Top

ISO-Prolog modes
****************

   *Author(s):* Daniel Cabeza, Manuel Hermenegildo.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 1.3#112 (1999/11/23, 1:8:50 MET)

   This file defines the " modes" used in the documentation of the
ISO-Prolog standard. See also *Note Classical Prolog modes:: for an
alternative set of modes.

* Menu:

* Usage and interface (isomodes)::
* Documentation on new modes (isomodes)::


File: ciao.info,  Node: Usage and interface (isomodes),  Next: Documentation on new modes (isomodes),  Prev: ISO-Prolog modes,  Up: ISO-Prolog modes

Usage and interface (`isomodes')
================================

   * *Library usage:*

     `:- use_package([assertions,isomodes]).'

   * *New operators defined:*

     `?/1' [200,fy], `@/1' [200,fy].

   * *New modes defined:*

     `+/1', `@/1', `-/1', `?/1', `*/1', `+/2', `@/2', `-/2', `?/2',
     `*/2'.

   * *Other modules used:*
        - *System library modules:*

          `assertions/meta_props'.



File: ciao.info,  Node: Documentation on new modes (isomodes),  Prev: Usage and interface (isomodes),  Up: ISO-Prolog modes

Documentation on new modes (`isomodes')
=======================================

 - MODE: +/1:
     *Usage:* `+ A'
        - *The following properties are added at call time:*

          `A' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')

 - MODE: @/1:
     *Usage:* `@(A)'
        - *The following properties are added globally:*

          `A' is not further instantiated.
          (`basic_props:not_further_inst/2')

 - MODE: -/1:
     *Usage:* `- A'
        - *The following properties are added at call time:*

          `A' is a free variable.   (`term_typing:var/1')

 - MODE: ?/1:
     Unspecified argument.


 - MODE: */1:
     Unspecified argument.


 - MODE: +/2:
     *Usage:* `A + X'
        - *The following properties are added at call time:*

          `A' has property `X'.   (`meta_props:call/2')

 - MODE: @/2:
     *Usage:* `@(A,X)'
        - *The following properties are added at call time:*

          `A' has property `X'.   (`meta_props:call/2')

        - *The following properties are added upon exit:*

          `A' has property `X'.   (`meta_props:call/2')

        - *The following properties are added globally:*

          `A' is not further instantiated.
          (`basic_props:not_further_inst/2')

 - MODE: -/2:
     *Usage:* `A - X'
        - *The following properties are added at call time:*

          `A' is a free variable.   (`term_typing:var/1')

        - *The following properties are added upon exit:*

          `A' has property `X'.   (`meta_props:call/2')

 - MODE: ?/2:
     *Usage:* `?(A,X)'
        - *Call and exit are *compatible* with:*

          `A' has property `X'.   (`meta_props:call/2')

        - *The following properties are added upon exit:*

          `A' has property `X'.   (`meta_props:call/2')

 - MODE: */2:
     *Usage:* `A * X'
        - *Call and exit are *compatible* with:*

          `A' has property `X'.   (`meta_props:call/2')


File: ciao.info,  Node: Classical Prolog modes,  Next: Run-time checking of assertions,  Prev: ISO-Prolog modes,  Up: Top

Classical Prolog modes
**********************

   *Author(s):* Manuel Hermenegildo.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 0.8#43 (1999/3/6, 18:39:38 CET)

   This file defines a number of very simple " modes" which are
frequently useful in programs. These correspond to the modes used in
classical Prolog texts with some simple addtions. Note that some of
these modes use the same symbol as one of the ISO-modes (see *Note
ISO-Prolog modes::) but with subtly different meaning.

* Menu:

* Usage and interface (basicmodes)::
* Documentation on new modes (basicmodes)::


File: ciao.info,  Node: Usage and interface (basicmodes),  Next: Documentation on new modes (basicmodes),  Prev: Classical Prolog modes,  Up: Classical Prolog modes

Usage and interface (`basicmodes')
==================================

   * *Library usage:*

     :- use_package([assertions,basicmodes]).

   * *New operators defined:*

     `?/1' [500,fx], `@/1' [500,fx].

   * *New modes defined:*

     `+/1', `-/1', `?/1', `@/1', `in/1', `out/1', `go/1', `+/2',
     `-/2', `?/2', `@/2', `in/2', `out/2', `go/2'.

   * *Other modules used:*
        - *System library modules:*

          `assertions/meta_props'.



File: ciao.info,  Node: Documentation on new modes (basicmodes),  Prev: Usage and interface (basicmodes),  Up: Classical Prolog modes

Documentation on new modes (`basicmodes')
=========================================

 - MODE: +/1:
     Input value in argument.

     *Usage:* `+ A'
        - *The following properties are added at call time:*

          `A' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')

 - MODE: -/1:
     No input value in argument.

     *Usage:* `- A'
        - *The following properties are added at call time:*

          `A' is a free variable.   (`term_typing:var/1')

 - MODE: ?/1:
     Unspecified argument.


 - MODE: @/1:
     No output value in argument.

     *Usage:* `@(A)'
        - *The following properties are added globally:*

          `A' is not further instantiated.
          (`basic_props:not_further_inst/2')

 - MODE: in/1:
     Input argument.

     *Usage:* `in(A)'
        - *The following properties are added at call time:*

          `A' is currently ground (it contains no variables).
          (`term_typing:ground/1')

        - *The following properties are added upon exit:*

          `A' is currently ground (it contains no variables).
          (`term_typing:ground/1')

 - MODE: out/1:
     Output argument.

     *Usage:* `out(A)'
        - *The following properties are added at call time:*

          `A' is a free variable.   (`term_typing:var/1')

        - *The following properties are added upon exit:*

          `A' is currently ground (it contains no variables).
          (`term_typing:ground/1')

 - MODE: go/1:
     Ground output (input/output argument).

     *Usage:* `go(A)'
        - *The following properties are added upon exit:*

          `A' is currently ground (it contains no variables).
          (`term_typing:ground/1')

 - MODE: +/2:
     *Usage:* `A + X'
        - *Call and exit are *compatible* with:*

          `A' has property `X'.   (`meta_props:call/2')

        - *The following properties are added at call time:*

          `A' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')

 - MODE: -/2:
     *Usage:* `A - X'
        - *Call and exit are *compatible* with:*

          `A' has property `X'.   (`meta_props:call/2')

        - *The following properties are added at call time:*

          `A' is a free variable.   (`term_typing:var/1')

 - MODE: ?/2:
     *Usage:* `?(A,X)'
        - *Call and exit are *compatible* with:*

          `A' has property `X'.   (`meta_props:call/2')

 - MODE: @/2:
     *Usage:* `@(A,X)'
        - *Call and exit are *compatible* with:*

          `A' has property `X'.   (`meta_props:call/2')

        - *The following properties are added globally:*

          `A' is not further instantiated.
          (`basic_props:not_further_inst/2')

 - MODE: in/2:
     *Usage:* `in(A,X)'
        - *Call and exit are *compatible* with:*

          `A' has property `X'.   (`meta_props:call/2')

        - *The following properties are added at call time:*

          `A' is currently ground (it contains no variables).
          (`term_typing:ground/1')

        - *The following properties are added upon exit:*

          `A' is currently ground (it contains no variables).
          (`term_typing:ground/1')

 - MODE: out/2:
     *Usage:* `out(A,X)'
        - *Call and exit are *compatible* with:*

          `A' has property `X'.   (`meta_props:call/2')

        - *The following properties are added at call time:*

          `A' is a free variable.   (`term_typing:var/1')

        - *The following properties are added upon exit:*

          `A' is currently ground (it contains no variables).
          (`term_typing:ground/1')

 - MODE: go/2:
     *Usage:* `go(A,X)'
        - *Call and exit are *compatible* with:*

          `A' has property `X'.   (`meta_props:call/2')

        - *The following properties are added upon exit:*

          `A' is currently ground (it contains no variables).
          (`term_typing:ground/1')


File: ciao.info,  Node: Run-time checking of assertions,  Next: *** PART VI - Ciao Prolog library miscellanea,  Prev: Classical Prolog modes,  Up: Top

Run-time checking of assertions
*******************************

   *Author(s):* German Puebla.

   This library package allows the use of run-time checks for the
assertions introduced in a program.

   The recommended way of performing *run-time checks* of predicate
assertions in a program is via the Ciao preprocessor (see `ciaopp'
manual), which performs the required program transformation. However,
this package can also be used to perform checking of program-point
assertions.

* Menu:

* Usage and interface (rtchecks)::
* Documentation on exports (rtchecks)::
* Documentation on multifiles (rtchecks)::
* Known bugs and planned improvements (rtchecks)::


File: ciao.info,  Node: Usage and interface (rtchecks),  Next: Documentation on exports (rtchecks),  Prev: Run-time checking of assertions,  Up: Run-time checking of assertions

Usage and interface (`rtchecks')
================================

   * *Library usage:*

     `:- use_package(rtchecks).'

     or

     `:- module(...,...,[rtchecks]).'

   * *Exports:*
        - *Predicates:*

          `check/1'.

        - *Multifiles:*

          `callme/2'.

   * *Other modules used:*
        - *System library modules:*

          `assertions/meta_props', `metaterms', `write'.



File: ciao.info,  Node: Documentation on exports (rtchecks),  Next: Documentation on multifiles (rtchecks),  Prev: Usage and interface (rtchecks),  Up: Run-time checking of assertions

Documentation on exports (`rtchecks')
=====================================

 - PREDICATE: check/1:
     `check(Property)'

     Checks whether the property defined by `Property' holds.
     Otherwise, a warning message is issued. It corresponds to a
     program-point check assertion (see *Note The Ciao assertion
     package::).

     *Usage:* `check(Property)'
        - *The following properties should hold at call time:*

          `Property' is of type `^ (list;list);list'.
          (`meta_props:regtype/2')


File: ciao.info,  Node: Documentation on multifiles (rtchecks),  Next: Known bugs and planned improvements (rtchecks),  Prev: Documentation on exports (rtchecks),  Up: Run-time checking of assertions

Documentation on multifiles (`rtchecks')
========================================

 - PREDICATE: callme/2:
     No further documentation available for this predicate.

     The predicate is *multifile*.



File: ciao.info,  Node: Known bugs and planned improvements (rtchecks),  Prev: Documentation on multifiles (rtchecks),  Up: Run-time checking of assertions

Known bugs and planned improvements (`rtchecks')
================================================

   * All the code in this package is included in the user program
     when it is used, ant there is a lot of it! A module should be
     used instead.

   * `check/1' uses lists instead of "proper" properties.


File: ciao.info,  Node: *** PART VI - Ciao Prolog library miscellanea,  Next: Operating system utilities,  Prev: Run-time checking of assertions,  Up: Top

PART VI - Ciao Prolog library miscellanea
*****************************************

   This part documents several Ciao libraries which provide different
useful functionalities. Such functionalities include operating system
calls, statistics from the Prolog engine, file manipulation, error
and interruption protection of calls, program reporting messages,
printing programs, an on-line browser of libraries, etc.


File: ciao.info,  Node: Operating system utilities,  Next: Prolog system internal predicates,  Prev: *** PART VI - Ciao Prolog library miscellanea,  Up: Top

Operating system utilities
**************************

   *Author(s):* Daniel Cabeza, Manuel Carro.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 1.3#50 (1999/9/8, 22:35:15 MEST)

   This module contains predicates for invoking services which are
typically provided by the operating system. Note that the predicates
which take names of files or directories as arguments in this module
expect atoms, not path aliases. I.e., generally these predicates will
not call `absolute_file_name/2' on names of files or directories
taken as arguments.

* Menu:

* Usage and interface (system)::
* Documentation on exports (system)::


File: ciao.info,  Node: Usage and interface (system),  Next: Documentation on exports (system),  Prev: Operating system utilities,  Up: Operating system utilities

Usage and interface (`system')
==============================

   * *Library usage:*

     `:- use_module(library(system)).'

   * *Exports:*
        - *Predicates:*

          `pause/1', `time/1', `datime/1', `datime/9', `getenvstr/2',
          `extract_paths/2', `get_pid/1', `current_host/1',
          `current_executable/1', `umask/2', `working_directory/2',
          `cd/1', `shell/0', `shell/1', `shell/2', `system/1',
          `system/2', `popen/3', `exec/4', `exec/3',
          `directory_files/2', `mktemp/2', `file_exists/1',
          `file_exists/2', `file_property/2', `file_properties/6',
          `modif_time/2', `modif_time0/2', `fmode/2', `chmod/2',
          `chmod/3', `delete_file/1'.

        - *Regular Types:*

          `datime_struct/1', `popen_mode/1'.



File: ciao.info,  Node: Documentation on exports (system),  Prev: Usage and interface (system),  Up: Operating system utilities

Documentation on exports (`system')
===================================

 - PREDICATE: pause/1:
     `pause(Seconds)'

     Make this thread sleep for some `Seconds'.

     The predicate is of type *implicit*.

     *Usage:* `pause(+int)'

 - PREDICATE: time/1:
     `time(Time)'

     `Time' is unified with the number of seconds elapsed since
     January, 1, 1970 (UTC).

     The predicate is of type *implicit*.

     *Usage:* `time(?(int))'

 - PREDICATE: datime/1:
     `datime(Datime)'

     `Datime' is unified with a term of the form
     `datime(Year,Month,Day,Hour,Minute,Second)' which contains the
     current date and time.

     *Usage:* `datime(?(datime_struct))'

 - PREDICATE: datime/9:
     `datime(Time,Year,Month,Day,Hour,Min,Sec,WeekDay,YearDay)'

     `Time' is as in `time/1'. If given, the rest of the arguments
     are unified with the date and time to which the `Time' argument
     refers. If `Time' is unbound, it is bound to current time and
     the rest of the arguments refer to current time. `WeekDay' is
     the number of days since Sunday, in the range 0 to 6. `YearDay'
     is the number of days since January 1, in the range 0 to 365.

     The predicate is of type *implicit*.

     *Usage:*







     `datime(?(int),?(int),?(int),?(int),?(int),?(int),?(int),?(int),?(int))'

 - REGTYPE: datime_struct/1:
     A regular type, defined as follows:
               datime_struct(datime(Year,Month,Day,Hour,Min,Sec)) :-
                       int(Year),
                       int(Month),
                       int(Day),
                       int(Hour),
                       int(Min),
                       int(Sec).

     *Usage:*
        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - PREDICATE: getenvstr/2:
     `getenvstr(Name,Value)'

     The environment variable `Name' has `Value'. Fails if variable
     `Name' is not defined.

     The predicate is of type *implicit*.

     *Usage:* `getenvstr(+atm,?(string))'

 - PREDICATE: extract_paths/2:
     `extract_paths(String,Paths)'

     Interpret `String' as the value of a UNIX environment variable
     holding a list of paths and return in `Paths' the list of the
     paths. Paths in `String' are separated by colons, and an empty
     path is considered a shorthand for '.' (current path). The most
     typical environment variable with this format is PATH. For
     example, this is a typical use:
          ?- set_prolog_flag(write_strings, on).
          
          yes
          ?- getenvstr('PATH', PATH), extract_paths(PATH, Paths).
          
          PATH = ":/home/bardo/bin:/home/clip/bin:/opt/bin/:/bin",
          Paths = [".","/home/bardo/bin","/home/clip/bin","/opt/bin/","/bin"] ?
          
          yes
          ?-

     *Usage:* `extract_paths(+string,?(list(string)))'

 - PREDICATE: get_pid/1:
     `get_pid(Pid)'

     Unifies `Pid' with the process identificator of the current
     process or thread.

     The predicate is of type *implicit*.

     *Usage:* `get_pid(?(int))'

 - PREDICATE: current_host/1:
     `current_host(Hostname)'

     `Hostname' is unified with the fully qualified name of the host.

     The predicate is of type *implicit*.

     *Usage:* `current_host(?(atm))'

 - PREDICATE: current_executable/1:
     `current_executable(Path)'

     Unifies `Path' with the path to the current executable.

     The predicate is of type *implicit*.

     *Usage:* `current_executable(?(atm))'

 - PREDICATE: umask/2:
     `umask(OldMask,NewMask)'

     The process file creation mask was `OldMask', and it is changed
     to `NewMask'.

     The predicate is of type *implicit*.

     *Usage 1:* `umask(?(int),+int)'
     *Usage 2:* `umask(OldMask,NewMask)'
        - *Description:* Gets the process file creation mask without
          changing it.

        - *The following properties should hold at call time:*

          `OldMask' is a free variable.   (`term_typing:var/1')

          `NewMask' is a free variable.   (`term_typing:var/1')

          The terms `OldMask' and `NewMask' are strictly identical.
          (`term_compare:== /2')

        - *The following properties hold upon exit:*

          `OldMask' is an integer.   (`basic_props:int/1')

          `NewMask' is an integer.   (`basic_props:int/1')

 - PREDICATE: working_directory/2:
     `working_directory(OldDir,NewDir)'

     Unifies current working directory with `OldDir', and then
     changes the working directory to `NewDir'. Calling
     `working_directory(Dir,Dir)' simply unifies `Dir' with the
     current working directory without changing anything else.

     The predicate is of type *implicit*.

     *Usage 1:* `working_directory(?(atm),+atm)'
     *Usage 2:* `working_directory(OldDir,NewDir)'
        - *Description:* Gets current working directory.

        - *The following properties should hold at call time:*

          `OldDir' is a free variable.   (`term_typing:var/1')

          `NewDir' is a free variable.   (`term_typing:var/1')

          The terms `OldDir' and `NewDir' are strictly identical.
          (`term_compare:== /2')

        - *The following properties hold upon exit:*

          `OldDir' is an atom.   (`basic_props:atm/1')

          `NewDir' is an atom.   (`basic_props:atm/1')

 - PREDICATE: cd/1:
     `cd(Path)'

     Changes working directory to `Path'.

     *Usage:* `cd(+atm)'

 - PREDICATE: shell/0:
     The predicate is of type *implicit*.

     *Usage:*
        - *Description:* Execs the shell specified by the environment
          variable `SHELL'. When the shell process terminates,
          control is returned to Prolog.

 - PREDICATE: shell/1:
     `shell(Command)'

     `Command' is executed in the shell specified by the environment
     variable `SHELL'. It succeeds if the exit code is zero and fails
     otherwise.

     *Usage:* `shell(+atm)'

 - PREDICATE: shell/2:
     `shell(Command,ReturnCode)'

     Executes `Command' in the shell specified by the environment
     variable `SHELL' and stores the exit code in `ReturnCode'.

     The predicate is of type *implicit*.

     *Usage:* `shell(+atm,?(int))'

 - PREDICATE: system/1:
     `system(Command)'

     Executes `Command' using the shell `/bin/sh'.

     *Usage:* `system(+atm)'

 - PREDICATE: system/2:
     `system(Command,ReturnCode)'

     Executes `Command' in the `/bin/sh' shell and stores the exit
     code in `ReturnCode'.

     The predicate is of type *implicit*.

     *Usage:* `system(+atm,?(int))'

 - PREDICATE: popen/3:
     `popen(Command,Mode,Stream)'

     Open a pipe to process `Command' in a new shell with a given
     `Mode' and return a communication `Stream' (as in UNIX
     `popen(3)'). If `Mode' is `read' the output from the process is
     sent to `Stream'. If `Mode' is `write', `Stream' is sent as
     input to the process. `Stream' may be read from or written into
     using the ordinary stream I/O predicates. `Stream' must be
     closed explicitly using `close/1', i.e., it is not closed
     automatically when the process dies.

     *Usage:* `popen(+atm,+popen_mode,-(stream))'

 - REGTYPE: popen_mode/1:
     *Usage:* `popen_mode(M)'
        - *Description:* `M' is 'read' or 'write'.

        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - PREDICATE: exec/4:
     `exec(Command,StdIn,StdOut,StdErr)'

     Starts the process `Command' and returns the I/O streams of the
     process in `StdIn', `StdOut', and `StdErr'.

     *Usage:* `exec(+atm,-(stream),-(stream),-(stream))'

 - PREDICATE: exec/3:
     `exec(Command,StdIn,StdOut)'

     Starts the process `Command' and returns the I/O streams of the
     process in `StdIn' and `StdOut'. `Standard error' is connected
     to whichever the parent process had it connected to.

     *Usage:* `exec(+atm,-(stream),-(stream))'

 - PREDICATE: directory_files/2:
     `directory_files(Directory,FileList)'

     `FileList' is the unordered list of entries (files, directories,
     etc.) in `Directory'.

     The predicate is of type *implicit*.

     *Usage:* `directory_files(+atm,?(list(atm)))'

 - PREDICATE: mktemp/2:
     `mktemp(Template,Filename)'

     Returns a unique `Filename' based on `Template': `Template' must
     be a valid file name with six trailing X, which are substituted
     to create a new file name.

     The predicate is of type *implicit*.

     *Usage:* `mktemp(+atm,?(atm))'

 - PREDICATE: file_exists/1:
     `file_exists(File)'

     Succeeds if `File' (a file or directory) exists (and is
     accessible).

     *Usage:* `file_exists(+atm)'

 - PREDICATE: file_exists/2:
     `file_exists(File,Mode)'

     `File' (a file or directory) exists and it is accessible with
     `Mode', as in the Unix call `access(2)'. Typically, `Mode' is 4
     for read permission, 2 for write permission and 1 for execute
     permission.

     The predicate is of type *implicit*.

     *Usage:* `file_exists(+atm,+int)'

 - PREDICATE: file_property/2:
     `file_property(File,Property)'

     `File' has the property `Property'. The possible properties are:

    type(`Type')
          `Type' is one of `regular', `directory', `symlink', `fifo',
          `socket' or `unknown'.

    linkto(`Linkto')
          If `File' is a symbolic link, `Linkto' is the file pointed
          to by the link (and the other properties come from that
          file, not from the link itself).

    mod_time(`ModTime')
          `ModTime' is the time of last modification (seconds since
          January, 1, 1970).

    mode(`Protection')
          `Protection' is the protection mode.

    size(`Size')
          `Size' is the size.

     If `Property' is uninstantiated, the predicate will enumerate
     the properties on backtracking.

     *Usage:* `file_property(+atm,?(struct))'

 - PREDICATE: file_properties/6:
     `file_properties(Path,Type,Linkto,Time,Protection,Size)'

     The file `Path' has the following properties:

        * File type `Type' (one of `regular', `directory', `symlink',
          `fifo', `socket' or `unknown').

        * If `Path' is a symbolic link, `Linkto' is the file pointed
          to. All other properties come from the file pointed, not
          the link. `Linkto' is " if `Path' is not a symbolic link.

        * Time of last modification `Time' (seconds since January, 1,
          1970).

        * Protection mode `Protection'.

        * Size in bytes `Size'.

     The predicate is of type *implicit*.

     *Usage:*
     `file_properties(+atm,?(atm),?(atm),?(int),?(int),?(int))'

 - PREDICATE: modif_time/2:
     `modif_time(File,Time)'

     The file `File' was last modified at `Time', which is in seconds
     since January, 1, 1970. Fails if `File' does not exist.

     *Usage:* `modif_time(+atm,?(int))'

 - PREDICATE: modif_time0/2:
     `modif_time0(File,Time)'

     If `File' exists, `Time' is its latest modification time, as in
     `modif_time/2'. Otherwise, if `File' does not exist, `Time' is
     zero.

     *Usage:* `modif_time0(+atm,?(int))'

 - PREDICATE: fmode/2:
     `fmode(File,Mode)'

     The file `File' has protection mode `Mode'.

     *Usage:* `fmode(+atm,?(int))'

 - PREDICATE: chmod/2:
     `chmod(File,NewMode)'

     Change the protection mode of file `File' to `NewMode'.

     The predicate is of type *implicit*.

     *Usage:* `chmod(+atm,+int)'

 - PREDICATE: chmod/3:
     `chmod(File,OldMode,NewMode)'

     The file `File' has protection mode `OldMode' and it is changed
     to `NewMode'.

     *Usage 1:* `chmod(+atm,?(int),+int)'
     *Usage 2:* `chmod(File,OldMode,NewMode)'
        - *Description:* Equivalent to fmode(`File',`OldMode')

        - *The following properties should hold at call time:*

          `File' is an atom.   (`basic_props:atm/1')

          `OldMode' is a free variable.   (`term_typing:var/1')

          `NewMode' is a free variable.   (`term_typing:var/1')

          The terms `OldMode' and `NewMode' are strictly identical.
          (`term_compare:== /2')

        - *The following properties hold upon exit:*

          `File' is an atom.   (`basic_props:atm/1')

          `OldMode' is an atom.   (`basic_props:atm/1')

          `NewMode' is an atom.   (`basic_props:atm/1')

 - PREDICATE: delete_file/1:
     `delete_file(File)'

     Delete the file `File'.

     The predicate is of type *implicit*.

     *Usage:* `delete_file(+atm)'


File: ciao.info,  Node: Prolog system internal predicates,  Next: ctrlcclean (library),  Prev: Operating system utilities,  Up: Top

Prolog system internal predicates
*********************************

   *Author(s):* Manuel Carro, Daniel Cabeza, Mats Carlsson.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 1.3#94 (1999/11/8, 18:36:7 MET)

   This module implements some miscellaneous predicates which provide
access to some internal statistics, special properties of the
predicates, etc.

* Menu:

* Usage and interface (prolog_sys)::
* Documentation on exports (prolog_sys)::
* Documentation on internals (prolog_sys)::
* Known bugs and planned improvements (prolog_sys)::


File: ciao.info,  Node: Usage and interface (prolog_sys),  Next: Documentation on exports (prolog_sys),  Prev: Prolog system internal predicates,  Up: Prolog system internal predicates

Usage and interface (`prolog_sys')
==================================

   * *Library usage:*

     `:- use_module(library(prolog_sys)).'

   * *Exports:*
        - *Predicates:*

          `statistics/2', `predicate_property/2'.



File: ciao.info,  Node: Documentation on exports (prolog_sys),  Next: Documentation on internals (prolog_sys),  Prev: Usage and interface (prolog_sys),  Up: Prolog system internal predicates

Documentation on exports (`prolog_sys')
=======================================

 - PREDICATE: statistics/0:
     No further documentation available for this predicate.

     The predicate is of type *implicit*.


 - PREDICATE: statistics/2:
     *Usage 1:* `statistics(Time_option,Time_result)'
        - *Description:* Gather information about time (either
          process time or wall time) since last consult or since
          start of program. Results are returned in milliseconds.

        - *The following properties should hold at call time:*

          `Time_option' is any term.   (`basic_props:term/1')

          `Time_result' is any term.   (`basic_props:term/1')

        - *The following properties hold upon exit:*

          Options to get information about execution time.
          `Time_option' must be one of `runtime', `walltime'.
          (`prolog_sys:time_option/1')

          `Time_result' is a two-element list of integers. The first
          integer is the time since the start of the execution; the
          second integer is the time since the previous consult to
          time.   (`prolog_sys:time_result/1')

     *Usage 2:* `statistics(Memory_option,Memory_result)'
        - *Description:* Gather information about memory consumption.

        - *The following properties should hold at call time:*

          `Memory_option' is any term.   (`basic_props:term/1')

          `Memory_result' is any term.   (`basic_props:term/1')

        - *The following properties hold upon exit:*

          Options to get information about memory usage.
          (`prolog_sys:memory_option/1')

          Result is a two-element list of integers. The first element
          is the space taken up by the option selected, measured in
          bytes; the second integer is zero for program space (which
          grows as ncessary), and the amount of free space otherwise.
          (`prolog_sys:memory_result/1')

     *Usage 3:* `statistics(Garbage_collection_option,Gc_result)'
        - *Description:* Gather information about garbage collection.

        - *The following properties should hold at call time:*

          `Garbage_collection_option' is any term.
          (`basic_props:term/1')

          `Gc_result' is any term.   (`basic_props:term/1')

        - *The following properties hold upon exit:*

          Options to get information about garbage collection.
          (`prolog_sys:garbage_collection_option/1')

          `Gc_result' is a tree-element list of integers, related to
          garbage collection and memory management. When
          `stack_shifts' is selected, the first one is the number of
          shifts (reallocations) of the local stack; the second is
          the number of shifts of the trail, and the third is the
          time spent in these shifts. When `garbage_collection' is
          selected, the numbers are, respectively, the number of
          garbage collections performed, the number of bytes freed,
          and the time spent in garbage collection.
          (`prolog_sys:gc_result/1')

     *Usage 4:* `statistics(Symbol_option,Symbol_result)'
        - *Description:* Gather information about number of symbols
          and predicates.

        - *The following properties should hold at call time:*

          `Symbol_option' is any term.   (`basic_props:term/1')

          `Symbol_result' is any term.   (`basic_props:term/1')

        - *The following properties hold upon exit:*

          Option to get information about the number of symbols in
          the program.   (`prolog_sys:symbol_option/1')

          `Symbol_result' is a two-element list of integers. The
          first one is the number of atom, functor, and predicate
          names in the symbol table. The second is the number of
          predicates known to be defined (although maybe without
          clauses).   (`prolog_sys:symbol_result/1')

 - PREDICATE: predicate_property/2:
     *Usage:* `predicate_property(Head,Property)'
        - *Description:* The predicate with clause `Head' is
          `Property'.

        - *The following properties should hold at call time:*

          `Head' is any term.   (`basic_props:term/1')

          `Property' is any term.   (`basic_props:term/1')

        - *The following properties hold upon exit:*

          `Head' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')

          `Property' is an atom.   (`basic_props:atm/1')

 - PREDICATE: current_atom/1:
     No further documentation available for this predicate.

     The predicate is of type *implicit*.


 - PREDICATE: current_predicate/2:
     No further documentation available for this predicate.

     The predicate is of type *implicit*.


 - PREDICATE: garbage_collect/0:
     No further documentation available for this predicate.

     The predicate is of type *implicit*.



File: ciao.info,  Node: Documentation on internals (prolog_sys),  Next: Known bugs and planned improvements (prolog_sys),  Prev: Documentation on exports (prolog_sys),  Up: Prolog system internal predicates

Documentation on internals (`prolog_sys')
=========================================

 - REGTYPE: time_option/1:
     *Usage:* `time_option(M)'
        - *Description:* Options to get information about execution
          time. `M' must be one of `runtime', `walltime'.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: memory_option/1:
     *Usage:* `memory_option(M)'
        - *Description:* Options to get information about memory
          usage.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: garbage_collection_option/1:
     *Usage:* `garbage_collection_option(M)'
        - *Description:* Options to get information about garbage
          collection.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: symbol_option/1:
     *Usage:* `symbol_option(M)'
        - *Description:* Option to get information about the number
          of symbols in the program.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: time_result/1:
     *Usage:* `time_result(Result)'
        - *Description:* `Result' is a two-element list of integers.
          The first integer is the time since the start of the
          execution; the second integer is the time since the
          previous consult to time.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: memory_result/1:
     *Usage:* `memory_result(Result)'
        - *Description:* Result is a two-element list of integers.
          The first element is the space taken up by the option
          selected, measured in bytes; the second integer is zero for
          program space (which grows as ncessary), and the amount of
          free space otherwise.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: gc_result/1:
     *Usage:* `gc_result(Result)'
        - *Description:* `Result' is a tree-element list of integers,
          related to garbage collection and memory management. When
          `stack_shifts' is selected, the first one is the number of
          shifts (reallocations) of the local stack; the second is
          the number of shifts of the trail, and the third is the
          time spent in these shifts. When `garbage_collection' is
          selected, the numbers are, respectively, the number of
          garbage collections performed, the number of bytes freed,
          and the time spent in garbage collection.

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: symbol_result/1:
     *Usage:* `symbol_result(Result)'
        - *Description:* `Result' is a two-element list of integers.
          The first one is the number of atom, functor, and predicate
          names in the symbol table. The second is the number of
          predicates known to be defined (although maybe without
          clauses).

        - *The following properties hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')


File: ciao.info,  Node: Known bugs and planned improvements (prolog_sys),  Prev: Documentation on internals (prolog_sys),  Up: Prolog system internal predicates

Known bugs and planned improvements (`prolog_sys')
==================================================

   * The space used by the process is not measured here: process
     data, code, and stack also take up memory. The memory reported
     for atoms is not what is actually used, but the space used up by
     the hash table (which is enlarged as needed).


File: ciao.info,  Node: ctrlcclean (library),  Next: errhandle (library),  Prev: Prolog system internal predicates,  Up: Top

ctrlcclean (library)
********************

   *Version:* 0.4#5 (1998/2/24)

* Menu:

* Usage and interface (ctrlcclean)::
* Documentation on exports (ctrlcclean)::


File: ciao.info,  Node: Usage and interface (ctrlcclean),  Next: Documentation on exports (ctrlcclean),  Prev: ctrlcclean (library),  Up: ctrlcclean (library)

Usage and interface (`ctrlcclean')
==================================

   * *Library usage:*

     `:- use_module(library(ctrlcclean)).'

   * *Other modules used:*
        - *System library modules:*

          `system'.



File: ciao.info,  Node: Documentation on exports (ctrlcclean),  Prev: Usage and interface (ctrlcclean),  Up: ctrlcclean (library)

Documentation on exports (`ctrlcclean')
=======================================

 - PREDICATE: ctrlc_clean/1:
     No further documentation available for this predicate.

     *Meta-predicate* with arguments: `ctrlc_clean(goal)'.


 - PREDICATE: delete_on_ctrlc/2:
     No further documentation available for this predicate.


 - PREDICATE: ctrlcclean/0:
     No further documentation available for this predicate.



File: ciao.info,  Node: errhandle (library),  Next: fastrw (library),  Prev: ctrlcclean (library),  Up: Top

errhandle (library)
*******************

   *Version:* 0.4#5 (1998/2/24)

* Menu:

* Usage and interface (errhandle)::
* Documentation on exports (errhandle)::


File: ciao.info,  Node: Usage and interface (errhandle),  Next: Documentation on exports (errhandle),  Prev: errhandle (library),  Up: errhandle (library)

Usage and interface (`errhandle')
=================================

   * *Library usage:*

     `:- use_module(library(errhandle)).'


File: ciao.info,  Node: Documentation on exports (errhandle),  Prev: Usage and interface (errhandle),  Up: errhandle (library)

Documentation on exports (`errhandle')
======================================

 - PREDICATE: error_protect/1:
     No further documentation available for this predicate.

     *Meta-predicate* with arguments: `error_protect(goal)'.


 - PREDICATE: handle_error/2:
     No further documentation available for this predicate.



File: ciao.info,  Node: fastrw (library),  Next: File name manipulation,  Prev: errhandle (library),  Up: Top

fastrw (library)
****************

   *Version:* 0.4#5 (1998/2/24)

* Menu:

* Usage and interface (fastrw)::
* Documentation on exports (fastrw)::


File: ciao.info,  Node: Usage and interface (fastrw),  Next: Documentation on exports (fastrw),  Prev: fastrw (library),  Up: fastrw (library)

Usage and interface (`fastrw')
==============================

   * *Library usage:*

     `:- use_module(library(fastrw)).'

   * *Other modules used:*
        - *System library modules:*

          `dict'.



File: ciao.info,  Node: Documentation on exports (fastrw),  Prev: Usage and interface (fastrw),  Up: fastrw (library)

Documentation on exports (`fastrw')
===================================

 - PREDICATE: fast_read/1:
     No further documentation available for this predicate.


 - PREDICATE: fast_write/1:
     No further documentation available for this predicate.


 - PREDICATE: fast_write_to_string/3:
     No further documentation available for this predicate.



File: ciao.info,  Node: File name manipulation,  Next: file_utils (library),  Prev: fastrw (library),  Up: Top

File name manipulation
**********************

   *Author(s):* Daniel Cabeza, Angel Fernandez Pineda.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 1.3#51 (1999/9/9, 16:28:44 MEST)

   This library provides some small utilities to handle file name
syntax.

* Menu:

* Usage and interface (filenames)::
* Documentation on exports (filenames)::


File: ciao.info,  Node: Usage and interface (filenames),  Next: Documentation on exports (filenames),  Prev: File name manipulation,  Up: File name manipulation

Usage and interface (`filenames')
=================================

   * *Library usage:*

     `:- use_module(library(filenames)).'

   * *Exports:*
        - *Predicates:*

          `no_path_file_name/2', `file_name_extension/3',
          `basename/2', `extension/2'.

   * *Other modules used:*
        - *System library modules:*

          `lists'.



File: ciao.info,  Node: Documentation on exports (filenames),  Prev: Usage and interface (filenames),  Up: File name manipulation

Documentation on exports (`filenames')
======================================

 - PREDICATE: no_path_file_name/2:
     This predicate will extract the last item (usually the file
     name) from a given path.

     The first argument must be instantiated to a string or atom.
     Whenever the first argument is an atom, the second argument will
     be an atom. Whenever the first argument is a string, the second
     argument will be a string.

     This predicate will fail under any of the following conditions:
        * First argument is not an atom, nor a string.

        * Second argument is not the last given path item (given path
          is the first argument).

     Those are the most usual usages of no_path_file_name/2:
          ?- no_path_file_name_("/home/nexusV/somefile.txt",K).
          
          K = "somefile.txt" ?
          
          yes
          ?- no_path_file_name('/home/nexusV/somefile.txt',K).
          
          K = 'somefile.txt' ?
          
          yes
          ?-

     *Usage:* `no_path_file_name(Path,FileName)'
        - *Description:* `FileName' is the file corresponding to the
          given `Path'.

        - *Call and exit should be *compatible* with:*

          `Path' is an atom or a string  (`filenames:atom_or_str/1')

          `FileName' is an atom or a string
          (`filenames:atom_or_str/1')

 - PREDICATE: file_name_extension/3:
     This predicate may be used in two ways:
        * To create a file name from its components: name and
          extension. For instance:

               ?- file_name_extension(File,mywork,'.txt').
               
               File = 'mywork.txt' ?
               
               yes
               ?-

        * To split a file name into its name and extension. For
          Instance:
               ?- file_name_extension('mywork.txt',A,B).
               
               A = mywork,
               B = '.txt' ?
               
               yes
               ?-

     Any other usage of file_name_extension/3 will cause the
     predicate to fail. Notice that valid arguments are accepted both
     as atoms or strings.

     *Usage:* `file_name_extension(FileName,BaseName,Extension)'
        - *Description:* Splits a `FileName' into its `BaseName' and
          `Extension'.

        - *Call and exit should be *compatible* with:*

          `FileName' is an atom or a string
          (`filenames:atom_or_str/1')

          `BaseName' is an atom or a string
          (`filenames:atom_or_str/1')

          `Extension' is an atom or a string
          (`filenames:atom_or_str/1')

 - PREDICATE: basename/2:
     `basename(FileName,BaseName)'

     `BaseName' is `FileName' without extension. Equivalent to
     `file_name_extension(FileName,BaseName,_)'. Useful to extract
     the base name of a file using functional syntax.

     *Usage:*
        - *Calls should, and exit will be compatible with:*

          `FileName' is an atom or a string
          (`filenames:atom_or_str/1')

          `BaseName' is an atom or a string
          (`filenames:atom_or_str/1')

 - PREDICATE: extension/2:
     `extension(FileName,Extension)'

     `Extension' is the extension (suffix) of `FileName'. Equivalent
     to `file_name_extension(FileName,_,Extension)'. Useful to
     extract the extension of a file using functional syntax.

     *Usage:*
        - *Calls should, and exit will be compatible with:*

          `FileName' is an atom or a string
          (`filenames:atom_or_str/1')

          `Extension' is an atom or a string
          (`filenames:atom_or_str/1')


File: ciao.info,  Node: file_utils (library),  Next: file_locks (library),  Prev: File name manipulation,  Up: Top

file_utils (library)
********************

   *Version:* 0.5#17 (1998/6/11, 21:5:3 MET DST)

* Menu:

* Usage and interface (file_utils)::
* Documentation on exports (file_utils)::


File: ciao.info,  Node: Usage and interface (file_utils),  Next: Documentation on exports (file_utils),  Prev: file_utils (library),  Up: file_utils (library)

Usage and interface (`file_utils')
==================================

   * *Library usage:*

     `:- use_module(library(file_utils)).'

   * *Exports:*
        - *Predicates:*

          `file_terms/2', `copy_stdout/1', `file_to_string/2'.

   * *Other modules used:*
        - *System library modules:*

          `read', `streams'.



File: ciao.info,  Node: Documentation on exports (file_utils),  Prev: Usage and interface (file_utils),  Up: file_utils (library)

Documentation on exports (`file_utils')
=======================================

 - PREDICATE: file_terms/2:
     *Usage 1:* `file_terms(@(File),?(Terms))'
        - *Description:* Transform a file `File' to/from a list of
          terms `Terms'.

        - *The following properties should hold upon exit:*

          `@(File)' is a source name.   (`streams_basic:sourcename/1')

          `?(Terms)' is a list.   (`basic_props:list/1')

     *Usage 2:* `file_terms(File,Terms)'
        - *Description:* Unifies `Terms' with the list of all terms
          in `File'.

        - *The following properties should hold at call time:*

          `File' is a source name.   (`streams_basic:sourcename/1')

          `Terms' is a free variable.   (`term_typing:var/1')

        - *The following properties should hold upon exit:*

          `File' is a source name.   (`streams_basic:sourcename/1')

          `Terms' is a list.   (`basic_props:list/1')

     *Usage 3:* `file_terms(File,Terms)'
        - *Description:* Writes the terms in list `Terms' (including
          the ending '.') onto file `File'.

        - *The following properties should hold at call time:*

          `File' is a source name.   (`streams_basic:sourcename/1')

          `Terms' is a list.   (`basic_props:list/1')

        - *The following properties should hold upon exit:*

          `File' is a source name.   (`streams_basic:sourcename/1')

          `Terms' is a list.   (`basic_props:list/1')

 - PREDICATE: copy_stdout/1:
     *Usage:* `copy_stdout(+File)'
        - *Description:* Copies file `File' to standard output.

        - *The following properties should hold upon exit:*

          `+File' is a source name.   (`streams_basic:sourcename/1')

 - PREDICATE: file_to_string/2:
     *Usage:* `file_to_string(+FileName,-(String))'
        - *Description:* Reads all the characters from the file
          `FileName' and returns them in `String'.

        - *Call and exit should be *compatible* with:*

          `+FileName' is a source name.
          (`streams_basic:sourcename/1')

          `-(String)' is a string (a list of character codes).
          (`basic_props:string/1')


File: ciao.info,  Node: file_locks (library),  Next: terms (library),  Prev: file_utils (library),  Up: Top

file_locks (library)
********************

* Menu:

* Usage and interface (file_locks)::
* Documentation on exports (file_locks)::


File: ciao.info,  Node: Usage and interface (file_locks),  Next: Documentation on exports (file_locks),  Prev: file_locks (library),  Up: file_locks (library)

Usage and interface (`file_locks')
==================================

   * *Library usage:*

     `:- use_module(library(file_locks)).'


File: ciao.info,  Node: Documentation on exports (file_locks),  Prev: Usage and interface (file_locks),  Up: file_locks (library)

Documentation on exports (`file_locks')
=======================================

 - PREDICATE: lock_file/3:
     No further documentation available for this predicate.


 - PREDICATE: unlock_file/2:
     No further documentation available for this predicate.



File: ciao.info,  Node: terms (library),  Next: tokenize (library),  Prev: file_locks (library),  Up: Top

terms (library)
***************

   *Version:* 1.3#124 (1999/11/27, 4:4:5 MET)

* Menu:

* Usage and interface (terms)::
* Documentation on exports (terms)::


File: ciao.info,  Node: Usage and interface (terms),  Next: Documentation on exports (terms),  Prev: terms (library),  Up: terms (library)

Usage and interface (`terms')
=============================

   * *Library usage:*

     `:- use_module(library(terms)).'


File: ciao.info,  Node: Documentation on exports (terms),  Prev: Usage and interface (terms),  Up: terms (library)

Documentation on exports (`terms')
==================================

 - PREDICATE: copy_args/3:
     No further documentation available for this predicate.


 - PREDICATE: arg/2:
     No further documentation available for this predicate.


 - PREDICATE: atom_concat/2:
     `atom_concat(Atms,Atm)'

     `Atm' is the atom resulting from concatenating all atoms in the
     list `Atms' in the order in which they appear.



File: ciao.info,  Node: tokenize (library),  Next: Printing status and error messages,  Prev: terms (library),  Up: Top

tokenize (library)
******************

   *Version:* 0.4#5 (1998/2/24)

* Menu:

* Usage and interface (tokenize)::
* Documentation on exports (tokenize)::
* Documentation on multifiles (tokenize)::


File: ciao.info,  Node: Usage and interface (tokenize),  Next: Documentation on exports (tokenize),  Prev: tokenize (library),  Up: tokenize (library)

Usage and interface (`tokenize')
================================

   * *Library usage:*

     `:- use_module(library(tokenize)).'

   * *Other modules used:*
        - *System library modules:*

          `read', `dict'.



File: ciao.info,  Node: Documentation on exports (tokenize),  Next: Documentation on multifiles (tokenize),  Prev: Usage and interface (tokenize),  Up: tokenize (library)

Documentation on exports (`tokenize')
=====================================

 - PREDICATE: read_tokens/2:
     No further documentation available for this predicate.



File: ciao.info,  Node: Documentation on multifiles (tokenize),  Prev: Documentation on exports (tokenize),  Up: tokenize (library)

Documentation on multifiles (`tokenize')
========================================

 - PREDICATE: define_flag/3:
     No further documentation available for this predicate.

     The predicate is *multifile*.



File: ciao.info,  Node: Printing status and error messages,  Next: A simple pretty-printer for Ciao programs,  Prev: tokenize (library),  Up: Top

Printing status and error messages
**********************************

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 1.3#108 (1999/11/18, 13:48:3 MET)

   This is a very simple library for printing status and error
messages to the console.

* Menu:

* Usage and interface (messages)::
* Documentation on exports (messages)::
* Documentation on multifiles (messages)::
* Known bugs and planned improvements (messages)::


File: ciao.info,  Node: Usage and interface (messages),  Next: Documentation on exports (messages),  Prev: Printing status and error messages,  Up: Printing status and error messages

Usage and interface (`messages')
================================

   * *Library usage:*

     `:- use_module(library(messages)).'

   * *Exports:*
        - *Predicates:*

          `error_message/1', `error_message/2', `error_message/3',
          `warning_message/1', `warning_message/2',
          `warning_message/3', `note_message/1', `note_message/2',
          `note_message/3', `simple_message/1', `simple_message/2',
          `optional_message/2', `optional_message/3',
          `debug_message/1', `debug_message/2', `debug_goal/2',
          `debug_goal/3'.

        - *Multifiles:*

          `callme/2', `issue_debug_messages/1'.

   * *Other modules used:*
        - *System library modules:*

          `assertions/meta_props', `format', `lists', `filenames'.



File: ciao.info,  Node: Documentation on exports (messages),  Next: Documentation on multifiles (messages),  Prev: Usage and interface (messages),  Up: Printing status and error messages

Documentation on exports (`messages')
=====================================

 - PREDICATE: error_message/1:
     *Meta-predicate* of type *implicit* with arguments:
     `error_message(addmodule)'.

     *Usage:* `error_message(Text)'
        - *Description:* The text provided in `Text' is printed as an
          ERROR message.

        - *The following properties should hold at call time:*

          `Text' is a string (a list of character codes).
          (`basic_props:string/1')

 - PREDICATE: error_message/2:
     *Meta-predicate* of type *implicit* with arguments:
     `error_message(?,addmodule)'.

     *Usage:* `error_message(Text,ArgList)'
        - *Description:* The text provided in `Text' is printed as an
          ERROR message, using the arguments in `ArgList' to
          interpret any variable-related formatting commands embedded
          in `Text'.

        - *The following properties should hold at call time:*

          `Text' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')

          `ArgList' is a list.   (`basic_props:list/1')

 - PREDICATE: error_message/3:
     *Meta-predicate* of type *implicit* with arguments:
     `error_message(?,?,addmodule)'.

     *Usage:* `error_message(Lc,Text,ArgList)'
        - *Description:* The text provided in `Text' is printed as an
          ERROR message, using the arguments in `ArgList' to
          interpret any variable-related formatting commands embedded
          in `Text', and reporting error location `Lc' (file and line
          numbers).

        - *The following properties should hold at call time:*

          `Lc' is of type `^loc(atm,int,int)'.
          (`meta_props:regtype/2')

          `Text' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')

          `ArgList' is a list.   (`basic_props:list/1')

 - PREDICATE: warning_message/1:
     *Meta-predicate* of type *implicit* with arguments:
     `warning_message(addmodule)'.

     *Usage:* `warning_message(Text)'
        - *Description:* The text provided in `Text' is printed as a
          WARNING message.

        - *The following properties should hold at call time:*

          `Text' is a string (a list of character codes).
          (`basic_props:string/1')

 - PREDICATE: warning_message/2:
     *Meta-predicate* of type *implicit* with arguments:
     `warning_message(?,addmodule)'.

     *Usage:* `warning_message(Text,ArgList)'
        - *Description:* The text provided in `Text' is printed as a
          WARNING message, using the arguments in `ArgList' to
          interpret any variable-related formatting commands embedded
          in `Text'.

        - *The following properties should hold at call time:*

          `Text' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')

          `ArgList' is a list.   (`basic_props:list/1')

 - PREDICATE: warning_message/3:
     *Meta-predicate* of type *implicit* with arguments:
     `warning_message(?,?,addmodule)'.

     *Usage:* `warning_message(Lc,Text,ArgList)'
        - *Description:* The text provided in `Text' is printed as a
          WARNING message, using the arguments in `ArgList' to
          interpret any variable-related formatting commands embedded
          in `Text', and reporting error location `Lc' (file and line
          numbers).

        - *The following properties should hold at call time:*

          `Lc' is of type `^loc(atm,int,int)'.
          (`meta_props:regtype/2')

          `Text' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')

          `ArgList' is a list.   (`basic_props:list/1')

 - PREDICATE: note_message/1:
     *Meta-predicate* of type *implicit* with arguments:
     `note_message(addmodule)'.

     *Usage:* `note_message(Text)'
        - *Description:* The text provided in `Text' is printed as a
          NOTE.

        - *The following properties should hold at call time:*

          `Text' is a string (a list of character codes).
          (`basic_props:string/1')

 - PREDICATE: note_message/2:
     *Meta-predicate* of type *implicit* with arguments:
     `note_message(?,addmodule)'.

     *Usage:* `note_message(Text,ArgList)'
        - *Description:* The text provided in `Text' is printed as a
          NOTE, using the arguments in `ArgList' to interpret any
          variable-related formatting commands embedded in `Text'.

        - *The following properties should hold at call time:*

          `Text' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')

          `ArgList' is a list.   (`basic_props:list/1')

 - PREDICATE: note_message/3:
     *Meta-predicate* of type *implicit* with arguments:
     `note_message(?,?,addmodule)'.

     *Usage:* `note_message(Lc,Text,ArgList)'
        - *Description:* The text provided in `Text' is printed as a
          NOTE, using the arguments in `ArgList' to interpret any
          variable-related formatting commands embedded in `Text',
          and reporting error location `Lc' (file and line numbers).

        - *The following properties should hold at call time:*

          `Lc' is of type `^loc(atm,int,int)'.
          (`meta_props:regtype/2')

          `Text' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')

          `ArgList' is a list.   (`basic_props:list/1')

 - PREDICATE: simple_message/1:
     *Usage:* `simple_message(Text)'
        - *Description:* The text provided in `Text' is printed.

        - *The following properties should hold at call time:*

          `Text' is a string (a list of character codes).
          (`basic_props:string/1')

 - PREDICATE: simple_message/2:
     *Usage:* `simple_message(Text,ArgList)'
        - *Description:* The text provided in `Text' is printed as a
          message, using the arguments in `ArgList'.

        - *The following properties should hold at call time:*

          `Text' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')

          `ArgList' is a list.   (`basic_props:list/1')

 - PREDICATE: optional_message/2:
     *Usage:* `optional_message(Text,Opts)'
        - *Description:* The text provided in `Text' is printed as a
          message, but only if the atom `-v' is a member of `Opts'.
          These predicates are meant to be used for optional
          messages, which are only to be printed when *verbose*
          output is requested explicitly.

        - *The following properties should hold at call time:*

          `Text' is a string (a list of character codes).
          (`basic_props:string/1')

          `Opts' is a list of `atm's.   (`basic_props:list/2')

 - PREDICATE: optional_message/3:
     *Usage:* `optional_message(Text,ArgList,Opts)'
        - *Description:* The text provided in `Text' is printed as a
          message, using the arguments in `ArgList', but only if the
          atom `-v' is a member of `Opts'. These predicates are meant
          to be used for optional messages, which are only to be
          printed when *verbose* output is requested explicitly.

        - *The following properties should hold at call time:*

          `Text' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')

          `ArgList' is a list.   (`basic_props:list/1')

          `Opts' is a list of `atm's.   (`basic_props:list/2')

 - PREDICATE: debug_message/1:
     *Meta-predicate* of type *implicit* with arguments:
     `debug_message(addmodule)'.

     *Usage:* `debug_message(Text)'
        - *Description:* The text provided in `Text' is printed as a
          debugging message. These messages are turned `on' by
          defining a fact of `issue_debug_messages/1' with the module
          name as argument.

        - *The following properties should hold at call time:*

          `Text' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')

 - PREDICATE: debug_message/2:
     *Meta-predicate* of type *implicit* with arguments:
     `debug_message(?,addmodule)'.

     *Usage:* `debug_message(Text,ArgList)'
        - *Description:* The text provided in `Text' is printed as a
          debugging message, using the arguments in `ArgList' to
          interpret any variable-related formatting commands embedded
          in `Text'. These messages are turned `on' by defining a
          fact of `issue_debug_messages/1' which the module name as
          argument.

        - *The following properties should hold at call time:*

          `Text' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')

          `ArgList' is a list.   (`basic_props:list/1')

 - PREDICATE: debug_goal/2:
     *Meta-predicate* of type *implicit* with arguments:
     `debug_goal(goal,addmodule)'.

     *Usage:* `debug_goal(Goal,Text)'
        - *Description:* `Goal' is called. The text provided in
          `Text' is then printed as a debugging message. The whole
          process (including running `Goal') is turned `on' by
          defining a fact of `issue_debug_messages/1' with the module
          name as argument.

 - PREDICATE: debug_goal/3:
     *Meta-predicate* of type *implicit* with arguments:
     `debug_goal(goal,?,addmodule)'.

     *Usage:* `debug_goal(Goal,Text,ArgList)'
        - *Description:* `Goal' is called. The text provided in
          `Text' is then printed as a debugging message, using the
          arguments in `ArgList' to interpret any variable-related
          formatting commands embedded in `Text'. Note that the
          variables in `ArgList' can be computed by `Goal'. The whole
          process (including running `Goal') is turned `on' by
          defining a fact of `issue_debug_messages/1' with the module
          name as argument.


File: ciao.info,  Node: Documentation on multifiles (messages),  Next: Known bugs and planned improvements (messages),  Prev: Documentation on exports (messages),  Up: Printing status and error messages

Documentation on multifiles (`messages')
========================================

 - PREDICATE: callme/2:
     No further documentation available for this predicate.

     The predicate is *multifile*.


 - PREDICATE: issue_debug_messages/1:
     The predicate is *multifile* and of type *data*.

     *Usage:* `issue_debug_messages(Module)'
        - *Description:* Printing of debugging messages is enabled
          for module `Module'.

        - *The following properties should hold upon exit:*

          `Module' is currently instantiated to an atom.
          (`term_typing:atom/1')


File: ciao.info,  Node: Known bugs and planned improvements (messages),  Prev: Documentation on multifiles (messages),  Up: Printing status and error messages

Known bugs and planned improvements (`messages')
================================================

   * Debug message switching should really be done with an expansion,
     for performance.


File: ciao.info,  Node: A simple pretty-printer for Ciao programs,  Next: Pretty-printing assertions,  Prev: Printing status and error messages,  Up: Top

A simple pretty-printer for Ciao programs
*****************************************

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 0.9#100 (1999/5/26, 12:36:46 MEST)

   This library module writes out to standard output a clause or a
list of clauses.

* Menu:

* Usage and interface (pretty_print)::
* Documentation on exports (pretty_print)::
* Documentation on internals (pretty_print)::


File: ciao.info,  Node: Usage and interface (pretty_print),  Next: Documentation on exports (pretty_print),  Prev: A simple pretty-printer for Ciao programs,  Up: A simple pretty-printer for Ciao programs

Usage and interface (`pretty_print')
====================================

   * *Library usage:*

     `:- use_module(library(pretty_print)).'

   * *Exports:*
        - *Predicates:*

          `pretty_print/2', `pretty_print/3'.

   * *Other modules used:*
        - *System library modules:*

          `vndict', `write'.



File: ciao.info,  Node: Documentation on exports (pretty_print),  Next: Documentation on internals (pretty_print),  Prev: Usage and interface (pretty_print),  Up: A simple pretty-printer for Ciao programs

Documentation on exports (`pretty_print')
=========================================

 - PREDICATE: pretty_print/2:
     *Usage:* `pretty_print(Cls,Flags)'
        - *Description:* Prints each clause in the list `Cls' after
          numbering its variables.

        - *The following properties should hold at call time:*

          `pretty_print:clauses(Cls)'  (`pretty_print:clauses/1')

          `Flags' is a list of `flag's.   (`basic_props:list/2')

 - PREDICATE: pretty_print/3:
     *Usage:* `pretty_print(Cls,Flags,Ds)'
        - *Description:* Prints each clause in the list `Cls' after
          using the corresponding variable names dictionary in `Ds'
          to name its variables.

        - *The following properties should hold at call time:*

          `pretty_print:clauses(Cls)'  (`pretty_print:clauses/1')

          `Flags' is a list of `flag's.   (`basic_props:list/2')

          `Ds' is a dictionary of variable names.
          (`vndict:varnamedict/1')


File: ciao.info,  Node: Documentation on internals (pretty_print),  Prev: Documentation on exports (pretty_print),  Up: A simple pretty-printer for Ciao programs

Documentation on internals (`pretty_print')
===========================================

 - REGTYPE: clauses/1:
     A regular type, defined as follows:
               clauses([]).
               clauses([_1|_2]) :-
                       clause(_1),
                       clauses(_2).
               clauses(_1) :-
                       clause(_1).

     *Usage:*
        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: clause/1:
     A regular type, defined as follows:
               clause(_1) :-
                       clterm(_1).
               clause((_1,_2)) :-
                       clterm(_1),
                       term(_2).

     *Usage:*
        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: clterm/1:
     A regular type, defined as follows:
               clterm(clause(_1,_2)) :-
                       callable(_1),
                       body(_2).
               clterm(directive(_1)) :-
                       body(_1).
               clterm((_1:-_2)) :-
                       callable(_1),
                       body(_2).
               clterm(_1) :-
                       callable(_1).

     *Usage:*
        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: body/1:
     A well formed body, including cge expressions and &-concurrent
     expressions. The atomic goals may or may not have a key in the
     form `^(goal:any)', and may or may not be module qualified, but
     if they are it has to be in the form `^(^(moddesc:goal):any)'.

     *Usage:* `body(X)'
        - *Description:* `X' is a printable body.

        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')

 - REGTYPE: flag/1:
     A keyword `ask/1' flags whether to output *asks* or *whens* and
     `nl/1' whether to separate clauses with a blank line or not.

     *Usage:* `flag(X)'
        - *Description:* `X' is a flag for the pretty-printer.

        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')


File: ciao.info,  Node: Pretty-printing assertions,  Next: The Ciao library browser,  Prev: A simple pretty-printer for Ciao programs,  Up: Top

Pretty-printing assertions
**************************

   *Author(s):* Francisco Bueno Carrillo.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 1.3#45 (1999/8/5, 14:43:7 MEST)

   This module defines some predicates which are useful for writing
assertions in a readable form.

* Menu:

* Usage and interface (assrt_write)::
* Documentation on exports (assrt_write)::


File: ciao.info,  Node: Usage and interface (assrt_write),  Next: Documentation on exports (assrt_write),  Prev: Pretty-printing assertions,  Up: Pretty-printing assertions

Usage and interface (`assrt_write')
===================================

   * *Library usage:*

     `:- use_module(library(assrt_write)).'

   * *Exports:*
        - *Predicates:*

          `write_assertion/6', `write_assertion_as_comment/6'.

   * *Other modules used:*
        - *System library modules:*

          `format', `assertions/assrt_lib', `messages',
          `assertions/assrt_props'.



File: ciao.info,  Node: Documentation on exports (assrt_write),  Prev: Usage and interface (assrt_write),  Up: Pretty-printing assertions

Documentation on exports (`assrt_write')
========================================

 - PREDICATE: write_assertion/6:
     *Usage:* `write_assertion(Goal,Status,Type,Body,Dict,Flag)'
        - *Description:* Writes the (normalized) assertion to current
          output.

        - *Call and exit should be *compatible* with:*

          `undefined:assertion_status(Status)'  (undefined property)

          `Type' is an admissible kind of assertion.
          (`assrt_props:assrt_type/1')

          `undefined:assertion(Body)'  (undefined property)

          `undefined:dictionary(Dict)'  (undefined property)

          `Flag' is `status' or `nostatus'.
          (`assrt_write:status_flag/1')

 - PREDICATE: write_assertion_as_comment/6:
     *Usage:*
     `write_assertion_as_comment(Goal,Status,Type,Body,Dict,Flag)'
        - *Description:* Writes the (normalized) assertion to current
          output as a Prolog comment.

        - *Call and exit should be *compatible* with:*

          `undefined:assertion_status(Status)'  (undefined property)

          `Type' is an admissible kind of assertion.
          (`assrt_props:assrt_type/1')

          `undefined:assertion(Body)'  (undefined property)

          `undefined:dictionary(Dict)'  (undefined property)

          `Flag' is `status' or `nostatus'.
          (`assrt_write:status_flag/1')


File: ciao.info,  Node: The Ciao library browser,  Next: Code translation utilities,  Prev: Pretty-printing assertions,  Up: Top

The Ciao library browser
************************

   *Author(s):* Angel Fernandez Pineda.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 1.3#39 (1999/7/21, 12:8:4 MEST)

   `librowser' library provides a set of predicates wich enables the
user to interactively find CIAO/Prolog libraries and/or any predicate
exported by them.

   This is a simple example:

     ?- apropos('*find*').
     persdbrt_sql: dbfindall/4
     persdbrtsql: dbfindall/4
     conc_aggregates: findall/3
     linda: rd_findall/3
     vndict: find_name/4
     internals: $find_file/8
     aggregates: findall/4,findall/3
     
     yes
     ?-

   Librowser is specially usefull when using inside GNU Emacs, just
place the cursor over a librowser response and press C-cTAB in order
to get help on the related predicate. Refer to the *"Using CIAO
inside GNU Emacs"* chapter for further information.

* Menu:

* Usage and interface (librowser)::
* Documentation on exports (librowser)::
* Documentation on internals (librowser)::


File: ciao.info,  Node: Usage and interface (librowser),  Next: Documentation on exports (librowser),  Prev: The Ciao library browser,  Up: The Ciao library browser

Usage and interface (`librowser')
=================================

   * *Library usage:*

     It is not necesary to use this library at user programs. It was
     designed to be used at the CIAO *toplevel* shell: `ciaosh'. In
     order to do so, just make use of `use_module/1' as follows:

     `use_module(library(librowser))'.

     Then, the library interface must be read. This is automatically
     done when calling any predicate at librowser, and the entire
     process will take a little moment.So, you should want to perform
     such a process after loading the CIAO toplevel:

          CIAO 0.9 #75: Fri Apr 30 19:04:24 MEST 1999
          ?- use_module(library(librowser)).
          
          yes
          ?- update.

     Whether you want this process to be automatically performed when
     loading `ciaosh', you may include those lines in your *.ciaorc*
     personal initialization file.

   * *Exports:*
        - *Predicates:*

          `update/0', `browse/2', `where/1', `describe/1',
          `system_lib/1', `apropos/1'.

   * *Other modules used:*
        - *System library modules:*

          `filenames', `read', `system', `streams', `patterns',
          `lists'.



File: ciao.info,  Node: Documentation on exports (librowser),  Next: Documentation on internals (librowser),  Prev: Usage and interface (librowser),  Up: The Ciao library browser

Documentation on exports (`librowser')
======================================

 - PREDICATE: update/0:
     This predicate will scan the CIAO system libraries for predicate
     definitions. This may be done once time before calling any other
     predicate at this library.

     update/0 will also be automatically called (once) when calling
     any other predicate at librowser.

     *Usage:*
        - *Description:* Creates an internal database of modules at
          CIAO system libraries.

 - PREDICATE: browse/2:
     This predicate is fully reversible, and is provided to inspect
     concrete predicate specifications. For example:
          ?- browse(M,findall/A).
          
          A = 3,
          M = conc_aggregates ? ;
          
          A = 4,
          M = aggregates ? ;
          
          A = 3,
          M = aggregates ? ;
          
          no
          ?-

     *Usage:* `browse(Module,Spec)'
        - *Description:* Asocciates the given `Spec' predicate
          specification with the `Module' which exports it.

        - *The following properties should hold at call time:*

          `Module' is a module name (an atom)
          (`librowser:module_name/1')

          `Spec' is a *Functor/Arity* predicate specification
          (`librowser:pred_spec/1')

 - PREDICATE: where/1:
     This predicate will print at the screen the module needed in
     order to import a given predicate specification. For example:
          ?- where(findall/A).
          findall/3 exported at module conc_aggregates
          findall/4 exported at module aggregates
          findall/3 exported at module aggregates
          
          yes
          ?-

     *Usage:* `where(Spec)'
        - *Description:* Display what module to load in order to
          import the given `Spec'.

        - *The following properties should hold at call time:*

          `Spec' is a *Functor/Arity* predicate specification
          (`librowser:pred_spec/1')

 - PREDICATE: describe/1:
     This one is used to find out which predicates were exported by a
     given module. Very usefull when you know the library, but not
     the concrete predicate. For example:
          ?- describe(librowser).
          Predicates at library librowser :
          
          apropos/1
          system_lib/1
          describe/1
          where/1
          browse/2
          update/0
          
          yes
          ?-

     *Usage:* `describe(Module)'
        - *Description:* Display a list of exported predicates at the
          given `Module'

        - *The following properties should hold at call time:*

          `Module' is a module name (an atom)
          (`librowser:module_name/1')

 - PREDICATE: system_lib/1:
     It retrieves on backtracking all CIAO system libraries stored in
     the internal database. Certainly, those which were scanned at
     `update/0' calling.

     *Usage:* `system_lib(Module)'
        - *Description:* `Module' variable will be successively
          instantiated to the system libaries stored in the internal
          database.

        - *The following properties should hold at call time:*

          `Module' is a module name (an atom)
          (`librowser:module_name/1')

 - PREDICATE: apropos/1:
     This tool makes use of regular expresions in order to find
     predicate specifications. It is very usefull whether you can't
     renember the full name of a predicate. Regular expresions take
     the same format as described in library `patterns'. Example:
          ?- apropos('atom_*').
          
          metaterms: atom_concat/2
          concurrency: atom_lock_state/2
          atomic_basic: atom_concat/3,atom_length/2,atom_codes/2
          iso_byte_char: atom_chars/2
          
          yes
          ?-

     *Usage:* `apropos(RegSpec)'
        - *Description:* This will search any predicate specification
          `Spec' which matches the given `RegSpec' incomplete
          predicate specification.

        - *The following properties should hold at call time:*

          `RegSpec' is a Pattern/Arity specification.
          (`librowser:apropos_spec/1')


File: ciao.info,  Node: Documentation on internals (librowser),  Prev: Documentation on exports (librowser),  Up: The Ciao library browser

Documentation on internals (`librowser')
========================================

 - REGTYPE: apropos_spec/1:
     Defined as:
          apropos_spec(_1).
          apropos_spec(Pattern/Arity) :-
                  pattern(Pattern),
                  int(Arity).

     *Usage:* `apropos_spec(S)'
        - *Description:* `S' is a Pattern/Arity specification.

        - *The following properties should hold globally:*

          Defines a regular type.   (`basic_props:regtype/1')


File: ciao.info,  Node: Code translation utilities,  Next: conc_aggregates (library),  Prev: The Ciao library browser,  Up: Top

Code translation utilities
**************************

   *Author(s):* Angel Fernandez Pineda.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 1.3#110 (1999/11/22, 11:52:54 MET)

   This library offers a general way to perform clause body
expansions. Goal, fact and spec translation predicates are
authomatically called when needed, while this utility navigates
through the meta-argument specification of the body itself. All
predicates within this library must be called at *second-pass
expansions*, since it uses information stored at `c_itf' library.

* Menu:

* Usage and interface (expansion_tools)::
* Documentation on exports (expansion_tools)::
* Documentation on internals (expansion_tools)::
* Known bugs and planned improvements (expansion_tools)::


File: ciao.info,  Node: Usage and interface (expansion_tools),  Next: Documentation on exports (expansion_tools),  Prev: Code translation utilities,  Up: Code translation utilities

Usage and interface (`expansion_tools')
=======================================

   * *Library usage:*

     This library is provided as a tool for those modules which
     performs source-to-source code translation, usually known as
     *code expanders*. It may be loaded as other modules using a
     `use_module/1'. Nothing special needs to be done.

   * *Exports:*
        - *Predicates:*

          `imports_meta_pred/3', `body_expander/6', `arg_expander/6'.

   * *Other modules used:*
        - *System library modules:*

          `compiler/c_itf'.



File: ciao.info,  Node: Documentation on exports (expansion_tools),  Next: Documentation on internals (expansion_tools),  Prev: Usage and interface (expansion_tools),  Up: Code translation utilities

Documentation on exports (`expansion_tools')
============================================

 - PREDICATE: imports_meta_pred/3:
     Macro provided in order to know meta-predicate specifications
     accessible from a module.

     *Usage:* `imports_meta_pred(Module,MetaSpec,AccessibleAt)'
        - *Description:* Tells whether `MetaSpec' meta-predicate
          specification is accessible from `Module'. `AccessibleAt'
          will be binded to '-' whether meta-predicate is a builtin
          one. If not, it will be unified with the module which
          defines the meta-predicate.

        - *The following properties should hold at call time:*

          `Module' is an atom.   (`basic_props:atm/1')

          `MetaSpec' is any term.   (`basic_props:term/1')

          `AccessibleAt' is a free variable.   (`term_typing:var/1')

 - PREDICATE: body_expander/6:
     This predicate is the main translation tool. It navigates
     through a clause body, when a single *goal* appears, user-code
     is called in order to perform a translation. Whether user-code
     fails to translate the involved goal, it remains the same.
     Regardless that goal is translated or not, an argument expansion
     will be performed over all goals if applicable (see
     `arg_expander/6' predicate).

     Variable (unknown at compile time) goals will also be attempt to
     translate.

     *Meta-predicate* with arguments:
     `body_expander(pred(3),pred(3),pred(3),?,?,?)'.

     *Usage:*






     `body_expander(GoalTrans,FactTrans,SpecTrans,Module,Body,ExpandedBody)'
        - *Description:* Translates `Body' to `ExpandedBody' by the
          usage of user-defined translators `GoalTrans', `FactTrans'
          and `SpecTrans'. The module where the original body appears
          must be unified with `Module' argument.

        - *The following properties should hold at call time:*

          `GoalTrans' is a user-defined predicate which performs
          *goal* meta-type translation
          (`expansion_tools:goal_expander/1')

          `FactTrans' is a user-defined predicate which performs
          *fact* meta-type translation
          (`expansion_tools:fact_expander/1')

          `SpecTrans' is a user-defined predicate which performs
          *spec* meta-type translation
          (`expansion_tools:spec_expander/1')

          `Module' is an atom.   (`basic_props:atm/1')

          `Body' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')

          `ExpandedBody' is a free variable.   (`term_typing:var/1')

 - PREDICATE: arg_expander/6:
     This predicate is an auxiliary translation tool, which is used by
     `body_expander/6' predicate. It remains exported as a macro. The
     predicate navigates through the *meta-argument specification* of
     a goal. Whether a *goal,fact or spec* argument appears,
     user-code is called in order to perform a translation. Whether
     user-code fails to translate the involved argument, it remains
     the same. Builtins as ','/2 or ';'/2 are treated as
     meta-predicates defining *goal* meta-arguments. When a *goal*
     meta-argument is located, `body_expander/6' will be called in
     order to navigate through it. Notice that a *goal* meta-argument
     may be unified with another goal defining another meta-argument,
     so navigation is required. If arguments are not known to
     arg_expander/6, translation will not occur. This is posible
     whether goal or qualifing module are variables.

     *Meta-predicate* with arguments:
     `arg_expander(pred(3),pred(3),pred(3),?,?,?)'.

     *Usage:*





     `arg_expander(GoalTrans,FactTrans,SpecTrans,Module,Goal,ExpandedGoal)'
        - *Description:* Translates `Goal' to `ExpandedGoal' by
          applying user-defined translators (`GoalTrans', `FactTrans'
          and `SpecTrans') to each meta-argument present at such
          goal. The module where the original goal appears must be
          unified with `Module' argument.

        - *The following properties should hold at call time:*

          `GoalTrans' is a user-defined predicate which performs
          *goal* meta-type translation
          (`expansion_tools:goal_expander/1')

          `FactTrans' is a user-defined predicate which performs
          *fact* meta-type translation
          (`expansion_tools:fact_expander/1')

          `SpecTrans' is a user-defined predicate which performs
          *spec* meta-type translation
          (`expansion_tools:spec_expander/1')

          `Module' is an atom.   (`basic_props:atm/1')

          `Goal' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')

          `ExpandedBody' is a free variable.   (`term_typing:var/1')


File: ciao.info,  Node: Documentation on internals (expansion_tools),  Next: Known bugs and planned improvements (expansion_tools),  Prev: Documentation on exports (expansion_tools),  Up: Code translation utilities

Documentation on internals (`expansion_tools')
==============================================

 - PROPERTY: expander_pred/1:
     *Usage:* `expander_pred(Pred)'
        - *Description:* `Pred' is a user-defined predicate used to
          perform code translations. First argument will be binded to
          the corresponding term to be translated. Second argument
          must be binded to the corresponding translation. Third
          argument will be binded to the current module were first
          argument appears. Additional arguments will be user-defined.


File: ciao.info,  Node: Known bugs and planned improvements (expansion_tools),  Prev: Documentation on internals (expansion_tools),  Up: Code translation utilities

Known bugs and planned improvements (`expansion_tools')
=======================================================

   * *pred(N)* meta-arguments are not supported at this moment.


File: ciao.info,  Node: conc_aggregates (library),  Next: *** PART VII - Ciao Prolog extensions,  Prev: Code translation utilities,  Up: Top

conc_aggregates (library)
*************************

   *Author(s):* Concurrent-safe (and incomplete) version of the
aggregates predicates, based on the regular versions by Richard A.
O'Keefe and David H.D. Warren. Concurrency-safeness provided by
Manuel Carro..

   This module implements thread-safe aggregation predicates. Its use
and results should be the same as those in the aggregates library,
but several goals can use them concurrently without the interference
and wrong results (due to implementation reasons) aggregates might
lead to. This particular implementation is completely based on the
one used in the aggregates library.

* Menu:

* Usage and interface (conc_aggregates)::
* Documentation on exports (conc_aggregates)::
* Known bugs and planned improvements (conc_aggregates)::


File: ciao.info,  Node: Usage and interface (conc_aggregates),  Next: Documentation on exports (conc_aggregates),  Prev: conc_aggregates (library),  Up: conc_aggregates (library)

Usage and interface (`conc_aggregates')
=======================================

   * *Library usage:*

     `:- use_module(library(conc_aggregates)).'

   * *Exports:*
        - *Predicates:*

          `findall/3'.



File: ciao.info,  Node: Documentation on exports (conc_aggregates),  Next: Known bugs and planned improvements (conc_aggregates),  Prev: Usage and interface (conc_aggregates),  Up: conc_aggregates (library)

Documentation on exports (`conc_aggregates')
============================================

 - PREDICATE: findall/3:
     *Meta-predicate* with arguments: `findall(?,goal,?)'.

     *Usage:* `findall(?(Template),+Generator,?(List))' < * ISO * >
        - *Description:* A special case of bagof, where all free
          variables in the `Generator' are taken to be existentially
          quantified. Safe in concurrent applications.


File: ciao.info,  Node: Known bugs and planned improvements (conc_aggregates),  Prev: Documentation on exports (conc_aggregates),  Up: conc_aggregates (library)

Known bugs and planned improvements (`conc_aggregates')
=======================================================

   * Thread-safe `setof/3' is not yet implemented.

   * Thread-safe `bagof/3' is not yet implemented.

   * Incomplete, not all predicates rewritten.


File: ciao.info,  Node: *** PART VII - Ciao Prolog extensions,  Next: Pure Prolog package,  Prev: conc_aggregates (library),  Up: Top

PART VII - Ciao Prolog extensions
*********************************

   The libraries documented in this part extend the Ciao language in
several different ways. The extensions include:
   * pure Prolog programming (although someone might view this as a
     restriction rather than an extension);

   * feature terms or *records* (i.e., structures with names for each
     field);

   * parallel (programming;

   * functional syntax;

   * global variables;

   * `setarg' and `undo';

   * active modules;

   * breadth-first execution;

   * constraint logic programming;

   * object oriented programming.


File: ciao.info,  Node: Pure Prolog package,  Next: argnames (library),  Prev: *** PART VII - Ciao Prolog extensions,  Up: Top

Pure Prolog package
*******************

   This library package allows the use of *pure Prolog* in a Ciao
module/program. It is based on the fact that if an *engine module* is
imported explicitly then all of them have to be imported explicitly.
The engine modules are:
   * `engine(arithmetic)'

     *Note Arithmetic::.

   * `engine(atomic_basic)'

     *Note Basic predicates handling names of constants::.

   * `engine(attributes)'

     *Note Attributed variables::.

   * `engine(basic_props)'

     *Note Basic data types and properties::.

   * `engine(basiccontrol)'

     *Note Control constructs/predicates::.

   * `engine(concurrency)'

     *Note Concurrency/multithreading primitives::.

   * `engine(data_facts)'

     *Note Fast/concurrent update of facts::.

   * `engine(exceptions)'

     *Note Exception handling::.

   * `engine(io_aux)'

     *Note Message printing primitives::.

   * `engine(io_basic)'

     *Note Basic input/output::.

   * `engine(prolog_flags)'

     *Note Changing system behaviour and various flags::.

   * `engine(streams_basic)'

     *Note Basic file/stream handling::.

   * `engine(system_info)'

     *Note Gathering some basic internal info::.

   * `engine(term_basic)'

     *Note Basic term manipulation::.

   * `engine(term_compare)'

     *Note Comparing terms::.

   * `engine(term_typing)'

     *Note Extra-logical properties for typing::.

   Note that if any of these modules is explicitely imported in a
program then the language defaults to Pure Prolog, plus the
functionality added by the modules explicitely imported.

   It is recommended that if you explicitely import an engine module
you also use this package, which will guarantee that the predicate
`true/0' is defined (note that this is the only Ciao builtin which
cannot be redefined).

* Menu:

* Usage and interface (pure)::


File: ciao.info,  Node: Usage and interface (pure),  Prev: Pure Prolog package,  Up: Pure Prolog package

Usage and interface (`pure')
============================

   * *Library usage:*

     `:- use_package(pure).'

     or

     `:- module(...,...,[pure]).'


File: ciao.info,  Node: argnames (library),  Next: Independent and-parallel execution,  Prev: Pure Prolog package,  Up: Top

argnames (library)
******************

* Menu:

* Usage and interface (argnames)::


File: ciao.info,  Node: Usage and interface (argnames),  Prev: argnames (library),  Up: argnames (library)

Usage and interface (`argnames')
================================

   * *Library usage:*

     `:- use_package(argnames).'

     or

     `:- module(...,...,[argnames]).'

   * *New operators defined:*

     `$/2' [150,xfx], `=>/2' [950,xfx], `argnames/1' [1150,fx].

   * *Other modules used:*
        - *System library modules:*

          `aggregates', `dynamic', `iso_misc', `iso_byte_char',
          `iso_incomplete', `operators', `read', `streams', `write'.



File: ciao.info,  Node: Independent and-parallel execution,  Next: functions (library),  Prev: argnames (library),  Up: Top

Independent and-parallel execution
**********************************

   *Author(s):* Manuel Hermenegildo, Manuel Carro.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   This library allows and-parallel execution of goals in
(Herbrand-)independent fashion. It resembles the execution rules of
[HG90]. Basically, goals are run in and-parallel *provided that their
arguments do not share bindings*, i.e., are not bound to terms which
contain a common variable.

   Beware: it is highly unstable at the moment!

* Menu:

* Usage and interface (andprolog)::
* Documentation on exports (andprolog)::
* Known bugs and planned improvements (andprolog)::


File: ciao.info,  Node: Usage and interface (andprolog),  Next: Documentation on exports (andprolog),  Prev: Independent and-parallel execution,  Up: Independent and-parallel execution

Usage and interface (`andprolog')
=================================

   * *Library usage:*

     `:- use_module(library(andprolog)).'

   * *Exports:*
        - *Predicates:*

          `=>/2', `active_agents/1'.

        - *Properties:*

          `indep/1', `indep/2'.

   * *Other modules used:*
        - *System library modules:*

          `assertions/doc_props'.



File: ciao.info,  Node: Documentation on exports (andprolog),  Next: Known bugs and planned improvements (andprolog),  Prev: Usage and interface (andprolog),  Up: Independent and-parallel execution

Documentation on exports (`andprolog')
======================================

 - PREDICATE: &/2:
     `GoalA & GoalB'

     `GoalA' and `GoalB' are run in independent and-parallel fashion.
     This is just a first sketch, and valid only for deterministic
     independent goals.

     *Meta-predicate* with arguments: `goal&goal'.


 - PREDICATE: =>/2:
     `=>(A,B)'

     If `A' is true `B' is run in parallel, otherwise sequentially.

     *Meta-predicate* of type *implicit* with arguments:
     `=>(goal,goal)'.

     *Usage:* `=>(A,B)'
        - *The following properties should hold at call time:*

          `B' is of the form `goal&goal'.
          (`andprolog:andcallable/1')

        - *The following properties hold globally:*

          Documentation is still incomplete: `=>(A,B)' may not
          conform the functionality documented.
          (`doc_props:doc_incomplete/1')

 - PROPERTY: indep/1:
     `indep(X)'

     The variables in each pair of the list ``X'' are pairwise
     independent.

     *Usage:* `indep(X)'
        - *Description:* The variables in pairs in ``X'' are pairwise
          independent.

 - PROPERTY: indep/2:
     `indep(X,Y)'

     `X' and `Y' are *independent*, i.e., they are bound to terms
     which have no variables in common. For example, `indep(X,Y)'
     holds for `X=f(Z),Y=g(K)' and also for `X=f(a),Y=X' (since both
     `X' and `Y' are bound to ground terms). It does not hold for
     `X=f(Z),Y=g(Z)' and for `X=Y'.

     *Usage:* `indep(X,Y)'
        - *Description:* `X' and `Y' do not have variables in common.

 - PREDICATE: active_agents/1:
     *Usage:* `active_agents(?(NumberOfAgents))'
        - *Description:* Tests/sets the number of active agents
          looking for goals to execute. As for now, those agents are
          resource-consuming, even when they are just looking for
          work, and not executing any user goals.

        - *The following properties should hold at call time:*

          `?(NumberOfAgents)' is an integer.   (`basic_props:int/1')


File: ciao.info,  Node: Known bugs and planned improvements (andprolog),  Prev: Documentation on exports (andprolog),  Up: Independent and-parallel execution

Known bugs and planned improvements (`andprolog')
=================================================

   * The fact that only the first solution is returned for the
     conjunction is due to performance matters, and we expect to
     remove it in a near future.

   * CGEs (i.e., `=>') are not supported.

   * The `indep/1', `indep/2', and `ground/1' are not very efficient;
     they might be replaced by native versions in a future.


File: ciao.info,  Node: functions (library),  Next: global (library),  Prev: Independent and-parallel execution,  Up: Top

functions (library)
*******************

* Menu:

* Usage and interface (functions)::


File: ciao.info,  Node: Usage and interface (functions),  Prev: functions (library),  Up: functions (library)

Usage and interface (`functions')
=================================

   * *Library usage:*

     `:- use_package(functions).'

     or

     `:- module(...,...,[functions]).'

   * *New operators defined:*

     `function/1' [1150,fx], `:=/2' [800,xfx], `~/1' [50,fx].

   * *Other modules used:*
        - *System library modules:*

          `aggregates', `dynamic', `iso_misc', `iso_byte_char',
          `iso_incomplete', `operators', `read', `streams', `write'.



File: ciao.info,  Node: global (library),  Next: Miscellaneous predicates,  Prev: functions (library),  Up: Top

global (library)
****************

   *Version:* 0.4#5 (1998/2/24)

* Menu:

* Usage and interface (global)::
* Documentation on exports (global)::


File: ciao.info,  Node: Usage and interface (global),  Next: Documentation on exports (global),  Prev: global (library),  Up: global (library)

Usage and interface (`global')
==============================

   * *Library usage:*

     `:- use_module(library(global)).'


File: ciao.info,  Node: Documentation on exports (global),  Prev: Usage and interface (global),  Up: global (library)

Documentation on exports (`global')
===================================

 - PREDICATE: set_global/2:
     No further documentation available for this predicate.


 - PREDICATE: get_global/2:
     No further documentation available for this predicate.


 - PREDICATE: push_global/2:
     No further documentation available for this predicate.


 - PREDICATE: pop_global/2:
     No further documentation available for this predicate.


 - PREDICATE: del_global/1:
     No further documentation available for this predicate.



File: ciao.info,  Node: Miscellaneous predicates,  Next: actmods (library),  Prev: global (library),  Up: Top

Miscellaneous predicates
************************

   *Author(s):* Manuel Carro, Daniel Cabeza.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 1.3#95 (1999/11/8, 18:37:30 MET)

   This module implements some miscellaneous non-logical (but
sometimes very useful) predicates.

* Menu:

* Usage and interface (odd)::
* Documentation on exports (odd)::


File: ciao.info,  Node: Usage and interface (odd),  Next: Documentation on exports (odd),  Prev: Miscellaneous predicates,  Up: Miscellaneous predicates

Usage and interface (`odd')
===========================

   * *Library usage:*

     `:- use_module(library(odd)).'

   * *Exports:*
        - *Predicates:*

          `setarg/3', `undo/1'.



File: ciao.info,  Node: Documentation on exports (odd),  Prev: Usage and interface (odd),  Up: Miscellaneous predicates

Documentation on exports (`odd')
================================

 - PREDICATE: setarg/3:
     *Usage:* `setarg(Index,Term,NewArg)'
        - *Description:* Replace destructively argument `Index' in
          `Term' by `NewArg'. The assignment is undone on
          backtracking. This is a major change to the normal behavior
          of data assignment in CIAO Prolog.

        - *The following properties should hold at call time:*

          `Index' is currently instantiated to an integer.
          (`term_typing:integer/1')

          `Term' is a compound term.   (`basic_props:struct/1')

          `NewArg' is any term.   (`basic_props:term/1')

        - *The following properties hold upon exit:*

          `Index' is currently instantiated to an integer.
          (`term_typing:integer/1')

          `Term' is a compound term.   (`basic_props:struct/1')

          `NewArg' is any term.   (`basic_props:term/1')

 - PREDICATE: undo/1:
     *Usage:* `undo(Goal)'
        - *Description:*  `call(`Goal')' is executed on backtracking.
          This is a major change to the normal control of CIAO Prolog
          execution.

        - *The following properties should hold at call time:*

          `Goal' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')

        - *The following properties hold upon exit:*

          `Goal' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')


File: ciao.info,  Node: actmods (library),  Next: Breadth-first execution,  Prev: Miscellaneous predicates,  Up: Top

actmods (library)
*****************

* Menu:

* Usage and interface (actmods)::


File: ciao.info,  Node: Usage and interface (actmods),  Prev: actmods (library),  Up: actmods (library)

Usage and interface (`actmods')
===============================

   * *Library usage:*

     `:- use_package(actmods).'

     or

     `:- module(...,...,[actmods]).'

   * *Other modules used:*
        - *System library modules:*

          `actmods/actmodrt', `aggregates', `dynamic', `iso_misc',
          `iso_byte_char', `iso_incomplete', `operators', `read',
          `streams', `write'.



File: ciao.info,  Node: Breadth-first execution,  Next: Constraint programming over rationals,  Prev: actmods (library),  Up: Top

Breadth-first execution
***********************

   *Author(s):* Daniel Cabeza, Manuel Carro.

   This package implements breadth-first execution of predicates.
Predicates written with operators `'<-'/1' (facts) and `'<-'/2'
(clauses) are executed using breadth-first search. An example of code
would be:
     :- module(bf_example, _, [bf]).
     
     test(bf) :- bfchain(a,d).
     test(df) :- chain(a,d).   % loops!
     
     bfchain(X,X) <- .
     bfchain(X,Y) <- arc(X,Z), bfchain(Z,Y).
     
     chain(X,X).
     chain(X,Y) :- arc(X,Z), chain(Z,Y).
     
     arc(a,b).
     arc(a,d).
     arc(b,c).
     arc(c,a).

* Menu:

* Usage and interface (bf)::
* Known bugs and planned improvements (bf)::


File: ciao.info,  Node: Usage and interface (bf),  Next: Known bugs and planned improvements (bf),  Prev: Breadth-first execution,  Up: Breadth-first execution

Usage and interface (`bf')
==========================

   * *Library usage:*

     `:- use_package(bf).'

     or

     `:- module(...,...,[bf]).'

   * *New operators defined:*

     `<-/2' [1200,xfx], `<-/1' [1200,xf].


File: ciao.info,  Node: Known bugs and planned improvements (bf),  Prev: Usage and interface (bf),  Up: Breadth-first execution

Known bugs and planned improvements (`bf')
==========================================

   * Does not correctly work in user files.


File: ciao.info,  Node: Constraint programming over rationals,  Next: Constraint programming over reals,  Prev: Breadth-first execution,  Up: Top

Constraint programming over rationals
*************************************

   *Author(s):* Christian Holzbaur, Daniel Cabeza.

   This package is currently under development.

* Menu:

* Usage and interface (clpq)::


File: ciao.info,  Node: Usage and interface (clpq),  Prev: Constraint programming over rationals,  Up: Constraint programming over rationals

Usage and interface (`clpq')
============================

   * *Library usage:*

     `:- use_package(clpq).'

     or

     `:- module(...,...,[clpq]).'


File: ciao.info,  Node: Constraint programming over reals,  Next: Object oriented programming,  Prev: Constraint programming over rationals,  Up: Top

Constraint programming over reals
*********************************

   *Author(s):* Christian Holzbaur, Daniel Cabeza.

   This package is currently under development.

* Menu:

* Usage and interface (clpr)::


File: ciao.info,  Node: Usage and interface (clpr),  Prev: Constraint programming over reals,  Up: Constraint programming over reals

Usage and interface (`clpr')
============================

   * *Library usage:*

     `:- use_package(clpr).'

     or

     `:- module(...,...,[clpr]).'


File: ciao.info,  Node: Object oriented programming,  Next: Declaring classes and interfaces,  Prev: Constraint programming over reals,  Up: Top

Object oriented programming
***************************

   *Author(s):* Angel Fernandez Pineda.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 1.3#63 (1999/9/29, 19:54:17 MEST)

   O'CIAO is a set of libraries which allows object-oriented
programming in CIAO Prolog. It extends the CIAO Prolog module system
by introducing two new concepts:

   * Inheritance.

   * Instantiation.

   *Polymorphism* is the third fundamental concept provided by object
oriented programming. This concept is not mentioned here since
*traditional PROLOG systems are polymorphic by nature*.

   Classes are declared in the same way as modules. However, they may
be enriched with inheritance declarations and other object-oriented
constructs. For an overview of the fundamentals of O'CIAO, see
`http://www.clip.dia.fi.upm.es/~clip/papers/ociao-tr.ps.gz'. However,
we will introduce the concepts in a tutorial way via examples.

* Menu:

* Early examples:::
* Recommendations on when to use objects:::
* Limitations on object usage:::


File: ciao.info,  Node: Early examples:,  Next: Recommendations on when to use objects:,  Prev: Object oriented programming,  Up: Object oriented programming

Early examples:
===============

   The following one is a very simple example which declares a class
- a simple stack. Note that if you replace *class/1* declaration with
a *module/1* declaration, it will compile correctly, and can be used
as a normal Prolog module.

     %%--------------------------------------------%%
     %% class/1, at the beginning of the file,     %%
     %% will declare current source to be a class. %%
     %%--------------------------------------------%%
     :- class(stack,[],[]).
     
     % State declaration: storage/1 will be an attribute.
     :- dynamic storage/1.
     
     % Interface declaration: the following predicates will
     % be available at run-time.
     
     :- export(push/1).
     :- export(pop/1).
     :- export(top/1).
     :- export(is_empty/0).
     
     % Code
     
     push(Item) :-
             nonvar(Item),
             asserta_fact(storage(Item)).
     
     pop(Item) :-
             var(Item),
             retract_fact(storage(Item)).
     
     top(Top) :-
             storage(Top),
             !.
     
     is_empty :-
             storage(_),
             !,
             fail.
     
     is_empty.

   If we load this code at the CIAO toplevel shell:

             ?- use_package(objects).
     
             yes
             ?- use_class(library('class/examples/stack')).
     
             yes
             ?-

   we can create two stack *instances* :

             ?- St1 new stack,St2 new stack.
     
             St1 = '9254074093385163',
             St2 = '9254074091' ? ,

   and then, we can operate on them separately:

             1 ?- St1:push(8),St2:push(9).
     
             St1 = '9254074093385163',
             St2 = '9254074091' ?
     
             yes
             1 ?- St1:top(I),St2:top(K).
     
             I = 8,
             K = 9,
             St1 = '9254074093385163',
             St2 = '9254074091' ?
     
             yes
             1 ?-

   The interesting point is that there are two stacks. If the
previous example had been a normal module, we would have a stack ,
but *only one* stack.

   The next example introduces the concepts of *inheritable*
predicate, *constructor*, *destructor* and *virtual method*. Refer to
the following sections for further explanation.

     %%----------------------------------%%
     %% A generic class to perform       %%
     %% item storage.                    %%
     %%----------------------------------%%
     :- class(generic).
     
     % Public interface declaration:
     :- export([set/1,get/1,callme/0]).
     
     % An attribute
     :- data datum/1.
     
     % inheritable/1 is used for datum/1
     % to become available to descendant
     % classes (if any).
     :- inheritable(datum/1).
     
     % Attribute initialization. Attributes
     % are easily initialized by writing clauses
     % for them.
     
     datum(none).
     
     % Code
     
     set(X) :-
             type_check(X),
             set_fact(datum(X)).
     
     get(X) :-
             datum(X).
     
     :- virtual type_check/1.
     
     type_check(X) :-
             nonvar(X).
     
     callme :-
             a_virtual(IMPL),
             display(IMPL),
             display(' implementation of a_virtual/0 '),
             nl.
     
     % virtual/1 will tell the compiler to use the most
     % descendant implementation of a_virtual/1 when calling
     % it from inside this code (for example,see callme/0).
     % If there is no descendant implementation for it,
     % the one defined bellow will be used.
     
     :- virtual a_virtual/1.
     a_virtual(generic).
     
     % Constructor: in this case, every time an instance
     % of this class is created, it will display a message.
     
     generic :-
             display(' generic class constructor '),
             nl.
     
     % Destructor: analogous to the previous constructor,
     % it will display a message every time an instance
     % of this class is eliminated.
     
     destructor :-
             display(' generic class destructor '),
             nl.

   And the following example, is an extension of previous class. This
is performed by establishing an inheritance relationship:

     %%----------------------------------%%
     %% This class provides additional   %%
     %% functionality to the generic     %%
     %% class.                           %%
     %%----------------------------------%%
     
     :- class(specific).
     
     % establish an inheritance relationship with "generic" class.
     :- inherit_class(library('class/examples/generic')).
     
     % override inherited datum/1.
     % datum/1 is said to be overriden because there are both
     % an inherited definition (from "generic" class) and a local one.
     
     :- data datum/1.
     :- inheritable datum/1.
     
     % Extend the public interface inherited from "generic".
     % note that set/1 and a_virtual/0 has been also overriden.
     % undo/0 is a new added functionality.
     
     :- export([set/1,undo/0]).
     
     % Code
     
     set(Value) :-
             inherited datum(OldValue),
             !,
             inherited set(Value),
             asserta_fact(datum(OldValue)).
     
     
     set(Value) :-
             inherited set(Value).
     
     undo :-
             retract_fact(datum(Last)),
             !,
             asserta_fact(inherited(datum(Last))).
     
     undo :-
             retractall_fact(inherited(datum(_))).
     
     % new implementation of a_virtual. This
     % implementation will be used from inherited callme/0
     % instead of that version defined at "generic".
     
     a_virtual(specific).
     
     % constructor
     
     specific :-
             generic,
             retractall_fact(inherited(datum(_))),
             display(' specific class constructor '),
             nl.
     
     % destructor
     
     destructor :-
             display(' specific class destructor '),
             nl.

   *Additional examples* may be found on the *library/class/examples*
directory relative to your CIAO Prolog instalation.


File: ciao.info,  Node: Recommendations on when to use objects:,  Next: Limitations on object usage:,  Prev: Early examples:,  Up: Object oriented programming

Recommendations on when to use objects:
=======================================

   We would like to give some advice in the use of object oriented
programming, in conjunction with the declarative paradigm.

   You should reconsider using O'CIAO in the following cases:

   * The pretended "objects" have no state,i.e., no data or dynamic
     predicates. In this case, a normal module will suffice.

   * There is state, but there will be only one instance of a
     pretended class. Again, a module suffices.

   * The "objects" are data structures (list,trees,etc) already
     supported by Prolog. However, it does make sense to model, using
     objects, data structures whose change implies a side-effect such
     as drawing a particular window on the screen.

   We recommend the usage of O'CIAO in the following cases:

   * You feel you will need to have several copies of a "module".

   * Local copies of a module are needed instead of a global module
     beeing modified by several ones.

   * The "classes" are a representation of external entities to
     Prolog. For example: the X-Window system.

   * There is state or code outside the Prolog system which needs to
     be manipulated. For example: interfaces to Java or Tcl/Tk code.

   * You are not familiar with Prolog, but you know about object
     oriented programming. O'CIAO may be used as a learning tool to
     introduce yourself on the declarative programming paradigm.


File: ciao.info,  Node: Limitations on object usage:,  Prev: Recommendations on when to use objects:,  Up: Object oriented programming

Limitations on object usage:
============================

   O'CIAO run-time speed is limited by the usage of meta-programming
structures, for instance: `X = (Object:mymethod(25)), call(X)'.
O'CIAO will optimize static manipulation of objects (those that can
be determined at compile time).


File: ciao.info,  Node: Declaring classes and interfaces,  Next: Error reporting when compiling classes and interfaces,  Prev: Object oriented programming,  Up: Top

Declaring classes and interfaces
********************************

   *Author(s):* Angel Fernandez Pineda.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 1.3#76 (1999/10/13, 18:29:1 MEST)

   O'CIAO classes are declared in the same way as traditional prolog
modules. The general mechanism of *source expansion* will translate
object-oriented declarations to normal prolog code. This is done
transparently to the user.

   Abstract *interfaces* are restricted classes which declare
exported predicates with no implementation. The implementation itselt
will be provided by some class using an `implements/1' declaration.
Only `export/1' and `data/1' declarations are allowed when declaring
an interface. Normal classes may treated as interfaces just ignoring
all exported predicate implementations.

* Menu:

* Usage and interface (class)::
* Documentation on new declarations (class)::
* Documentation on exports (class)::
* Known bugs and planned improvements (class)::


File: ciao.info,  Node: Usage and interface (class),  Next: Documentation on new declarations (class),  Prev: Declaring classes and interfaces,  Up: Declaring classes and interfaces

Usage and interface (`class')
=============================

   * *Library usage:*

     To declare a class the compiler must be told to use the `class'
     *source expansion*. To do so, source code must start with a
     module declaration which loads the class package:
                     :- class(ClassName).

     or a `module/3' declaration, as follows:
                     :- module(ClassName,[],[class]).

     interfaces are declared in a similar way:
                     :- interface(InterfaceName).

     Please, do not use SICStus-like module declaration, with a
     non-empty export list. In other case, some non-sense errors will
     be reported by normal CIAO module system.

     Most of the regular CIAO declarations may be used when defining
     a class, such as `concurrent/1', `dynamic/1', `discontiguous/1',
     `multifile/1', and so on.

     However, there are some restrictions wich apply to those
     declarations:
        * `meta_predicate/1' declaration is not allowed to hold
          *addmodule and pred(N) meta-arguments*, except for
          previously declared multifiles.

        * Attribute and multifile predicates must be declared before
          any clause of the related predicate.

        * There is no sense in declaring an attribute as
          meta_predicate.

     It is a good practique to put all your declarations at the very
     begining of the file, just before the code itself.

   * *Exports:*
        - *Predicates:*

          `inherited/1', `self/1', `constructor/0', `destructor/0'.

   * *New declarations defined:*

     `export/1', `public/1', `inheritable/1', `data/1', `dynamic/1',
     `concurrent/1', `inherit_class/1', `implements/1', `virtual/1'.

   * *Other modules used:*
        - *System library modules:*

          `objects/objects_rt'.



File: ciao.info,  Node: Documentation on new declarations (class),  Next: Documentation on exports (class),  Prev: Usage and interface (class),  Up: Declaring classes and interfaces

Documentation on new declarations (`class')
===========================================

 - DECLARATION: export/1:
     Declares a method or attribute to be part of the *public
     interface*.

     The public interface is the set of predicates wich will be
     accesible from any code establishing an usage relationship with
     this class (see `use_class/1' for further information).

     Publishing an attribute or method is very similar to *exporting*
     a predicate in a Prolog module.

     Whether an inherited and exported predicate is overriden, it
     must be explicitly exported again.

     An inherited (but not exported) predicate may become exported,
     without overriding it by the usage of this declaration.

     *Usage:* :- `export(Spec)'.
        - *Description:* `Spec' will be part of the public (exported)
          interface.

        - *The following properties should hold at call time:*

          `Spec' is a method or attribute specification.
          (`objects_rt:method_spec/1')

 - DECLARATION: public/1:
     Just an alias for `export/1'.

     *Usage:* :- `public(Spec)'.
        - *Description:* This declaration may be used instead of
          `export/1'.

        - *The following properties should hold at call time:*

          `Spec' is a method or attribute specification.
          (`objects_rt:method_spec/1')

 - DECLARATION: inheritable/1:
     Declares a method or attribute to be inherited by descendant
     classes. Notice that all *public predicates are inheritable by
     default*. There is no need to mark them as inheritable.

     Traditionaly, object oriented languages makes use of the
     *protected* concept. Inheritable/1 may be used as the same
     concept.

     The set of inheritable predicates is called the *inheritable
     interface*.

     *Usage:* :- `inheritable(MethodSpec)'.
        - *Description:* `MethodSpec' is accessible to descendant
          classes.

        - *The following properties should hold at call time:*

          `MethodSpec' is a method or attribute specification.
          (`objects_rt:method_spec/1')

 - DECLARATION: data/1:
     Declares an *attribute* at current class. Attributes are used to
     build the internal state of instances. So, each instance will
     own a particular copy of those attribute definitions. In this
     way, one instance may have different state from another.

     O'CIAO attributes are restricted to hold simple facts. It is not
     possible to hold a Head :- Body clause at an instance attribute.

     Notice that attributes are *multi-evaluated* by nature, and may
     be manipulated by the habitual *assert/retract* family of
     predicates.

     Attributes may also be initialized. In order to do so, simply
     put some clauses after the attribute definition. Each time an
     instance is created, its initial state will be built from those
     *initialization clauses*.

     Note: whether a data/1 declaration appears inside an interface,
     it will be automatically exported.

     *Usage:* :- `data Spec'.
        - *Description:* `Spec' is an attribute.

        - *The following properties should hold at call time:*

          `Spec' is a method or attribute specification.
          (`objects_rt:method_spec/1')

 - DECLARATION: dynamic/1:
     Just an alias for `data/1'.

     *Usage:* :- `dynamic Spec'.
        - *Description:* You may use this declaration instead of
          `data/1'.

        - *The following properties should hold at call time:*

          `Spec' is a method or attribute specification.
          (`objects_rt:method_spec/1')

 - DECLARATION: concurrent/1:
     Declares a *concurrent attribute* at current class. Concurrent
     attributes are just the same as normal attributes, those
     declared using `data/1', except for they may freeze the calling
     thread instead of failing when no more choice points are
     remaining on the concurrent attribute.

     In order to get more information about concurrent behavior take
     a look to the concurrent/1 built-in declaration on CIAO Prolog
     module system.

     *Usage:* :- `concurrent Spec'.
        - *Description:* Declares `Spec' to be a concurrent attribute.

        - *The following properties should hold at call time:*

          `Spec' is a method or attribute specification.
          (`objects_rt:method_spec/1')

 - DECLARATION: inherit_class/1:
     Makes any public and/or inheritable predicate at inherited class
     to become accesible by any instance derived from current class.

     Inherited class is also called the *super class*.

     Only one inherit_class/1 declaration is allowed to be present at
     current source.

     Notice that inheritance is public by default. Any public and/or
     inheritable declaration will remain the same to descendant
     classes. However, any inherited predicate may be *overriden*
     (redefined).

     A predicate is said to be *overriden* when it has been inherited
     from super class, but there are clauses (or a `data/1'
     declaration) present at current class for such a predicate.

     Whether a *public* predicate is overriden, the local definition
     must also be exported, otherwise an error is reported.

     Whether an *inheritable* predicate (not public) is overriden,
     the local definition must also be marked as inheritable or
     exported, otherwise an error is also reported.

     Note: whether inherit_class/1 appears inside an interface, it
     will be used as an `implements/1' declaration.

     *Usage:* :- `inherit_class(Source)'.
        - *Description:* Establish an *inheritance relationship*
          between current class and the class defined at `Source'
          file.

        - *The following properties should hold at call time:*

          `Source' is a valid path to a prolog file containing a
          class declaration (without .pl extension).
          (`objects_rt:class_source/1')

 - DECLARATION: implements/1:
     Forces current source to provide an implementation for the given
     interface file. Such interface file may declare another class or
     a specific interface. Interface files are described at
     `interface_doc' library.

     Every public predicate present at given interface file will be
     automatically declared as public at current source, so you
     *must* provide an implementation for such predicates.

     The effect of this declaration is called *interface
     inheritance*,and there is no restriction on the number of
     implements/1 declarations present at current code.

     *Usage:* :- `implements(Interface)'.
        - *Description:* Current source is supposed to provide an
          implementation for `Interface'.

        - *The following properties should hold at call time:*

          `Interface' is a valid path to a prolog file containing a
          class declaration or an interface declaration (without .pl
          extension).   (`objects_rt:interface_source/1')

 - DECLARATION: virtual/1:
     This declaration may be used whenever descendant classes are to
     implement different versions of a given predicate.

     *virtual* predicates give a chance to handle, in an uniform way,
     different implementations of the same functionality.

     Whether a virtual predicate is declared as a method, there must
     be at least one clause of it present at current source. Whenever
     no special implementation is needed at current class, a
     never-fail/allways-fail clause may be defined (depending on your
     needs). For example:

             :- virtual([ test1/1 , test2/2 ]).
             test1(_).
             test2(_,_) :- fail.

     This kind of virtual methods are also known as *abstract
     methods*, since implementation is fully delegated to descendant
     classes.

     An attribute may be also declared as a virtual one, but there is
     no need to write clauses for it.

     *Usage:* :- `virtual(VirtualMethodSpec)'.
        - *Description:* All calls to `VirtualMethodSpec' predicate
          in current source will use the most descendant
          implementation of it.

        - *The following properties should hold at call time:*

          `VirtualMethodSpec' is a method specification.
          (`objects_rt:virtual_method_spec/1')


File: ciao.info,  Node: Documentation on exports (class),  Next: Known bugs and planned improvements (class),  Prev: Documentation on new declarations (class),  Up: Declaring classes and interfaces

Documentation on exports (`class')
==================================

 - PREDICATE: inherited/1:
     This predicate qualificator may be used whenever you need to
     reference an attribute or method on the super class.

     Since methods and attributes may be redefined, this qualificator
     is need to distinguish between a locally declared predicate and
     the inherited one, which has the same name.

     There is no need to use inherited/1 if a particular inherited
     predicate has not been redefined at current class.

     *Usage:* `inherited(Goal)'
        - *Description:* References a given `Goal' at the super class

        - *The following properties should hold at call time:*

          `Goal' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')

 - PREDICATE: self/1:
     Determines which instance is currently executing self/1 goal.

     Predicate will fail if argument is not a free variable.
     Otherwise, it will allways succeed, retrieving the instance
     identifier which is executing current code.

     This functionality is very usefull since an object must have
     knowledge of other object's identifier in order to send messages
     to it.For example:

     :- concurrent ack/0.

     send_data_to_object(Data,Obj) :- self(X), Obj:take_this(Data,X),
     current_fact(ack).

     acknowledge :- asserta_fact(ack).

     take_this(Data,Sender) :- validate_data(Data),
     Sender:acknowledge.

     *Usage:* `self(Variable)'
        - *Description:* Retrieves current instance identifier in
          `Variable'

        - *The following properties should hold at call time:*

          `Variable' is a free variable.   (`term_typing:var/1')

        - *The following properties should hold upon exit:*

          `Variable' is an unique term which identifies an object.
          (`objects_rt:instance_id/1')

 - PREDICATE: constructor/0:
     A *constructor* is a special case of method which complains the
     following conditions:

        * The constructor functor matches the current class name.

        * A constructor may hold any number of arguments.

        * If an inheritance relationship was defined, an inherited
          constructor must be manually called (see below).

        * When instance creation takes place, any of the declared
          constructors are implicitly called. The actual constructor
          called depends on the `new/2' goal specified by the user.

     This is a simple example of constructor declaration for the foo
     class:

                     foo :-
                         display('an instance was born').

     Constructor declaration is not mandatory, and there may be more
     than one constructor declarations (with different arity) at the
     source code.

     This functionality is usefull when some computation is needed at
     instance creation. For example: opening a socket, clearing the
     screen, etc.

     Whenever an inheritance relationship is established, and there
     is any constructor defined at the super class, you must call
     manually an inherited constructor. Here is an example:

                     :- class(foo).
                     :- inherit_class(myclass).
          
                     foo :-
                         myclass(0),
                         display('an instance was born').
          
                     foo(N) :- myclass(N).

     Consequences may be unpredictable, if you forget to call an
     inherited constructor. You should also take care not to call an
     inherited constructor twice.

     All defined constructors are inheritable by default. A
     constructor may also be declared as public (by the user), but it
     is not mandatory.

     *Usage:*
        - *Description:* Constructors are implicitly declared

 - PREDICATE: destructor/0:
     A *destructor* is a special case of method which will be
     automatically called when instance destruction takes place.

     A destructor will never be wanted to be part of the public
     interface, and there is no need to mark them as inheritable,
     since all inherited destructors are called by O'CIAO just before
     yours.

     This is a simple example of destructor declaration:

                     destructor :-
                         display('goodbye, cruel world!!!').

     Destructor declaration is not mandatory. Failure or sucess of
     destructors will be ignored by O'CIAO, and they will be called
     only once.

     This functionality is usefull when some computation is need at
     instance destruction. For example: closing an open file.

     *Usage:*
        - *Description:* Destructors are implicitly declared


File: ciao.info,  Node: Known bugs and planned improvements (class),  Prev: Documentation on exports (class),  Up: Declaring classes and interfaces

Known bugs and planned improvements (`class')
=============================================

   * addmodule and pred(N) meta-arguments are not allowed on
     meta-predicates.


File: ciao.info,  Node: Error reporting when compiling classes and interfaces,  Next: Using OCIAO objects,  Prev: Declaring classes and interfaces,  Up: Top

Error reporting when compiling classes and interfaces
*****************************************************

   *Author(s):* Angel Fernandez Pineda.

   *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

   *Version of last change:* 1.3#66 (1999/9/30, 13:19:4 MEST)

   This chapter will explain error reporting when declaring a class.
The first section will explain compile-time errors, this is, any
semantic error which may be determined at compile time. The second
section will explain run-time errors, this is, any exception that may
be raisen by the incorrect usage of O'CIAO. Some of those errors may
be not reported at compile time, due to the use of
meta-programational structures. For example:

   `functor(X,my_method,0),call(X).'

   O'CIAO is not able to check whether my_method/0 is a valid method
or not. So, this kind of checking is left to run time.

* Menu:

* Error reporting at compile time::
* Error reporting at run time::
* Normal Prolog module system interaction::
* Usage and interface (class_error)::


File: ciao.info,  Node: Error reporting at compile time,  Next: Error reporting at run time,  Prev: Error reporting when compiling classes and interfaces,  Up: Error reporting when compiling classes and interfaces

Error reporting at compile time
===============================

   * *ERROR : multiple inheritance not allowed.*

     There are two or more inherit_class/1 declarations found at your
     code. Only one declaration is allowed, since there is no
     multiple code inheritance support.

   * *ERROR : invalid inheritance declaration.*

     The given parameter to inherit_class/1 declaration is not a
     valid path to a Prolog source.

   * *ERROR : sorry, addmodule meta-arg is not allowed at *F/A*. *

     You are trying to declare *F/A* as meta-predicate, and one of
     the meta-arguments is *addmodule*. This is not allowed in O'CIAO
     due to implementation restrictions. For example:

     `:- meta_predicate example(addmodule).'

     `example(X,FromModule) :- call(FromModule:X).'

   * *ERROR : invalid attribute declaration for *Arg*. *

     Argument to data/1 or dynamic/1 declaration is not a valid
     predicate specification of the form *Functor/Arity*. For example:

     `:- data attr.'

     `:- dynamic attr(_).'

     `:- data attr/m.'

     etc,etc...

   * *ERROR : pretended attribute *F/A* was assumed to be a method.*

     You put some clauses of *F/A* before the corresponding data/1 or
     dynamic/1 declaration. For example:

     `attr(initial_value).'

     `:- data attr/1.'

     It is a must to declare attributes before any clause of the
     given predicate.

   * *ERROR : destructor/0 is not allowed to be an attribute.*

     There is a :- data(destructor/0) or :- dynamic(destructor/0).
     declaration in your code. This is not allowed since destructor/0
     is a reserved predicate, and must be allways a method.

   * *ERROR : *Constructor* is not allowed to be an attribute.*

     As the previos error, you are trying to declare a constructor as
     an attribute. A constructor must be allways a method.

   * *ERROR : invalid multifile: destructor/0 is a reserved
     predicate.*

     There is a :- multifile(destructor/0). declaration in your code.
     This is not allowed since destructor/0 is a reserved predicate,
     and must be allways a method.

   * *ERROR : invalid multifile: *Constructor* is a reserved
     predicate.*

     As the previos error, you are trying to declare a constructor as
     a multifile. Any constructor must allways be a method.

   * *ERROR : multifile declaration of *F/A* ignored: it was assumed
     to be a method.*

     You put some clauses of *F/A* before the corresponding
     multifile/1 declaration. For example:

     example(a,b).

     `:- multifile example/2.'

     Multifile predicates must be declared before any clause of the
     given predicate.

   * *ERROR : invalid multifile declaration: multifile(*Arg*). *

     Given argument to multifile/1 declaration is not a valid
     predicate specification, of the form *Functor/Arity*.

   * *ERROR : invalid public declaration: *Arg*. *

     Given argument *Arg* to public/1 or export/1 declaration is not
     a valid predicate specification, of the form *Functor/Arity*.

   * *ERROR : invalid inheritable declaration: inheritable(*Arg*). *

     Given argument *Arg* to inheritable/1 declaration is not a valid
     predicate specification, of the form *Functor/Arity*.

   * *ERROR : destructor/0 is not allowed to be virtual.*

     There is a :- virtual(destructor/0) declaration present at your
     code. Destructors and/or constructors are not allowed to be
     virtual.

   * *ERROR : *Constructor* is not allowed to be virtual.*

     As the previous error, you are trying to declare a constructor
     as virtual. This is not allowed.

   * *ERROR : invalid virtual declaration: virtual(*Arg*). *

     Given argument to virtual/1 declaration is not a valid predicate
     specification, of the form *Functor/Arity*.

   * *ERROR : clause of *F/A* ignored : only facts are allowed as
     initial state.*

     You declared *F/A* as an attribute, then you put some clauses of
     that predicate in the form *Head :- Body*. For example:

     `:- data my_attribute/1.'

     `my_attribute(X) :- X>=0 , X<=2.'

     This is not allowed since attributes are assumed to hold simple
     facts. The correct usage for those *initialization clauses* is:

     `:- data my_attribute/1.'

     `my_attribute(0).'

     `my_attribute(1).'

     `my_attribute(2).'

   * *ERROR : multifile *F/A* is not allowed to be public.*

     The given *F/A* predicate is both present at multifile/1 and
     public/1 declarations. For example:

     `:- public(p/1).'

     `:- multifile(p/1).'

     This is not allowed since multifile predicates are not related
     to Object Oriented Programming.

   * *ERROR : multifile *F/A* is not allowed to be inheritable.*

     Analogous to previous error.

   * *ERROR : multifile *F/A* is not allowed to be virtual.*

     Analogous to previous error.

   * *ERROR : virtual *F/A* must be a method or attribute defined at
     this class.*

     There is a virtual/1 declaration for *F/A*, but there is not any
     clause of that predicate nor a `data/1' declaration. You must
     declare at least one clause for every virtual method. Virtual
     attributes does not require any clause but a `data/1'
     declaration must be present.

   * *ERROR : implemented interface *Module* is not a valid
     interface.*

     There is an `implements/1' declaration present at your code
     where given *Module* is not declared as class nor interface.

   * *ERROR : predicate *F/A* is required both as method (at *Itf1*
     interface) and attribute (at *Itf2* interface).*

     There is no chance to give a correct implementation for *F/A*
     predicate since *Itf1* and *Itf2* interfaces require different
     definitions. To avoid this error, you must remove one of the
     related `implements/1' declaration.

   * *ERROR : inherited *Source* must be a class.*

     There is an :- inherit_class(*Source*) declaration, but that
     source was not declared as a class.

   * *ERROR : circular inheritance: *Source* is not a valid
     super-class.*

     Establishing an inheritance relationship with *Source* will
     cause current class to be present twice in the inheritance line.
     This is not allowed. The cause of this is error is simple :
     There is some inherited class from *Source* which also
     establishes an inheritance relationship with current source.

   * *ERROR : method/attribute *F/A* must be implemented.*

     Some of the implemented interfaces requires *F/A* to be defined,
     but there is no definition for such predicate, even an inherited
     one.

   * *ERROR : local implementation of *F/A* hides inheritable/public
     definition.*

     There is an inherited definition for *F/A* which is been
     redefined at current class, but there is no valid
     inheritable/public declaration for the last one. Overriden
     public predicates must be also declared as public. Overriden
     inheritable predicates must be declared either as public or
     inheritable.

   * *ERROR : public predicate *F/A* was not defined nor inherited.*

     There is a `public/1' declaration for *F/A*, but there is no
     definition for it at current class nor an inherited one.

   * *ERROR : argument to self/1 must be a free variable.*

     Argument to self/1 is not a variable, for example: `self(abc)'.

   * *ERROR : unknown inherited attribute in *Goal*.*

     *Goal* belongs to assert/retract family of predicates, and given
     argument is not a valid inherited attribute. The most probable
     causes of this error are:

        * The given predicate is defined at super-class, but you
          forgot to mark it as inheritable (or public), at such class.

        * The given predicate was not defined (at super-class) as an
          attribute, just as a method.

   * *ERROR : unknown inherited goal: *Goal*.*

     The given *Goal* was not found at super-class, or it is not
     accessible. Check whether *Goal* was marked as inheritable (or
     public) at super-class.

   * *ERROR : invalid argument: *F/A* is not an attribute.*

     You are trying to pass a method as an argument to any predicate
     which expect a *fact* predicate.

   * *ERROR : unknown inherited fact: *Fact*.*

     There is a call to any predicate which expects a *fact* argument
     (those declared as data or dynamic),but the actual argument is
     not an inherited attribute.For example:

     `asserta_fact(inherited(not_an_attribute(8)))'

     where not_an_attribute/1 was not declared as data or dynamic by
     the super-class (or corresponding ascendant).

   * *ERROR : unknown inherited spec: *F/A*.*

     There is a reference to an inherited predicate specification,
     but the involved predicate has not been inherited.

   * *WARNING : meta-predicate specification of *F/A* ignored since
     this is an attribute.*

     You declared *F/A* both as an attribute and a meta-predicate.
     For example:

     `:- meta_predicate attr(goal).'

     `:- data attr/1.'

     There is no sense in declaring an attribute as meta-predicate.

   * *WARNING : class destructor is public*

     There is a :- public(destructor/0) declaration present at your
     code. Marking a destructor as public is a very bad idea since
     anybody may destroy or corrupt an instance before the proper
     time.

   * *WARNING : class destructor is inheritable*

     Analogous to previous error.

   * *WARNING : There is no call to inherited constructor/s*

     You have not declared any constructor at your class, but there
     is any inherited constructor that should be called. Whenever you
     do not need constructors, but there is an inheritance
     relationship (where super-class declares a constructor), you
     should write a simple constructor as the following example:
             :- class(myclass).
             :- inherit_class(other_class).
          
             myclass :-
                     other_class.

   * *WARNING : multifile *F/A* hides inherited predicate.*

     You declared as multifle a predicate which matches an inherited
     predicate name. Any reference to the inherited predicate must be
     done by the ways of the inherited/1 qualificator.


File: ciao.info,  Node: Error reporting at run time,  Next: Normal Prolog module system interaction,  Prev: Error reporting at compile time,  Up: Error reporting when compiling classes and interfaces

Error reporting at run time
===========================

   * *EXCEPTION : error(existence_error(object_goal,*Goal*),*Mod*).*

     Called *Goal* from module (or class) *Mod* is unknown or has not
     been published.


File: ciao.info,  Node: Normal Prolog module system interaction,  Next: Usage and interface (class_error),  Prev: Error reporting at run time,  Up: Error reporting when compiling classes and interfaces

Normal Prolog module system interaction
=======================================

        O'CIAO works in conjunction with the habitual CIAO Prolog
module system, which also reports its own error messages. This will
cause CIAO to report a little criptic error messages due to the
general mechanism of source-to-source expansion. Those are some tips
you must consider when compiling a class:

        * Any error relative to method 'm' with arity A will be
          reported for predicate 'obj$m'/A+1. For example :

          `WARNING: (lns 28-30) [Item,Itema] - singleton variables in
          obj$remove/2'

          This error is relative to method remove/1.

        * `set_prolog_flag/1' declaration will be usefull when
          declaring multiple constructors. It will avoid some awful
          warnings. Example:

                  :- class(myclass).
               
                  %% Use this declaration whenever several constructors are needed.
               
                  :- set_prolog_flag(multi_arity_warnings,off).
               
                  myclass(_).
               
                  myclass(_,_).
               
                  :- set_prolog_flag(multi_arity_warnings,on).


File: ciao.info,  Node: Usage and interface (class_error),  Prev: Normal Prolog module system interaction,  Up: Error reporting when compiling classes and interfaces

Usage and interface (`class_error')
===================================

        * *Library usage:*

          `:- use_module(library(class_error)).'


File: ciao.info,  Node: Using OCIAO objects,  Next: Error reporting when using objects,  Prev: Error reporting when compiling classes and interfaces,  Up: Top

Using OCIAO objects
*******************

        *Author(s):* Angel Fernandez Pineda.

        *Version:* 1.3#124 (1999/11/27, 4:4:5 MET)

        *Version of last change:* 1.3#78 (1999/10/13, 18:31:8 MEST)

        This package is required to enable user code to create
objects and manipulate them, as well as loading any needed class.

     * Menu:
     
     * Usage and interface (objects)::
     * Documentation on new declarations (objects)::
     * Documentation on exports (objects)::


File: ciao.info,  Node: Usage and interface (objects),  Next: Documentation on new declarations (objects),  Prev: Using OCIAO objects,  Up: Using OCIAO objects

Usage and interface (`objects')
===============================

        * *Library usage:*

          Any code which needs to use objects must include the
          objects package:
                   :- module(*ModuleName*,*Exports*,[objects]).
          You can use objects even if your code is a class. Note that
          declaring a class does not automatically enables the code
          to create instances.
                   :- class(*ModuleName*,[],[objects]).

          This package enables both static and dynamic usage of
          objects.

        * *Exports:*
             - *Properties:*

               `class_source/1', `constructor/1', `instance_id/1',
               `class_name/1'.

        * *New declarations defined:*

          `use_class/1', `instance_of/2', `new/2'.



File: ciao.info,  Node: Documentation on new declarations (objects),  Next: Documentation on exports (objects),  Prev: Usage and interface (objects),  Up: Using OCIAO objects

Documentation on new declarations (`objects')
=============================================

      - DECLARATION: use_class/1:
          It establishes an usage relationship between the given file
          (which is supposed to declare a class) and current source.
          Usage relationships are needed in order to enable code to
          create instances of the given class, and to make calls to
          instances derived from such class.

          Since an interface is some kind of class, they may be used
          within this declaration but only for semantic checking
          porpouses. Instances will not be derived from interfaces.

          use_class/1 is used in the same way as `use_module/1'.

          *Usage:* :- `use_class(ClassSource)'.
             - *Description:* Establish usage relationship with
               `ClassSource'.

             - *The following properties should hold at call time:*

               `ClassSource' is path to a file declaring a class.
               (`user(... /objects_doc):class_source/1')

      - DECLARATION: instance_of/2:
          Statically declares an identifier to be an instance of a
          given class.

          It may be used as `new/2' predicate except for:
             * The instance identifier will not be a variable, it
               must be provided by the user, and must be unique.

             * Instance creation will never fail, even if the
               constructor fails.

          For every statically declared object the given constructor
          will be called at program startup. Those instances may be
          destroyed manually, but it is not recommended.

          When reloading the involved class from the CIAO toplevel
          shell. It may destroy statically declared instances, and
          create them again.

          Statically declared instances must be called using a
          specifically designed module-qualification:
          `ClassName(Object):Goal'. For example:
                   :- module(example,[main/0],[objects]).
                   :- use_class(library(counter)).
                   :- cnt instance_of counter(10).
               
                   main :-
                        counter(cnt):decrease(1),
                        counter(cnt):current_value(X),
                        display(X).
          But *statically written code* (only) is allowed to use
          module-style qualifications as a macro:
                   main :-
                        cnt:decrease(1),
                        cnt:current_value(X),
                        display(X).
          Notice that dynamically expanded goals such as
          `X=cnt,X:decrease(1)' will not work, use
          `X=counter(cnt),X:decrease(1)' instead.

          *Usage:* :- `instance_of(Object,Constructor)'.
             - *Description:* Declares `Object' to be an instance of
               the class denoted by `Constructor'.

             - *The following properties should hold at call time:*

               `Object' is an unique atom which identifies an object.
               (`user(... /objects_doc):instance_id/1')

               `Constructor' is a term whose functor matches a class
               name.   (`user(... /objects_doc):constructor/1')

      - DECLARATION: new/2:
          This declaration has the same effect as `instance_of/2'.

          *Usage:* :- `new(Object,Constructor)'.
             - *Description:* Just an alias for `instance_of/2'.

             - *The following properties should hold at call time:*

               `Object' is an unique atom which identifies an object.
               (`user(... /objects_doc):instance_id/1')

               `Constructor' is a term whose functor matches a class
               name.   (`user(... /objects_doc):constructor/1')


File: ciao.info,  Node: Documentation on exports (objects),  Prev: Documentation on new declarations (objects),  Up: Using OCIAO objects

Documentation on exports (`objects')
====================================

      - PROPERTY: class_source/1:
          *Usage:* `class_source(Source)'
             - *Description:* `Source' is path to a file declaring a
               class.

      - PROPERTY: constructor/1:
          *Usage:* `constructor(Cons)'
             - *Description:* `Cons' is a term whose functor matches
               a class name.

      - PROPERTY: instance_id/1:
          *Usage:* `instance_id(ID)'
             - *Description:* `ID' is an unique atom which identifies
               an object.

      - PROPERTY: class_name/1:
          *Usage:* `class_name(ClassName)'
             - *Description:* `ClassName' is an atom denoting a class.

      - PREDICATE: use_class/1:
          It establishes an usage relationship between the given file
          (which is supposed to declare a class) and current source.
          Usage relationships are needed in order to enable code to
          create instances of the given class, and to make calls to
          instances derived from such class.

          Since an interface is some kind of class, they may be used
          within this declaration but only for semantic checking
          porpouses. Instances will not be derived from interfaces.

          use_class/1 is used in the same way as `use_module/1'.


      - PREDICATE: instance_of/2:
          Statically declares an identifier to be an instance of a
          given class.

          It may be used as `new/2' predicate except for:
             * The instance identifier will not be a variable, it
               must be provided by the user, and must be unique.

             * Instance creation will never fail, even if the
               constructor fails.

          For every statically declared object the given constructor
          will be called at program startup. Those instances may be
          destroyed manually, but it is not recommended.

          When reloading the involved class from the CIAO toplevel
          shell. It may destroy statically declared instances, and
          create them again.

          Statically declared instances must be called using a
          specifically designed module-qualification:
          `ClassName(Object):Goal'. For example:
                   :- module(example,[main/0],[objects]).
                   :- use_class(library(counter)).
                   :- cnt instance_of counter(10).
               
                   main :-
                        counter(cnt):decrease(1),
                        counter(cnt):current_value(X),
                        display(X).
          But *statically written code* (only) is allowed to use
          module-style qualifications as a macro:
                   main :-
                        cnt:decrease(1),
                        cnt:current_value(X),
                        display(X).
          Notice that dynamically expanded goals such as
          `X=cnt,X:decrease(1)' will not work, use
          `X=counter(cnt),X:decrease(1)' instead.


      - PREDICATE: new/2:
          This declaration has the same effect as `instance_of/2'.



File: ciao.info,  Node: Error reporting when using objects,  Next: Run time usage of objects,  Prev: Using OCIAO objects,  Up: Top

Error reporting when using objects
**********************************

        *Author(s):* Angel Fernandez Pineda.

        *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

        *Version of last change:* 1.3#79 (1999/10/13, 18:48:0 MEST)

        Compile-time errors are restricted to some local analysis.
Since there is no type declaration in the Prolog language, there is
no posibility to determine whenever a given variable will hold an
instance of any class.

        However, little semantic analysis is performed. User may aid
to perform such an analysis by the usage of run time checks (which
are also detected at compile time), or static declarations. For
example:

        `clause(Obj) :- Obj:a_method(334).'

        O'CIAO may be not able to determine whenever a_method/1 is a
valid method for instance Obj, unless some help is provided:

        `clause(Obj) :- Obj instance_of myclass,Obj:a_method(334).'

        In such case, O'CIAO will report any semantic error at
compile-time.

        Most of the run-time errors are related to normal CIAO Prolog
module system. Since objects are treated as normal Prolog modules at
run time, there is no further documentation here about that stuff.

     * Menu:
     
     * Error reporting at compile time (objects)::
     * Error reporting at run time (objects)::
     * Usage and interface (objects_error)::


File: ciao.info,  Node: Error reporting at compile time (objects),  Next: Error reporting at run time (objects),  Prev: Error reporting when using objects,  Up: Error reporting when using objects

Error reporting at compile time (objects)
=========================================

        * *ERROR : invalid instance identifier *ID*: must be an atom*

          There is a `instance_of/2' or `new/2' declaration where
          first argument *ID* must be an unique atom, but currently
          it is not. Statically declared instances needs an
          identifier to be provided by the user.

        * *ERROR : instance identifier *ID* already in use*

          There are two or more `instance_of/2' declarations with the
          same first argument *ID*. Instance identifiers must be
          unique.

        * *ERROR : invalid use_class/1 declaration: *SourceFile* is
          not a class*

          Those are the causes for this error:

             * The given *SourceFile* does not exist, or is not
               accesible.

             * The given *SourceFile* is not a Prolog source.

             * The given *SourceFile* is a valid Prolog source, but
               it does not declare a class.

        * *ERROR : unknown class on *ID* instance declaration*

          The class defined on the `instance_of/2' declaration for
          *ID* instance has not been loaded by a `use_class/1'
          declaration.

        * *ERROR : instance identifier *ID* is an exisisting Prolog
          module*

          There is an statically declared instance whose identifier
          may cause interference with the CIAO Prolog module system.
          Use another instance identifier.

        * *ERROR : unknown constructor on *ID* instance declaration*

          The given constructor on the `instance_of/2' declaration
          for *ID* has not been defined at the corresponding class.

        * *ERROR : constructor is needed on *ID* instance declaration*

          No constructor was defined on the `instance_of/2'
          declaration for *ID* and default constructor is not
          allowed. You must provide a constructor.

        * *ERROR : static instance *ID* was derived from a different
          constructor at *AnotherModule**

          *ID* has been declared to be an static instance both on
          *AnotherModule* and current source, but different
          constructors were used. The most probable causes for this
          error are:

             * Occasionally, there is another module using the same
               instance identifier and it was not noticed by you.
               Another different identifier may be used instead.

             * It was you intention to use the same object as
               declared by the other module. In this case, the same
               constructor must be used.

        * *ERROR : invalid first argument in call to new(*Arg*,_)*

          There is a new/1 goal in your code where first argument is
          not a free variable. For example:

          `myobj new myclass'

          First argument must be a variable in order to receive a
          run-time generated object identifier.

        * *ERROR : unknown class in call to new(?,*Constructor*) *

          The given *Constructor* in call to new/2 does not
          correspond to any used class at current code. The most
          probable cause of this may be:

             * You forgot to include a `use_class/1' declaration in
               your code.

             * There is a spelling mistake in the constructor.For
               example:

               :- use_class(myclass).

               foo(X) :- X new mclass.

        * *ERROR : can not create an instance from an interface:
          new(?,*Constructor*) *

          Given *Constructor* references an interface rather than a
          class. Instances can not be derived from interface-expanded
          code.

        * *ERROR : unknown constructor in call to
          new(?,*Constructor*) *

          As the previous error, there is a mistake in the given
          *Constructor*. This error is reported when you are trying
          to call a constructor which was not defined at the
          corresponding class. Check the class definition to find
          what is going on.

          Another cause for this error is the incorrect usage of the
          default constructor. Whenever there are one or more
          constructors defined at the involved class, you are
          restricted to chose one of them. This seems that default
          constructor will be available, if and only if, there are no
          constructors defined at the involved class.

        * *ERROR : call to non-public *ID:Goal**

          You are trying to call a method which was not declared as
          public by the class specified in `instance_of/2'
          declaration for *ID*.

        * *ERROR : call to inaccessible predicate at instance
          *ID:Goal**

          There is a call to *Goal* at statically declared instance
          *ID* which is unknown or was not declared as public.

        * *ERROR : unknown instance *ID* of class *Class* at *Goal**

          There is a call to *Goal* where involved statically
          declared instance *ID* is unknown or is not derived from
          *Class*. Check whether it was declared by a `instance_of/2'
          declaration.

        * *ERROR : inaccessible attribute *Fact* at instance *ID**

          There is an attempt to use *ID:Fact* but it was not
          declared as public.

        * *ERROR : unknown attribute *Fact* at instance *ID**

          There is an attempt to use *ID:Fact* but it is unknown or
          it is not an attribute (may be a method).

        * *WARNING : invalid call to new(?,_)*

          There is a call to new/2 in you code where first argument
          variable has been determined to hold any other instance.
          For example:

          `foo :- X new myclass,X new otherclass.'

          or

          `foo(X) :- X instance_of myclass, X new myclass.'

          The related call to new/2 will allways fail.

        * *WARNING : called *Goal* is not public at any used class*

          There is a call to *Var*:*Goal* where *Var* has not been
          determined to be compatible with any class. However, *Goal*
          is not public at any class specified by the `use_class/1'
          declaration.

          This is a warning (not an error) since *Var*:*Goal* may be
          not related to Object Oriented Programing.


File: ciao.info,  Node: Error reporting at run time (objects),  Next: Usage and interface (objects_error),  Prev: Error reporting at compile time (objects),  Up: Error reporting when using objects

Error reporting at run time (objects)
=====================================

             * *EXCEPTION : instantiation_error( '1st argument must
               be free variable')*

               Calling to new/1 requieres first argument to be a free
               variable. For example:

               `X = this_will_raise_an_exception,X new myclass.'

             * *EXCEPTION : instantiation_error('class not given')*

               You called new/2 using a free variable as second
               argument.

             * *EXCEPTION :
               instantiation_error(inaccesible_class(*Class*),
               from(*Module*)) *

               *Module* tried to create an instance of *Class* by the
               ways of new/2, but there is no usage relationship
               between *Module* and *Class*.

             * *EXCEPTION : instantiation_error(invalid_constructor(
               *Constructor*)) *

               *Constructor* was not defined by the corresponding
               class.


File: ciao.info,  Node: Usage and interface (objects_error),  Prev: Error reporting at run time (objects),  Up: Error reporting when using objects

Usage and interface (`objects_error')
=====================================

             * *Library usage:*

               `:- use_module(library(objects_error)).'


File: ciao.info,  Node: Run time usage of objects,  Next: Using classes from the CIAO toplevel shell,  Prev: Error reporting when using objects,  Up: Top

Run time usage of objects
*************************

             *Author(s):* Angel Fernandez Pineda, Angel Fernandez
Pineda.

             *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

             *Version of last change:* 1.3#96 (1999/11/10, 17:38:35
MET)

             This library provides run-time support for object
creation and manipulation. Objects are also called class instances,
or simply instances.

             Objects in CIAO are treated as normal modules. This is,
an object is a run-time generated Prolog module, which may be
identified by an unique term across the whole application.

             This is a very simple example of how to create an
instance, and how to make calls to it:

                           AnObj new myclass,
                           AnObj:mymethod.

             In order to make any object accessible from code, an
usage relationship must be established between the class (from which
instances are derived) and the code itself. Refer to `use_class/1'
predicate or `use_class/1' declaration in order to do so.

          * Menu:
          
          * Usage and interface (objects_rt)::
          * Documentation on exports (objects_rt)::
          * Known bugs and planned improvements (objects_rt)::


File: ciao.info,  Node: Usage and interface (objects_rt),  Next: Documentation on exports (objects_rt),  Prev: Run time usage of objects,  Up: Run time usage of objects

Usage and interface (`objects_rt')
==================================

             * *Library usage:*

               This library is automatically loaded when using the
               *objects* package:
                        :- module(*ModuleName*,*Exports*,[objects]).
               Nothing special needs to be done.

             * *Exports:*
                  - *Predicates:*

                    `new/2', `instance_of/2', `derived_from/2',
                    `interface/2', `instance_codes/2', `destroy/1'.

                  - *Properties:*

                    `constructor/1', `class_name/1',
                    `interface_name/1', `instance_id/1',
                    `class_source/1', `interface_source/1',
                    `method_spec/1', `virtual_method_spec/1'.

             * *Other modules used:*
                  - *System library modules:*

                    `prolog_sys', `system'.



File: ciao.info,  Node: Documentation on exports (objects_rt),  Next: Known bugs and planned improvements (objects_rt),  Prev: Usage and interface (objects_rt),  Up: Run time usage of objects

Documentation on exports (`objects_rt')
=======================================

           - PREDICATE: new/2:
               Dynamic instance creation takes place by the ways of
               this predicate.

               It takes a free variable as first argument which will
               be instantiated to an internal object identifier.

               Second argument must be instantiated to a class
               constructor. Class constructors are designed to
               perform an initialization on the new created instance.
               Notice that instance initialization may involve some
               kind of computation, not only *state initialization*.

               A class constructor is made by a functor, which must
               match the intended class name, and any number of
               parameters. For example:

                                Obj new myclass(1500,'hello, world!!!')

               Those parameters depends (obviously) on the
               constructors defined at the class source. If no
               constructors where defined, no parameters are needed.
               This is called the default constructor. An example:

                                Obj new myclass

               The default constructor can not be called if there is
               any constructor available at the class source.

               Instantiation will raise an exception and fail
               whenever any of this conditions occur:
                  * First argument is not a free variable.

                  * Second argument functor is a class, but there is
                    no usage relationship with it.

                  * Second argument functor is not a class.

                  * The given constructor is unknown.

                  * The given constructor fails (notice that default
                    constructor never fails).

               Objects may also be statically declared, refer to
               `instance_of/2' declaration.

               *Usage:* `new(InstanceVar,Constructor)'
                  - *Description:* Creates a new instance of the
                    class specified by `Constructor' returning its
                    identifier in `InstanceVar'

                  - *The following properties should hold at call
                    time:*

                    `InstanceVar' is a free variable.
                    (`term_typing:var/1')

                    `Constructor' is a term whose functor matches a
                    class name.   (`objects_rt:constructor/1')

                  - *The following properties should hold upon exit:*

                    `InstanceVar' is an unique term which identifies
                    an object.   (`objects_rt:instance_id/1')

           - PREDICATE: instance_of/2:
               This predicate is used to perform dynamic type
               checking. You may check whether a particular instance
               belongs to a particular class or related descendants.

               instance_of/2 is used to perform static semantic
               analisys over object oriented code constructions.

               By the use of instance_of/2 you may help to perform
               such analisys.

               *Usage 1:* `instance_of(Instance,Class)'
                  - *Description:* Test whether `Instance' was
                    derived from any descendant of `Class', or that
                    class itself

                  - *The following properties should hold at call
                    time:*

                    `Instance' is an unique term which identifies an
                    object.   (`objects_rt:instance_id/1')

                    `Class' is an atom denoting a class.
                    (`objects_rt:class_name/1')

               *Usage 2:* `instance_of(Instance,Class)'
                  - *Description:* Retrieves, on backtracking, the
                    inheritance line of `Instance' commencing on the
                    creation class (that specified on call to
                    `new/2') and continuing on the rest of ascendant
                    classes, if any.

                  - *The following properties should hold at call
                    time:*

                    `Instance' is an unique term which identifies an
                    object.   (`objects_rt:instance_id/1')

                    `Class' is a free variable.
                    (`term_typing:var/1')

                  - *The following properties should hold upon exit:*

                    `Class' is an atom denoting a class.
                    (`objects_rt:class_name/1')

           - PREDICATE: derived_from/2:
               Test whether an object identifier was derived directly
               from a class, by the usage of `new/2' or a static
               instance declaration ( `instance_of/2').

               *Usage 1:* `derived_from(Instance,Class)'
                  - *Description:* Test derivation of `Instance' from
                    `Class'

                  - *The following properties should hold at call
                    time:*

                    `Instance' is an unique term which identifies an
                    object.   (`objects_rt:instance_id/1')

                    `Class' is an atom denoting a class.
                    (`objects_rt:class_name/1')

               *Usage 2:* `derived_from(Instance,Class)'
                  - *Description:* Retrieves the `Class' responsable
                    of the derivation of `Instance'.

                  - *The following properties should hold at call
                    time:*

                    `Instance' is an unique term which identifies an
                    object.   (`objects_rt:instance_id/1')

                    `Class' is a free variable.
                    (`term_typing:var/1')

                  - *The following properties should hold upon exit:*

                    `Class' is an atom denoting a class.
                    (`objects_rt:class_name/1')

           - PREDICATE: interface/2:
               This predicate is used to ensure a given interface to
               be implemented by a given instance.

               *Usage 1:* `interface(Instance,Interface)'
                  - *Description:* Check whether `Instance'
                    implements the given `Interface'.

                  - *The following properties should hold at call
                    time:*

                    `Instance' is an unique term which identifies an
                    object.   (`objects_rt:instance_id/1')

                    `Interface' is an unique atom which identifies a
                    public interface.
                    (`objects_rt:interface_name/1')

               *Usage 2:* `interface(Instance,Interfaces)'
                  - *Description:* Retrieves on backtracking all the
                    implemented `Interfaces' of `Instance'.

                  - *The following properties should hold at call
                    time:*

                    `Instance' is an unique term which identifies an
                    object.   (`objects_rt:instance_id/1')

                    `Interfaces' is a free variable.
                    (`term_typing:var/1')

                  - *The following properties should hold upon exit:*

                    `Interfaces' is an unique atom which identifies a
                    public interface.
                    (`objects_rt:interface_name/1')

           - PREDICATE: instance_codes/2:
               Retrieves a character string representation from an
               object identifier and vice-versa.

               *Usage 1:* `instance_codes(Instance,String)'
                  - *Description:* Retrieves a `String'
                    representation of given `Instance'.

                  - *The following properties should hold at call
                    time:*

                    `Instance' is an unique term which identifies an
                    object.   (`objects_rt:instance_id/1')

                    `String' is a free variable.
                    (`term_typing:var/1')

                  - *The following properties should hold upon exit:*

                    `String' is a string (a list of character codes).
                    (`basic_props:string/1')

               *Usage 2:* `instance_codes(Instance,String)'
                  - *Description:* Reproduces an `Instance' from its
                    `String' representation. Such an instance must be
                    alive across the application: this predicate will
                    fail whether the involved instance has been
                    destroyed.

                  - *The following properties should hold at call
                    time:*

                    `Instance' is a free variable.
                    (`term_typing:var/1')

                    `String' is a string (a list of character codes).
                    (`basic_props:string/1')

                  - *The following properties should hold upon exit:*

                    `Instance' is an unique term which identifies an
                    object.   (`objects_rt:instance_id/1')

           - PREDICATE: destroy/1:
               As well as instances are created, they must be
               destroyed when no longer needed in order to release
               system resources.

               Unfortunately, current O'CIAO implementation does not
               support automatic instance destruction, so user must
               manually call *destroy/1* in order to do so.

               The programmer *must ensure* that no other references
               to the involved object are left in memory when
               destroy/1 is called. If not, unexpected results may be
               obtained.

               *Usage:* `destroy(Instance)'
                  - *Description:* Destroys the object identified by
                    `Instance'.

                  - *The following properties should hold at call
                    time:*

                    `Instance' is an unique term which identifies an
                    object.   (`objects_rt:instance_id/1')

           - PROPERTY: constructor/1:
               *Usage:* `constructor(Cons)'
                  - *Description:* `Cons' is a term whose functor
                    matches a class name.

           - PROPERTY: class_name/1:
               *Usage:* `class_name(ClassName)'
                  - *Description:* `ClassName' is an atom denoting a
                    class.

           - PROPERTY: interface_name/1:
               *Usage:* `interface_name(Interface)'
                  - *Description:* `Interface' is an unique atom
                    which identifies a public interface.

           - PROPERTY: instance_id/1:
               *Usage:* `instance_id(ID)'
                  - *Description:* `ID' is an unique term which
                    identifies an object.

           - PROPERTY: class_source/1:
               *Usage:* `class_source(Source)'
                  - *Description:* `Source' is a valid path to a
                    prolog file containing a class declaration
                    (without .pl extension).

           - PROPERTY: interface_source/1:
               *Usage:* `interface_source(Source)'
                  - *Description:* `Source' is a valid path to a
                    prolog file containing a class declaration or an
                    interface declaration (without .pl extension).

           - PROPERTY: method_spec/1:
               There is no difference between method or attribute
               specifications, and habitual predicate specifications.
               It is just a Functor/Arity term.

               *Usage:* `method_spec(Spec)'
                  - *Description:* `Spec' is a method or attribute
                    specification.

           - PROPERTY: virtual_method_spec/1:
               *Usage:* `virtual_method_spec(Spec)'
                  - *Description:* `Spec' is a method specification.


File: ciao.info,  Node: Known bugs and planned improvements (objects_rt),  Prev: Documentation on exports (objects_rt),  Up: Run time usage of objects

Known bugs and planned improvements (`objects_rt')
==================================================

             * Rock-and-roll Star ate my hamster :-(


File: ciao.info,  Node: Using classes from the CIAO toplevel shell,  Next: *** PART VIII - Interfaces to other languages and systems,  Prev: Run time usage of objects,  Up: Top

Using classes from the CIAO toplevel shell
******************************************

             *Author(s):* Angel Fernandez Pineda.

             *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

             *Version of last change:* 1.3#21 (1999/7/7, 10:27:51
MEST)

             The CIAO toplevel shell will be a usefull tool in order
to compile and test O'CIAO classes. Those classes may be dynamically
loaded, so some instances of them may be created to perform any
needed test.

          * Menu:
          
          * Usage and interface (dynclasses)::
          * Documentation on exports (dynclasses)::
          * Known bugs and planned improvements (dynclasses)::


File: ciao.info,  Node: Usage and interface (dynclasses),  Next: Documentation on exports (dynclasses),  Prev: Using classes from the CIAO toplevel shell,  Up: Using classes from the CIAO toplevel shell

Usage and interface (`dynclasses')
==================================

             * *Library usage:*

               This library will be automatically loaded when using
               the *objects* package from the toplevel shell:
                    	?- use_package(objects).

               It may be usefull for you to put a `:-
               use_package(objects)' declaration on your *.cshrc*
               initialization file. In such case, absolutely nothing
               is needed to load this library.

               The Emacs ciao-mode will also automatically load this
               library when a *Load buffer* command is issued (`C-c
               l').

             * *Exports:*
                  - *Predicates:*

                    `use_class/1'.

             * *Other modules used:*
                  - *System library modules:*

                    `dynmods', `filenames', `objects/objects_rt'.



File: ciao.info,  Node: Documentation on exports (dynclasses),  Next: Known bugs and planned improvements (dynclasses),  Prev: Usage and interface (dynclasses),  Up: Using classes from the CIAO toplevel shell

Documentation on exports (`dynclasses')
=======================================

           - PREDICATE: use_class/1:
               This predicate is something very similar to
               `use_module/1'.

               It will (re)compile and/or (re)load a class source
               file from the CIAO shell so instances of that class
               can be now created.

               There is an implicit usage relationship between the
               CIAO shell and *any and all loaded* classes. This
               seems that user is allowed to create ( `new/1') and
               call any public predicate even when the involved class
               was not specifically loaded using the use_class/1
               predicate.For example:
                       :- module(test,[example/1],[objects]).
                    
                       :- use_class(test_class).
                    
                        example(Obj) :-
                            Obj new test_class,
                            Obj:do_something.

               Whenever this code is loaded:

                    	?- use_module(test).

               user is allowed to handle instances of *test_class*
               (and ascendants):

                    	?- test:example(SomeObj), SomeObj:test_something.

               Note that *test_class* was not loaded using
               use_class/1 predicate, but public predicate
               *test_something/0* may be called.

               Some other usefull notes:

                  * Every time a class is reloaded using use_class/1,
                    all previously created instances of that class
                    will be automatically destroyed.

                  * Predicate use_class/1 will fail if called from
                    user programs.

                  * use_class/1 will have no effect whether given
                    source is not a class.

               *Usage:* `use_class(Source)'
                  - *Description:* Compile and load `Source' class


File: ciao.info,  Node: Known bugs and planned improvements (dynclasses),  Prev: Documentation on exports (dynclasses),  Up: Using classes from the CIAO toplevel shell

Known bugs and planned improvements (`dynclasses')
==================================================

             * Not really a bug: when loading code which declares
               static instances ( `use_module/1'), those instances
               may be not correctly created, and predicates will fail
               whenever they are not supposed to do. This may be
               avoided by reloading again the involved module, but
               make sure it is modified and saved to disk before
               doing so.


File: ciao.info,  Node: *** PART VIII - Interfaces to other languages and systems,  Next: Foreign interface,  Prev: Using classes from the CIAO toplevel shell,  Up: Top

PART VIII - Interfaces to other languages and systems
*****************************************************

             The following interfaces to/from Ciao Prolog are
documented in this part:
             * external interface (e.g., to C);

             * socket interface;

             * tcl/tk interface;

             * Web http-like interface;

             * persistent predicate databases (interface between the
               Prolog internal database and the external file system);

             * SQL-like database interface;

             * Java interface.


File: ciao.info,  Node: Foreign interface,  Next: Utilities for on-demand compilation of foreign files,  Prev: *** PART VIII - Interfaces to other languages and systems,  Up: Top

Foreign interface
*****************

             *Author(s):* Jose Morales, Manuel Carro.

             *Version:* 1.4 (1999/11/27, 19:0:0 MEST)

             *Version of last change:* 1.3#123 (1999/11/27, 3:3:55
MET)

             This module exports two predicates,
`build_foreign_interface/1' and `rebuild_foreign_interface/1'. These
predicates know about the correspondence between C types and Ciao
Prolog types through the assertions documenting them.

             Each predicate implemented as a foreign C function must
appear in the module as:

                    :- true pred prolog_predicate(m1(Arg1), ... mN(ArgN)) :: type1 *
                         ... * typeN + (foreign(foreign_function_name), returns(ArgR)).
               
                    :- impl_defined([..., prolog_predicate/N, ...]).

             where `m1', ..., `mN' and `type1', ..., `typeN' are
respectively the modes and types of the arguments.

             `prolog_predicate/N' is implemented by
`foreign_function_name', whose result is unified with `ArgR'.

             This notation can be simplified if the name of the
foreign function is the same as the name of the Ciao Prolog
predicate, replacing `foreign(foreign_function)' with just `foreign'.
`returns(ArgR)' specifies that the result of the function corresponds
to the `ArgR' argument of the Ciao Prolog predicate. If the foreign
function does not return anything, then `returns(ArgR)' must be
removed. Note that `returns' cannot be used without `foreign'.

                    :- true pred prolog_predicate(m1(Arg1), ... mN(ArgN)) :: type1 *
                         ... * typeN + foreign.

          * Menu:
          
          * Equivalence between Ciao Prolog and C modes::
          * Equivalence between Ciao Prolog and C types::
          * Examples::
          * Usage and interface (foreign_interface)::
          * Documentation on exports (foreign_interface)::


File: ciao.info,  Node: Equivalence between Ciao Prolog and C modes,  Next: Equivalence between Ciao Prolog and C types,  Prev: Foreign interface,  Up: Foreign interface

Equivalence between Ciao Prolog and C modes
===========================================

             (This section has not been written yet)


File: ciao.info,  Node: Equivalence between Ciao Prolog and C types,  Next: Examples,  Prev: Equivalence between Ciao Prolog and C modes,  Up: Foreign interface

Equivalence between Ciao Prolog and C types
===========================================

             The translation between Ciao Prolog and C types is
defined only for some simple types. The translation to be performed
is solely defined by types of the arguments in the Ciao Prolog
predicate, obeying the table below:

             * num <-> double

             * int <-> int

             * atm <-> char *

             * string <-> char * (with trailing zero)

             * byte_list <-> char * (a buffer, with associated length)

             * address <-> void *

             Strings, atoms, and lists of bytes are passed to (and
from) C as dynamically (malloc) created arrays of characters (bytes).
Those arrays are freed by Ciao Prolog upon return of the foreign
function unless `do_not_free/2' is specified (see examples below).

             Empty lists of bytes are converted into `NULL', and
strings `[]' or atoms " are converted into *""* (a zero ended C
string). *NULL* is converted into an empty list or the *"* atom.

             `NULL' strings and empty buffers are converted into the
empty list or the null atom (`'''). Empty Ciao Prolog strings (`"' or
`[]') and null atoms are converted into zero-terminated strings of
zero length. Empty Ciao Prolog lists are converted into `NULL'.

             The type `byte_list/1' requires an additional property,
`size_of/3', to indicate which argument represents its size.


File: ciao.info,  Node: Examples,  Next: Usage and interface (foreign_interface),  Prev: Equivalence between Ciao Prolog and C types,  Up: Foreign interface

Examples
========

          * Menu:
          
          * Mathematical functions::
          * Addresses and C pointers::
          * Lists of bytes and buffers::
          * Strings and atoms::


File: ciao.info,  Node: Mathematical functions,  Next: Addresses and C pointers,  Prev: Examples,  Up: Examples

Mathematical functions
----------------------

             *math.pl*

               :- module(math,
               	[sin/2,
               	 cos/2,
               	 fabs/2
               	],
               	[assertions,
               	 basicmodes,
               	 regtypes,
               	 'foreign_interface/syntax'
               	]).
               
               :- true pred sin(in(X),go(Y)) :: num * num + (foreign,returns(Y)).
               :- true pred cos(in(X),go(Y)) :: num * num + (foreign,returns(Y)).
               :- true pred fabs(in(X),go(Y)) :: num * num + (foreign,returns(Y)).
               
               :- extra_compiler_opts(['-O2']).
               :- extra_compiler_opts('LINUXi86',['-ffast-math']).
               :- use_foreign_library([m]).
               
               :- impl_defined([sin/2,cos/2,fabs/2]).


File: ciao.info,  Node: Addresses and C pointers,  Next: Lists of bytes and buffers,  Prev: Mathematical functions,  Up: Examples

Addresses and C pointers
------------------------

             *objects.pl*

               :- module(objects,
               	[object/2,
               	 show_object/1
               	],
               	[assertions,
               	 basicmodes,
               	 regtypes,
               	 'foreign_interface/syntax'
               	]).
               
               :- true pred object(in(N),go(Object)) :: int * address +
               	(foreign,returns(Object)).
               
               :- true pred show_object(in(Object)) :: address + foreign.
               
               :- use_foreign_source(objects_c).
               :- extra_compiler_opts('-O2').
               
               :- impl_defined([object/2,show_object/1]).

             *objects_c.c*

               #include <stdio.h>
               
               struct object {
                 char *name;
                 char *colour;
               };
               
               #define OBJECTS 3
               
               struct object objects[OBJECTS] =
               { {"ring","golden"},
                 {"table","brown"},
                 {"bottle","green"} };
               
               struct object *object(int n) {
                 return &objects[n % OBJECTS];
               }
               
               void show_object(struct object *o) {
                 printf("I show you a %s %s\n", o->colour, o->name);
               }


File: ciao.info,  Node: Lists of bytes and buffers,  Next: Strings and atoms,  Prev: Addresses and C pointers,  Up: Examples

Lists of bytes and buffers
--------------------------

             *byte_lists.pl*

               :- module(byte_lists,
               	[obtain_list/3,
               	 show_list/2
               	],
               	[assertions,
               	 basicmodes,
               	 regtypes,
               	 'foreign_interface/syntax'
               	]).
               
               :- true pred obtain_list(in(N),go(Length),go(List)) :: int * int * byte_list
               	+ (foreign,size_of(List,Length)).
               :- true pred show_list(in(Length),in(List)) :: int * byte_list
               	+ (foreign,size_of(List,Length)).
               
               :- use_foreign_source(bytes_op).
               
               :- impl_defined([obtain_list/3,show_list/2]).

             *bytes_op.c*

               #include <malloc.h>
               #include <stdio.h>
               
               void obtain_list(int n, int *l, char **s) {
                 int i;
                 int c;
                 if (n < 0) n = 0;
                 *l = n;
                 *s = (char *)malloc(*l);
                 for (i = 0; i < *l; i++) {
                   (*s)[i] = i;
                 }
               }
               
               void show_list(int l, char *s) {
                 if (s) {
                   int n;
                   printf("From C: [");
                   for (n = 0; n < l; n++) {
                     printf(" %d", s[n]);
                   }
                   printf("]\n");
                 } else {
                   printf("From C: []\n");
                 }
               }


File: ciao.info,  Node: Strings and atoms,  Prev: Lists of bytes and buffers,  Up: Examples

Strings and atoms
-----------------

             *strings_and_atoms.pl*

               :- module(strings_and_atoms,
               	[lookup_string/2,
               	 lookup_atom/2,
               	 a_string/1,
               	 show_string/1,
               	 show_atom/1
               	],
               	[assertions,
               	 basicmodes,
               	 regtypes,
               	 'foreign_interface/syntax'
               	]).
               
               
               :- true pred a_string(go(S)) ::
               	string + (foreign(get_static_str),returns(S),do_not_free(S)).
               
               :- true pred lookup_string(in(N),go(S)) ::
               	int * string + (foreign(get_str),returns(S)).
               :- true pred lookup_atom(in(N),go(S)) ::
               	int * atm + (foreign(get_str),returns(S)).
               
               :- true pred show_string(in(S)) :: string + foreign(put_str).
               :- true pred show_atom(in(S)) :: atm + foreign(put_str).
               
               :- use_foreign_source(str_op).
               
               :- impl_defined([lookup_string/2,lookup_atom/2,show_string/1,show_atom/1,
                                a_string/1]).

             *str_op.c*

               #include <malloc.h>
               #include <stdio.h>
               
               char *get_static_str() {
                 return "this is a string Ciao Prolog should not free";
               }
               
               char *get_str(int n) {
                 char *s;
                 int size;
                 int i;
                 int c;
                 if (n < 0) n = -n;
                 size = (n%4) + 5;
                 s = (char *)malloc(size+1);
                 for (i = 0, c = ((i + n) % ('z' - 'a' + 1)) + 'a'; i < size; i++,c++) {
                   if (c > 'z') c = 'a';
                   s[i] = c;
                 }
                 s[i] = 0;
                 return s;
               }
               
               void put_str(char *s) {
                 if (s) {
                   printf("From C: \"%s\"\n", s);
                 } else {
                   printf("From C: null\n");
                 }
               }


File: ciao.info,  Node: Usage and interface (foreign_interface),  Next: Documentation on exports (foreign_interface),  Prev: Examples,  Up: Foreign interface

Usage and interface (`foreign_interface')
=========================================

             * *Library usage:*

               `:- use_module(library(foreign_interface)).'

             * *Exports:*
                  - *Predicates:*

                    `build_foreign_interface/1',
                    `rebuild_foreign_interface/1',
                    `build_foreign_interface_explicit_decls/2',
                    `build_foreign_interface_object/1',
                    `rebuild_foreign_interface_object/1',
                    `do_interface/1'.

             * *Other modules used:*
                  - *System library modules:*

                    `terms', `lists', `llists', `aggregates',
                    `system', `format', `messages',
                    `assertions/assrt_lib', `foreign_compilation',
                    `compiler/c_itf', `ctrlcclean', `errhandle'.



File: ciao.info,  Node: Documentation on exports (foreign_interface),  Prev: Usage and interface (foreign_interface),  Up: Foreign interface

Documentation on exports (`foreign_interface')
==============================================

           - PREDICATE: build_foreign_interface/1:
               *Usage:* `build_foreign_interface(in(File))'
                  - *Description:* Reads assertions from `File',
                    generates the gluecode for the Ciao Prolog
                    interface, compiles the foreign files and the
                    gluecode file, and links everything in a shared
                    object. Checks modification times to determine
                    automatically which files must be
                    generated/compiled/linked.

                  - *Call and exit should be *compatible* with:*

                    `in(File)' is a source name.
                    (`streams_basic:sourcename/1')

           - PREDICATE: rebuild_foreign_interface/1:
               *Usage:* `rebuild_foreign_interface(in(File))'
                  - *Description:* Like `build_foreign_interface/1',
                    but it does not check the modification time of
                    any file.

                  - *Call and exit should be *compatible* with:*

                    `in(File)' is a source name.
                    (`streams_basic:sourcename/1')

           - PREDICATE: build_foreign_interface_explicit_decls/2:
               *Usage:*





               `build_foreign_interface_explicit_decls(in(File),in(Decls))'
                  - *Description:* Like `build_foreign_interface/1',
                    but use declarations in `Decls' instead of
                    reading the declarations from `File'.

                  - *Call and exit should be *compatible* with:*

                    `in(File)' is a source name.
                    (`streams_basic:sourcename/1')

                    `in(Decls)' is a list of `term's.
                    (`basic_props:list/2')

           - PREDICATE: build_foreign_interface_object/1:
               *Usage:* `build_foreign_interface_object(in(File))'
                  - *Description:* Compiles the gluecode file with
                    the foreign source files producing an unique
                    object file.

                  - *Call and exit should be *compatible* with:*

                    `in(File)' is a source name.
                    (`streams_basic:sourcename/1')

           - PREDICATE: rebuild_foreign_interface_object/1:
               *Usage:* `rebuild_foreign_interface_object(in(File))'
                  - *Description:* Compiles (again) the gluecode file
                    with the foreign source files producing an unique
                    object file.

                  - *Call and exit should be *compatible* with:*

                    `in(File)' is a source name.
                    (`streams_basic:sourcename/1')

           - PREDICATE: do_interface/1:
               *Usage:* `do_interface(in(Decls))'
                  - *Description:* Given the declarations in `Decls',
                    this predicate succeeds if these declarations
                    involve the creation of the foreign interface

                  - *Call and exit should be *compatible* with:*

                    `in(Decls)' is a list of `term's.
                    (`basic_props:list/2')


File: ciao.info,  Node: Utilities for on-demand compilation of foreign files,  Next: The socket interface,  Prev: Foreign interface,  Up: Top

Utilities for on-demand compilation of foreign files
****************************************************

             *Author(s):* Manuel Carro, Jose Morales.

             *Version:* 1.3#121 (1999/11/26, 20:23:11 MET)

             *Version of last change:* 1.3#36 (1999/7/20, 10:37:31
MEST)

             This module provides two predicates which give the user
information regarding how to compile external (C) files in order to
link them with the CIAO Prolog engine at runtime.

             These predicates are not intended to be called directly
by the end-user. Instead, a tool or module whose aim is generating
dynamically loadable files from source files should use the
predicates in this file in order to find out what are the proper
compiler and linker to use, and which options must be passed to them
in the current architecture.

          * Menu:
          
          * Usage and interface (foreign_compilation)::
          * Documentation on exports (foreign_compilation)::


File: ciao.info,  Node: Usage and interface (foreign_compilation),  Next: Documentation on exports (foreign_compilation),  Prev: Utilities for on-demand compilation of foreign files,  Up: Utilities for on-demand compilation of foreign files

Usage and interface (`foreign_compilation')
===========================================

             * *Library usage:*

               `:- use_module(library(foreign_compilation)).'

             * *Exports:*
                  - *Predicates:*

                    `compiler_and_opts/2', `linker_and_opts/2'.

             * *Other modules used:*
                  - *System library modules:*

                    `system'.



File: ciao.info,  Node: Documentation on exports (foreign_compilation),  Prev: Usage and interface (foreign_compilation),  Up: Utilities for on-demand compilation of foreign files

Documentation on exports (`foreign_compilation')
================================================

           - PREDICATE: compiler_and_opts/2:
               *Usage:* `compiler_and_opts(?(Compiler),?(Opts))'
                  - *Description:* If you want to compile a foreign
                    language file for dynamic linking in the current
                    operating system and architecture, you have to
                    use the compiler `Compiler' and gite it the
                    options `Opts'. A variable in `Opts' means that
                    no special option is needed.

                  - *The following properties should hold at call
                    time:*

                    `?(Compiler)' is currently instantiated to an
                    atom.   (`term_typing:atom/1')

                    `?(Opts)' is a list of `atom's.
                    (`basic_props:list/2')

           - PREDICATE: linker_and_opts/2:
               *Usage:* `linker_and_opts(?(Linker),?(Options))'
                  - *Description:* If you want to link a foreign
                    language file for dynamic linking in the current
                    operating system and architecture, you have to
                    use the linker `Compiler' and gite it the options
                    `Opts'. A variable in `Opts' means that no
                    special option is needed.

                  - *The following properties should hold at call
                    time:*

                    `?(Linker)' is currently instantiated to an atom.
                    (`term_typing:atom/1')

                    `?(Options)' is a list of `atom's.
                    (`basic_props:list/2')


File: ciao.info,  Node: The socket interface,  Next: The tcl/tk interface,  Prev: Utilities for on-demand compilation of foreign files,  Up: Top

The socket interface
********************

             *Author(s):* Manuel Carro, Daniel Cabeza.

             *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

             *Version of last change:* 1.3#5 (1999/6/21, 14:22:42
MEST)

             This module defines primitives to open sockets, send,
and receive data from them. This allows communicating with other
processes, on the same machine or across the Internet. The reader
should also consult standard bibliography on the topic for a proper
use of these primitives.

          * Menu:
          
          * Usage and interface (sockets)::
          * Documentation on exports (sockets)::


File: ciao.info,  Node: Usage and interface (sockets),  Next: Documentation on exports (sockets),  Prev: The socket interface,  Up: The socket interface

Usage and interface (`sockets')
===============================

             * *Library usage:*

               `:- use_module(library(sockets)).'

             * *Exports:*
                  - *Predicates:*

                    `connect_to_socket/3', `socket_recv/2',
                    `socket_recv_code/3', `socket_send/2',
                    `select_socket/5', `socket_accept/2',
                    `bind_socket/3', `connect_to_socket_type/4'.

                  - *Regular Types:*

                    `socket_type/1'.

             * *Other modules used:*
                  - *System library modules:*

                    `sockets/sockets_c'.



File: ciao.info,  Node: Documentation on exports (sockets),  Prev: Usage and interface (sockets),  Up: The socket interface

Documentation on exports (`sockets')
====================================

           - PREDICATE: connect_to_socket/3:
               *Usage:* `connect_to_socket(+Host,+Port,-(Stream))'
                  - *Description:* Calls `connect_to_socket_type/4'
                    with SOCK_STREAM connection type. This is the
                    connection type you want in order to use the
                    `write/2' and `read/2' predicates (and other
                    stream IO related predicates).

                  - *Call and exit should be *compatible* with:*

                    `+Host' is an atom.   (`basic_props:atm/1')

                    `+Port' is an integer.   (`basic_props:int/1')

                    `-(Stream)' is an open stream.
                    (`streams_basic:stream/1')

           - PREDICATE: socket_recv/2:
               *Usage:* `socket_recv(+Stream,?(String))'
                  - *Description:* As `socket_recv_code/3', but the
                    return code is ignored.

                  - *Call and exit should be *compatible* with:*

                    `+Stream' is an open stream.
                    (`streams_basic:stream/1')

                    `?(String)' is a string (a list of character
                    codes).   (`basic_props:string/1')

           - REGTYPE: socket_type/1:
               Defines the atoms which can be used to specify the
               socket type recognized by `connect_to_socket_type/4'.
               Defined as follows:
                    socket_type(stream).
                    socket_type(dgram).
                    socket_type(raw).
                    socket_type(seqpacket).
                    socket_type(rdm).

               *Usage:* `socket_type(T)'
                  - *Description:* `T' is a valid socket type.

                  - *The following properties should hold globally:*

                    Defines a regular type.
                    (`basic_props:regtype/1')

           - PREDICATE: socket_recv_code/3:
               *Usage:*
               `socket_recv_code(+Stream,?(String),?(Length))'
                  - *Description:* Receives a `String' from the
                    socket associated to `Stream', and returns its
                    `Length'. If `Length' is -1, no more data is
                    available.

                  - *Call and exit should be *compatible* with:*

                    `+Stream' is an open stream.
                    (`streams_basic:stream/1')

                    `?(String)' is a string (a list of character
                    codes).   (`basic_props:string/1')

                    `?(Length)' is an integer.   (`basic_props:int/1')

           - PREDICATE: socket_send/2:
               *Usage:* `socket_send(+Stream,+String)'
                  - *Description:* Sends `String' to the socket
                    associated to `Stream'. The socket has to be in
                    connected state. `String' is not supposed to be
                    NULL terminated, since it is a Prolog string. If
                    a NULL terminated string is needed at the other
                    side, it has to be explicitly created in Prolog.

                  - *Call and exit should be *compatible* with:*

                    `+Stream' is an open stream.
                    (`streams_basic:stream/1')

                    `+String' is a string (a list of character codes).
                    (`basic_props:string/1')

           - PREDICATE: select_socket/5:
               *Usage:*













               `select_socket(+Socket,-(NewStream),+TO_ms,+Streams,-(ReadStreams))'
                  - *Call and exit should be *compatible* with:*

                    `+Socket' is an integer.   (`basic_props:int/1')

                    `-(NewStream)' is an open stream.
                    (`streams_basic:stream/1')

                    `+TO_ms' is an integer.   (`basic_props:int/1')

                    `+Streams' is a list of `stream's.
                    (`basic_props:list/2')

                    `-(ReadStreams)' is a list of `stream's.
                    (`basic_props:list/2')

           - PREDICATE: socket_accept/2:
               *Usage:* `socket_accept(+Sock,-(Stream))'
                  - *Description:* Creates a new `Stream' connected
                    to `Sock'.

                  - *Call and exit should be *compatible* with:*

                    `+Sock' is an integer.   (`basic_props:int/1')

                    `-(Stream)' is an open stream.
                    (`streams_basic:stream/1')

           - PREDICATE: bind_socket/3:
               *Usage:* `bind_socket(?(Port),+Length,-(Socket))'
                  - *Description:* Returs an AF_INET `Socket' bound
                    to `Port' (which may be assigned by the OS or
                    defined by the caller), and listens to it (hence
                    no listen call in this set of primitives).
                    `Length' specifies the maximum number of pending
                    connections.

                  - *Call and exit should be *compatible* with:*

                    `?(Port)' is an integer.   (`basic_props:int/1')

                    `+Length' is an integer.   (`basic_props:int/1')

                    `-(Socket)' is an integer.   (`basic_props:int/1')

           - PREDICATE: connect_to_socket_type/4:
               *Usage:*
               `connect_to_socket_type(+Host,+Port,+Type,-(Stream))'
                  - *Description:* Returns a `Stream' which connects
                    to `Host'. The `Type' of connection can be
                    defined. A `Stream' is returned, which can be
                    used to `write/2' to, to `read/2', to
                    `socket_send/2' to, or to `socket_recv/2' from
                    the socket.

                  - *Call and exit should be *compatible* with:*

                    `+Host' is currently instantiated to an atom.
                    (`term_typing:atom/1')

                    `+Port' is an integer.   (`basic_props:int/1')

                    `+Type' is a valid socket type.
                    (`sockets:socket_type/1')

                    `-(Stream)' is an open stream.
                    (`streams_basic:stream/1')


File: ciao.info,  Node: The tcl/tk interface,  Next: Connecting with the Web,  Prev: The socket interface,  Up: Top

The tcl/tk interface
********************

             *Author(s):* Montse Iglesias.

             *Version:* 1.3#120 (1999/11/26, 12:5:17 MET)

             *Version of last change:* 0.9#85 (1999/5/7, 19:55:11
MEST)

             The `tcltk' library package is a bidirectional to the
*Tcl* (pronounced Tickle) language and *Tk* toolkit. Tcl is an
interpreter scripting language with many extensions packages, in
particular the graphical interface toolkit Tk

          * Menu:
          
          * Usage and interface (tcltk)::
          * Documentation on exports (tcltk)::


File: ciao.info,  Node: Usage and interface (tcltk),  Next: Documentation on exports (tcltk),  Prev: The tcl/tk interface,  Up: The tcl/tk interface

Usage and interface (`tcltk')
=============================

             * *Library usage:*

               `:- use_module(library(tcltk)).'

             * *Exports:*
                  - *Predicates:*

                    `tcl_new/1', `tcl_eval/3', `tcl_delete/1',
                    `tcl_event/3', `tk_new/2'.

                  - *Regular Types:*

                    `tclInterpreter/1', `tclCommand/1'.

             * *Other modules used:*
                  - *System library modules:*

                    `tcltk/tcltk_low_level', `write', `strings'.



File: ciao.info,  Node: Documentation on exports (tcltk),  Prev: Usage and interface (tcltk),  Up: The tcl/tk interface

Documentation on exports (`tcltk')
==================================

           - REGTYPE: tclInterpreter/1:
               *Usage:* `tclInterpreter(I)'
                  - *Description:* `I' is a reference to a *Tcl*
                    interpreter.

                  - *The following properties should hold globally:*

                    Defines a regular type.
                    (`basic_props:regtype/1')

           - REGTYPE: tclCommand/1:
               A *Tcl* command is specified as follows:
                          Command         --> Atom  { other than [] }
                                            | Number
                                            | chars(PrologString)
                                            | write(Term)
                                            | format(Fmt,Args)
                                            | dq(Command)
                                            | br(Command)
                                            | sqb(Command)
                                            | min(Command)
                                            | ListOfCommands
                          ListOfCommands  --> []
                                            |[Command|ListOfCommands]

               where:

              Atom

              Number
                    denote their printed representations.

              chars(PrologString)
                    denotes the string represented by *PrologString*
                    (a list of character codes).

              write(Term)
                    denotes the string that is printed by the
                    corresponding built-in pridicate.

              format(Term)
                    denotes the string that is printed by the
                    corresponding built-in pridicate.

              dq(Command)
                    denotes the string specified by *Command*,
                    enclosed in double quotes.

              br(Command)
                    denotes the string specified by *Command*,
                    enclosed in braces.

              sqb(Command)
                    denotes the string specified by *Command*,
                    enclosed in square brackets.

              min(Command)
                    denotes the string specified by *Command*,
                    immediately preceded by a hyphen.

              ListOfCommands
                    denotes the strings denoted by each element,
                    separated by spaces.

               *Usage:* `tclCommand(C)'
                  - *Description:* `C' is a *Tcl* command.

                  - *The following properties should hold globally:*

                    Defines a regular type.
                    (`basic_props:regtype/1')

           - PREDICATE: tcl_new/1:
               *Usage:* `tcl_new(-(TclInterpreter))'
                  - *Description:* Creates a new interpreter,
                    initializes it, and returns a reference to it in
                    `TclInterpreter'.

                  - *Call and exit should be *compatible* with:*

                    `-(TclInterpreter)' is a reference to a *Tcl*
                    interpreter.   (`tcltk:tclInterpreter/1')

           - PREDICATE: tcl_eval/3:
               *Usage:* `tcl_eval(+TclInterpreter,+Command,-(Result))'
                  - *Description:* Evaluates the commands and the
                    result will be stored as a string in *Result*

                  - *Call and exit should be *compatible* with:*

                    `+TclInterpreter' is a reference to a *Tcl*
                    interpreter.   (`tcltk:tclInterpreter/1')

                    `+Command' is a *Tcl* command.
                    (`tcltk:tclCommand/1')

                    `-(Result)' is a string (a list of character
                    codes).   (`basic_props:string/1')

           - PREDICATE: tcl_delete/1:
               *Usage:* `tcl_delete(+TclInterpreter)'
                  - *Description:* Deletes the interpreter in
                    `TclInterpreter' and the memory used by it

                  - *Call and exit should be *compatible* with:*

                    `+TclInterpreter' is a reference to a *Tcl*
                    interpreter.   (`tcltk:tclInterpreter/1')

           - PREDICATE: tcl_event/3:
               *Usage:*
               `tcl_event(+TclInterpreter,+Command,-(Events))'
                  - *Description:* Do the receive non blocking of the
                    event and terms will be stored from Tcl by the
                    *prolog_event* command as a list of terms in
                    *Events*.

                  - *Call and exit should be *compatible* with:*

                    `+TclInterpreter' is a reference to a *Tcl*
                    interpreter.   (`tcltk:tclInterpreter/1')

                    `+Command' is a *Tcl* command.
                    (`tcltk:tclCommand/1')

                    `-(Events)' is a list.   (`basic_props:list/1')

           - PREDICATE: tk_event_loop/1:
               No further documentation available for this predicate.


           - PREDICATE: tk_new/2:
               *Usage:* `tk_new(+Options,-(TclInterpreter))'
                  - *Description:* Performs basic Tcl and Tk
                    initialization and creates the main window of a
                    Tk application.*Options* is a list of optional
                    elements according to :

                   name
                         Sets the Tk application name. The
                         application name will be displayed in the
                         main window and is also used for
                         communicating between applications in Tk.
                         Default name is an empty string.

                   display
                         Gives the name of the screen on which to
                         create the main window. Default is normally
                         determined by the DISPLAY environment
                         variable.

                   file
                         Open the sript file, commands will not be
                         read from standard input and the execution
                         returns back to Prolog only after all
                         windows (and the interpreter) have been
                         deleted.

                   *Call and exit should be *compatible* with:*
                         `+Options' is a list.
                         (`basic_props:list/1')

                         `-(TclInterpreter)' is a reference to a
                         *Tcl* interpreter.
                         (`tcltk:tclInterpreter/1')

                          - PREDICATE: tk_new/4:
                              No further documentation available for
                              this predicate.



File: ciao.info,  Node: Connecting with the Web,  Next: html (library),  Prev: The tcl/tk interface,  Up: Top

Connecting with the Web
***********************

                            This package implements the PiLLoW
library [CHV96a] in Ciao. It is not yet documented here, but you can
access `http://clip.dia.fi.upm.es/Software/pillow/pillow.html' to see
documentation on previous versions. However, note that this version
is newer and has some bug fixes and added functionality (templates,
XML processing, and others, which you can try to guess the rest by
looking at the source).

                         * Menu:
                         
                         * Usage and interface (pillow)::


File: ciao.info,  Node: Usage and interface (pillow),  Prev: Connecting with the Web,  Up: Connecting with the Web

Usage and interface (`pillow')
==============================

                            * *Library usage:*

                              `:- use_package(pillow).'

                              or

                              `:- module(...,...,[pillow]).'

                            * *New operators defined:*

                              `$/2' [150,xfx], `$/1' [150,fx].

                            * *Other modules used:*
                                 - *System library modules:*

                                   `pillow/http', `pillow/html'.



File: ciao.info,  Node: html (library),  Next: http (library),  Prev: Connecting with the Web,  Up: Top

html (library)
**************

                            *Version:* 1.3#120 (1999/11/26, 12:5:17
MET)

                            *Version of last change:* 1.3#115
(1999/11/24, 0:58:36 MET)

                         * Menu:
                         
                         * Usage and interface (html)::
                         * Documentation on exports (html)::


File: ciao.info,  Node: Usage and interface (html),  Next: Documentation on exports (html),  Prev: html (library),  Up: html (library)

Usage and interface (`html')
============================

                            * *Library usage:*

                              `:- use_module(library(html)).'

                            * *Other modules used:*
                                 - *System library modules:*

                                   `strings', `lists', `system',
                                   `pillow/common'.



File: ciao.info,  Node: Documentation on exports (html),  Prev: Usage and interface (html),  Up: html (library)

Documentation on exports (`html')
=================================

                          - PREDICATE: url_info/2:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: url_info_relative/3:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: url_query/2:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: output_html/1:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: html2terms/2:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: xml2terms/2:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: html_template/3:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: http_lines/3:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: html_report_error/1:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: get_form_input/1:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: get_form_value/3:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: form_empty_value/1:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: text_lines/2:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: form_default/3:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: my_url/1:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: form_request_method/1:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: icon_address/2:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: html_protect/1:
                              No further documentation available for
                              this predicate.

                              *Meta-predicate* with arguments:
                              `html_protect(goal)'.



File: ciao.info,  Node: http (library),  Next: Persistent predicate database,  Prev: html (library),  Up: Top

http (library)
**************

                            *Version:* 1.3#120 (1999/11/26, 12:5:17
MET)

                            *Version of last change:* 1.3#114
(1999/11/24, 0:57:16 MET)

                         * Menu:
                         
                         * Usage and interface (http)::
                         * Documentation on exports (http)::


File: ciao.info,  Node: Usage and interface (http),  Next: Documentation on exports (http),  Prev: http (library),  Up: http (library)

Usage and interface (`http')
============================

                            * *Library usage:*

                              `:- use_module(library(http)).'

                            * *Other modules used:*
                                 - *System library modules:*

                                   `sockets/sockets', `strings',
                                   `lists', `pillow/common'.



File: ciao.info,  Node: Documentation on exports (http),  Prev: Usage and interface (http),  Up: http (library)

Documentation on exports (`http')
=================================

                          - PREDICATE: fetch_url/3:
                              No further documentation available for
                              this predicate.



File: ciao.info,  Node: Persistent predicate database,  Next: Using the persdb library,  Prev: http (library),  Up: Top

Persistent predicate database
*****************************

                            *Author(s):* J.M. Gomez, D. Cabeza, and
M. Hermenegildo, `clip@dia.fi.upm.es',
`http://www.clip.dia.fi.upm.es/', The CLIP Group, Facultad de
Inform'atica, Universidad Polit'ecnica de Madrid.

                            *Version:* 1.3#120 (1999/11/26, 12:5:17
MET)

                            *Version of last change:* 0.8#31
(1998/12/27, 19:17:20 MET)

                         * Menu:
                         
                         * Introduction to persistent predicates::
                         * Persistent predicates::
                         * Using file-based persistent predicates::
                         * Implementation Issues::
                         * Using persistent predicates from the top level::
                         * Usage and interface (persdbrt)::
                         * Documentation on exports (persdbrt)::
                         * Documentation on multifiles (persdbrt)::
                         * Documentation on internals (persdbrt)::
                         * Known bugs and planned improvements (persdbrt)::


File: ciao.info,  Node: Introduction to persistent predicates,  Next: Persistent predicates,  Prev: Persistent predicate database,  Up: Persistent predicate database

Introduction to persistent predicates
=====================================

                            This library implements a *generic
persistent predicate database*. The basic notion implemented by the
library is that of a persistent predicate. The persistent predicate
concept provides a simple, yet powerful generic persistent data
access method [CHGT98,Par97]. A persistent predicate is a special
kind of dynamic, data predicate that "resides" in some persistent
medium (such as a set of files, a database, etc.) that is typically
external to the program using such predicates. The main effect is
that any changes made to to a persistent predicate from a program
"survive" across executions. I.e., if the program is halted and
restarted the predicate that the new process sees is in precisely the
same state as it was when the old process was halted (provided no
change was made in the meantime to the storage by other processes or
the user).

                            Persistent predicates appear to a program
as ordinary predicates, and calls to these predicates can appear in
clause bodies in the usual way. However, the definitions of these
predicates do not appear in the program. Instead, the library
maintains automatically the definitions of predicates which have been
declared as persistent in the persistent storage.

                            Updates to persistent predicates can be
made by calling predicates similar to `assertz_fact/1' and
`retract_fact/1'. The library makes sure that each update is a
transactional update, in the sense that if the update terminates,
then the permanent storage has definitely been modified. For example,
if the program making the updates is halted just after the update and
then restarted, then the updated state of the predicate will be seen.
This provides security against possible data loss due to, for
example, a system crash. Also, due to the atomicity of the
transactions, persistent predicates allow concurrent updates from
several programs.


File: ciao.info,  Node: Persistent predicates,  Next: Using file-based persistent predicates,  Prev: Introduction to persistent predicates,  Up: Persistent predicate database

Persistent predicates, files, and relational databases
======================================================

                            The concept of persistent predicates
provided by this library essentially implements a light-weight,
simple, and at the same time powerful form of relational database (a
deductive database), and which is standalone, in the sense that it
does not require external support, other than the file management
capabilities provided by the operating system. This is due to the
fact that the persistent predicates are in fact stored in one or more
auxiliary files in a given directory.

                            This type of database is specially useful
when building small to medium-sized standalone applications in Prolog
which require persistent storage. In many cases it provides a much
easier way of implementing such storage than using files under direct
program control. For example, interactive applications can use
persistent predicates to represent their internal state in a way that
is close to the application. The persistence of such predicates then
allows automatically restoring the state to that at the end of a
previous session. Using persistent predicates amounts to simply
declaring some predicates as such and eliminates having to worry
about opening files, closing them, recovering from system crashes,
etc.

                            In other cases, however, it may be
convenient to use a relational database as persistent storage. This
may be the case, for example, when the data already resides in such a
database (where it is perhaps accessed also by other applications) or
the volume of data is very large.  `persdb_sql' [CCG98] is a
companion library which implements the same notion of persistent
predicates used herein, but keeping the storage in a relational
database. This provides a very natural and transparent way to access
SQL database relations from a Prolog program. In that library,
facilities are also provided for reflecting more complex *views* of
the database relations as predicates. Such views can be constructed
as conjunctions, disjunctions, projections, etc. of database
relations, and may include SQL-like aggregation operations.

                            A nice characteristic of the notion of
persistent predicates used in both of these libraries is that it
abstracts away how the predicate is actually stored. Thus, a program
can use persistent predicates stored in files or in external
relational databases interchangeably, and the type of storage used
for a given predicate can be changed without having to modify the
program (except for replacing the corresponding `persistent/2'
declarations).

                            An example application of the `persdb' and
`persdb_sql' libraries (and also the `pillow' library [CH97]), is
`WebDB' [GCH98].  `WebDB' is a generic, highly customizable
*deductive database engine* with an *html interface*.  `WebDB' allows
creating and maintaining Prolog-based databases as well as relational
databases (residing in conventional relational database engines)
using any standard WWW browser.


File: ciao.info,  Node: Using file-based persistent predicates,  Next: Implementation Issues,  Prev: Persistent predicates,  Up: Persistent predicate database

Using file-based persistent predicates
======================================

                            Persistent predicates can be declared
statically, using `persistent/2' declarations (which is the preferred
method, when possible), or dynamically via calls to
`make_persistent/2'. Currently, persistent predicates may only
contain facts, i.e., they are *dynamic* predicates of type `data/1',
and *should be declared as such*.

                            Predicates declared as persistent are
linked to a directory, and the persistent state of the predicate will
be kept in several files in that directory. The files in which the
persistent predicates are stored are in readable, plain ASCII format,
and in Prolog syntax. One advantage of this approach is that such
files can also be created or edited by hand, in a text editor, or
even by other applications.

                            An example definition of a persistent
predicate implemented by files follows:

                              :- persistent(p/3,dbdir).
                              
                              :- multifile persistent_dir/2.
                              :- data persistent_dir/2.
                              
                              persistent_dir(dbdir, '/home/clip/public_html/db').

                            The first line declares the predicate
`p/3' persistent. The argument `dbdir' is a key used to index into a
fact of the relation `persistent_dir/2', which specifies the
directory where the corresponding files will be kept. The effect of
the declaration, together with the `persistent_dir/2' fact, is that,
although the predicate is handled in the same way as a normal data
predicate, in addition the system will create and maintain
efficiently a persistent version of `p/3' via files in the directory
`/home/clip/public_html/db'.

                            The level of indirection provided by the
`dbdir' argument makes it easy to place the storage of several
persistent predicates in a common directory, by specifying the same
key for all of them. It also allows changing the directory for
several such persistent predicates by modifying only one fact in the
program. Furthermore, the `persistent_dir/2' predicate can even be
dynamic and specified at run-time.


File: ciao.info,  Node: Implementation Issues,  Next: Using persistent predicates from the top level,  Prev: Using file-based persistent predicates,  Up: Persistent predicate database

Implementation Issues
=====================

                            We outline the current implementation
approach. This implementation attempts to provide at the same time
efficiency and security. To this end, up to three files are used for
each predicate (the persistence set): the data file, the operations
file, and the backup file. In the updated state the facts (tuples)
that define the predicate are stored in the data file and the
operations file is empty (the backup file, which contains a security
copy of the data file, may or may not exist).

                            While a program using a persistent
predicate is running, any insertion (assert) or deletion (retract)
operations on the predicate are performed on both the program memory
and on the persistence set. However, in order to incurr only a small
overhead in the execution, rather than changing the data file
directly, a record of each of the insertion and deletion operations
is *appended* to the operations file. The predicate is then in a
transient state, in that the contents of the data file do not reflect
exactly the current state of the corresponding predicate. However,
the complete persistence set does.

                            When a program starts, when it is halted,
or, periodically, when it is idle for some time, all pending
operations in the operations file are performed on the data file. A
backup of the data file is created first to prevent data loss if the
system crashes during this operation. The order in which this
updating of files is done ensures that, if at any point the process
dies, on restart data will be completely recovered. This process of
updating the persistence set can also be triggered at any point in
the execution of a program by calling `update_files/2'.


File: ciao.info,  Node: Using persistent predicates from the top level,  Next: Usage and interface (persdbrt),  Prev: Implementation Issues,  Up: Persistent predicate database

Using persistent predicates from the top level
==============================================

                            Special care must be taken when using
persistent predicates from the top level. This includes not only
defining persistent predicates on the fly from de top level (which is
not really very useful in practice) but also the more frequent case
of loading into the top level modules or user files which use
persistent predicates. As mentioned before, the persistence set is
updated automatically each time a program using the corresponding
persistent predicates is run or halted. However, since the top level
itself is also a standard program, persistent predicates would only
be updated whenever the top level is started, when they are typically
still not loaded.

                            If a program launched from a top level
needs to update the persistence sets of any persistent predicate it
must be done by calling the `update_files/2' method explicitly.


File: ciao.info,  Node: Usage and interface (persdbrt),  Next: Documentation on exports (persdbrt),  Prev: Using persistent predicates from the top level,  Up: Persistent predicate database

Usage and interface (`persdbrt')
================================

                            * *Library usage:*

                              Typically, this library is used
                              including the 'persdb' package into the
                              syntax list of the module, or using the
                              `syntax/1' declaration:
                             In a module:
                                                :- module(bar, [main/1], [persdb]).
                                   or
                                                :- module(bar, [main/1]).
                                                :- include(library(persdb)).

                             In a *user* file:
                                                :- syntax([persdb]).
                                   or
                                                :- include(library(persdb)).
                                   This syntax file loads the
                              run-time and compile-time versions of
                              the library (`persdbtr.pl' and
                              `persdbrt.pl') and includes some needed
                              declarations.

                            * *Exports:*
                                 - *Predicates:*

                                   `passertz_fact/1',
                                   `pretract_fact/1',
                                   `pcurrent_fact/1', `init_persdb/0',
                                   `initialize_db/0',
                                   `make_persistent/2',
                                   `update_files/2'.

                                 - *Multifiles:*

                                   `persistent_dir/2',
                                   `$is_persistent/2'.

                            * *Other modules used:*
                                 - *System library modules:*

                                   `lists', `streams', `read',
                                   `system', `file_locks/file_locks'.



File: ciao.info,  Node: Documentation on exports (persdbrt),  Next: Documentation on multifiles (persdbrt),  Prev: Usage and interface (persdbrt),  Up: Persistent predicate database

Documentation on exports (`persdbrt')
=====================================

                          - PREDICATE: passertz_fact/1:
                              *Meta-predicate* with arguments:
                              `passertz_fact(fact)'.

                              *Usage:* `passertz_fact(Fact)'
                                 - *Description:* Persistent version
                                   of `assertz_fact/1': the current
                                   instance of `Fact' is interpreted
                                   as a fact (i.e., a relation tuple)
                                   and is added at the end of the
                                   definition of the corresponding
                                   predicate. The predicate concerned
                                   must be declared `persistent'. Any
                                   uninstantiated variables in the
                                   `Fact' will be replaced by new,
                                   private variables.

                                 - *The following properties should
                                   hold at call time:*

                                   `Fact' is a term which represents
                                   a goal, i.e., an atom or a
                                   structure.
                                   (`basic_props:callable/1')

                          - PREDICATE: pretract_fact/1:
                              *Meta-predicate* with arguments:
                              `pretract_fact(fact)'.

                              *Usage:* `pretract_fact(Fact)'
                                 - *Description:* Persistent version
                                   of `retract_fact/1': deletes on
                                   backtracking all the facts which
                                   unify with `Fact'. The predicate
                                   concerned must be declared
                                   `persistent'.

                                 - *The following properties should
                                   hold at call time:*

                                   `Fact' is a term which represents
                                   a goal, i.e., an atom or a
                                   structure.
                                   (`basic_props:callable/1')

                          - PREDICATE: pcurrent_fact/1:
                              *Meta-predicate* with arguments:
                              `pcurrent_fact(fact)'.

                              *Usage:* `pcurrent_fact(Fact)'
                                 - *Description:* Persistent version
                                   of `current_fact/1': the fact
                                   `Fact' exists in the current
                                   database. The predicate concerned
                                   must be declared `persistent'.
                                   Provides on backtracking all the
                                   facts (tuples) which unify with
                                   `Fact'.

                                 - *The following properties should
                                   hold at call time:*

                                   `Fact' is a term which represents
                                   a goal, i.e., an atom or a
                                   structure.
                                   (`basic_props:callable/1')

                          - PREDICATE: init_persdb/0:
                              *Usage:*
                                 - *Description:* Executes
                                   `initialize_db/0' if no
                                   initialization has been done yet.
                                   Needed when accesing persistent
                                   predicates before doing any of
                                   `passertz_fact/1',
                                   `pretract_fact/1', or
                                   `pcurrent_fact/1'.

                          - PREDICATE: initialize_db/0:
                              *Usage:*
                                 - *Description:* Initializes the
                                   whole database, updating the state
                                   of the declared persistent
                                   predicates.

                          - PREDICATE: make_persistent/2:
                              *Meta-predicate* with arguments:
                              `make_persistent(spec,?)'.

                              *Usage:*
                              `make_persistent(PredDesc,Keyword)'
                                 - *Description:* Dynamic version of
                                   the `persistent' declaration.

                                 - *The following properties should
                                   hold at call time:*

                                   `PredDesc' is a Name/Arity
                                   structure denoting a predicate
                                   name:
                                        predname(P/A) :-
                                                atm(P),
                                                int(A).

                                   (`basic_props:predname/1')

                                   `Keyword' is an atom corresponding
                                   to a directory identifier.
                                   (`persdbrt:keyword/1')

                          - PREDICATE: update_files/2:
                              *Usage:* `update_files(PredDesc,Arity)'
                                 - *Description:* Updates the state
                                   of the given persistent predicate
                                   and its corresponding persistence
                                   set.

                                 - *The following properties should
                                   hold upon exit:*

                                   `PredDesc' is a Name/Arity
                                   structure denoting a predicate
                                   name:
                                        predname(P/A) :-
                                                atm(P),
                                                int(A).

                                   (`basic_props:predname/1')

                                   `Arity' is an integer.
                                   (`basic_props:int/1')


File: ciao.info,  Node: Documentation on multifiles (persdbrt),  Next: Documentation on internals (persdbrt),  Prev: Documentation on exports (persdbrt),  Up: Persistent predicate database

Documentation on multifiles (`persdbrt')
========================================

                          - PREDICATE: persistent_dir/2:
                              The predicate is *multifile* and of
                              type *data*.

                              *Usage:*
                              `persistent_dir(Keyword,Location_Path)'
                                 - *Description:* Relates identifiers
                                   of locations (the `Keyword's) with
                                   descriptions of such locations
                                   (`Location_Path's).
                                   `Location_Path' is *a directory*
                                   and it means that the definition
                                   for the persistent predicates
                                   associated with `Keyword' is kept
                                   in files in that directory. These
                                   files, in the updated state,
                                   contain the actual definition of
                                   the predicate in Prolog syntax
                                   (but with module names resolved).

                                 - *The following properties should
                                   hold at call time:*

                                   `Keyword' is an atom corresponding
                                   to a directory identifier.
                                   (`persdbrt:keyword/1')

                                   `Location_Path' is an atom which
                                   is the name of a directory.
                                   (`persdbrt:directoryname/1')

                          - PREDICATE: $is_persistent/2:
                              No further documentation available for
                              this predicate.

                              The predicate is *multifile*.



File: ciao.info,  Node: Documentation on internals (persdbrt),  Next: Known bugs and planned improvements (persdbrt),  Prev: Documentation on multifiles (persdbrt),  Up: Persistent predicate database

Documentation on internals (`persdbrt')
=======================================

                          - REGTYPE: keyword/1:
                              An atom which identifies a fact of the
                              `persistent_dir/2' relation. This fact
                              relates this atom to a directory in
                              which the persistent storage for one or
                              more persistent predicates is kept.

                              *Usage:* `keyword(X)'
                                 - *Description:* `X' is an atom
                                   corresponding to a directory
                                   identifier.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - REGTYPE: directoryname/1:
                              *Usage:* `directoryname(X)'
                                 - *Description:* `X' is an atom
                                   which is the name of a directory.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')


File: ciao.info,  Node: Known bugs and planned improvements (persdbrt),  Prev: Documentation on internals (persdbrt),  Up: Persistent predicate database

Known bugs and planned improvements (`persdbrt')
================================================

                            * Shouldn't the declarations for
                              persistent_dir/2 be inside persdb.pl?
                              (would save a lot of writing).

                            * make_persistent/2 should really be
                              persistent/2 (since it doesn't really
                              make a predicate persistent but rather
                              declares it as such, i.e., we do not
                              use make_data/1, we use data/1) ?

                            * having to use pcurrent_fact is not so
                              nice

                            * passert, pretract, etc. should really
                              be overloaded versions of assert,
                              retract etc., i.e., it should be
                              possible to use assertz_fact directly

                            * we need also asserta_fact, right?
                              Otherwise isn't it difficult to do many
                              things?


File: ciao.info,  Node: Using the persdb library,  Next: SQL persistent database interface,  Prev: Persistent predicate database,  Up: Top

Using the persdb library
************************

                            Through the following examples we will
try to illustrate the two mains ways of declaring and using
persistent predicates: statically (the preferred method) and
dynamically (necessary when the new persistent predicates have to be
defined at run-time). The final example is a small application
implementing a simple persistent queue.

                         * Menu:
                         
                         * An example of persistent predicates (static version)::
                         * An example of persistent predicates (dynamic version)::
                         * A simple application: a persistent queue::


File: ciao.info,  Node: An example of persistent predicates (static version),  Next: An example of persistent predicates (dynamic version),  Prev: Using the persdb library,  Up: Using the persdb library

An example of persistent predicates (static version)
====================================================

                              :- include(library(persdb)).
                              
                              %% Required declarations for persistent_dir/2.
                              :- multifile persistent_dir/2.
                              :- data persistent_dir/2.
                              
                              %% Declare the directory associated to the key "db" where the
                              %% persistence sets of the persistent predicates are stored:
                              persistent_dir(db,'./').
                              
                              %% Declare a persistent predicate:
                              :- persistent(bar/1, db).
                              
                              %% Read a term, storing it in a new fact of the persistent predicate
                              %% and list all the current facts of that predicate
                              main:-
                                   read(X),
                                   passertz_fact(bar(X)),
                                   findall(Y,bar(Y),L),
                                   write(L).


File: ciao.info,  Node: An example of persistent predicates (dynamic version),  Next: A simple application: a persistent queue,  Prev: An example of persistent predicates (static version),  Up: Using the persdb library

An example of persistent predicates (dynamic version)
=====================================================

                              :- include(library(persdb)).
                              
                              %% Required declarations for persistent_dir/2.
                              :- multifile persistent_dir/2.
                              :- data persistent_dir/2.
                              
                              main([X]):-
                              %%   Declare the directory associated to the key "db"
                                   asserta_fact(persistent_dir(db,'./')),
                              %%   Declare the predicate bar/1 as dynamic (and data) at run-time
                                   data(bar/1),
                              %%   Declare the predicate bar/1 as persistent at run-time
                                   make_persistent(bar/1, db),
                                   passertz_fact(bar(X)),
                                   findall(Y, bar(Y), L),
                                   write(L).


File: ciao.info,  Node: A simple application: a persistent queue,  Prev: An example of persistent predicates (dynamic version),  Up: Using the persdb library

A simple application: a persistent queue
========================================

                              :- module(queue, [main/0]).
                              
                              :- include(library(persdb)).
                              
                              :- multifile persistent_dir/2.
                              :- data persistent_dir/2.
                              
                              :- persistent(queue/1, queue_dir).
                              
                              persistent_dir(queue_dir,'./pers').
                              
                              main:-
                                   write('Action ( in(Term). | out. | list. | halt. ): '),
                                   read(A),
                                   (  handle_action(A)
                                   -> true
                                   ;  write('Unknown command.'), nl ),
                                   main.
                              
                              handle_action(halt) :-
                                   halt.
                              handle_action(in(Term)) :-
                                   passertz_fact(queue(Term)),
                                   main.
                              handle_action(out) :-
                                   (  pretract_fact(queue(Term))
                                   -> write('Out '), write(Term)
                                   ;  write('FIFO empty.') ),
                                   nl,
                                   main.
                              handle_action(list) :-
                                   findall(Term,pcurrent_fact(queue(Term)),Terms),
                                   write('Contents: '), write(Terms), nl,
                                   main.


File: ciao.info,  Node: SQL persistent database interface,  Next: Prolog to SQL translator,  Prev: Using the persdb library,  Up: Top

SQL persistent database interface
*********************************

                            *Author(s):* I. Caballero, D. Cabeza,
J.M. G'omez, and M. Hermenegildo, `clip@dia.fi.upm.es',
`http://www.clip.dia.fi.upm.es/', The CLIP Group, Facultad de
Inform'atica, Universidad Polit'ecnica de Madrid.

                            *Version:* 1.3#121 (1999/11/26, 20:23:11
MET)

                            *Version of last change:* 0.9#35
(1999/4/6, 13:52:16 MEST)

                            The purpose of this library is to
implement an instance of the generic concept of persistent
predicates, where external relational databases are used for storage
(see the documentation of the `persdb' library and [CHGT98,Par97] for
details). To this end, this library exports SQL persistent versions
of the `assertz_fact/1', `retract_fact/1' and `retractall_fact/1'
builtin predicates. Persistent predicates also allow concurrent
updates from several programs, since each update is atomic.

                            The notion of persistence provides a very
natural and transparent way to access database relations from a
Prolog program. Stub definitions are provided for such predicates
which access the database when the predicate is called (using the
`db_client' library). A Prolog to SQL translator is used to generate
the required SQL code dynamically (see library `pl2sql').

                            This library also provides facilities for
reflecting more complex views of the database relations as Prolog
predicates. Such views can be constructed as conjunctions,
disjunctions, projections, etc. of database relations. Also, SQL-like
aggregation operations are supported.

                         * Menu:
                         
                         * Implementation of the Database Interface::
                         * Example(s)::
                         * Usage and interface (persdbrtsql)::
                         * Documentation on exports (persdbrtsql)::
                         * Documentation on multifiles (persdbrtsql)::
                         * Documentation on internals (persdbrtsql)::
                         * Known bugs and planned improvements (persdbrtsql)::


File: ciao.info,  Node: Implementation of the Database Interface,  Next: Example(s),  Prev: SQL persistent database interface,  Up: SQL persistent database interface

Implementation of the Database Interface
========================================

                            The architecture of the low-level
implementation of the database interface was defined with two goals
in mind:

                            * to simplify the communication between
                              the Prolog system and the relational
                              database engines as much as possible,
                              and

                            * to give as much flexibility as possible
                              to the overall system. This includes
                              simultaneous access to several
                              databases, allowing both the databases
                              and clients to reside on the same
                              physical machine or different machines,
                              and allowing the clients to reside in
                              Win95/NT or Unix machines.

                            In order to allow the flexibility
mentioned above, a client-sever architecture was chosen. The
following figure depicts the overall architecture of the system:


                         [Image file: autofigarchitecture.eps]

                            At the server side, a "database mediator
server" connects on one side to the databases using the ODBC
interface (this interface is available for the databases of the
RadioWeb project, as well as for the majority of the databases
running in the Win95/NT operating systems) and on the other it is
connected to the network by TCP/IP using a fixed socket number /
service (currently fixed to socket number 2020).

                            The mediator server must run on the
Windows (NT/95) operating system, on the machine where the databases
are also running. The (Prolog) clients which connect to it can be run
locally at the server machine. In addition, remote clients running on
different machines can also connect to the mediator server by
connecting to its socket number (service). Such clients can run on
either Unix or Windows systems.

                            After the connection is established a
client can send commands to the mediator server which will pass them
to the corresponding database server, and then the data will traverse
in the opposite direction. These messages include logging on and off
from the database, sending SQL queries, and receiving the responses.

                            The low level implementation of the
current library is accomplished by providing several abstraction
levels over the socket interface library of the Prolog engine. These
layers of abstraction implement the persistent predicate view, build
the appropriate commands for the database using a translator of
Prolog goals to SQL commands, issue such commands using the mediator
send/receive procedures, parse the responses, and present such
responses to the Prolog engine via backtracking.


File: ciao.info,  Node: Example(s),  Next: Usage and interface (persdbrtsql),  Prev: Implementation of the Database Interface,  Up: SQL persistent database interface

Example(s)
==========

                              :- include(library('persdb_sql/persdb_sql')).
                              :- use_module(library(format)).
                              
                              %% ------------------------------------------------- %%
                              %% First sample database : 'SA 6.0 Sample' %%
                              %% ------------------------------------------------- %%
                              
                              %% Declare product/4 a persistent predicate, storage in 'radiowebdb':
                              :- sql_persistent(product( int,    int, string, string ),
                                            product( quantity,   id,      name,   size   ),
                                            sampledb).
                              sql_persistent_location(sampledb, %% The 'sampledb' descriptor:
                                       db('ASA 6.0 Sample','dba', 'sql','r2d5.dia.fi.upm.es':2020)).
                              
                              main0 :-
                              %% Prints the contents of the relation 'product/4' by backtracking over it:
                                       format("Printing table:\n",[]),
                                       product(Quantity, Id, Name, Size),
                                       format("Tuple: ~w \t ~w \t ~w \t ~w \n",
                                              [Quantity, Id, Name, Size]),
                                       fail.
                              main0 :-
                                       format("Done.\n",[]).
                              
                              %% Generalizing table printing:
                              %% Prints the contents of Pred by backtracking over it
                              print_predicate(Pred):-
                                      format("Printing relation:\n",[]),
                                      Pred, %% predicate call
                                      Pred=..[_|Args],
                                      format("\t Tuple: ~w \n",[Args]),
                                      fail.
                              print_predicate(_Pred):-
                                      format("Done.~n",[]).
                              
                              main1 :- %% similar to main0:
                              %% Prints the contents of the relation 'product/4' by backtracking over it:
                                      print_predicate(product(_Quantity,_Id,_Name,_Size)).
                              
                              main2 :- %% Issues a complex query inside a db_findall:
                                       dbfindall(sampledb,
                                                 foo(Quantity, Id, Name, Size, Bar),
                                                 ( product(Quantity, Id, Name, Size),
                                                   I^N^S^(Bar is avg(Q,product(Q, I, N, S)))
                                                 ),
                                                 Results),
                                       format("Results = ~w~n",[Results]).
                              main21 :- %% Using db_call
                                       dbcall(sampledb,
                                           (product(Quantity, Id, Name, Size),
                                            product(Quantity, Id1, _Name1, _Size1),Id1>Id)),
                              %%       product(Quantity, Id, Name, Size),
                              %%          product(Quantity, Id1, Name1, Size1),
                              %%          Id1>Id,
                                       format("Tuple: ~w \t ~w \t ~w \t ~w \n",
                                              [Quantity, Id, Name, Size]).
                              
                              main22 :-  % get the set of tables from a database
                                      sql_get_tables(sampledb,TablesList),
                                      display(TablesList).
                              
                              main23 :- % get table attributes and its types
                                      sql_table_types(sampledb, 'Customer', AttList),
                                      display(AttList).
                              
                              %% ------------------------------------------------- %%
                              %% Second sample database : 'Literature'             %%
                              %% ------------------------------------------------- %%
                              
                              :- sql_persistent(authors(string,string,int),
                                             authors(firstName,lastName,id), %% 'id' is the primary key
                                             literature_db).
                              sql_persistent_location(literature_db,
                                      db('Literature','dba','sql','r2d5.dia.fi.upm.es':2020)).
                              
                              main3:- %% Prints the contents of authors
                                       print_predicate(authors(_FirstName,_LastName,_Id)) .
                              
                              main4:- %% assert a persistent fact
                                       dbassertz_fact(authors('Pedro','Calderon de la Barca',17)).
                              
                              main6:- %% retract a persistent fact
                                       dbretract_fact(authors('Pedro','Calderon de la Barca',17)).
                              
                              
                              main9:- %% checking if a persistent fact is a current fact
                                      dbcurrent_fact(authors(_X,_Y,_Z)).


File: ciao.info,  Node: Usage and interface (persdbrtsql),  Next: Documentation on exports (persdbrtsql),  Prev: Example(s),  Up: SQL persistent database interface

Usage and interface (`persdbrtsql')
===================================

                            * *Library usage:*

                              Typically, this library is used
                              including the 'persdb_sql' package into
                              the package list of the module, or
                              using the `use_package/1' declaration:
                             In a module:
                                        	:- module(bar, [main/1], [persdb_sql]).
                                   or
                                                :- module(bar, [main/1]).
                                                :- include(library(persdb_sql)).

                             In a *user* file:
                                        	:- use_package([persdb_sql]).
                                   or
                                                :- include(library(persdb_sql)).
                                   This loads the run-time and
                              compile-time versions of the library
                              (`persdbtr_sql.pl' and
                              `persdbrt_sql.pl') and includes some
                              needed declarations.

                            * *Exports:*
                                 - *Predicates:*

                                   `init_sql_persdb/0',
                                   `dbassertz_fact/1',
                                   `dbretract_fact/1',
                                   `dbcurrent_fact/1',
                                   `dbretractall_fact/1',
                                   `make_sql_persistent/3',
                                   `dbfindall/4', `dbcall/2',
                                   `sql_query/3', `sql_get_tables/2',
                                   `sql_table_types/3'.

                                 - *Multifiles:*

                                   `sql_persistent_location/2'.

                            * *Other modules used:*
                                 - *System library modules:*

                                   `persdb_sql/db_client',
                                   `persdb_sql/pl2sql',
                                   `persdb_sql/sqltypes', `dynamic',
                                   `terms', `metaterms', `messages',
                                   `lists', `aggregates',







                                   `persdb_sql/insert_compiler/pl2sqlinsert'.



File: ciao.info,  Node: Documentation on exports (persdbrtsql),  Next: Documentation on multifiles (persdbrtsql),  Prev: Usage and interface (persdbrtsql),  Up: SQL persistent database interface

Documentation on exports (`persdbrtsql')
========================================

                          - PREDICATE: init_sql_persdb/0:
                              *Usage:*
                                 - *Description:* Internal predicate,
                                   used to transform predicates
                                   statically declared as persistent
                                   (see `sql_persistent/3') into real
                                   persistent predicates.

                          - PREDICATE: sql_persistent/3:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: dbassertz_fact/1:
                              The predicate is of type *implicit*.

                              *Usage:* `dbassertz_fact(+Fact)'
                                 - *Description:* Persistent
                                   extension of `assertz_fact/1': the
                                   current instance of `Fact' is
                                   interpreted as a fact (i.e., a
                                   relation tuple) and is added to
                                   the end of the definition of the
                                   corresponding predicate. If any
                                   integrity constraint violation is
                                   done (database stored predicates),
                                   an error will be displayed. The
                                   predicate concerned must be
                                   statically ( `sql_persistent/3')
                                   or dinamically (
                                   `make_sql_persistent/3') declared.
                                   Any uninstantiated variables in
                                   the `Fact' will be replaced by
                                   new, private variables. *Note:*
                                   *assertion of facts with
                                   uninstantiated variables not
                                   implemented at this time.*

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+Fact' is a fact (a term whose
                                   main functor is not `':-'/2').
                                   (`persdbrtsql:fact/1')

                          - PREDICATE: dbretract_fact/1:
                              The predicate is of type *implicit*.

                              *Usage:* `dbretract_fact(+Fact)'
                                 - *Description:* Persistent
                                   extension of `retract_fact/1':
                                   deletes on backtracking all the
                                   facts which unify with `Fact'. The
                                   predicate concerned must be
                                   statically ( `sql_persistent/3')
                                   or dinamically (
                                   `make_sql_persistent/3') declared.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+Fact' is a fact (a term whose
                                   main functor is not `':-'/2').
                                   (`persdbrtsql:fact/1')

                          - PREDICATE: dbcurrent_fact/1:
                              The predicate is of type *implicit*.

                              *Usage:* `dbcurrent_fact(+Fact)'
                                 - *Description:* Persistent
                                   extension of `current_fact/1': the
                                   fact `Fact' exists in the current
                                   database. The predicate concerned
                                   must be declared
                                   `sql_persistent/3'. Provides on
                                   backtracking all the facts
                                   (tuples) which unify with `Fact'.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+Fact' is a fact (a term whose
                                   main functor is not `':-'/2').
                                   (`persdbrtsql:fact/1')

                          - PREDICATE: dbretractall_fact/1:
                              The predicate is of type *implicit*.

                              *Usage:* `dbretractall_fact(+Fact)'
                                 - *Description:* Persistent
                                   extension of `retractall_fact/1':
                                   when called deletes all the facts
                                   which unify with `Fact'. The
                                   predicate concerned must be
                                   statically ( `sql_persistent/3')
                                   or dinamically (
                                   `make_sql_persistent/3') declared.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+Fact' is a fact (a term whose
                                   main functor is not `':-'/2').
                                   (`persdbrtsql:fact/1')

                          - PREDICATE: make_sql_persistent/3:
                              *Meta-predicate* of type *implicit*
                              with arguments:
                              `make_sql_persistent(addmodule,?,?)'.

                              *Usage:*






















                              `make_sql_persistent(PrologPredTypes,TableAttributes,Keyword)'
                                 - *Description:* Dynamic version of
                                   the `sql_persistent/3' declaration.

                                 - *The following properties should
                                   hold upon exit:*

                                   `PrologPredTypes' is a structure
                                   describing a Prolog predicate name
                                   with its types.
                                   (`persdbrtsql:prologPredTypes/1')

                                   `TableAttributes' is a structure
                                   describing a table name and some
                                   attributes.
                                   (`persdbrtsql:tableAttributes/1')

                                   `Keyword' is the name of a
                                   persistent storage location.
                                   (`persdbrtsql:persLocId/1')

                          - PREDICATE: dbfindall/4:
                              *Usage:*











                              `dbfindall(+DBId,+Pattern,+ComplexGoal,-(Results))'
                                 - *Description:* Similar to
                                   `findall/3', but `Goal' is
                                   executed in database `DBId'.
                                   Certain restrictions and
                                   extensions apply to both `Pattern'
                                   and `ComplexGoal' stemming from
                                   the Prolog to SQL translation
                                   involved (see the corresponding
                                   type definitions for details).

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+DBId' a unique identifier of a
                                   database session connection.
                                   (`db_client:dbconnection/1')

                                   `+Pattern' is a database
                                   projection term.
                                   (`pl2sql:projterm/1')

                                   `+ComplexGoal' is a database query
                                   goal.   (`pl2sql:querybody/1')

                                   `-(Results)' is a list.
                                   (`basic_props:list/1')

                          - PREDICATE: dbcall/2:
                              *Usage:* `dbcall(+DBId,+ComplexGoal)'
                                 - *Description:* Internal predicate,
                                   used by the transformed versions
                                   of the persistent predicates. Not
                                   meant to be called directly by
                                   users. It is exported by the
                                   library so that it can be used by
                                   the transformed versions of the
                                   persistent predicates in the
                                   modules in which they reside.
                                   Sends `ComplexGoal' to database
                                   `DBId' for evaluation.
                                   `ComplexGoal' must be a call to a
                                   persistent predicate which resides
                                   in database `DBId'.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+DBId' a unique identifier of a
                                   database session connection.
                                   (`db_client:dbconnection/1')

                                   `+ComplexGoal' is a database query
                                   goal.   (`pl2sql:querybody/1')

                          - PREDICATE: sql_query/3:
                              *Usage:*





                              `sql_query(+DBId,+SQLString,AnswerTableTerm)'
                                 - *Description:* `ResultTerm' is the
                                   response from database `DBId' to
                                   the SQL query in `SQLString' to
                                   database `DBId'. `AnswerTableTerm'
                                   can express a set of tuples, an
                                   error answer or a 'ok' response
                                   (see `answertableterm/1' for
                                   details). At the moment,
                                   `sql_query/3' log in and out for
                                   each query. This should be changed
                                   to log in only the first time and
                                   log out on exit and/or via a timer
                                   in the standard way.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+DBId' a unique identifier of a
                                   database session connection.
                                   (`db_client:dbconnection/1')

                                   `+SQLString' is a string
                                   containing SQL code.
                                   (`pl2sql:sqlstring/1')

                                   `AnswerTableTerm' is a response
                                   from the ODBC database interface.
                                   (`db_client:answertableterm/1')

                          - PREDICATE: sql_get_tables/2:
                              *Usage 1:*
                              `sql_get_tables(+Location,-(Tables))'
                                 - *Description:* `Tables' contains
                                   the tables available in `Location'.

                                 - *Call and exit should be
                                   *compatible* with:*



                                   `persdbrtsql:persLocation(+Location)'
                                   (`persdbrtsql:persLocation/1')

                                   `-(Tables)' is a list of `atm's.
                                   (`basic_props:list/2')

                              *Usage 2:*

                              `sql_get_tables(+DbConnection,-(Tables))'
                                 - *Description:* `Tables' contains
                                   the tables available in
                                   `DbConnection'.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+DbConnection' a unique
                                   identifier of a database session
                                   connection.
                                   (`db_client:dbconnection/1')

                                   `-(Tables)' is a list of `atm's.
                                   (`basic_props:list/2')

                          - PREDICATE: sql_table_types/3:
                              *Usage 1:*








                              `sql_table_types(+Location,+Table,-(AttrTypes))'
                                 - *Description:* `AttrTypes' are the
                                   attributes and types of `Table' in
                                   `Location'.

                                 - *Call and exit should be
                                   *compatible* with:*



                                   `persdbrtsql:persLocation(+Location)'
                                   (`persdbrtsql:persLocation/1')

                                   `+Table' is an atom.
                                   (`basic_props:atm/1')

                                   `-(AttrTypes)' is a list.
                                   (`basic_props:list/1')

                              *Usage 2:*












                              `sql_table_types(+DbConnection,+Table,-(AttrTypes))'
                                 - *Description:* `AttrTypes' are the
                                   attributes and types of `Table' in
                                   `DbConnection'.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+DbConnection' a unique
                                   identifier of a database session
                                   connection.
                                   (`db_client:dbconnection/1')

                                   `+Table' is an atom.
                                   (`basic_props:atm/1')

                                   `-(AttrTypes)' is a list.
                                   (`basic_props:list/1')

                          - REGTYPE: socketname/1:
                              *Usage:* `socketname(IPP)'
                                 - *Description:* `IPP' is a
                                   structure describing a complete
                                   TCP/IP port address.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - REGTYPE: dbname/1:
                              *Usage:* `dbname(DBId)'
                                 - *Description:* `DBId' is the
                                   identifier of an ODBC database.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - REGTYPE: user/1:
                              *Usage:* `user(User)'
                                 - *Description:* `User' is a user
                                   name in the ODBC database.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - REGTYPE: passwd/1:
                              *Usage:* `passwd(Passwd)'
                                 - *Description:* `Passwd' is the
                                   password for the user name in the
                                   ODBC database.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - REGTYPE: projterm/1:
                              *Usage:* `projterm(DBProjTerm)'
                                 - *Description:* `DBProjTerm' is a
                                   database projection term.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - REGTYPE: querybody/1:
                              *Usage:* `querybody(DBGoal)'
                                 - *Description:* `DBGoal' is a
                                   database query goal.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - (: UNDOC_REEXPORT) SQLTYPE/1:
                              Imported from `sqltypes' (see the
                              corresponding documentation for
                              details).



File: ciao.info,  Node: Documentation on multifiles (persdbrtsql),  Next: Documentation on internals (persdbrtsql),  Prev: Documentation on exports (persdbrtsql),  Up: SQL persistent database interface

Documentation on multifiles (`persdbrtsql')
===========================================

                          - PREDICATE: sql_persistent_location/2:
                              Relates names of locations (the
                              `Keyword's) with descriptions of such
                              locations (`Location's).

                              The predicate is *multifile* and of
                              type *data*.

                              *Usage 1:*



                              `sql_persistent_location(Keyword,Location)'
                                 - *Description:* `Keyword' is an
                                   identifier for the persistent data
                                   location `Location'.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `Keyword' is the name of a
                                   persistent storage location.
                                   (`persdbrtsql:persLocId/1')


                                   `persdbrtsql:persLocation(Location)'
                                   (`persdbrtsql:persLocation/1')

                              *Usage 2:*





                              `sql_persistent_location(Keyword,DBLocation)'
                                 - *Description:* In this usage,
                                   `DBLocation' is a *relational
                                   database*, in which case the
                                   predicate is stored as tuples in
                                   the database.

                                 - *The following properties should
                                   hold upon exit:*

                                   `Keyword' is the name of a
                                   persistent storage location.
                                   (`persdbrtsql:persLocId/1')

                                   `DBLocation' is a structure
                                   describing a database.
                                   (`persdbrtsql:database_desc/1')


File: ciao.info,  Node: Documentation on internals (persdbrtsql),  Next: Known bugs and planned improvements (persdbrtsql),  Prev: Documentation on multifiles (persdbrtsql),  Up: SQL persistent database interface

Documentation on internals (`persdbrtsql')
==========================================

                          - PREDICATE: db_query/4:
                              *Usage:*




                              `db_query(+DBId,+ProjTerm,+Goal,ResultTerm)'
                                 - *Description:* `ResultTerm'
                                   contains all the tuples which are
                                   the response from database `DBId'
                                   to the Prolog query `Goal',
                                   projected onto `ProjTerm'. Uses
                                   `pl2sqlstring/3' for the Prolog to
                                   SQL translation and `sql_query/3'
                                   for posing the actual query.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+DBId' a unique identifier of a
                                   database session connection.
                                   (`db_client:dbconnection/1')

                                   `+ProjTerm' is a database
                                   projection term.
                                   (`pl2sql:projterm/1')

                                   `+Goal' is a database query goal.
                                   (`pl2sql:querybody/1')

                                   `ResultTerm' is a tuple of values
                                   from the ODBC database interface.
                                   (`db_client:tuple/1')

                          - PREDICATE: db_query_one_tuple/4:
                              *Usage:*














                              `db_query_one_tuple(+DBId,+ProjTerm,+Goal,ResultTerm)'
                                 - *Description:* `ResultTerm' is one
                                   of the tuples which are the
                                   response from database `DBId' to
                                   the Prolog query `Goal', projected
                                   onto `ProjTerm'. Uses
                                   `pl2sqlstring/3' for the Prolog to
                                   SQL translation and
                                   `sql_query_one_tuple/3' for posing
                                   the actual query. After last tuple
                                   has been reached, a null tuple is
                                   unified with ResultTerm, and the
                                   connection to the database
                                   finishes.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+DBId' a unique identifier of a
                                   database session connection.
                                   (`db_client:dbconnection/1')

                                   `+ProjTerm' is a database
                                   projection term.
                                   (`pl2sql:projterm/1')

                                   `+Goal' is a database query goal.
                                   (`pl2sql:querybody/1')

                                   `ResultTerm' is a predicate
                                   containing a tuple.
                                   (`db_client:answertupleterm/1')

                          - PREDICATE: sql_query_one_tuple/3:
                              *Usage:*











                              `sql_query_one_tuple(+DBId,+SQLString,ResultTuple)'
                                 - *Description:* `ResultTuple'
                                   contains an element from the set
                                   of tuples which represents the
                                   response in `DBId' to the SQL
                                   query `SQLString'. If the
                                   connection is kept, succesive
                                   calls return consecutive tuples,
                                   until the last tuple is reached.
                                   Then a null tuple is unified with
                                   `ResultTuple' and the connection
                                   is finished (calls to
                                   `db_logoff/1' and
                                   `odbc_disconnect/1').

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+DBId' a unique identifier of a
                                   database session connection.
                                   (`db_client:dbconnection/1')

                                   `+SQLString' is a string
                                   containing SQL code.
                                   (`pl2sql:sqlstring/1')

                                   `ResultTuple' is a tuple of values
                                   from the ODBC database interface.
                                   (`db_client:tuple/1')

                          - REGTYPE: dbconnection/1:
                              *Usage:* `dbconnection(H)'
                                 - *Description:* `H' a unique
                                   identifier of a database session
                                   connection.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - REGTYPE: tuple/1:
                              *Usage:* `tuple(T)'
                                 - *Description:* `T' is a tuple of
                                   values from the ODBC database
                                   interface.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')


File: ciao.info,  Node: Known bugs and planned improvements (persdbrtsql),  Prev: Documentation on internals (persdbrtsql),  Up: SQL persistent database interface

Known bugs and planned improvements (`persdbrtsql')
===================================================

                            * At least in the shell, reloading a file
                              after changing the definition of a
                              persistent predicate does not eliminate
                              the old definition...

                            * Functionality missing: some questions
                              need to be debugged.

                            * Warning: still using kludgey
                              string2term and still using some
                              non-uniquified temp files.

                            * Needs to be unified with the file-based
                              library.


File: ciao.info,  Node: Prolog to SQL translator,  Next: Low-level socket interface to SQL/ODBC databases,  Prev: SQL persistent database interface,  Up: Top

Prolog to SQL translator
************************

                            *Author(s):* C. Draxler. Adapted by M.
Hermenegildo and I. Caballero.

                            *Version:* 1.3#120 (1999/11/26, 12:5:17
MET)

                            *Version of last change:* 0.9#96
(1999/5/21, 19:53:48 MEST)

                            This library performs translation of
Prolog queries into SQL. The code is an adaptation for CIAO of the
Prolog to SQL compiler written by Christoph Draxler, CIS Centre for
Information and Speech Processing, Ludwig-Maximilians-University
Munich, `draxler@cis.uni-muenchen.de', Version 1.1. Many thanks to
Christoph for allowing us to include this adaptation of his code with
CIAO.

                            The translator needs to know the
correspondence between Prolog predicates and the SQL tables in the
database. To this end this module exports two multifile predicates,
`relation/3' and `attribute/4'. See the description of these
predicates for details on how such correspondance is specified.

                            The main entry points to the translator
are `pl2sqlstring/3' and `pl2sqlterm/3'. Details on the types of
queries allowed can be found in the description of these predicates.

                            *Example:* the following program would
print out a term representing the SQL query corresponding to the
given Prolog query:

                              :- use_module(library('persdb_sql/pl2sql')).
                              :- use_module(library(strings)).
                              
                              :- multifile [relation/3,attribute/4].
                              :- data [relation/3,attribute/4].
                              
                              relation(product,3,'PRODUCT').
                              attribute(1,'PRODUCT','ID',int).
                              attribute(2,'PRODUCT','QUANTITY',int).
                              attribute(3,'PRODUCT','NAME',string).
                              
                              main :-
                                   pl2sqlstring( f(L,K),
                                        ((product(L,N,a); product(L,N,b)),
                                         \+ product(2,3,b),
                                         L + 2 > avg(Y, Z^product(Z,Y,a)),
                                         K is N + max(X, product(X,2,b))
                                         ), T),
                                   write_string(T).
                              
                              %%     printqueries(T).

                            *Note:* while the translator can be used
directly in programs, it is more convenient to use a higher-level
abstraction: persistent predicates (implemented in the `persdb'
library). The notion of persistent predicates provides a completely
transparent interface between Prolog and relational databases. When
using this library, the Prolog to SQL translation is called
automatically as needed.

                         * Menu:
                         
                         * Usage and interface (pl2sql)::
                         * Documentation on exports (pl2sql)::
                         * Documentation on multifiles (pl2sql)::
                         * Documentation on internals (pl2sql)::
                         * Known bugs and planned improvements (pl2sql)::


File: ciao.info,  Node: Usage and interface (pl2sql),  Next: Documentation on exports (pl2sql),  Prev: Prolog to SQL translator,  Up: Prolog to SQL translator

Usage and interface (`pl2sql')
==============================

                            * *Library usage:*

                              `:- use_module(library(pl2sql)).'

                            * *Exports:*
                                 - *Predicates:*

                                   `pl2sqlstring/3', `pl2sqlterm/3',
                                   `printqueries/1',
                                   `sqlterm2string/2'.

                                 - *Regular Types:*

                                   `querybody/1', `projterm/1',
                                   `sqlstring/1'.

                                 - *Multifiles:*

                                   `relation/3', `attribute/4'.

                            * *Other modules used:*
                                 - *System library modules:*

                                   `persdb_sql/sqltypes', `write',
                                   `read', `dec10_io', `system',
                                   `iso_misc', `lists', `aggregates',
                                   `messages'.



File: ciao.info,  Node: Documentation on exports (pl2sql),  Next: Documentation on multifiles (pl2sql),  Prev: Usage and interface (pl2sql),  Up: Prolog to SQL translator

Documentation on exports (`pl2sql')
===================================

                          - PREDICATE: pl2sqlstring/3:
                              *Usage:*























                              `pl2sqlstring(+ProjectionTerm,+DatabaseGoal,-(SQLQueryString))'
                                 - *Description:* This is the top
                                   level predicate which translates
                                   complex Prolog goals into the
                                   corresponding SQL code.

                                   The query code is prepared in such
                                   a way that the result is projected
                                   onto the term `ProjectionTerm'
                                   (also in a similar way to the
                                   first argument of `setof/3')). See
                                   the predicate
                                   `translate_projection/3' for
                                   restrictions on this term.

                                   `SQLQueryString' contains the code
                                   of the SQL query, ready to be sent
                                   to an SQL server.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+ProjectionTerm' is a database
                                   projection term.
                                   (`pl2sql:projterm/1')

                                   `+DatabaseGoal' is a database
                                   query goal.
                                   (`pl2sql:querybody/1')

                                   `-(SQLQueryString)' is a string
                                   containing SQL code.
                                   (`pl2sql:sqlstring/1')

                          - REGTYPE: querybody/1:
                              `DBGoal' is a goal meant to be executed
                              in the external database. It can be a
                              complex term containing conjunctions,
                              disjunctions, and negations, of:

                                 * Atomic goals, which must have been
                                   defined via `relation/3' and
                                   `attribute/4' and reside in the
                                   (same) database. Their arguments
                                   must be either ground or free
                                   variables. If they are ground,
                                   they must be bound to constants of
                                   the type declared for that
                                   argument. If an argument is a free
                                   variable, it may *share* with
                                   (i.e., be the same variable as)
                                   other free variables in other goal
                                   arguments.

                                 * Database comparison goals, whose
                                   main functor must be a database
                                   comparison operator (see `pl2sql':
                                   `comparison/2') and whose
                                   arguments must be *database
                                   arithmetic expressions*.

                                 * Database calls to is/2. The left
                                   side of such a call may be either
                                   unbound, in which case it is bound
                                   to the result of evaluating the
                                   right side, or bound in which case
                                   an equality condition is tested.
                                   The right side must be a *database
                                   arithmetic expression*.

                              The binding of variables follows Prolog
                              rules:

                                 * variables are bound by positive
                                   base goals and on the left side of
                                   the `is/2' predicate.

                                 * Comparison operations, negated
                                   goals, and right sides of the
                                   `is/2' predicate do not return
                                   variable bindings and may even
                                   require all arguments to be bound
                                   for a safe evaluation.

                              Database arithmetic expressions may
                              contain:

                                 * Numeric constants (i.e., integers,
                                   reals, etc.).

                                 * Bound variables, i.e., variables
                                   which will be bound during
                                   execution through occurrence
                                   within a positive database goal,
                                   or by a preceding arithmetic
                                   function.

                                 * Database arithmetic functions,
                                   which are a subset of those
                                   typically accepted within `is/2'
                                   (see `pl2sql':
                                   `arithmetic_functor/2').

                                 * Database aggregation functions,
                                   each of which has two arguments: a
                                   variable indicating the argument
                                   over which the function is to be
                                   computed, and a goal argument
                                   which must contain in at least one
                                   argument position the variable
                                   (e.g.
                                   `avg(Seats,plane(Type,Seats))').
                                   The goal argument may only be a
                                   conjunction of (positive or
                                   negative) base goals. See `pl2sql':
                                   `aggregate_functor/2' for the
                                   admissible aggregate functions.

                              In addition, variables can be
                              existentially quantified using `^/2'
                              (in a similar way to how it is done in
                              `setof/3').

                              Note that it is assumed that the
                              arithmetic operators in Prolog and SQL
                              are the same, i.e., `+' is addition in
                              Prolog and in SQL, etc.

                              *Usage:* `querybody(DBGoal)'
                                 - *Description:* `DBGoal' is a
                                   database query goal.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - REGTYPE: projterm/1:
                              `DBProjTerm' is a term onto which the
                              result of a database query code is (in
                              a similar way to the first argument of
                              `setof/3')).

                              A `ProjectionTerm' must meet the
                              following restrictions:

                                 * The functor of `ProjectionTerm'
                                   may not be one of the built-in
                                   predicates, i.e. ',', ';', etc.
                                   are not allowed.

                                 * Only variables and constants are
                                   allowed as arguments, i.e., no
                                   structured terms may appear.

                              *Usage:* `projterm(DBProjTerm)'
                                 - *Description:* `DBProjTerm' is a
                                   database projection term.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - REGTYPE: sqlstring/1:
                                   sqlstring(S) :-
                                           string(S).

                              *Usage:* `sqlstring(S)'
                                 - *Description:* `S' is a string
                                   containing SQL code.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - PREDICATE: pl2sqlterm/3:
                              *Usage:*



















                              `pl2sqlterm(+ProjectionTerm,+DatabaseGoal,-(SQLQueryTerm))'
                                 - *Description:* Similar to
                                   `pl2sqlstring/3' except that
                                   `SQLQueryTerm' is a representation
                                   of the SQL query as a Prolog term.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+ProjectionTerm' is a database
                                   projection term.
                                   (`pl2sql:projterm/1')

                                   `+DatabaseGoal' is a database
                                   query goal.
                                   (`pl2sql:querybody/1')

                                   `-(SQLQueryTerm)' is a list of
                                   `sqlterm's.
                                   (`basic_props:list/2')

                          - PREDICATE: printqueries/1:
                              *Usage:* `printqueries(SQLTermList)'
                                 - *Description:* Print to standard
                                   output in SQL the list of SQL term
                                   `SQLTermList'.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `SQLTermList' is a list of
                                   `sqlterm's.
                                   (`basic_props:list/2')

                          - PREDICATE: sqlterm2string/2:
                              *Usage:*

                              `sqlterm2string(+Queries,-(QueryString))'
                                 - *Description:* `QueryString' is a
                                   string representation of the list
                                   of queries in Prolog-term format
                                   in `Queries'.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+Queries' is a list of `sqlterm's.
                                   (`basic_props:list/2')

                                   `-(QueryString)' is a string
                                   containing SQL code.
                                   (`pl2sql:sqlstring/1')

                          - (: UNDOC_REEXPORT) SQLTYPE/1:
                              Imported from `sqltypes' (see the
                              corresponding documentation for
                              details).



File: ciao.info,  Node: Documentation on multifiles (pl2sql),  Next: Documentation on internals (pl2sql),  Prev: Documentation on exports (pl2sql),  Up: Prolog to SQL translator

Documentation on multifiles (`pl2sql')
======================================

                          - PREDICATE: relation/3:
                              The predicate is *multifile* and of
                              type *data*.

                              *Usage:*
                              `relation(PredName,Arity,TableName)'
                                 - *Description:* This predicate,
                                   together with `attribute/4',
                                   defines the correspondence between
                                   Prolog predicates and the SQL
                                   tables in the database. These two
                                   relations constitute an extensible
                                   meta-database which maps Prolog
                                   predicate names to SQL table
                                   names, and Prolog predicate
                                   argument positions to SQL
                                   attributes.

                                   `PredName' is the chosen Prolog
                                   name for an SQL table. `Arity' is
                                   the number of arguments of the
                                   predicate. `TableName' is the name
                                   of the SQL table in the Database
                                   Management System.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `PredName' is an atom.
                                   (`basic_props:atm/1')

                                   `Arity' is an integer.
                                   (`basic_props:int/1')

                                   `TableName' is an atom.
                                   (`basic_props:atm/1')

                          - PREDICATE: attribute/4:
                              The predicate is *multifile* and of
                              type *data*.

                              *Usage:*
                              `attribute(ANumber,TblName,AName,AType)'
                                 - *Description:* This predicate maps
                                   the argument positions of a Prolog
                                   predicate to the SQL attributes of
                                   its corresponding table. The types
                                   of the arguments need to be
                                   specified, and this information is
                                   used for consistency checking
                                   during the translation and for
                                   output formatting. A minimal type
                                   system is provided to this end.
                                   The allowable types are given by
                                   `sqltype/1'.

                                   `ANumber' is the argument number
                                   in the Prolog relation. `TblName'
                                   is the name of the SQL table in
                                   the Database Management System.
                                   `AName' is the name of the
                                   corresponding attribute in the
                                   table. `AType' is the (translator)
                                   data type of the attribute.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `ANumber' is an integer.
                                   (`basic_props:int/1')

                                   `TblName' is an atom.
                                   (`basic_props:atm/1')

                                   `AName' is an atom.
                                   (`basic_props:atm/1')

                                   `AType' is an SQL data type
                                   supported by the translator.
                                   (`sqltypes:sqltype/1')


File: ciao.info,  Node: Documentation on internals (pl2sql),  Next: Known bugs and planned improvements (pl2sql),  Prev: Documentation on multifiles (pl2sql),  Up: Prolog to SQL translator

Documentation on internals (`pl2sql')
=====================================

                          - PREDICATE: query_generation/3:
                              *Usage:*
































                              `query_generation(+ListOfConjunctions,+ProjectionTerm,-(ListOfQueries))'
                                 - *Description:* For each
                                   Conjunction in
                                   `ListOfConjunctions', translate
                                   the pair
                                   `(ProjectionTerm,Conjunction)' to
                                   an SQL query and connect each such
                                   query through a UNION-operator to
                                   result in the `ListOfQueries'.

                                   A Conjunction consists of positive
                                   or negative subgoals. Each subgoal
                                   is translated as follows:

                                      * the functor of a goal that is
                                        not a comparison operation is
                                        translated to a relation name
                                        with a range variable,

                                      * negated goals are translated
                                        to NOT EXISTS-subqueries with
                                        * projection,

                                      * comparison operations are
                                        translated to comparison
                                        operations in the
                                        WHERE-clause,

                                      * aggregate function terms are
                                        translated to aggregate
                                        function (sub)queries.

                                   The arguments of a goal are
                                   translated as follows:

                                      * `variables of a goal' are
                                        translated to qualified
                                        attributes,

                                      * variables occurring in
                                        several goals are translated
                                        to equality comparisons (equi
                                        join) in the WHERE-clause,

                                      * constant arguments are
                                        translated to equality
                                        comparisons in the
                                        WHERE-clause.

                                   Arithmetic functions are treated
                                   specially (

                                   `translate_arithmetic_function/5').
                                   See also `querybody/1' for details
                                   on the syntax accepted and
                                   restrictions.


                          - PREDICATE: translate_conjunction/5:
                              *Usage:*


























                              `translate_conjunction(Conjunction,SQLFrom,SQLWhere,Dict,NewDict)'
                                 - *Description:* Translates a
                                   conjunction of goals (represented
                                   as a list of goals preceeded by
                                   existentially quantified
                                   variables) to FROM-clauses and
                                   WHERE-clauses of an SQL query. A
                                   dictionary containing the
                                   associated SQL table and attribute
                                   names is built up as an
                                   accumulator pair (arguments `Dict'
                                   and `NewDict').

                          - PREDICATE: translate_goal/5:
                              *Usage:*












                              `translate_goal(Goal,SQLFrom,SQLWhere,Dict,NewDict)'
                                 - *Description:* Translates:

                                      * a positive database goal to
                                        the associated FROM- and
                                        WHERE clause of an SQL query,

                                      * a negated database goal to a
                                        negated existential subquery,

                                      * an arithmetic goal to an
                                        arithmetic expression or an
                                        aggregate function query,

                                      * a comparison goal to a
                                        comparison expression, and

                                      * a negated comparison goal to
                                        a comparison expression with
                                        the opposite comparison
                                        operator.


                          - PREDICATE:
                         translate_arithmetic_function/5:
                              *Usage:*
































                              `translate_arithmetic_function(Result,Expression,SQLWhere,Dict,NewDict)'
                                 - *Description:* Arithmetic
                                   functions (left side of is/2
                                   operator is bound to value of
                                   expression on right side) may be
                                   called with either:

                                      * `Result' unbound: then
                                        `Result' is bound to the
                                        value of the evaluation of
                                        `Expression',

                                      * `Result' bound: then an
                                        equality condition is
                                        returned between the value of
                                        `Result' and the value of the
                                        evaluation of `Expression'.

                                        Only the equality test shows
                                        up in the WHERE clause of an
                                        SQLquery.


                          - PREDICATE: translate_comparison/5:
                              *Usage:*


























                              `translate_comparison(LeftArg,RightArg,CompOp,Dict,SQLComparison)'
                                 - *Description:* Translates the left
                                   and right arguments of a
                                   comparison term into the
                                   appropriate comparison operation
                                   in SQL. The result type of each
                                   argument expression is checked for
                                   type compatibility.

                          - PREDICATE: aggregate_function/3:
                              *Usage:*































                              `aggregate_function(AggregateFunctionTerm,Dict,AggregateFunctionQuery)'
                                 - *Description:* Supports the Prolog
                                   aggregate function terms listed in
                                   `aggregate_functor/2' within
                                   arithmetic expressions. Aggregate
                                   functions are translated to the
                                   corresponding SQL built-in
                                   aggregate functions.

                          - PREDICATE: comparison/2:
                              *Usage:*
                              `comparison(PrologOperator,SQLOperator)'
                                 - *Description:* Defines the mapping
                                   between Prolog operators and SQL
                                   operators:
                                        comparison(=,=).
                                        comparison(<,<).
                                        comparison(>,>).
                                        comparison(@<,<).
                                        comparison(@>,>).

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `PrologOperator' is an atom.
                                   (`basic_props:atm/1')

                                   `SQLOperator' is an atom.
                                   (`basic_props:atm/1')

                          - PREDICATE: negated_comparison/2:
                              *Usage:*








                              `negated_comparison(PrologOperator,SQLOperator)'
                                 - *Description:* Defines the mapping
                                   between Prolog operators and the
                                   complementary SQL operators:
                                        negated_comparison(=,<>).
                                        negated_comparison(\==,=).
                                        negated_comparison(>,=<).
                                        negated_comparison(=<,>).
                                        negated_comparison(<,>=).
                                        negated_comparison(>=,<).

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `PrologOperator' is an atom.
                                   (`basic_props:atm/1')

                                   `SQLOperator' is an atom.
                                   (`basic_props:atm/1')

                          - PREDICATE: arithmetic_functor/2:
                              *Usage:*







                              `arithmetic_functor(PrologFunctor,SQLFunction)'
                                 - *Description:* Defines the
                                   admissible arithmetic functions on
                                   the Prolog side and their
                                   correspondence on the SQL side:
                                        arithmetic_functor(+,+).
                                        arithmetic_functor(-,-).
                                        arithmetic_functor(*,*).
                                        arithmetic_functor(/,/).

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `PrologFunctor' is an atom.
                                   (`basic_props:atm/1')

                                   `SQLFunction' is an atom.
                                   (`basic_props:atm/1')

                          - PREDICATE: aggregate_functor/2:
                              *Usage:*






                              `aggregate_functor(PrologFunctor,SQLFunction)'
                                 - *Description:* Defines the
                                   admissible aggregate functions on
                                   the Prolog side and their
                                   correspondence on the SQL side:
                                        aggregate_functor(avg,'AVG').
                                        aggregate_functor(min,'MIN').
                                        aggregate_functor(max,'MAX').
                                        aggregate_functor(sum,'SUM').
                                        aggregate_functor(count,'COUNT').

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `PrologFunctor' is an atom.
                                   (`basic_props:atm/1')

                                   `SQLFunction' is an atom.
                                   (`basic_props:atm/1')


File: ciao.info,  Node: Known bugs and planned improvements (pl2sql),  Prev: Documentation on internals (pl2sql),  Up: Prolog to SQL translator

Known bugs and planned improvements (`pl2sql')
==============================================

                            * Need to separate db predicate names by
                              module.

                            * Warning: using kludgy SQL term to
                              string conversion because of bugs in
                              sqlterm2string/2.


File: ciao.info,  Node: Low-level socket interface to SQL/ODBC databases,  Next: Low-level Prolog to Java interface,  Prev: Prolog to SQL translator,  Up: Top

Low-level socket interface to SQL/ODBC databases
************************************************

                            *Author(s):* D. Cabeza, M. Carro, I.
Caballero, and M. Hermenegildo..

                            *Version:* 1.3#120 (1999/11/26, 12:5:17
MET)

                            *Version of last change:* 1.3#53
(1999/9/15, 23:37:55 MEST)

                            This library provides a socket-based
interface to SQL Databases, using the database mediator server ODBC
interface developed by C. Taboch and I. Caballero. The interface
currently works for databases running in Win95/NT machines via ODBC.
This low-level interface was defined with two goals in mind:

                            * To simplify the communication between
                              the Prolog system and the relational
                              database engines as much as possible.

                            * To give as much flexibility to the
                              overall system. This includes
                              supporting simultaneous access to
                              several databases, and also allowing
                              both the databases and clients to
                              reside on the same or different
                              physical Win95/NT machines. The clients
                              can reside also in Unix/Linux machines.
                              It is also possible to access database
                              selections in either tuple at a time or
                              set at a time fashion, as needed.

                            In order to allow the flexibility
mentioned above, a socket (TCP/IP) client-server architecture was
chosen. The interface has two main components:

                            * At the server side, a *database
                              mediator server* connects on one side
                              to the databases using the ODBC
                              interface and on the other to a fixed
                              port number (service), on which the
                              mediator server listens for requests.
                              The source code (and executables) for
                              this server (slightly modified versions
                              of C. Taboch original code) are in the
                              same directory as this library. This
                              executable must be running on the
                              Windows (NT/95) machine where the
                              databas(es) is(are) also running.(1)

                            * At the client side a Prolog client can
                              connect to the database by loading this
                              library and calling the appropriate
                              predicates. The Prolog client can run
                              on either Windows or Unix/Linux
                              systems, locally at the server machine
                              or remotely in different machines. The
                              mediator server port number (service)
                              used is currently fixed to 2020. After
                              the connection is established a client
                              can send commands to the mediator
                              server which will pass them to the
                              corresponding database server, and then
                              the response data will return in the
                              opposite direction. These messages
                              include login on and off from the
                              database, sending SQL queries, and
                              receiving the responses.

                            *Example:*
                              :- use_module(library('persdb_sql/db_client')).
                              :- use_module(library(format)).
                              :- use_module(library(lists)).
                              
                              :- multifile issue_debug_messages/1.
                              :- data issue_debug_messages/1.
                              issue_debug_messages('db_client').
                              
                              main0:- %% getting the tables existing in a database
                                      odbc_connect('r2d5.dia.fi.upm.es':2020,Stream),
                                      db_login(Stream,'DaletDemo',dalet_admin,dalet_admin,
                              %%        db_login(Stream,'ASA 6.0 Sample',dba,sql,
                                               dbconnection(Stream,DbHandle)),
                              %%        db_get_tables(dbconnection(Stream,DbHandle),TablesList),
                                      db_table_types(dbconnection(Stream,DbHandle),'Titles',AttList),
                                      db_logoff(dbconnection(Stream,DbHandle)),
                                      odbc_disconnect(Stream),
                                      format("Results: ~w \n",AttList).
                              
                              
                              main1 :- %% accessing the whole table in one go
                                      odbc_connect('r2d5.dia.fi.upm.es':2020,Stream),
                                      db_login(Stream,'ASA 6.0 Sample',dba,sql,Conn),
                                      db_eval_sql(Conn,"SELECT fname,lname,address from ""DBA"".customer
                                                 WHERE ((Id>100) AND (Id<105))",Term),
                                      write(Term), nl,nl,nl,nl,nl,nl,nl,nl,nl,nl,nl,nl,nl,nl,nl,
                                      functor(Term,X,_Y),
                                      write(X),nl,
                                      Term=..[_|L],
                                      write('That is L'),nl,
                                      write(L),nl,L=[M],length(M,N),write(N),
                              %        db_eval_sql(Conn,"SELECT id,name,description,color from
                              %                    ""DBA"".product WHERE size='One size fits all'
                              %                    OR size='Large'",Term2),
                              %        write(Term2), nl,
                                      db_logoff(Conn),
                                      odbc_disconnect(Stream).
                              
                              main2:- %% accessing tuples one by one
                                      odbc_connect('r2d5.dia.fi.upm.es':2020,Stream),
                                      db_login(Stream,'ASA 6.0 Sample',dba,sql,Conn),
                                      db_stmt_handle(Conn,
                                            "SELECT fname,lname,address from ""DBA"".customer
                                             WHERE ((Id>100) AND (Id<105))",QueryConn),
                                      db_one_tuple(QueryConn,Answer),
                                      format("First Tuple: ~w \n",Answer),
                                      db_one_tuple(QueryConn,Answer2),
                                      format("Second Tuple: ~w \n",Answer2),
                                      db_logoff(Conn),
                                      odbc_disconnect(Stream).
                              
                              main3:- %% bringing tuples (one to one) from Literature Database
                                      %% TO SEE : check it
                                      odbc_connect('r2d5.dia.fi.upm.es':2020,Stream),
                                      db_login(Stream,'Literature',dba,sql,Conn),
                                      db_stmt_handle(Conn,"SELECT * FROM AUTHORS ORDER BY ID",QueryConn),
                                      print_all_one_by_one(QueryConn),
                                      db_logoff(Conn),
                                      odbc_disconnect(Stream).
                              
                              print_all_one_by_one(QueryConn):-
                                      db_one_tuple(QueryConn,Answer),
                                      Answer\=[],
                                      !,
                                      format(" ~w \n",Answer),
                                      print_all_one_by_one(QueryConn).
                              print_all_one_by_one(_QueryConn):-
                                      write(' Finished fetching query statement.'),
                                      nl.
                              
                              main4:- %% inserting a tuple into the Literature database
                                      odbc_connect('r2d5.dia.fi.upm.es':2020,Stream),
                                      db_login(Stream,'Literature',dba,sql,Conn),
                                      db_stmt_handle(Conn,
                                             "INSERT INTO AUTHORS values ('Martin Gaite',
                                              'Carmen',10,'1910-7-10 00:00:00:000')",_QueryConn),
                                      db_logoff(Conn),
                                      odbc_disconnect(Stream).
                              
                              main5:- %% creating a view
                                      odbc_connect('r2d5.dia.fi.upm.es':2020,Stream),
                                      db_login(Stream,'Literature',dba,sql,Conn),
                                      db_stmt_handle(Conn,
                                             "CREATE VIEW AntoniosDateOfBirth AS SELECT
                                              LastName,Date_of_birth FROM
                                              AUTHORS where FirstName='Antonio';",_QueryConn),
                                      db_logoff(Conn),
                                      odbc_disconnect(Stream).
                              
                              main6:- %% printing the view
                                      odbc_connect('r2d5.dia.fi.upm.es':2020,Stream),
                                      db_login(Stream,'Literature',dba,sql,Conn),
                                      db_eval_sql(Conn,"select * from AntoniosDateOfBirth",Term),
                                      write(Term),
                                      db_logoff(Conn),
                                      odbc_disconnect(Stream).
                              
                              main7:- %% dropping a view
                                      odbc_connect('r2d5.dia.fi.upm.es':2020,Stream),
                                      db_login(Stream,'Literature',dba,sql,Conn),
                                      db_eval_sql(Conn,"DROP VIEW AntoniosDateOfBirth",Term),
                                      write(Term),
                                      db_logoff(Conn),
                                      odbc_disconnect(Stream).

                         * Menu:
                         
                         * Usage and interface (db_client)::
                         * Documentation on exports (db_client)::
                         * Documentation on internals (db_client)::
                         * Known bugs and planned improvements (db_client)::

                            ---------- Footnotes ----------

                            (1) The server can be downloaded from the
                         same site(s) as the CIAO system. The
                         downloaded package contains complete
                         installation instructions for the server.
                         Before trying to run the CIAO Prolog side of
                         things, make sure that the server is
                         correctly installed and running, and that it
                         can be accessed from the small sample client
                         that comes with the server distribution.
                         Once this is achieved, connection from CIAO
                         should not pose problems.


File: ciao.info,  Node: Usage and interface (db_client),  Next: Documentation on exports (db_client),  Prev: Low-level socket interface to SQL/ODBC databases,  Up: Low-level socket interface to SQL/ODBC databases

Usage and interface (`db_client')
=================================

                            * *Library usage:*

                              `:- use_module(library(db_client)).'

                            * *Exports:*
                                 - *Predicates:*

                                   `odbc_connect/2', `db_login/5',
                                   `db_eval_sql/3',
                                   `db_stmt_handle/3',
                                   `db_one_tuple/2',
                                   `db_get_tables/2',
                                   `db_table_types/3', `db_logoff/1',
                                   `odbc_disconnect/1'.

                                 - *Regular Types:*

                                   `socketname/1', `dbname/1',
                                   `user/1', `passwd/1',
                                   `dbconnection/1',
                                   `answertableterm/1', `tuple/1',
                                   `dbqueryconnection/1',
                                   `answertupleterm/1'.

                            * *Other modules used:*
                                 - *System library modules:*

                                   `sockets/sockets', `write',
                                   `strings', `lists',
                                   `persdb_sql/string2term',
                                   `messages'.



File: ciao.info,  Node: Documentation on exports (db_client),  Next: Documentation on internals (db_client),  Prev: Usage and interface (db_client),  Up: Low-level socket interface to SQL/ODBC databases

Documentation on exports (`db_client')
======================================

                          - PREDICATE: odbc_connect/2:
                              *Usage:*
                              `odbc_connect(+DbAddress,-(Stream))'
                                 - *Description:* Opens a socket
                                   connection to port `DbAddress',
                                   which should be the address of a
                                   database mediator server. `Stream'
                                   is the identifier of the
                                   corresponding Prolog stream. It is
                                   simply a call to
                                   `connect_to_socket/3'

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+DbAddress' is a structure
                                   describing a complete TCP/IP port
                                   address.
                                   (`db_client:socketname/1')

                                   `-(Stream)' is an open stream.
                                   (`streams_basic:stream/1')

                          - PREDICATE: db_login/5:
                              *Usage:*

















                              `db_login(+Stream,+DbName,+User,+Passwd,-(DbConnection))'
                                 - *Description:* Logs on to the
                                   database `DbName' with user `User'
                                   and password `Passwd' via
                                   connection `Stream'.
                                   `DbConnection' contains the
                                   identifier of the session, to be
                                   used in the calls to other
                                   predicates defining the interface.
                                   It fails and display an error
                                   message if the login is not
                                   succesfully completed.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+Stream' is an open stream.
                                   (`streams_basic:stream/1')

                                   `+DbName' is the identifier of an
                                   ODBC database.
                                   (`db_client:dbname/1')

                                   `+User' is a user name in the ODBC
                                   database.   (`db_client:user/1')

                                   `+Passwd' is the password for the
                                   user name in the ODBC database.
                                   (`db_client:passwd/1')

                                   `-(DbConnection)' a unique
                                   identifier of a database session
                                   connection.
                                   (`db_client:dbconnection/1')

                          - REGTYPE: socketname/1:
                                   socketname(IPAddress:PortNumber) :-
                                           atm(IPAddress),
                                           int(PortNumber).

                              *Usage:* `socketname(IPP)'
                                 - *Description:* `IPP' is a
                                   structure describing a complete
                                   TCP/IP port address.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - REGTYPE: dbname/1:
                                   dbname(DBId) :-
                                           atm(DBId).

                              *Usage:* `dbname(DBId)'
                                 - *Description:* `DBId' is the
                                   identifier of an ODBC database.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - REGTYPE: user/1:
                                   user(User) :-
                                           atm(User).

                              *Usage:* `user(User)'
                                 - *Description:* `User' is a user
                                   name in the ODBC database.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - REGTYPE: passwd/1:
                                   passwd(Passwd) :-
                                           atm(Passwd).

                              *Usage:* `passwd(Passwd)'
                                 - *Description:* `Passwd' is the
                                   password for the user name in the
                                   ODBC database.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - REGTYPE: dbconnection/1:
                                   dbconnection(dbconnection(DbStream,DbHandle)) :-
                                           stream(DbStream),
                                           dbhandle(DbHandle).

                              *Usage:* `dbconnection(H)'
                                 - *Description:* `H' a unique
                                   identifier of a database session
                                   connection.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - PREDICATE: db_eval_sql/3:
                              *Usage:*

















                              `db_eval_sql(+DbConnection,+Sentence,-(AnswerTableTerm))'
                                 - *Description:* Evaluates the SQL
                                   code in `Sentence' in database
                                   session `DbConnection'.
                                   `AnswerTableTerm' is the response.
                                   If a wrong answer is obtained,
                                   `AnswerTableTerm' will indicate
                                   the error (see `answertableterm'
                                   for details).

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+DbConnection' a unique
                                   identifier of a database session
                                   connection.
                                   (`db_client:dbconnection/1')

                                   `+Sentence' is a string of SQL
                                   code.   (`db_client:sqlstring/1')

                                   `-(AnswerTableTerm)' is a response
                                   from the ODBC database interface.
                                   (`db_client:answertableterm/1')

                          - REGTYPE: answertableterm/1:
                              Represents the types of responses that
                              will be returned from the ODBC database
                              interface. These can be a set of answer
                              tuples, or the atom `ok' in case of a
                              successful addition or deletion.

                              *Usage:* `answertableterm(AT)'
                                 - *Description:* `AT' is a response
                                   from the ODBC database interface.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - REGTYPE: tuple/1:
                                   tuple(T) :-
                                           list(T,atm).

                              *Usage:* `tuple(T)'
                                 - *Description:* `T' is a tuple of
                                   values from the ODBC database
                                   interface.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - PREDICATE: db_stmt_handle/3:
                              *Usage:*






















                              `db_stmt_handle(+DbConnection,+Sentence,-(DbQueryConnection))'
                                 - *Description:* Evaluates the SQL
                                   code in `Sentence' in database
                                   session `DbConnection'. If
                                   `Sentence' is a succesfull
                                   selection, `DbQueryConnection' is
                                   a *handle* to the set of tuples
                                   produced by this selection. The
                                   individual members of this set can
                                   then be accessed via
                                   `DbQueryConnection' using the
                                   `db_one_tuple/2' predicate. If
                                   `Sentence' is not succesfull or is
                                   not a selection,
                                   `DbQueryConnection' will contain
                                   the answer received.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+DbConnection' a unique
                                   identifier of a database session
                                   connection.
                                   (`db_client:dbconnection/1')

                                   `+Sentence' is a string of SQL
                                   code.   (`db_client:sqlstring/1')

                                   `-(DbQueryConnection)' is a unique
                                   identifier of a query answer in a
                                   database session connection.
                                   (`db_client:dbqueryconnection/1')

                          - REGTYPE: dbqueryconnection/1:
                                   dbqueryconnection(dbqueryconnection(DbStream,DbHandle,StmtHandle)) :-
                                           stream(DbStream),
                                           dbhandle(DbHandle),
                                           stmthandle(StmtHandle).

                              *Usage:* `dbqueryconnection(H)'
                                 - *Description:* `H' is a unique
                                   identifier of a query answer in a
                                   database session connection.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - PREDICATE: db_one_tuple/2:
                              *Usage:*







                              `db_one_tuple(+DbQueryConnection,-(TupleTerm))'
                                 - *Description:* `TupleTerm'
                                   represents the last tuple read
                                   from handle `DbQueryConnection'.
                                   Will be an empty list if all the
                                   answers have already been read. It
                                   displays an error if any
                                   unformatted string is fetched.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+DbQueryConnection' is a unique
                                   identifier of a query answer in a
                                   database session connection.
                                   (`db_client:dbqueryconnection/1')

                                   `-(TupleTerm)' is a predicate
                                   containing a tuple.
                                   (`db_client:answertupleterm/1')

                          - REGTYPE: answertupleterm/1:
                                   answertupleterm([]).
                                   answertupleterm(tup(T)) :-
                                           tuple(T).

                              *Usage:* `answertupleterm(X)'
                                 - *Description:* `X' is a predicate
                                   containing a tuple.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - PREDICATE: db_get_tables/2:
                              *Usage:*
                              `db_get_tables(+DbConnection,-(Tables))'
                                 - *Description:* `Tables' contains
                                   the tables available in
                                   `DbConnection'.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+DbConnection' a unique
                                   identifier of a database session
                                   connection.
                                   (`db_client:dbconnection/1')

                                   `-(Tables)' is a list of `atm's.
                                   (`basic_props:list/2')

                          - PREDICATE: db_table_types/3:
                              *Usage:*











                              `db_table_types(+DbConnection,+Table,-(AttrTypes))'
                                 - *Description:* `AttrTypes' are the
                                   attributes and types of `Table' in
                                   `DbConnection'.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+DbConnection' a unique
                                   identifier of a database session
                                   connection.
                                   (`db_client:dbconnection/1')

                                   `+Table' is an atom.
                                   (`basic_props:atm/1')

                                   `-(AttrTypes)' is a list.
                                   (`basic_props:list/1')

                          - PREDICATE: db_logoff/1:
                              *Usage:* `db_logoff(+DbConnection)'
                                 - *Description:* Logs off from the
                                   database identified by
                                   `DbConnection'. It fails and
                                   display an error message if the
                                   login is not succesfully completed.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+DbConnection' a unique
                                   identifier of a database session
                                   connection.
                                   (`db_client:dbconnection/1')

                          - PREDICATE: odbc_disconnect/1:
                              *Usage:* `odbc_disconnect(+Stream)'
                                 - *Description:* Closes the socket
                                   connection to `Stream'. It is
                                   simply a call to `close/1'.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+Stream' is an open stream.
                                   (`streams_basic:stream/1')

                          - PREDICATE: match_string/3:
                              No further documentation available for
                              this predicate.



File: ciao.info,  Node: Documentation on internals (db_client),  Next: Known bugs and planned improvements (db_client),  Prev: Documentation on exports (db_client),  Up: Low-level socket interface to SQL/ODBC databases

Documentation on internals (`db_client')
========================================

                          - REGTYPE: dbhandle/1:
                                   dbhandle(H) :-
                                           string(H).

                              *Usage:* `dbhandle(H)'
                                 - *Description:* `H' is the internal
                                   database identifier (handle) of a
                                   database session.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - REGTYPE: stmthandle/1:
                                   stmthandle(H) :-
                                           string(H).

                              *Usage:* `stmthandle(H)'
                                 - *Description:* `H' is the internal
                                   statement identifier (handle) of a
                                   query answer in a database session
                                   connection.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')


File: ciao.info,  Node: Known bugs and planned improvements (db_client),  Prev: Documentation on internals (db_client),  Up: Low-level socket interface to SQL/ODBC databases

Known bugs and planned improvements (`db_client')
=================================================

                            * Need to fix the problem with parametric
                              types being meta_predicates ...
                              list(_,tuple/1).


File: ciao.info,  Node: Low-level Prolog to Java interface,  Next: Low-level Java to Prolog interface,  Prev: Low-level socket interface to SQL/ODBC databases,  Up: Top

Low-level Prolog to Java interface
**********************************

                            *Author(s):* Jes'us Correas.

                            This module defines a low level Prolog to
Java interface.

                         * Menu:
                         
                         * Usage and interface (javart)::
                         * Documentation on exports (javart)::


File: ciao.info,  Node: Usage and interface (javart),  Next: Documentation on exports (javart),  Prev: Low-level Prolog to Java interface,  Up: Low-level Prolog to Java interface

Usage and interface (`javart')
==============================

                            * *Library usage:*

                              `:- use_module(library(javart)).'

                            * *Exports:*
                                 - *Predicates:*

                                   `java_create_object/2',
                                   `java_delete_object/1',
                                   `java_invoke_method/2',
                                   `java_get_value/2',
                                   `java_set_value/2',
                                   `java_connection/0',
                                   `java_remote_connection/1',
                                   `java_disconnection/0',
                                   `java_add_listener/3',
                                   `java_remove_listener/3'.

                                 - *Regular Types:*

                                   `machine_name/1',
                                   `java_constructor/1',
                                   `java_object/1', `java_method/1',
                                   `java_field/1', `java_event/1',
                                   `prolog_predicate/1'.

                            * *Other modules used:*
                                 - *Application modules:*

                                   `javasock'.

                                 - *System library modules:*

                                   `format', `lists', `read', `write',
                                   `system'.



File: ciao.info,  Node: Documentation on exports (javart),  Prev: Usage and interface (javart),  Up: Low-level Prolog to Java interface

Documentation on exports (`javart')
===================================

                          - PREDICATE: java_create_object/2:
                              *Usage:*














                              `java_create_object(+java_constructor,-(java_object))'
                                 - *Description:* New java object
                                   creation. The constructor must be
                                   built by the full class name as
                                   main functor, and the parameters
                                   passed to the constructor as
                                   arguments of the structure.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+java_constructor' is a java
                                   constructor (structure with
                                   functor as constructor name (full
                                   package specification), and
                                   arguments as constructor ones).
                                   (`javart:java_constructor/1')

                                   `-(java_object)' is a java object
                                   (structure with functor
                                   '$java_object', and argument an
                                   integer given by java side).
                                   (`javart:java_object/1')

                          - REGTYPE: machine_name/1:
                              *Usage:* `machine_name(X)'
                                 - *Description:* `X' is the Internet
                                   name of a machine.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - REGTYPE: java_constructor/1:
                              *Usage:* `java_constructor(X)'
                                 - *Description:* `X' is a java
                                   constructor (structure with
                                   functor as constructor name (full
                                   package specification), and
                                   arguments as constructor ones).

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - REGTYPE: java_object/1:
                              *Usage:* `java_object(X)'
                                 - *Description:* `X' is a java
                                   object (structure with functor
                                   '$java_object', and argument an
                                   integer given by java side).

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - PREDICATE: java_delete_object/1:
                              *Usage:*
                              `java_delete_object(+java_object)'
                                 - *Description:* Java objects
                                   deletion.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+java_object' is a java object
                                   (structure with functor
                                   '$java_object', and argument an
                                   integer given by java side).
                                   (`javart:java_object/1')

                          - PREDICATE: java_invoke_method/2:
                              *Usage:*







                              `java_invoke_method(+java_object,+java_method)'
                                 - *Description:* Invokes a java
                                   method on an object.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+java_object' is a java object
                                   (structure with functor
                                   '$java_object', and argument an
                                   integer given by java side).
                                   (`javart:java_object/1')

                                   `+java_method' is a java method
                                   (structure with functor as method
                                   name, and arguments as method
                                   ones, plus a result argument. This
                                   result argument is unified with
                                   the atom 'Yes' if the java method
                                   returns void).
                                   (`javart:java_method/1')

                          - REGTYPE: java_method/1:
                              *Usage:* `java_method(X)'
                                 - *Description:* `X' is a java
                                   method (structure with functor as
                                   method name, and arguments as
                                   method ones, plus a result
                                   argument. This result argument is
                                   unified with the atom 'Yes' if the
                                   java method returns void).

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - PREDICATE: java_get_value/2:
                              *Usage:*


                              `java_get_value(+java_object,+java_field)'
                                 - *Description:* Get the value of a
                                   field. The field value in the
                                   Java_field functor must be
                                   uninstantiated.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+java_object' is a java object
                                   (structure with functor
                                   '$java_object', and argument an
                                   integer given by java side).
                                   (`javart:java_object/1')

                                   `+java_field' is a java field
                                   (structure with functor as field
                                   name, and argument as value).
                                   (`javart:java_field/1')

                          - PREDICATE: java_set_value/2:
                              *Usage:*


                              `java_set_value(+java_object,+java_field)'
                                 - *Description:* Set the value of a
                                   field. The field value in the
                                   Java_field functor must be
                                   instantiated.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+java_object' is a java object
                                   (structure with functor
                                   '$java_object', and argument an
                                   integer given by java side).
                                   (`javart:java_object/1')

                                   `+java_field' is a java field
                                   (structure with functor as field
                                   name, and argument as value).
                                   (`javart:java_field/1')

                          - REGTYPE: java_field/1:
                              *Usage:* `java_field(X)'
                                 - *Description:* `X' is a java field
                                   (structure with functor as field
                                   name, and argument as value).

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - PREDICATE: java_connection/0:
                              *Usage:*
                                 - *Description:* Starts java server
                                   and connects it through data and
                                   event sockets.

                          - PREDICATE: java_remote_connection/1:
                              *Usage:*
                              `java_remote_connection(+machine_name)'
                                 - *Description:* Starts java server
                                   in machine_name and connects it
                                   through data and event sockets.

                          - PREDICATE: java_disconnection/0:
                              *Usage:*
                                 - *Description:* Closes the
                                   connection with the java process.

                          - PREDICATE: java_add_listener/3:
                              *Meta-predicate* with arguments:
                              `java_add_listener(?,?,goal)'.

                              *Usage:*























                              `java_add_listener(+java_object,+java_event,+prolog_predicate)'
                                 - *Description:* Adds a listener to
                                   an event on an object.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+java_object' is a java object
                                   (structure with functor
                                   '$java_object', and argument an
                                   integer given by java side).
                                   (`javart:java_object/1')

                                   `+java_event' is a java event
                                   represented as an atom with the
                                   basic event constructor name
                                   (e.g.,
                                   'java.awt.event.ActionListener').
                                   (`javart:java_event/1')

                                   `+prolog_predicate' is a prolog
                                   predicate. Prolog term that
                                   represents the predicate that must
                                   be invoked when the event raises
                                   on the object. The predicate
                                   arguments can be java objects, or
                                   even the result of java methods.
                                   These java objects will be
                                   evaluated when the event raises
                                   (instead of when the listener is
                                   added). The arguments that
                                   represent java objects must be
                                   instantiated to already created
                                   objects. The variables will be
                                   kept uninstantiated when the event
                                   raises and the predicate will be
                                   called.
                                   (`javart:prolog_predicate/1')

                          - REGTYPE: java_event/1:
                              *Usage:* `java_event(X)'
                                 - *Description:* `X' is a java event
                                   represented as an atom with the
                                   basic event constructor name
                                   (e.g.,
                                   'java.awt.event.ActionListener').

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - REGTYPE: prolog_predicate/1:
                              *Usage:* `prolog_predicate(X)'
                                 - *Description:* `X' is a prolog
                                   predicate. Prolog term that
                                   represents the predicate that must
                                   be invoked when the event raises
                                   on the object. The predicate
                                   arguments can be java objects, or
                                   even the result of java methods.
                                   These java objects will be
                                   evaluated when the event raises
                                   (instead of when the listener is
                                   added). The arguments that
                                   represent java objects must be
                                   instantiated to already created
                                   objects. The variables will be
                                   kept uninstantiated when the event
                                   raises and the predicate will be
                                   called.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - PREDICATE: java_remove_listener/3:
                              *Usage:*


























                              `java_remove_listener(+java_object,+java_event,+prolog_predicate)'
                                 - *Description:* Removes a listener
                                   from an object event queue.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+java_object' is a java object
                                   (structure with functor
                                   '$java_object', and argument an
                                   integer given by java side).
                                   (`javart:java_object/1')

                                   `+java_event' is a java event
                                   represented as an atom with the
                                   basic event constructor name
                                   (e.g.,
                                   'java.awt.event.ActionListener').
                                   (`javart:java_event/1')

                                   `+prolog_predicate' is a prolog
                                   predicate. Prolog term that
                                   represents the predicate that must
                                   be invoked when the event raises
                                   on the object. The predicate
                                   arguments can be java objects, or
                                   even the result of java methods.
                                   These java objects will be
                                   evaluated when the event raises
                                   (instead of when the listener is
                                   added). The arguments that
                                   represent java objects must be
                                   instantiated to already created
                                   objects. The variables will be
                                   kept uninstantiated when the event
                                   raises and the predicate will be
                                   called.
                                   (`javart:prolog_predicate/1')


File: ciao.info,  Node: Low-level Java to Prolog interface,  Next: Low-level Prolog to Java socket connection,  Prev: Low-level Prolog to Java interface,  Up: Top

Low-level Java to Prolog interface
**********************************

                            *Author(s):* Jes'us Correas.

                            This module defines a low level Java to
Prolog interface.

                         * Menu:
                         
                         * Usage and interface (jtopl)::
                         * Documentation on exports (jtopl)::


File: ciao.info,  Node: Usage and interface (jtopl),  Next: Documentation on exports (jtopl),  Prev: Low-level Java to Prolog interface,  Up: Low-level Java to Prolog interface

Usage and interface (`jtopl')
=============================

                            * *Library usage:*

                              `:- use_module(library(jtopl)).'

                            * *Exports:*
                                 - *Predicates:*

                                   `prolog_server/0',
                                   `prolog_parse/2'.

                            * *Other modules used:*
                                 - *Application modules:*

                                   `javasock'.

                                 - *System library modules:*

                                   `system', `read', `write',
                                   `dynamic', `lists', `format',
                                   `dynmods', `atom2term'.



File: ciao.info,  Node: Documentation on exports (jtopl),  Prev: Usage and interface (jtopl),  Up: Low-level Java to Prolog interface

Documentation on exports (`jtopl')
==================================

                          - PREDICATE: prolog_server/0:
                              *Usage:*
                                 - *Description:* Prolog server entry
                                   point. Reads from the standard
                                   input the node name and port
                                   number where the java client
                                   resides, and starts the prolog
                                   server listening at the data
                                   socket. This predicate acts as a
                                   server: includes an infinite
                                   read-process loop until the
                                   prolog_exit command is received.

                          - PREDICATE: prolog_parse/2:
                              *Usage:* `prolog_parse(+String,-(Term))'
                                 - *Description:* Parses the string
                                   received as first argument and
                                   returns the prolog term as second
                                   argument. This is a private
                                   predicate but is called from java
                                   side.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+String' is a string (a list of
                                   character codes).
                                   (`basic_props:string/1')

                                   `-(Term)' is any term.
                                   (`basic_props:term/1')


File: ciao.info,  Node: Low-level Prolog to Java socket connection,  Next: linda (library),  Prev: Low-level Java to Prolog interface,  Up: Top

Low-level Prolog to Java socket connection
******************************************

                            *Author(s):* Jes'us Correas.

                            This module defines a low level socket
interface, to be used by javart and jtopl.

                         * Menu:
                         
                         * Usage and interface (javasock)::
                         * Documentation on exports (javasock)::


File: ciao.info,  Node: Usage and interface (javasock),  Next: Documentation on exports (javasock),  Prev: Low-level Prolog to Java socket connection,  Up: Low-level Prolog to Java socket connection

Usage and interface (`javasock')
================================

                            * *Library usage:*

                              `:- use_module(library(javasock)).'

                            * *Exports:*
                                 - *Predicates:*

                                   `socket_connection/2',
                                   `socket_disconnection/0',
                                   `java_fast_write/2',
                                   `java_stream/3'.

                            * *Other modules used:*
                                 - *System library modules:*

                                   `fastrw', `read',
                                   `sockets/sockets', `dynamic',
                                   `format'.



File: ciao.info,  Node: Documentation on exports (javasock),  Prev: Usage and interface (javasock),  Up: Low-level Prolog to Java socket connection

Documentation on exports (`javasock')
=====================================

                          - PREDICATE: socket_connection/2:
                              *Usage:*
                              `socket_connection(+node,+stream)'
                                 - *Description:* Given a stream
                                   connected to a node, gets the
                                   socket port from the given stream
                                   and creates the sockets to connect
                                   to the java process.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+node' is currently instantiated
                                   to an atom.
                                   (`term_typing:atom/1')

                                   `+stream' is an open stream.
                                   (`streams_basic:stream/1')

                          - PREDICATE: socket_disconnection/0:
                              *Usage:*
                                 - *Description:* Closes the sockets
                                   to disconnect from the java
                                   process.

                          - PREDICATE: java_fast_read/2:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: java_fast_write/2:
                              *Usage 1:*
                              `java_fast_write(+type,+term)'
                                 - *Description:* writes on the given
                                   stream type the term received as
                                   second argument.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+type' is currently instantiated
                                   to an atom.
                                   (`term_typing:atom/1')

                                   `+term' is any term.
                                   (`basic_props:term/1')

                              *Usage 2:*
                              `java_fast_write(+type,-(term))'
                                 - *Description:* reads from the
                                   given stream type one term and
                                   unifies it with the term received
                                   as second argument.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `+type' is currently instantiated
                                   to an atom.
                                   (`term_typing:atom/1')

                                   `-(term)' is any term.
                                   (`basic_props:term/1')

                          - PREDICATE: java_stream/3:
                              The predicate is of type *dynamic*.

                              *Usage:*





                              `java_stream(DataStream,EventStream,Address)'
                                 - *Description:* Stores the ids of
                                   the streams used.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `DataStream' is an atom.
                                   (`basic_props:atm/1')

                                   `EventStream' is an integer.
                                   (`basic_props:int/1')

                                   `undefined:machine_name(Address)'
                                   (undefined property)


File: ciao.info,  Node: linda (library),  Next: *** PART IX - Abstract data types,  Prev: Low-level Prolog to Java socket connection,  Up: Top

linda (library)
***************

                            *Version:* 0.9#66 (1999/4/29, 12:28:0
MEST)

                         * Menu:
                         
                         * Usage and interface (linda)::
                         * Documentation on exports (linda)::


File: ciao.info,  Node: Usage and interface (linda),  Next: Documentation on exports (linda),  Prev: linda (library),  Up: linda (library)

Usage and interface (`linda')
=============================

                            * *Library usage:*

                              `:- use_module(library(linda)).'

                            * *Other modules used:*
                                 - *System library modules:*

                                   `read', `fastrw',
                                   `sockets/sockets'.



File: ciao.info,  Node: Documentation on exports (linda),  Prev: Usage and interface (linda),  Up: linda (library)

Documentation on exports (`linda')
==================================

                          - PREDICATE: linda_client/1:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: close_client/0:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: in/1:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: in/2:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: in_noblock/1:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: out/1:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: rd/1:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: rd/2:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: rd_noblock/1:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: rd_findall/3:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: linda_timeout/2:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: halt_server/0:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: open_client/2:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: in_stream/2:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: out_stream/2:
                              No further documentation available for
                              this predicate.



File: ciao.info,  Node: *** PART IX - Abstract data types,  Next: atom2term (library),  Prev: linda (library),  Up: Top

PART IX - Abstract data types
*****************************

                            This part includes libraries which
implement some generic data structures that are habitually used in
programs.


File: ciao.info,  Node: atom2term (library),  Next: counters (library),  Prev: *** PART IX - Abstract data types,  Up: Top

atom2term (library)
*******************

                            *Author(s):* Francisco Bueno, Daniel
Cabeza.

                            *Version:* 1.3#120 (1999/11/26, 12:5:17
MET)

                            *Version of last change:* 0.9#78
(1999/5/3, 19:19:27 MEST)

                         * Menu:
                         
                         * Usage and interface (atom2term)::
                         * Documentation on exports (atom2term)::


File: ciao.info,  Node: Usage and interface (atom2term),  Next: Documentation on exports (atom2term),  Prev: atom2term (library),  Up: atom2term (library)

Usage and interface (`atom2term')
=================================

                            * *Library usage:*

                              `:- use_module(library(atom2term)).'

                            * *Exports:*
                                 - *Predicates:*

                                   `atom2term/2', `string2term/2'.



File: ciao.info,  Node: Documentation on exports (atom2term),  Prev: Usage and interface (atom2term),  Up: atom2term (library)

Documentation on exports (`atom2term')
======================================

                          - PREDICATE: atom2term/2:
                              *Usage:* `atom2term(+Atom,-(Term))'
                                 - *Description:* Convert an atom
                                   into a term. `Atom' is an atom,
                                   but must have term syntax. `Term'
                                   is a term resulting from parsing
                                   `Atom' char by char. Note: this is
                                   just a simple version written for
                                   parsing daVinci's messages. There
                                   should be a call to the standard
                                   reader to do this!

                          - PREDICATE: string2term/2:
                              *Usage:* `string2term(+String,-(Term))'
                                 - *Description:* Same as
                                   `atom2term/2' but first argument
                                   is a string (containing a term).

                          - PREDICATE: parse_term/3:
                              No further documentation available for
                              this predicate.



File: ciao.info,  Node: counters (library),  Next: Identity lists,  Prev: atom2term (library),  Up: Top

counters (library)
******************

                            *Version:* 0.4#5 (1998/2/24)

                         * Menu:
                         
                         * Usage and interface (counters)::
                         * Documentation on exports (counters)::


File: ciao.info,  Node: Usage and interface (counters),  Next: Documentation on exports (counters),  Prev: counters (library),  Up: counters (library)

Usage and interface (`counters')
================================

                            * *Library usage:*

                              `:- use_module(library(counters)).'


File: ciao.info,  Node: Documentation on exports (counters),  Prev: Usage and interface (counters),  Up: counters (library)

Documentation on exports (`counters')
=====================================

                          - PREDICATE: setcounter/2:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: getcounter/2:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: inccounter/2:
                              No further documentation available for
                              this predicate.



File: ciao.info,  Node: Identity lists,  Next: Term manipulation,  Prev: counters (library),  Up: Top

Identity lists
**************

                            *Author(s):* Francisco Bueno.

                            *Version:* 0.4#5 (1998/2/24)

                            The operations in this module handle
lists by performing equality checks via identity instead of
unification.

                         * Menu:
                         
                         * Usage and interface (idlists)::
                         * Documentation on exports (idlists)::


File: ciao.info,  Node: Usage and interface (idlists),  Next: Documentation on exports (idlists),  Prev: Identity lists,  Up: Identity lists

Usage and interface (`idlists')
===============================

                            * *Library usage:*

                              `:- use_module(library(idlists)).'

                            * *Exports:*
                                 - *Predicates:*

                                   `list_insert/2', `add_after/4',
                                   `add_before/4', `delete/3',
                                   `subtract/3', `union_idlists/3'.



File: ciao.info,  Node: Documentation on exports (idlists),  Prev: Usage and interface (idlists),  Up: Identity lists

Documentation on exports (`idlists')
====================================

                          - PREDICATE: member_0/2:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: memberchk/2:
                              `memberchk(X,Xs)'

                              Checks that `X' is an element of (list)
                              `Xs'.


                          - PREDICATE: list_insert/2:
                              *Usage:* `list_insert(-(List),+Term)'
                                 - *Description:* Adds `Term' to the
                                   end of (tail-opened) `List' if
                                   there is not an element in `List'
                                   identical to `Term'.

                          - PREDICATE: add_after/4:
                              *Usage:* `add_after(+L0,+E0,+E,-(L))'
                                 - *Description:* Adds element `E'
                                   after the first element identical
                                   to `E0' (or at end) of list `L0',
                                   returning in `L' the new list.

                          - PREDICATE: add_before/4:
                              *Usage:* `add_before(+L0,+E0,+E,-(L))'
                                 - *Description:* Adds element `E'
                                   before the first element identical
                                   to `E0' (or at start) of list
                                   `L0', returning in `L' the new
                                   list.

                          - PREDICATE: delete/3:
                              *Usage:*
                              `delete(+List,+Element,-(Rest))'
                                 - *Description:* `Rest' has the same
                                   elements of `List' except for all
                                   the occurrences of elements
                                   identical to `Element'.

                          - PREDICATE: subtract/3:
                              *Usage:*
                              `subtract(+Set,+Set0,-(Difference))'
                                 - *Description:* `Difference' has
                                   the same elements of `Set' except
                                   those which have an identical
                                   occurrence in `Set0'.

                          - PREDICATE: union_idlists/3:
                              *Usage:*
                              `union_idlists(+List1,+List2,-(List))'
                                 - *Description:* `List' has the
                                   elements which are in `List1' but
                                   are not identical to an element in
                                   `List2' followed by the elements
                                   in `List2'.


File: ciao.info,  Node: Term manipulation,  Next: Lists of numbers,  Prev: Identity lists,  Up: Top

Term manipulation
*****************

                            *Version:* 0.8#30 (1998/12/17, 9:55:33
MET)

                         * Menu:
                         
                         * Usage and interface (metaterms)::
                         * Documentation on exports (metaterms)::


File: ciao.info,  Node: Usage and interface (metaterms),  Next: Documentation on exports (metaterms),  Prev: Term manipulation,  Up: Term manipulation

Usage and interface (`metaterms')
=================================

                            * *Library usage:*

                              `:- use_module(library(metaterms)).'

                            * *Other modules used:*
                                 - *System library modules:*

                                   `lists', `idlists', `sort',
                                   `write'.



File: ciao.info,  Node: Documentation on exports (metaterms),  Prev: Usage and interface (metaterms),  Up: Term manipulation

Documentation on exports (`metaterms')
======================================

                          - PREDICATE: varset/2:
                              `varset(Term,Xs)'

                              `Xs' is the sorted list of all the
                              variables in `Term'.


                          - PREDICATE: varsbag/3:
                              `varsbag(Term,Vs,Xs)'

                              `Vs' is the list of all the variables
                              in `Term' ordered as they appear in
                              `Term' left-to-right depth-first
                              (including duplicates) plus `Xs'.


                          - PREDICATE: ask/2:
                              `ask(Term1,Term2)'

                              `Term1' and `Term2' unify without
                              producing bindings for the variables of
                              `Term1'. I.e.,
                              `instance(`Term1',`Term2')' holds.


                          - PREDICATE: instance/2:
                              `instance(Term1,Term2)'

                              `Term2' is an instance of `Term1'.


                          - PREDICATE: variant/2:
                              `variant(Term1,Term2)'

                              `Term1' and `Term2' are identical up to
                              renaming.



File: ciao.info,  Node: Lists of numbers,  Next: Pattern (regular expression) matching,  Prev: Term manipulation,  Up: Top

Lists of numbers
****************

                            *Version:* 0.9#99 (1999/5/26, 11:33:15
MEST)

                         * Menu:
                         
                         * Usage and interface (numlists)::
                         * Documentation on exports (numlists)::


File: ciao.info,  Node: Usage and interface (numlists),  Next: Documentation on exports (numlists),  Prev: Lists of numbers,  Up: Lists of numbers

Usage and interface (`numlists')
================================

                            * *Library usage:*

                              `:- use_module(library(numlists)).'

                            * *Exports:*
                                 - *Predicates:*

                                   `get_primes/2', `sum_list/2',
                                   `sum_list/3',
                                   `sum_list_of_lists/2',
                                   `sum_list_of_lists/3'.

                                 - *Regular Types:*

                                   `intlist/1', `numlist/1'.

                            * *Other modules used:*
                                 - *System library modules:*

                                   `lists'.



File: ciao.info,  Node: Documentation on exports (numlists),  Prev: Usage and interface (numlists),  Up: Lists of numbers

Documentation on exports (`numlists')
=====================================

                          - PREDICATE: get_primes/2:
                              *Usage:* `get_primes(N,Primes)'
                                 - *Description:* Computes the `N'th
                                   first prime numbers in ascending
                                   order.

                                 - *The following properties should
                                   hold at call time:*

                                   `N' is an integer.
                                   (`basic_props:int/1')

                                 - *The following properties should
                                   hold upon exit:*

                                   `Primes' is a list of integers.
                                   (`numlists:intlist/1')

                          - REGTYPE: intlist/1:
                              *Usage:* `intlist(X)'
                                 - *Description:* `X' is a list of
                                   integers.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - REGTYPE: numlist/1:
                              *Usage:* `numlist(X)'
                                 - *Description:* `X' is a list of
                                   numbers.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - PREDICATE: sum_list/2:
                              *Usage:* `sum_list(List,N)'
                                 - *Description:* `N' is the total
                                   sum of the elements of `List'.

                                 - *The following properties should
                                   hold at call time:*

                                   `List' is a list of numbers.
                                   (`numlists:numlist/1')

                                 - *The following properties should
                                   hold upon exit:*

                                   `N' is a number.
                                   (`basic_props:num/1')

                          - PREDICATE: sum_list/3:
                              *Usage:* `sum_list(List,N0,N)'
                                 - *Description:* `N' is the total
                                   sum of the elements of `List' plus
                                   `N0'.

                                 - *The following properties should
                                   hold at call time:*

                                   `List' is a list of numbers.
                                   (`numlists:numlist/1')

                                   `N0' is a number.
                                   (`basic_props:num/1')

                                 - *The following properties should
                                   hold upon exit:*

                                   `N' is a number.
                                   (`basic_props:num/1')

                          - PREDICATE: sum_list_of_lists/2:
                              *Usage:* `sum_list_of_lists(Lists,N)'
                                 - *Description:* `N' is the total
                                   sum of the elements of the lists
                                   of `Lists'.

                                 - *The following properties should
                                   hold at call time:*

                                   `List' is a list of `numlist's.
                                   (`basic_props:list/2')

                                 - *The following properties should
                                   hold upon exit:*

                                   `N' is a number.
                                   (`basic_props:num/1')

                          - PREDICATE: sum_list_of_lists/3:
                              *Usage:* `sum_list_of_lists(Lists,N0,N)'
                                 - *Description:* `N' is the total
                                   sum of the elements of the lists
                                   of `Lists' plus `N0'.

                                 - *The following properties should
                                   hold at call time:*

                                   `List' is a list of `numlist's.
                                   (`basic_props:list/2')

                                   `N0' is a number.
                                   (`basic_props:num/1')

                                 - *The following properties should
                                   hold upon exit:*

                                   `N' is a number.
                                   (`basic_props:num/1')


File: ciao.info,  Node: Pattern (regular expression) matching,  Next: queues (library),  Prev: Lists of numbers,  Up: Top

Pattern (regular expression) matching
*************************************

                            *Version:* 1.3#120 (1999/11/26, 12:5:17
MET)

                            *Version of last change:* 1.3#49
(1999/9/8, 21:8:9 MEST)

                            This library provides facilities for
matching strings and terms against *patterns* (i.e., *regular
expressions*).

                         * Menu:
                         
                         * Usage and interface (patterns)::
                         * Documentation on exports (patterns)::


File: ciao.info,  Node: Usage and interface (patterns),  Next: Documentation on exports (patterns),  Prev: Pattern (regular expression) matching,  Up: Pattern (regular expression) matching

Usage and interface (`patterns')
================================

                            * *Library usage:*

                              `:- use_module(library(patterns)).'

                            * *Exports:*
                                 - *Predicates:*

                                   `match_pattern/2',
                                   `match_pattern/3',
                                   `case_insensitive_match/2',
                                   `match_pattern_pred/2'.

                                 - *Regular Types:*

                                   `pattern/1'.

                            * *Other modules used:*
                                 - *System library modules:*

                                   `lists'.



File: ciao.info,  Node: Documentation on exports (patterns),  Prev: Usage and interface (patterns),  Up: Pattern (regular expression) matching

Documentation on exports (`patterns')
=====================================

                          - PREDICATE: match_pattern/2:
                              *Usage:* `match_pattern(Pattern,String)'
                                 - *Description:* Matches `String'
                                   against `Pattern'. For example,
                                   `match_pattern("*.pl","foo.pl")'
                                   succeeds.

                                 - *The following properties should
                                   hold at call time:*

                                   `Pattern' is a pattern to match
                                   against.   (`patterns:pattern/1')

                                   `String' is a string (a list of
                                   character codes).
                                   (`basic_props:string/1')

                          - PREDICATE: match_pattern/3:
                              *Usage:*
                              `match_pattern(Pattern,String,Tail)'
                                 - *Description:* Matches `String'
                                   against `Pattern'. `Tail' is the
                                   remainder of the string after the
                                   match. For example,


                                   `match_pattern("??*","foo.pl",Tail)'
                                   succeeds, instantiating `Tail' to
                                   `"o.pl"'.

                                 - *The following properties should
                                   hold at call time:*

                                   `Pattern' is a pattern to match
                                   against.   (`patterns:pattern/1')

                                   `String' is a string (a list of
                                   character codes).
                                   (`basic_props:string/1')

                                   `Tail' is a string (a list of
                                   character codes).
                                   (`basic_props:string/1')

                          - PREDICATE: case_insensitive_match/2:
                              *Usage:*
                              `case_insensitive_match(Pred1,Pred2)'
                                 - *Description:* Tests if two
                                   predicates `Pred1' and `Pred2'
                                   match in a case-insensitive way.

                          - PREDICATE: letter_match/2:
                              No further documentation available for
                              this predicate.


                          - REGTYPE: pattern/1:
                              Special characters for `Pattern' are:
                             *
                                   Matches any string, including the
                                   null string.

                             ?
                                   Matches any single character.

                             [...]
                                   Matches any one of the enclosed
                                   characters. A pair of characters
                                   separated by a minus sign denotes
                                   a range; any character lexically
                                   between those two characters,
                                   inclusive, is matched. If the
                                   first character following the [ is
                                   a ^ then any character not
                                   enclosed is matched. No other
                                   character is special inside this
                                   construct. To include a ] in a
                                   character set, you must make it
                                   the first character. To include a
                                   `-', you must use it in a context
                                   where it cannot possibly indicate
                                   a range: that is, as the first
                                   character, or immediately after a
                                   range.

                             |
                                   specifies an alternative. Two
                                   regular expressions A and B with |
                                   in between form an expression that
                                   matches anything that either A or
                                   B will match.

                             {...}
                                   groups alternatives inside larger
                                   patterns.

                             \
                                   Quotes a special character
                                   (including itself).

                              *Usage:* `pattern(P)'
                                 - *Description:* `P' is a pattern to
                                   match against.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - PREDICATE: match_pattern_pred/2:
                              *Usage:*
                              `match_pattern_pred(Pred1,Pred2)'
                                 - *Description:* Tests if two
                                   predicates `Pred1' and `Pred2'
                                   match using regular expressions.


File: ciao.info,  Node: queues (library),  Next: Random numbers,  Prev: Pattern (regular expression) matching,  Up: Top

queues (library)
****************

                            *Version:* 0.4#5 (1998/2/24)

                         * Menu:
                         
                         * Usage and interface (queues)::
                         * Documentation on exports (queues)::


File: ciao.info,  Node: Usage and interface (queues),  Next: Documentation on exports (queues),  Prev: queues (library),  Up: queues (library)

Usage and interface (`queues')
==============================

                            * *Library usage:*

                              `:- use_module(library(queues)).'


File: ciao.info,  Node: Documentation on exports (queues),  Prev: Usage and interface (queues),  Up: queues (library)

Documentation on exports (`queues')
===================================

                          - PREDICATE: q_empty/1:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: q_insert/3:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: q_member/2:
                              No further documentation available for
                              this predicate.


                          - PREDICATE: q_delete/3:
                              No further documentation available for
                              this predicate.



File: ciao.info,  Node: Random numbers,  Next: sets (library),  Prev: queues (library),  Up: Top

Random numbers
**************

                            *Author(s):* Daniel Cabeza.

                            This module provides predicates for
generating pseudo-random numbers

                         * Menu:
                         
                         * Usage and interface (random)::
                         * Documentation on exports (random)::


File: ciao.info,  Node: Usage and interface (random),  Next: Documentation on exports (random),  Prev: Random numbers,  Up: Random numbers

Usage and interface (`random')
==============================

                            * *Library usage:*

                              `:- use_module(library(random)).'

                            * *Exports:*
                                 - *Predicates:*

                                   `random/1', `random/3',
                                   `srandom/1'.



File: ciao.info,  Node: Documentation on exports (random),  Prev: Usage and interface (random),  Up: Random numbers

Documentation on exports (`random')
===================================

                          - PREDICATE: random/1:
                              `random(Number)'

                              `Number' is a (pseudo-) random number
                              in the range [0.0,1.0]

                              The predicate is of type *implicit*.

                              *Usage:* `random(-(float))'

                          - PREDICATE: random/3:
                              `random(Low,Up,Number)'

                              `Number' is a (pseudo-) random number
                              in the range [`Low', `Up']

                              The predicate is of type *implicit*.

                              *Usage 1:* `random(+int,+int,-(int))'
                                 - *Description:* If `Low' and `Up'
                                   are integers, `Number' is an
                                   integer.

                              *Usage 2:* `random(+flt,+num,-(flt))'
                              *Usage 3:* `random(+int,+flt,-(flt))'

                          - PREDICATE: srandom/1:
                              `srandom(Seed)'

                              Changes the sequence of pseudo-random
                              numbers according to `Seed'. The
                              stating sequence of numbers generated
                              can be duplicated by calling the
                              predicate with `Seed' unbound (the
                              sequence depends on the OS).

                              The predicate is of type *implicit*.

                              *Usage:* `srandom(?(int))'


File: ciao.info,  Node: sets (library),  Next: Variable names dictionaries,  Prev: Random numbers,  Up: Top

sets (library)
**************

                            *Version:* 1.3#120 (1999/11/26, 12:5:17
MET)

                            *Version of last change:* 0.9#17
(1999/3/23, 20:57:20 MET)

                            This module implements set operations.
Sets are just ordered lists.

                         * Menu:
                         
                         * Usage and interface (sets)::
                         * Documentation on exports (sets)::


File: ciao.info,  Node: Usage and interface (sets),  Next: Documentation on exports (sets),  Prev: sets (library),  Up: sets (library)

Usage and interface (`sets')
============================

                            * *Library usage:*

                              `:- use_module(library(sets)).'

                            * *Exports:*
                                 - *Predicates:*

                                   `insert/3', `ord_delete/3',
                                   `ord_member/2',
                                   `ord_test_member/3',
                                   `ord_subtract/3',
                                   `ord_intersection/3',
                                   `ord_intersection_diff/4',
                                   `ord_intersect/2', `ord_subset/2',
                                   `ord_subset_diff/3', `ord_union/3',
                                   `ord_union_diff/4',
                                   `ord_union_symdiff/4',
                                   `ord_union_change/3', `merge/3',
                                   `ord_disjoint/2', `setproduct/3'.

                            * *Other modules used:*
                                 - *System library modules:*

                                   `sort'.



File: ciao.info,  Node: Documentation on exports (sets),  Prev: Usage and interface (sets),  Up: sets (library)

Documentation on exports (`sets')
=================================

                          - PREDICATE: insert/3:
                              *Usage:*
                              `insert(+Set1,+Element,-(Set2))'
                                 - *Description:* It is true when
                                   `Set2' is `Set1' with `Element'
                                   inserted in it, preserving the
                                   order.

                          - PREDICATE: ord_delete/3:
                              *Usage:* `ord_delete(+Set0,+X,-(Set))'
                                 - *Description:* It succeeds if
                                   `Set' is `Set0' without element
                                   `X'.

                          - PREDICATE: ord_member/2:
                              *Usage:* `ord_member(+X,+Set)'
                                 - *Description:* It succeeds if `X'
                                   is member of `Set'.

                          - PREDICATE: ord_test_member/3:
                              *Usage:*
                              `ord_test_member(+Set,+X,-(Result))'
                                 - *Description:* If `X' is member of
                                   `Set' then `Result'=`yes'.
                                   Otherwise `Result'=`no'.

                          - PREDICATE: ord_subtract/3:
                              *Usage:*

                              `ord_subtract(+Set1,+Set2,?(Difference))'
                                 - *Description:* It is true when
                                   `Difference' contains all and only
                                   the elements of `Set1' which are
                                   not also in `Set2'.

                          - PREDICATE: ord_intersection/3:
                              *Usage:*







                              `ord_intersection(+Set1,+Set2,?(Intersection))'
                                 - *Description:* It is true when
                                   `Intersection' is the ordered
                                   representation of `Set1' and
                                   `Set2', provided that `Set1' and
                                   `Set2' are ordered lists.

                          - PREDICATE: ord_intersection_diff/4:
                              *Usage:*

























                              `ord_intersection_diff(+Set1,+Set2,-(Intersect),-(NotIntersect))'
                                 - *Description:* `Intersect'
                                   contains those elements which are
                                   both in `Set1' and `Set2', and
                                   `NotIntersect' those which are in
                                   `Set1' but not in `Set2'.

                          - PREDICATE: ord_intersect/2:
                              *Usage:* `ord_intersect(+Xs,+Ys)'
                                 - *Description:* Succeeds when the
                                   two ordered lists have at least
                                   one element in common.

                          - PREDICATE: ord_subset/2:
                              *Usage:* `ord_subset(+Xs,+Ys)'
                                 - *Description:* Succeeds when every
                                   element of `Xs' appears in `Ys'.

                          - PREDICATE: ord_subset_diff/3:
                              *Usage:*




                              `ord_subset_diff(+Set1,+Set2,-(Difference))'
                                 - *Description:* It succeeds when
                                   every element of `Set1' appears in
                                   `Set2' and `Difference' has the
                                   elements of `Set2' which are not
                                   in `Set1'.

                          - PREDICATE: ord_union/3:
                              *Usage:*
                              `ord_union(+Set1,+Set2,?(Union))'
                                 - *Description:* It is true when
                                   `Union' is the union of `Set1' and
                                   `Set2'. When some element occurs
                                   in both sets, `Union' retains only
                                   one copy.

                          - PREDICATE: ord_union_diff/4:
                              *Usage:*












                              `ord_union_diff(+Set1,+Set2,-(Union),-(Difference))'
                                 - *Description:* It succeeds when
                                   `Union' is the union of `Set1' and
                                   `Set2', and `Difference' is `Set2'
                                   set-minus `Set1'.

                          - PREDICATE: ord_union_symdiff/4:
                              *Usage:*









                              `ord_union_symdiff(+Set1,+Set2,-(Union),-(Diff))'
                                 - *Description:* It is true when
                                   Diff is the symmetric difference
                                   of Set1 and Set2, and Union is the
                                   union of Set1 and Set2.

                          - PREDICATE: ord_union_change/3:
                              *Usage:*
                              `ord_union_change(+Set1,+Set2,-(Union))'
                                 - *Description:* `Union' is the
                                   union of `Set1' and `Set2' and
                                   `Union' is different from `Set2'.

                          - PREDICATE: merge/3:
                              *Usage:* `merge(+Set1,+Set2,?(Union))'
                                 - *Description:* See `ord_union/3'.

                          - PREDICATE: ord_disjoint/2:
                              *Usage:* `ord_disjoint(+Set1,+Set2)'
                                 - *Description:* `Set1' and `Set2'
                                   have no element in common.

                          - PREDICATE: setproduct/3:
                              *Usage:*
                              `setproduct(+Set1,+Set2,-(Product))'
                                 - *Description:* `Product' has all
                                   two element sets such that one
                                   element is in `Set1' and the other
                                   in `set2', except that if the same
                                   element belongs to both, then the
                                   corresponding one element set is
                                   in `Product'.


File: ciao.info,  Node: Variable names dictionaries,  Next: *** PART X - Miscellaneous standalone utilities,  Prev: sets (library),  Up: Top

Variable names dictionaries
***************************

                            *Author(s):* Francisco Bueno.

                            *Version:* 1.3#120 (1999/11/26, 12:5:17
MET)

                            *Version of last change:* 0.8#19
(1998/12/3, 12:53:16 MET)

                         * Menu:
                         
                         * Usage and interface (vndict)::
                         * Documentation on exports (vndict)::


File: ciao.info,  Node: Usage and interface (vndict),  Next: Documentation on exports (vndict),  Prev: Variable names dictionaries,  Up: Variable names dictionaries

Usage and interface (`vndict')
==============================

                            * *Library usage:*

                              `:- use_module(library(vndict)).'

                            * *Exports:*
                                 - *Predicates:*

                                   `create_dict/2', `complete_dict/3',
                                   `complete_vars_dict/3',
                                   `prune_dict/3', `dict2varnamesl/2',
                                   `varnamesl2dict/2', `rename/2',
                                   `vars_names_dict/3'.

                                 - *Regular Types:*

                                   `null_dict/1', `varname/1',
                                   `varnamesl/1', `varnamedict/1'.

                            * *Other modules used:*
                                 - *System library modules:*

                                   `idlists', `metaterms', `sets',
                                   `sort'.



File: ciao.info,  Node: Documentation on exports (vndict),  Prev: Usage and interface (vndict),  Up: Variable names dictionaries

Documentation on exports (`vndict')
===================================

                          - REGTYPE: null_dict/1:
                              *Usage:* `null_dict(D)'
                                 - *Description:* `D' is an empty
                                   dictionary.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - PREDICATE: create_dict/2:
                              *Usage:* `create_dict(Term,Dict)'
                                 - *Description:* `Dict' has names
                                   for all variables in `Term'.

                                 - *The following properties should
                                   hold at call time:*

                                   `Term' is any term.
                                   (`basic_props:term/1')

                                 - *The following properties should
                                   hold upon exit:*

                                   `Dict' is a dictionary of variable
                                   names.   (`vndict:varnamedict/1')

                          - PREDICATE: complete_dict/3:
                              *Usage:*
                              `complete_dict(+Dict,+Term,-(NewDict))'
                                 - *Description:* `NewDict' is `Dict'
                                   augmented with the variables of
                                   `Term' not yet in `Dict'.

                          - PREDICATE: complete_vars_dict/3:
                              *Usage:*




                              `complete_vars_dict(+Dict,+Vars,-(NewDict))'
                                 - *Description:* `NewDict' is `Dict'
                                   augmented with the variables of
                                   the list `Vars' not yet in `Dict'.

                          - PREDICATE: prune_dict/3:
                              *Usage:*
                              `prune_dict(+Term,+Dict,-(NewDict))'
                                 - *Description:* `NewDict' is `Dict'
                                   reduced to just the variables of
                                   `Term'.

                          - PREDICATE: dict2varnamesl/2:
                              *Usage:* `dict2varnamesl(Dict,VNs)'
                                 - *Description:* Translates `Dict'
                                   to `VNs'.

                                 - *The following properties should
                                   hold at call time:*

                                   `Dict' is a dictionary of variable
                                   names.   (`vndict:varnamedict/1')

                                 - *The following properties should
                                   hold upon exit:*

                                   `VNs' is a list of `Name=Var', for
                                   a variable `Var' and its name
                                   `Name'.   (`vndict:varnamesl/1')

                          - PREDICATE: varnamesl2dict/2:
                              *Usage:* `varnamesl2dict(VNs,Dict)'
                                 - *Description:* Translates `VNs' to
                                   `Dict'.

                                 - *The following properties should
                                   hold at call time:*

                                   `VNs' is a list of `Name=Var', for
                                   a variable `Var' and its name
                                   `Name'.   (`vndict:varnamesl/1')

                                 - *The following properties should
                                   hold upon exit:*

                                   `Dict' is a dictionary of variable
                                   names.   (`vndict:varnamedict/1')

                          - PREDICATE: find_name/4:
                              `find_name(Vars,Names,V,Name)'

                              Given that
                              `vars_names_dict(Dict,Vars,Names)'
                              holds, it acts as `rename(X,Dict)', but
                              the name of `X' is given as `Name'
                              instead of unified with it.


                          - PREDICATE: rename/2:
                              *Usage:* `rename(Term,Dict)'
                                 - *Description:* Unifies each
                                   variable in `Term' with its name
                                   in `Dict'. If no name is found, a
                                   new name is created.

                                 - *The following properties should
                                   hold at call time:*

                                   `Dict' is a dictionary of variable
                                   names.   (`vndict:varnamedict/1')

                          - REGTYPE: varname/1:
                              *Usage:* `varname(N)'
                                 - *Description:* `N' is term
                                   representing a variable name.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - REGTYPE: varnamesl/1:
                              *Usage:* `varnamesl(D)'
                                 - *Description:* `D' is a list of
                                   `Name=Var', for a variable `Var'
                                   and its name `Name'.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - REGTYPE: varnamedict/1:
                              *Usage:* `varnamedict(D)'
                                 - *Description:* `D' is a dictionary
                                   of variable names.

                                 - *The following properties should
                                   hold globally:*

                                   Defines a regular type.
                                   (`basic_props:regtype/1')

                          - PREDICATE: vars_names_dict/3:
                              *Usage:*
                              `vars_names_dict(Dict,Vars,Names)'
                                 - *Description:* `Varss' is a sorted
                                   list of variables, and `Names' is
                                   a list of their names, which
                                   correspond in the same order.

                                 - *Call and exit should be
                                   *compatible* with:*

                                   `Dict' is a dictionary of variable
                                   names.   (`vndict:varnamedict/1')

                                   `Vars' is a list.
                                   (`basic_props:list/1')

                                   `Names' is a list.
                                   (`basic_props:list/1')


File: ciao.info,  Node: *** PART X - Miscellaneous standalone utilities,  Next: Printing the declarations and code in a file,  Prev: Variable names dictionaries,  Up: Top

PART X - Miscellaneous standalone utilities
*******************************************

                            *Author(s):* F. Bueno, D. Cabeza, M.
Carro,, M. Hermenegildo, P. L'opez, and G. Puebla,
<clip@dia.fi.upm.es>, `http://www.clip.dia.fi.upm.es/', The CLIP
Group, School of Computer Science, Technical University of Madrid.

                            This is the documentation for a set of
miscellaneous standalone utilities contained in the `etc' directory
of the CIAO distribution.


File: ciao.info,  Node: Printing the declarations and code in a file,  Next: Printing the contents of a bytecode file,  Prev: *** PART X - Miscellaneous standalone utilities,  Up: Top

Printing the declarations and code in a file
********************************************

                            *Author(s):* Manuel Hermenegildo.

                            *Version:* 0.5#6 (1999/4/15, 20:33:6 MEST)

                            A simple program for printing assertion
information ( predicate declarations, property declarations, type
declarations, etc.) and printing code-related information ( imports,
exports, libraries used, etc.) on a file. The file should be a single
CIAO or Prolog source file. It uses the CIAO compiler's pass one to
do it. This program is specially useful for example to check what the
compiler is actually seeing after syntactic expansions, as well as
for checking what assertions the assertion normalizer is producing
from the original assertions in the file.

                         * Menu:
                         
                         * Usage (fileinfo)::
                         * More detailed explanation of options (fileinfo)::


File: ciao.info,  Node: Usage (fileinfo),  Next: More detailed explanation of options (fileinfo),  Prev: Printing the declarations and code in a file,  Up: Printing the declarations and code in a file

Usage (fileinfo)
================


                                  fileinfo -asr <filename.asr>
                                     : pretty prints the contents of <filename.asr>
                              
                                  fileinfo [-v] [-m] <-a|-c|-e> <filename> [libdir1] ... [libdirN]
                                  -v : verbose output (e.g., lists all files read)
                                  -m : restrict info to current module
                                  -a : print assertions
                                  -c : print code and interface (imports/exports, etc.)
                                  -e : print only errors - useful to check syntax of assertions in file
                              
                                  fileinfo -h
                                     : print this information


File: ciao.info,  Node: More detailed explanation of options (fileinfo),  Prev: Usage (fileinfo),  Up: Printing the declarations and code in a file

More detailed explanation of options (fileinfo)
===============================================

                            * If the `-a' option is selected,
                              `fileinfo' prints the assertions (only
                              code-oriented assertions - not
                              comment-oriented assertions) in the
                              file *after normalization*. If the `-c'
                              option is selected `fileinfo' prints
                              the file interface, the declarations
                              contained in the file, and the actual
                              code. If the `-e' option is selected
                              `fileinfo' prints only any sintactic
                              and import-export errors found in the
                              file, including the assertions.

                            * `filename' must be the name of a Prolog
                              or CIAO source file.

                            * This filename can be followed by other
                              arguments which will be taken to be
                              library directory paths in which to
                              look for files used by the file being
                              analyzed.

                            * If the `-m' option is selected, only
                              the information related to the current
                              module is printed.

                            * The `-v' option produces verbose
                              output. This is very useful for
                              debugging, since all the files accessed
                              during assertion normalization are
                              listed.

                            * In the `-asr' usage, `fileinfo' can be
                              used to print the contents of a `.asr'
                              file in human-readable form.


File: ciao.info,  Node: Printing the contents of a bytecode file,  Next: Gathering the dependent files for a file,  Prev: Printing the declarations and code in a file,  Up: Top

Printing the contents of a bytecode file
****************************************

                            *Author(s):* Daniel Cabeza.

                            *Version:* 0.5#2 (1999/11/11, 19:20:50
MET)

                            This simple program takes as an argument
a bytecode (.po) file and prints out in symbolic form the information
contained in the file. It uses compiler and engine builtins to do so,
so that it keeps track with changes in bytecode format.

                         * Menu:
                         
                         * Usage (viewpo)::


File: ciao.info,  Node: Usage (viewpo),  Prev: Printing the contents of a bytecode file,  Up: Printing the contents of a bytecode file

Usage (viewpo)
==============


                              	viewpo <file1>.po
                              	   : print .po contents in symbolic form
                              
                              	viewpo -h
                              	   : print this information


File: ciao.info,  Node: Gathering the dependent files for a file,  Next: Finding differences between two Prolog files,  Prev: Printing the contents of a bytecode file,  Up: Top

Gathering the dependent files for a file
****************************************

                            *Author(s):* Daniel Cabeza, Manuel
Hermenegildo.

                            *Version:* 1.0#6 (1998/11/5, 13:56:58 MET)

                            This simple program takes a single CIAO
or Prolog source filename (which is typically the main file of an
application). It prints out the list of all the dependent files,
i.e., all files needed in order to build the application, including
those which reside in libraries. This is particularly useful in
Makefiles, for building standalone distributions (e.g., .tar files)
automatically.

                            The filename should be followed by other
arguments which will be taken to be library directory paths in which
to look for files used by the file being analyzed.

                         * Menu:
                         
                         * Usage (get_deps)::


File: ciao.info,  Node: Usage (get_deps),  Prev: Gathering the dependent files for a file,  Up: Gathering the dependent files for a file

Usage (get_deps)
================


                              	get_deps [-u <filename>] <filename> [lib_dir1] ... [lib_dirN]
                                         : return dependent files for <filename>
                                           found in [lib_dir1] ... [lib_dirN]
                              
                              	get_deps -h
                                         : print this information


File: ciao.info,  Node: Finding differences between two Prolog files,  Next: The Ciao lpmake scripting facility,  Prev: Gathering the dependent files for a file,  Up: Top

Finding differences between two Prolog files
********************************************

                            *Author(s):* Francisco Bueno.

                            This simple program works like the good
old diff but for files that contain Prolog code. It prints out the
clauses that it finds are different in the files. Its use avoids
textual differences such as different variable names and different
formatting of the code in the files.

                         * Menu:
                         
                         * Usage (pldiff)::
                         * Known bugs and planned improvements (pldiff)::


File: ciao.info,  Node: Usage (pldiff),  Next: Known bugs and planned improvements (pldiff),  Prev: Finding differences between two Prolog files,  Up: Finding differences between two Prolog files

Usage (pldiff)
==============


                              	pldiff <file1> <file2>
                              	   : find differences
                              
                              	pldiff -h
                              	   : print this information

                            but you can also use the program as a
library and invoke the predicate:

                                 pldiff( <filename> , <filename> )


File: ciao.info,  Node: Known bugs and planned improvements (pldiff),  Prev: Usage (pldiff),  Up: Finding differences between two Prolog files

Known bugs and planned improvements (`pldiff')
==============================================

                            * Currently uses variant/2 to compare
                              clauses. This is useful, but there
                              should be an option to select the way
                              clauses are compared, e.g., some form
                              of equivalence defined by the user.


File: ciao.info,  Node: The Ciao lpmake scripting facility,  Next: Find out which architecture we are running on,  Prev: Finding differences between two Prolog files,  Up: Top

The Ciao lpmake scripting facility
**********************************

                            *Author(s):* Manuel Hermenegildo.

                            *Note:* `lpmake' and the `make' library
are still under active development, and they may change substantially
in future releases.

                            `lpmake' is a Ciao application which uses
the Ciao `make' library to implement a dependency-driven scripts in a
similar way to the Unix `make' facility.

                            The original purpose of the Unix `make'
utility was to determine automatically which pieces of a large
program needed to be recompiled, and issue the commands to recompile
them. In fact, `make' is often used for many other purposes: it can
be used to describe any task where some files must be updated
automatically from others whenever the others change.

                            To prepare to use `lpmake', you must
write a file (typically called `Makefile.pl') that describes the
relationships among files in your program or application, and states
the commands for updating each file. In a program, typically the
executable file is updated from object files, which are in turn made
by compiling source files.

                            Once a suitable makefile exists, each
time you change some source files, simply typing `lpmake' suffices to
perform all necessary recompilations. The `make' program uses the
makefile data base and the last modification times of the files to
decide which of the files need to be updated. For each of those
files, it issues the commands recorded in the data base.

                            `lpmake' executes commands in the
`Makefile.pl' to update one or more target *names*, where *name* is
typically a program, but can also be a file to be generated or even a
"virtual" target. If no `-l' or `-m' options are present, `lpmake'
will look for the makefile `Makefile.pl'.

                            `lpmake' updates a target if it depends
on prerequisite files that have been modified since the target was
last modified, or if the target does not exist.

                            You can provide command line arguments to
`lpmake' to control which files should be regenerated, or how.

                            *Note:* if you use `make' and
`functions', then `make' should appear before `functions' in the list
of packages.


File: ciao.info,  Node: Find out which architecture we are running on,  Next: *** PART XI - Appendices,  Prev: The Ciao lpmake scripting facility,  Up: Top

Find out which architecture we are running on
*********************************************

                            *Author(s):* Manuel Carro, Robert Manchek.

                            *Version:* 0.0 (1998/8/12, 19:53:41 MET
DST)

                            The architecure and operating system the
engine is compiled for determines whether we can use or not certain
libraries. This script, taken from a PVM distribution, uses a
heuristic (which may need to be tuned from time to time) to find out
the platform. It returns a string which is used throughout the engine
(in #ifdefs) to enable/disable certain characteristics.

                         * Menu:
                         
                         * Usage (ciao_get_arch)::
                         * More details::


File: ciao.info,  Node: Usage (ciao_get_arch),  Next: More details,  Prev: Find out which architecture we are running on,  Up: Find out which architecture we are running on

Usage (ciao_get_arch)
=====================

                                 Usage: ciao_get_arch


File: ciao.info,  Node: More details,  Prev: Usage (ciao_get_arch),  Up: Find out which architecture we are running on

More details
============

                            Look at the script itself...


File: ciao.info,  Node: *** PART XI - Appendices,  Next: Installing Ciao,  Prev: Find out which architecture we are running on,  Up: Top

PART XI - Appendices
********************

                            The appendix included extensively
documents the installation of the Ciao environment.


File: ciao.info,  Node: Installing Ciao,  Next: References,  Prev: *** PART XI - Appendices,  Up: Top

Installing Ciao
***************

                            *Author(s):* Manuel Carro, Daniel Cabeza,
Manuel Hermenegildo.

                            *Version:* 1.3#120 (1999/11/26, 12:5:17
MET)

                            *Version of last change:* 1.3#117
(1999/11/25, 1:44:7 MET)

                            This describes the installation procedure
for the Ciao Prolog system, including libraries and manuals. Please
read *Note Un*x installation summary:: and *Note Un*x full
installation instructions:: for the installation procedures from
sources on Un*x (Linux, SunOS, Solaris, etc.) machines. Windows
NT/95/98 users are referred to *Note Installation and compilation
under Windows:: and *Note Windows installation from the precompiled
distribution::.

                            If you find any problems during
installation, please refer to *Note Troubleshooting (nasty messages
and nifty workarounds)::.  See also *Note Downloading new versions::
and *Note Reporting bugs::.

                         * Menu:
                         
                         * Un*x installation summary::
                         * Un*x full installation instructions::
                         * Installation and compilation under Windows::
                         * Windows installation from the precompiled distribution::
                         * Windows installation from the standard source distribution::
                         * Checking for correct installation::
                         * Cleaning up the source directory::
                         * Environment variables used by Ciao executables::
                         * Multiarchitecture support::
                         * Architecture specific notes and limitations::
                         * Downloading new versions::
                         * Keeping up to date: the Ciao users mailing list::
                         * Reporting bugs::
                         * Porting to currently unsupported operating systems::
                         * Troubleshooting (nasty messages and nifty workarounds)::


File: ciao.info,  Node: Un*x installation summary,  Next: Un*x full installation instructions,  Prev: Installing Ciao,  Up: Installing Ciao

Un*x installation summary
=========================

                            *Note:* it is recommended that you read
the full installation instructions (specially if the installation
will be shared by different architectures). However, in many cases it
suffices to follow this summary:

                           1. Uncompress and unpackage (using
                              `gunzip' and `tar -xpf') the
                              distribution. This will put everyting
                              in a new directory whose name reflects
                              the Ciao version.

                           2. Enter the newly created directory
                              (`SRC'). Edit `SETTINGS' and check/set
                              the variables `SRC', `BINROOT' (where
                              the executables will go), `LIBROOT'
                              (where the libraries will go), and
                              `DOCROOT' (where the documentation will
                              go, preferably a directory *accessible
                              via* WWW).

                           3. Type `gmake install'. This will build
                              executables, compile libraries, and
                              install everything in a directory
                              `LIBROOT/ciao' and in `BINROOT'.

                              Note that `gmake' refers to the GNU
                              implementation of the make Un*x
                              command, which is available in many
                              systems (including all Linux systems)
                              simply as `make'. I.e., you can try
                              simply typing `make install' if `gmake
                              install' does not work. If typing
                              `make' stops right away with error
                              messages it is probably an older
                              version and you need to install `gmake'.

                           4. Make the following modifications in
                              your startup scripts. If you are
                              installing Ciao globally in a
                              multi-user machine, make sure that you
                              instruct all users to do the same. This
                              will make the documentation accessible,
                              set the correct mode when opening Ciao
                              source files in `emacs', etc.
                              (<LIBROOT> must be replaced by the
                              appropriate value):

                                 * For users a *csh-compatible shell*
                                   ( `csh', `tcsh', ...), add to
                                   `~/.cshrc':

                                                if ( -e <LIBROOT>/ciao/DOTcshrc ) then
                                                   source <LIBROOT>/ciao/DOTcshrc
                                                endif

                                 * For users of an *sh-compatible
                                   shell* ( `sh', `bash', ...), add to
                                   `~/.profile':

                                                if [ -f <LIBROOT>/ciao/DOTprofile ]; then
                                                   . <LIBROOT>/ciao/DOTprofile
                                                fi

                                   This will set up things so that
                                   the Ciao executables are found and
                                   you can access the Ciao system
                                   manuals using the `info' command.

                                 * Also, if you use `emacs' (highly
                                   recommended) add this line to your
                                   `~/.emacs' file:

                                                (load-file "<LIBROOT>/ciao/DOTemacs")

                              If you are the system administrator,
                              the previous steps can be done once and
                              for all, and globally for all users by
                              including the lines above in the
                              central startup scripts (e.g., in Linux
                              `/etc/cshrc'/ `/etc/csh.cshrc',
                              `/etc/bashrc',


                              `/usr/share/emacs/.../lisp/site-init.pl',
                              etc.).

                           5. Downloading the emacs editor, if it is
                              not available in the system, is highly
                              recommended (see *Note Un*x full
                              installation instructions::).

                           6. You may want to read now *Note Checking
                              for correct installation:: and the
                              documentation, which is stored in
                              `DOCROOT' (copied from
                              `SRC/doc/reference') and can be easily
                              accessed as explained in that same
                              section.

                           7. If you have any problems you may want
                              to check the rest of the instructions.
                              The system can be *uninstalled* by
                              typing `gmake uninstall'.



File: ciao.info,  Node: Un*x full installation instructions,  Next: Installation and compilation under Windows,  Prev: Un*x installation summary,  Up: Installing Ciao

Un*x full installation instructions
===================================

                           1. *Uncompress and unpackage:* (using
                              `gunzip' and `tar -xpf') the
                              distribution in a suitable directory.
                              This will create a new directory called
                              `ciao-X.Y', where `X.Y' is the version
                              number of the distribution. The `-p'
                              option in the `tar' command ensures
                              that the relative dates of the files in
                              the package are preserved, which is
                              needed for correct operation of the
                              Makefiles.

                           2. *Select Installation Options:* Edit the
                              file `SETTINGS' and set the following
                              variables:

                                 * `SRC': directory where the sources
                                   are stored.

                                 * `BINROOT': directory where the
                                   Ciao executables will go. For
                                   example, if
                                   `BINROOT=/usr/local/bin', then the
                                   Ciao compiler ( `ciaoc') will be
                                   stored at `/usr/local/bin/ciaoc'
                                   (actually, it will be a link to
                                   `ciaoc-'*VersionNumber* -this
                                   applies also to other executables
                                   below and is done so that several
                                   versions can coexist).

                                 * `LIBROOT': directory where the
                                   run-time libraries will be
                                   installed.  The Ciao installation
                                   procedure will create a new
                                   subdirectory `ciao' below
                                   `LIBROOT' and a subdirectory below
                                   this one for each Ciao version
                                   installed. For example, if
                                   `LIBROOT=/usr/local/lib' and you
                                   have Ciao version `x.y', then the
                                   libraries will be installed under
                                   `/usr/local/lib/ciao/ciao-x.y'.
                                   This allows you to install
                                   site-specific programs under
                                   `/usr/local/lib/ciao' and they
                                   will not be overwritten if a new
                                   version of Ciao is installed. It
                                   also allows having several Ciao
                                   versions installed simultaneously
                                   (the *last one installed* will be
                                   used by default when typing
                                   `ciao').

                                 * `DOCROOT': directory where the
                                   manuals will be installed. It is
                                   often convenient of this directory
                                   is accessible via WWW
                                   (`DOCROOT=/home/httpd/html/ciao',
                                   or something like that).

                              For network-based installations, it is
                              of *utmost importance* that the paths
                              given be reachable in all the networked
                              machines. Different machines with
                              different architectures can share the
                              same physical `SRC' directory during
                              installation, since compilations for
                              different architectures take place in
                              dedicated subdirectories. Also,
                              different machines/architectures can
                              share the same `LIBROOT' directory.
                              This saves space since the architecture
                              independent libraries will be shared.
                              See *Note Multiarchitecture support::
                              below.

                           3. *Compile Ciao:* At the ciao top level
                              directory type `gmake all'.

                              *Important:* use GNU make ( `gmake'),
                              not the standard UNIX make, as the
                              latter does not support some features
                              used during the compilation. It does
                              not matter if the name of the
                              executable is `make' or `gmake': only
                              make sure that it is GNU make.

                              This will:

                                 * Build an engine in
                                   `$(SRC)/bin/$(CIAOARCH)', where
                                   `$(CIAOARCH)' depends on the
                                   architecture. The engine is the
                                   actual interpreter of the low
                                   level code into which Ciao Prolog
                                   programs are compiled.

                                 * Build a new Ciao standalone
                                   compiler ( `ciaoc'), with the
                                   default paths set for your local
                                   configuration (nonetheless, these
                                   can be overridden by environment
                                   variables, as described below).

                                 * Precompile all the libraries under
                                   `$(SRC)/lib' and `$(SRC)/library'
                                   using this compiler.

                                 * Compile a toplevel Prolog shell
                                   and a shell for Prolog scripts,
                                   under the `$(SRC)/shell' directory.

                                 * Compile some small, auxiliary
                                   applications (contained in the
                                   `etc' directory, and documented in
                                   the part of the manual on
                                   'Miscellaneous Standalone
                                   Utilities').

                              This step can be repeated successively
                              for several architectures in the same
                              source directory. Only the engine and
                              some small parts of the libraries
                              (those written in C) differ from one
                              architecture to the other. Standard
                              Ciao Prolog code compiles into bytecode
                              object files (`.po') and/or executables
                              which are portable among machines of
                              different architecture, provided there
                              is an executable engine accessible in
                              every such machine. See more details
                              below under *Note Multiarchitecture
                              support::.

                           4. *Check compilation:* If the above steps
                              have been satisfactorily finished, the
                              compiler has compiled itself and all
                              the distribution modules, and very
                              probably everything is fine. To further
                              check this before final installation
                              you can type `gmake test', which will
                              compile and execute a small program
                              containing several tests.

                           5. *Install Ciao:* To install Ciao in the
                              directories selected in the file
                              `SETTINGS' during step 2 above, type
                              `gmake justinstall'. This will:

                                 * Install the executables of the Ciao
                                   program development tools (i.e.,
                                   the general driver/top-level
                                   `ciao', the standalone compiler
                                   `ciaoc', the script interpreter
                                   `ciao-shell', miscellaneous
                                   utilities, etc.) in `BINROOT' (see
                                   below). In order to use these
                                   tools, the `PATH' environment
                                   variable of users needs to contain
                                   the path `BINROOT'.

                                 * Install the Ciao libraries under
                                   `LIBROOT/ciao' (these will be
                                   automatically found).

                                 * Install under `DOCROOT' the Ciao
                                   manuals in several formats (such
                                   as GNU `info', `html',
                                   `postscript', etc.), depending on
                                   the distribution. In order for
                                   these manuals to be found when
                                   typing `M-x info' within `emacs',
                                   or by the standalone `info' and
                                   `man' commands, the `MANPATH' and
                                   `INFOPATH' environment variables
                                   of users both need to contain the
                                   path `DOCROOT'.

                                 * Install under `LIBROOT/ciao' the
                                   Ciao GNU `emacs' interface (
                                   `ciao.el', which provides an
                                   interactive interface to the Ciao
                                   program development tools, as well
                                   as some other auxiliary files) and
                                   a file `DOTemacs' containing the
                                   `emacs' initialization commands
                                   which are needed in order to use
                                   the Ciao `emacs' interface.

                           6. *Set up user environments:* In order to
                              automate the process of setting the
                              variables above, the installation
                              process leaves the files
                              `LIBROOT/ciao/DOTcshrc' (for `csh'-like
                              shells), `LIBROOT/ciao/DOTprofile' (for
                              `sh'-like shells), and
                              `LIBROOT/ciao/DOTemacs' (for emacs)
                              with appropriate definitions which will
                              take care of all needed environment
                              variable definitions and emacs mode
                              setup. Thus, if you are installing in a
                              multi-user machine, make sure that you
                              instruct all users to make the
                              following modifications in their
                              startup scripts or that you follow
                              these instructions yourself if you are
                              installing Ciao only for your personal
                              use (<LIBROOT> must be replaced by the
                              appropriate value):

                                 * For users a *csh-compatible shell*
                                   ( `csh', `tcsh', ...), add to
                                   `~/.cshrc':

                                                if ( -e <LIBROOT>/ciao/DOTcshrc ) then
                                                   source <LIBROOT>/ciao/DOTcshrc
                                                endif

                                 * For users of an *sh-compatible
                                   shell* ( `sh', `bash', ...), add to
                                   `~/.profile':

                                                if [ -f <LIBROOT>/ciao/DOTprofile ]; then
                                                   . <LIBROOT>/ciao/DOTprofile
                                                fi

                                   This will set up things so that
                                   the Ciao executables are found and
                                   you can access the Ciao system
                                   manuals using the `info' command.

                                 * Also, if you use `emacs' (highly
                                   recommended) add this line to your
                                   `~/.emacs' file:

                                                (load-file "<LIBROOT>/ciao/DOTemacs")

                              If you are the system administrator,
                              the previous steps can be done once and
                              for all, and globally for all users by
                              including the lines above in the
                              central startup scripts (e.g., in Linux
                              `/etc/cshrc'/ `/etc/csh.cshrc',
                              `/etc/bashrc',


                              `/usr/share/emacs/.../lisp/site-init.pl',
                              etc.).

                           7. *Download and install Emacs
                              (optional):* If the `emacs' editor is
                              not available in your system, its
                              installation is highly recommended (if
                              you are installing in a multi-user
                              machine, you may want to do it in a
                              general area so that it is available
                              for other users, even if you do not use
                              it yourself).

                              The emacs editor (in all its versions:
                              Un*x, Windows, etc.) can be donloaded
                              from, for example,
                              `http://www.emacs.org/', and also from
                              the many GNU mirror sites worldwide
                              (See `http://www.gnu.org/' for a list),
                              in the `gnu/emacs' and
                              `gnu/windows/emacs' directories. For
                              example, at UPM it can be found at





                              `ftp://ftp.fi.upm.es/pub/mirrors/gnu/emacs'
                              and






















                              `ftp://ftp.fi.upm.es/pub/mirrors/gnu/windows/emacs'.
                              You can find answers to frequently
                              asked question about `emacs' in general
                              at



















                              `http://www.gnu.org/software/emacs/emacs-faq.text'
                              and about the Windows version at































                              `http://www.gnu.org/software/emacs/windows/ntemacs.html'.

                           8. *Check installation:* You may want to
                              read now *Note Checking for correct
                              installation:: and the documentation,
                              which is stored in `DOCROOT' (copied
                              from `SRC/doc/reference') and can be
                              easily accessed as explained that same
                              section.


                            Other useful `make' targets are listed at
the beginning of `$(SRC)/Makefile'.

                            If you have any problems you may want to
check *Note Troubleshooting (nasty messages and nifty workarounds)::.

                            The system can be *uninstalled* by typing
`gmake uninstall' in the top directory (the variables in `SETTINGS'
should have the same value as when the install was performed, so that
the same directories are cleaned).


File: ciao.info,  Node: Installation and compilation under Windows,  Next: Windows installation from the precompiled distribution,  Prev: Un*x full installation instructions,  Up: Installing Ciao

Installation and compilation under Windows
==========================================

                            There are two possibilities in order to
install Ciao Prolog on Windows NT/95/98 machines:

                            * Installing from the Windows
                              *precompiled* distribution. This is the
                              easiest since it requires no
                              compilation and is highly recommended.

                            * Installing the standard Ciao Prolog
                              (Un*x) system source distribution and
                              compiling it under Windows. This is
                              somewhat more complex and currently
                              requires the (freely available) Cygnus
                              Win32 development libraries.

                            The two procedures are described in the
following sections.


File: ciao.info,  Node: Windows installation from the precompiled distribution,  Next: Windows installation from the standard source distribution,  Prev: Installation and compilation under Windows,  Up: Installing Ciao

Windows installation from the precompiled distribution
======================================================

                            This describes the installation of Ciao
after downloading the Windows *precompiled* distribution. This is the
simplest Windows installation, since it requires no compilation and
is highly recommended.

                         * Menu:
                         
                         * Installation of the precompiled distribution::
                         * Getting started after Windows installation::
                         * Starting executables from the Windows command line::
                         * Using the emacs environment under Windows::
                         * Compiling the miscellaneous utilities under Windows::
                         * Server installation under Windows::
                         * Uninstallation under Windows::


File: ciao.info,  Node: Installation of the precompiled distribution,  Next: Getting started after Windows installation,  Prev: Windows installation from the precompiled distribution,  Up: Windows installation from the precompiled distribution

Installation of the precompiled distribution
--------------------------------------------

                            Please follow these steps (below we use
the terms *folder* and *directory* interchangeably):

                           1. Download the precompiled distribution
                              and unpack it into any suitable folder,
                              such as, e.g., `C:\Program Files' (this
                              will create there a folder whose name
                              reflects the Ciao version). Due to
                              limitations of Windows related to file
                              associations, do not put Ciao too deep
                              in the folder hierarchy. For unpacking
                              you will need a recent version of a zip
                              archive manager - there are many freely
                              available such as `WinZip', `unzip',
                              `pkunzip', etc.). If you have a
                              previous version of Ciao installed,
                              make sure you do not have any Ciao
                              applications (including, e.g., a
                              toplevel shell) running, or the
                              extraction process may not be able to
                              complete. You may want to delete the
                              entire folder of the previous
                              installation to save space.

                           2. Run (e.g. by double-clicking on it) the
                              `install'(`.bat') script. This will
                              update the windows registry (the file
                              `ciao.reg' lists the additions) and
                              also create some `.bat' files for
                              running Ciao executables from the
                              command line. It also creates
                              initialization scripts for the `emacs'
                              editor. After that, you may need to
                              reboot for the changes in the registry
                              to take effect.

                           3. You may want to add a *windows shortcut*
                              in a convenient place, such as the
                              desktop, to `ciaosh.cpx', the standard
                              interactive toplevel shell. It is
                              located inside the `shell' folder
                              (e.g., click on the file `ciaosh.cpx'
                              with the right mouse button and select
                              the appropriate option, `Send
                              to->Desktop as shortcut').

                           4. You may also want to add another
                              shortcut to the file `ciao.html'
                              located inside
                              `doc\reference\ciao_html' so that you
                              can open the Ciao manual by simply
                              double-clicking on this shortcut.



File: ciao.info,  Node: Getting started after Windows installation,  Next: Starting executables from the Windows command line,  Prev: Installation of the precompiled distribution,  Up: Windows installation from the precompiled distribution

Getting started after Windows installation
------------------------------------------

                            The actions and registry changes
performed by the installation procedure, in addition to setting icons
for ciao-related file types, make several other things possible:

                            * Double-clicking on the shortcut made
                              above to `ciao.html' should show the
                              Ciao manual in your default WWW
                              browser. Make sure you configure your
                              browser to use *style sheets* for
                              correct formatting of the manual (note,
                              however, some older versions of
                              Explorer did not support style sheets
                              well and will give better results
                              turning them off). The `doc\reference'
                              folder contains the manual also in the
                              other formats present in the
                              distribution, such as `info' (very
                              convenient for users of the `emacs'
                              editor/program development system) and
                              `postscript' or `pdf', which are
                              specially useful for printing, using an
                              application such as `ghostview' (freely
                              available from




                              `http://www.cs.wisc.edu/~ghost/index.html')
                              or `acrobat reader'
                              (`http://www.adobe.com') respectively.

                            * It is possible to run any Ciao
                              executable (ending in `.cpx') by
                              double-clicking on it. For example, you
                              can try starting this way `ciaosh.cpx',
                              from inside the shell folder or from
                              the shortcut created above.

                            * Once the shell is started, you can load
                              and execute Prolog modules inside the
                              interactive toplevel shell in the
                              standard way (e.g., type
                              `use_module(*file*).',
                              `use_module(library(*file*)).' for
                              library modules,
                              `ensure_loaded(*file*).' for files
                              which are not modules, and
                              `use_package(*file*).' for library
                              packages).

                              For example, you may want to type
                              `use_package(iso)' to ensure Ciao has
                              loaded all the iso builtins (whether
                              this is done by default or not depends
                              on your `.ciaorc' file). Do not worry
                              about any 'module already in
                              executable' messages -these are normal
                              and simply mean that a certain module
                              is already pre-loaded in the toplevel
                              shell. At this point, typing
                              `write(hello).' should work.

                            * To change the working directory to,
                              say, the `tests' directory, first do:

                                       ?- use_module(library(system)).

                              (loading the `system' library makes a
                              number of system-related predicates
                              such as `cd/1' accessible) and then:

                                       ?- cd('$/tests').

                              (in Ciao the sequence `$/' *at the
                              beginning of a path name* is replaced
                              by the path of the Ciao root directory).

                            * Executables can be generated from the
                              toplevel shell (using `make_exec/2') or
                              using the standalone compiler (
                              `ciaoc.cpx', located in the `ciaoc'
                              folder). To be able to make an
                              executable, the file should define the
                              predicate `main/1' (or `main/0'), which
                              will be called upon startup (see the
                              corresponding manual section for
                              details).

                              For example, within the `tests'
                              directory, you can type:

                                       ?- make_exec(hw,_).

                              which should produce an executable.
                              Double-clicking on this executable
                              should execute it.

                            * The Ciao toplevel can be made to
                              execute upon startup a number of
                              commands (such as, e.g., loading
                              certain files or setting certain Prolog
                              flags) contained in an initialization
                              file. This file should be called
                              `.ciaorc' and placed in your *home*
                              folder (e.g., the same in which you put
                              your `.emacs' file). You need to set
                              the environment variable `HOME' to the
                              path of this folder for the Ciao
                              toplevel shell to be able to locate
                              this file on startup.

                            * To exit the top level shell, type
                              `halt.' as usual, or <^Z>.

                            * Another way of creating Ciao
                              executables from source files is by
                              right-clicking on `.pl' files and
                              choosing "make executable". This also
                              uses the standalone compiler.

                            * Double-clicking on files ending in
                              `.pls', "ciao prolog scripts", will
                              also execute them. These are files
                              containing Prolog source but which get
                              executed without having to explicitly
                              compile them (in the same way as, e.g.,
                              `.bat' files). As an example, you can
                              double click on the file `hw.pls' in the
                              `tests' folder and look at the source
                              with an editor. You can try changing
                              the `Hello world' message and
                              double-clicking again.

                              As you can see, the file should define
                              the predicate `main/1', which will be
                              called upon startup. The two header
                              lines are only necessary in Un*x. You
                              can leave them in in Windows (so that
                              the script will work also in Un*x
                              without any change) or you can take
                              them out. These two lines can be added
                              automatically in `emacs' from the
                              Ciao/Prolog menu or by typing <^C> <I>
                              <S>.


File: ciao.info,  Node: Starting executables from the Windows command line,  Next: Using the emacs environment under Windows,  Prev: Getting started after Windows installation,  Up: Windows installation from the precompiled distribution

Starting executables from the Windows command line
--------------------------------------------------

                            The installation script also creates a
`.bat' skeleton file (`bat_skel' in folder Win32) which allows
running Ciao executables from the command line. If you want to run a
Ciao executable `file.cpx' from the command line, you normally copy
the skeleton file to the folder were the executable is and rename it
to file.bat, then change its contents as explained in a comment
inside. Note that this `.bat' file is usually not necessary in NT, as
its command shell understands file extension associations, i.e., in
windows NT it is possible to run the `file.cpx' executable directly.
Due to limitations of `.bat' files in Windows 95/98, in those OSs no
more than 9 command line arguments can be passed to the executable
(in NT there is no such restriction).

                            The installation script creates also
`ciaosh.bat' and `ciaoc.bat' files (in the `shell' and `ciaoc'
folders respectively). These allow calling the interactive top-level
and the standalone compiler from the command line in Windows95/98.


File: ciao.info,  Node: Using the emacs environment under Windows,  Next: Compiling the miscellaneous utilities under Windows,  Prev: Starting executables from the Windows command line,  Up: Windows installation from the precompiled distribution

Using the emacs environment under Windows
-----------------------------------------

                            While it is easy to use Ciao with any
editor of your choice, using it within the `emacs' editor/program
development system is highly recommended: Ciao includes an `emacs'
*mode* which greatly simplifies many program development tasks (see
*Note Using Ciao inside GNU emacs:: for details on the capabilities of
`ciao'/ `emacs' combination.

                            The emacs editor (in all its versions:
Un*x, Windows, etc.) can be donloaded from, for example,
`http://www.emacs.org/', and also from the many GNU mirror sites
worldwide (See `http://www.gnu.org/' for a list), in the `gnu/emacs'
and `gnu/windows/emacs' directories. For example, at UPM it can be
found at `ftp://ftp.fi.upm.es/pub/mirrors/gnu/emacs' and
`ftp://ftp.fi.upm.es/pub/mirrors/gnu/windows/emacs'. You can find
answers to frequently asked question about `emacs' in general at
`http://www.gnu.org/software/emacs/emacs-faq.text' and about the
Windows version at
`http://www.gnu.org/software/emacs/windows/ntemacs.html'.

                            In order to allow `emacs' to load the
Ciao mode automatically when editing and to access the documentation,
open using `emacs' (<^X><^F>)) the file `~/.emacs' (or, perhaps,
`c:/.emacs') and add the following line to it:

                                      (load-file "<CIAODIR>/DOTemacs.el")

                         where you should put in place of `<CIAODIR>'
the directory where you installed the Ciao distribution. After doing
this (and exiting and restarting `emacs') the following things should
work:

                            * When opening a Prolog file (with `.pl'
                              or `.pls' ending) the code should
                              appear highlighted according to syntax
                              (e.g., comments in red), and a
                              `Ciao/Prolog' menu should appear in the
                              menu bar on top of the `emacs' window.

                            * Accessing the Ciao manuals from the
                              `Ciao/Prolog' menu (or typing <^H> <i>)
                              should open a list of manuals in info
                              format in which the Ciao manual(s)
                              should appear.

                            * Loading the file using the
                              `Ciao/Prolog' menu (or typing <^C> <l>)
                              should start in another emacs buffer
                              the Ciao toplevel shell and load the
                              file. You should now be able to switch
                              the the toplevel shell and make queries
                              from within `emacs'.

                            * You can also, e.g., create executables
                              from the `Ciao/Prolog' menu. See *Note
                              Using Ciao inside GNU emacs:: for the
                              many other functionalities of this
                              environment.


File: ciao.info,  Node: Compiling the miscellaneous utilities under Windows,  Next: Server installation under Windows,  Prev: Using the emacs environment under Windows,  Up: Windows installation from the precompiled distribution

Compiling the miscellaneous utilities under Windows
---------------------------------------------------

                            The `etc' folder contains a number of
utilities, documented in the manual in *PART V - Miscellaneous
Standalone Utilities*. In the Win32 distribution these utilities are
not compiled by the installation process. You can create the
executable for each of them when needed by compiling the
corresponding `.pl' file.


File: ciao.info,  Node: Server installation under Windows,  Next: Uninstallation under Windows,  Prev: Compiling the miscellaneous utilities under Windows,  Up: Windows installation from the precompiled distribution

Server installation under Windows
---------------------------------

                            If you would like to install Ciao on a
server machine, used by several clients, the following steps are
recommended:

                            * Follow the standard installation
                              procedure on the server. All the
                              functionality specified in the previous
                              sections should then be available on
                              the server.

                            * Perform a *client installation* on each
                              client, by running (e.g., double-click
                              on it) the `client.bat' script. This
                              should update the registry of each
                              client.


File: ciao.info,  Node: Uninstallation under Windows,  Prev: Server installation under Windows,  Up: Windows installation from the precompiled distribution

Uninstallation under Windows
----------------------------

                            To uninstall Ciao under Windows, simply
delete the directory in which you put the Ciao distribution. If you
also want to delete the registry entries created by the Ciao
installation (not strictly needed) this must currently be done by
hand. The installation leaves a list of these entries in the file
`ciao.reg' to aid in this task. Also, all the register entries
contain the word *ciao*. Thus, to delete all Ciao entries, run the
application `regedit' (for example, by selecting `Run' from the
Windows `Start' menu), search (<^F>) for *ciao* in all registry
entries (i.e., select all of `Keys', `Values', and `Data' in the
`Edit->Find' dialog), and delete each matching key (click on the left
window to find the matching key for each entry found).


File: ciao.info,  Node: Windows installation from the standard source distribution,  Next: Checking for correct installation,  Prev: Windows installation from the precompiled distribution,  Up: Installing Ciao

Windows installation from the standard source distribution
==========================================================

                            In order to compile Ciao Prolog for Win32
environments you need to have the (public domain) *Cygnus Win32* and
development libraries installed in your system. Compilation should be
performed preferably under Windows NT.

                            * Thus, the first step, if Cygnus Win32
                              is not installed in your system, is to
                              download it (from, e.g.,
                              `http://www.cygnus.com/misc/gnu-win32')
                              and install it. The compilation process
                              also requires that the executables
                              `rm.exe', `sh.exe', and `uname.exe'
                              from the Cygnus distribution be copied
                              under `/bin' prior to starting the
                              process (if these executables are not
                              available under `/bin' the compilation
                              process will produce a number of errors
                              and eventually stop prematurely).

                            * Assuming all of the above is installed,
                              type `make allwin32'. This will compile
                              both the engine and the Prolog
                              libraries. In this process, system
                              libraries that are normally linked
                              dynamically under Un*x (i.e., those for
                              which `.so' dynamically loadable files
                              are generated) are linked statically
                              into the engine (this is done instead
                              of generating `.dll's because of a
                              limitation in the current version of
                              the Cygnus Win32 environment). No
                              actual installation is made at this
                              point, i.e., this process leaves things
                              in a similar state as if you had just
                              downloaded and uncompressed the
                              precompiled distribution. Thus, in
                              order to complete the installation you
                              should now:

                            * Follow the procedure outlined in the
                              first item of *Note Windows
                              installation from the precompiled
                              distribution:: above.

                            A further note regarding the executables
generated by the Ciao compiler and top-level: the same considerations
given in *Note Windows installation from the precompiled
distribution:: apply regarding `.bat' files, etc. However, in a
system in which Cygnus Win32 is installed these executables can also
be used in a very simple way. In fact, the executables can be run as
in Un*x by simply typing their name at the `bash' shell command line
without any associated `.bat' files. This only requires that the
`bash' shell which comes with Cygnus Win32 be installed and
accessible: simply, make sure that `/bin/sh.exe' exists.


File: ciao.info,  Node: Checking for correct installation,  Next: Cleaning up the source directory,  Prev: Windows installation from the standard source distribution,  Up: Installing Ciao

Checking for correct installation
=================================

                            If everything has gone well, several
applications and tools should be available to a normal user. The most
important ones are the following:

                            * Typing `ciao' (or `ciaosh') in Un*x or
                              double-clicking on the `ciaosh.cpx'
                              icon or its direct access in Windows)
                              should start the typical Prolog top
                              level (the sources are located in
                              `$(SRC)/shell'). Typing, e.g.,
                              `use_module(library(dec10_io)).' at the
                              top level prompt should show a message
                              correctly loading this library from the
                              library directories. Note that some
                              predicates that are built-ins in other
                              Prolog are available through libraries
                              in Ciao. This facilitates making small
                              executables.

                            * Typing `ciaoc' in Un*x (or
                              double-clicking on the `ciaoc.cpx' icon
                              in Windows) should produce the help
                              message from the Ciao standalone
                              compiler (note that programs can also
                              be compiled from the shell). In its
                              simplest use, given a top-level
                              *foo*`.pl' file for an application (the
                              file must define the a predicate
                              `main/0' or `main/1') it compiles an
                              executable `foo', automatically
                              detecting which other files need
                              recompilation.

                            * Typing `ciao-shell' should produce a
                              message saying that no code was found.
                              This is a Ciao application which can be
                              used to write scripts written in
                              Prolog, i.e., files which do not need
                              any explicit compilation to be run. In
                              Windows these scripts execute by simply
                              double-clicking on them.

                            Also, the following documentation-related
actions should work:

                            * If the `info' program is installed,
                              starting `info' should produce a list
                              of manuals which should include Ciao
                              manual(s) in a separate section (you
                              may need to log out and back in so that
                              your shell variables are reinitialized).

                            * If `emacs' is installed, typing `M-x
                              info' should have the same result as
                              above (you may also need to log out and
                              back in for this).

                            * Opening with a WWW browser (e.g.,
                              `netscape') the directory name or `URL'
                              corresponding to `DOCROOT' should show
                              a series of Ciao-related manuals.

                            * In Un*x, typing `man ciao' should
                              produce a man page with general
                              information on Ciao.


File: ciao.info,  Node: Cleaning up the source directory,  Next: Environment variables used by Ciao executables,  Prev: Checking for correct installation,  Up: Installing Ciao

Cleaning up the source directory
================================

                            After installation, the source directory
can be cleaned up in several ways:

                            * `gmake uninstall' removes the
                              installation but does not touch the
                              source directories.

                            * `gmake totalclean' leaves the
                              distribution is its original form,
                              throwing away any intermediate files
                              (as well as any unneeded files left
                              behind by the Ciao developers), while
                              still allowing recompilation.

                            Other useful `make' targets are listed at
the beginning of `$(SRC)/Makefile'.


File: ciao.info,  Node: Environment variables used by Ciao executables,  Next: Multiarchitecture support,  Prev: Cleaning up the source directory,  Up: Installing Ciao

Environment variables used by Ciao executables
==============================================

                            The executables generated by the Ciao
compiler (including the ciao development tools themselves) locate
automatically where the Ciao engine and libraries have been
installed, since those paths are stored as defaults in the engine and
compiler at installation time. Thus, there is no need for setting any
environment variables in order to *run* Ciao executables (on a single
architecture - see *Note Multiarchitecture support:: for running on
multiple architectures).

                            However, the default paths can be
overridden by using the environment variables `CIAOENGINE' and
`CIAOLIB'. The first one will tell the Ciao executables where to look
for an engine, and the second will tell them where to look for the
libraries. Thus, it is possible to actually use the Ciao system
without installing it by setting these variables to the following
values:
                            * `CIAOENGINE':
                              `$(SRC)/bin/$(CIAOARCH)/ciaoengine'

                            * `CIAOLIB': `$(SRC)'

                            where `$(CIAOARCH)' is the string echoed
by the command `SRC/etc/ciao_get_arch' (or `BINROOT/ciao_get_arch',
after installation).

                            This allows using alternate engines or
libraries, which can be very useful for system development and
experimentation.


File: ciao.info,  Node: Multiarchitecture support,  Next: Architecture specific notes and limitations,  Prev: Environment variables used by Ciao executables,  Up: Installing Ciao

Multiarchitecture support
=========================

                            As mentioned before, Ciao applications
(including the compiler and the top level) can run on several
machines with different architectures without any need for
recompiling, provided there is one Ciao engine (compiled for the
corresponding architecture) accessible in each machine. Also, the
Ciao libraries (installed in `LIBROOT', which contain also the
engines) and the actual binaries (installed in `BINROOT') can
themselves be shared on several machines with different
architectures, saving disk space.

                            For example, assume that the compiler is
installed as:

                            `/usr/local/share/bin/ciaoc'

                            and the libraries are installed under

                            `/usr/local/share/lib'

                            Assume also that the `/usr/local/share'
directory is mounted on, say, a number of Linux and a number of
Solaris boxes. In order for `ciaoc' to run correctly on both
machines, the following is needed:

                           1. Make sure you that have done `gmake
                              install' on one machine of each
                              architecture (once for Linux and once
                              for Solaris in our example). This
                              recompiles and installs a new engine
                              and any architecture-dependent parts of
                              the libraries for each architecture.
                              The engines will have names such as
                              `ciaoengine.LINUXi86',
                              `ciaoengine.SolarisSparc', and so on.

                           2. In multi-architecture environments it
                              is even more important to make sure
                              that users make the modifications to
                              their startup scripts using
                              `<LIBROOT>/ciao/DOTcshrc' etc. The
                              selection of the engine (and
                              architecture-dependent parts of
                              libraries) is done in these scripts by
                              setting the environment variable
                              `CIAOARCH', using the `ciao_get_arch'
                              command, which is installed
                              automatically when installing Ciao.
                              This will set `CIAOARCH' to, say,
                              `LINUXi86', `SolarisSparc',
                              respectively, and `CIAOENGINE' will be
                              set to `ciaoengine.'*CIAOARCH*.

                              However, note that this is not strictly
                              necessary if running on only one
                              architecture: if `CIAOARCH' is not set
                              (i.e., undefined), the Ciao executables
                              will look simply for `ciaoengine',
                              which is always a link to the latest
                              engine installed in the libraries. But
                              including the initialization files
                              provided has the advantage of setting
                              also paths for the manuals, etc.



File: ciao.info,  Node: Architecture specific notes and limitations,  Next: Downloading new versions,  Prev: Multiarchitecture support,  Up: Installing Ciao

Architecture specific notes and limitations
===========================================

                            Ciao makes use of advanced
characteristics of modern architectures and operating systems such as
multithreading, shared memory, sockets, locks, dynamic load
libraries, etc., some of which which are sometimes not present in a
given system and others may be implemented in very different ways
across the different systems. As a result, currently not all Ciao
features are available in all supported operating systems. Sometimes
this is because not all the required features are present in all the
OS flavors supported and sometimes because we simply have not had the
time to port them yet.

                            The current state of matters is as
follows:

                        LINUX:
                              multithreading, shared DB access, and
                              locking working.

                        Solaris:
                              multithreading, shared DB access, and
                              locking working.

                        SunOS 4:
                              multithreading, shared DB access, and
                              locking NOT working.

                        Win 95/NT:
                              multithreading, shared DB access,
                              locking, and dynamic linking of object
                              code (C) libraries NOT working.

                            The features that do not work are
disabled at compile time. If problems appear, please disable them
explicitly in the `SETTINGS' file. We will make this more automatic
sometime in the future.


File: ciao.info,  Node: Downloading new versions,  Next: Keeping up to date: the Ciao users mailing list,  Prev: Architecture specific notes and limitations,  Up: Installing Ciao

Downloading new versions
========================

                            Ciao and its related libraries and
utilities are under constant improvement, so you should make sure
that you have the latest versions of the different components, which
can be dowloaded from:

                            `http://clip.dia.fi.upm.es/Software'


File: ciao.info,  Node: Keeping up to date: the Ciao users mailing list,  Next: Reporting bugs,  Prev: Downloading new versions,  Up: Installing Ciao

Keeping up to date: the Ciao users mailing list
===============================================

                            We recommend that you join the Ciao
*users mailing list* (`ciao-users@clip.dia.fi.upm.es'), in order to
receive information on new versions and solutions to problems. Simply
send a message to <ciao-users-request@clip.dia.fi.upm.es>, containing
in the body only the word:

                            `subscribe'

                            alone in one line. Messages in the list
are strictly limited to issues directly related to Ciao Prolog and
your email address will of course be kept strictly confidential. You
mail also want to subscribe to the `comp.lang.prolog' newsgroup.

                            There is additional info available on the
Ciao system, other CLIP group software, publications on the
technology underlying these systems, etc. in the CLIP group's WWW
site `http://clip.dia.fi.upm.es'.


File: ciao.info,  Node: Reporting bugs,  Next: Porting to currently unsupported operating systems,  Prev: Keeping up to date: the Ciao users mailing list,  Up: Installing Ciao

Reporting bugs
==============

                            If you still have problems after
downloading the latest version and reading the installation
instructions you can send a message to <ciao-bug@clip.dia.fi.upm.es>.
Please be as informative as possible in your messages, so that we can
reproduce the bug.

                            * For *installation problems* we
                              typically need to have the version and
                              patch number of the Ciao package (e.g.,
                              the name of the file downloaded), the
                              output produced by the installation
                              process (you can capture it by
                              redirecting the output into a file or
                              cutting and pasting with the mouse),
                              and the exact version of the Operating
                              System you are using (as well as the C
                              compiler, if you took a source
                              distribution).

                            * For *problems during use* we also need
                              the Ciao and OS versions and a small
                              example of code which we can run to
                              reproduce the bug.


File: ciao.info,  Node: Porting to currently unsupported operating systems,  Next: Troubleshooting (nasty messages and nifty workarounds),  Prev: Reporting bugs,  Up: Installing Ciao

Porting to currently unsupported operating systems
==================================================

                            If you would like to port Ciao to a
currently unsupported platform, there are several issues to take into
account. The main one is to get the *engine* to compile in that
platform, i.e., the C code under the `engine' directory. To this end,
look under the directory `$(SRC)/makefile-sysdep': there is a
`mkf-CIAOARCH' file for every architecture/OS under which Ciao is
known to compile. You can start from the closest one and customize it
for your local distribution or installed tools. But please keep the
original files! Once a working engine is achieved, it should be
possible to continue with the standard installation procedure, which
will try to use a completely static version of the standalone
compiler (`ciaoc.sta' in the `ciaoc' directory) to compile the
interactive top-level ( `ciaosh') and a new version of the standalone
compiler ( `ciaoc'). These in turn should be able to compile the
Prolog libraries. You may also need to look at some libraries (such
as, for example, `sockets') which contain C code. Porting to other
Un*x flavours should be easy while other operating system families
may require more work. If you do succeed in porting to a platform
that is currently please send the `mkf-CIAOARCH' and any patches to
<ciao@clip.dia.fi.upm.es>, and we will include it (with due credit,
of course) in the next distribution.


File: ciao.info,  Node: Troubleshooting (nasty messages and nifty workarounds),  Prev: Porting to currently unsupported operating systems,  Up: Installing Ciao

Troubleshooting (nasty messages and nifty workarounds)
======================================================

                            The following a list of common
installation problems reported by users:

                            * *Problem:*

                              During engine compilation, the
                              following message appears:

                              `tasks.c:102:PTHREAD_CANCEL_ASYNCHRONOUS
                              undeclared (first use of this
                              function)'.

                              *Possible reason and solution:*

                              Your (Linux?) system does not have
                              (yet) the Posix threads library
                              installed. You can upgrade to one which
                              does have it, or download the library
                              from



































                              `http://pauillac.inria.fr/~xleroy/linuxthreads/index.html'

                              and install it, or disable the use of
                              threads in Linux: for this, edit the
                              `SETTINGS' file and specify
                              `USE_THREADS=no', which will avoid
                              linking against thread libraries (it
                              will disable the use of thread-related
                              primitives as well). Clean the engine
                              with `make engclean' and restart
                              compilation.

                              If you have any alternative threads
                              library available, you can tinker with
                              `engine/threads.h' and the files under
                              `makefile-sysdep' in order to get the
                              task managing macros right for your
                              system. Be sure to link the right
                              library. If you succeed, we
                              (<ciao@clip.dia.fi.upm.es>) will be
                              happy of knowing about what you have
                              done.

                            * *Problem:*

                              `-lpthread: library not found' (or
                              similar)

                              *Possible reason and solution:*

                              Your (Linux?) system seems to have
                              Posix threads installed, but there is
                              no threads library in the system. In
                              newer releases (e.g., RedHat 5.0), the
                              Posix threads system calls have been
                              included in `glibc.so', so specifying
                              `-lpthread' in
                              `makefile-sysdep/mkf-LINUX' is not
                              needed; remove it. `make engclean' and
                              restart installation.

                              Alternatively, you may have made a
                              custom installation of Posix threads in
                              a non-standard location: be sure to
                              include the flag



                              `-L/this/is/where/the/posix/libraries/are'
                              *before* `-lpthread', and to update
                              `/etc/ld.so.conf' (see `man ldconfig').

                            * *Problem:*

                              `Segmentation Violation' (when starting
                              the first executable)

                              *Possible reason and solution:*

                              This has been observed with certain
                              older versions of `gcc' which generated
                              erroneous code under full optimization.
                              The best solution is to upgrade to a
                              newer version of `gcc'. Alternatively,
                              lowering the level of optimization (by
                              editing the `SETTINGS' file in the main
                              directory of the distribution) normally
                              solves the problem, at the cost of
                              reduced execution speed.

                            * *Problem:* `ciaoc:








                              /home/clip/lib/ciao/ciao-X.Y/engine/ciaoengine:
                              not found'

                              *Possible reason and solution:*

                                 * The system was not fully installed
                                   and the variable `CIAOENGINE' was
                                   not set.

                                 * The system was installed, the
                                   variable `CIAOENGINE' is set, but
                                   it is does not point to a valid
                                   ciaoengine.

                              See the file `LIBROOT/ciao/DOTcshrc'
                              for user settings for environment
                              variables.

                            * *Problem:*

                              `ERROR: File library(compiler) not
                              found - aborting...' (or any other
                              library is not found)

                              *Possible reason and solution:*

                                 * The system was not installed and
                                   the variable `CIAOLIB' was not set.

                                 * The system is installed and the
                                   variable `CIAOLIB' is wrong.

                              See the file `LIBROOT/ciao/DOTcshrc'
                              for user settings for environment
                              variables.

                            * *Problem:*

                              `ERROR: File
                              <some_directory>/<some_file>.itf not
                              found - aborting...'

                              *Possible reason and solution:*

                              Can appear when compiling `.pl' files.
                              The file to compile (<some_file>.pl) is
                              not in the directory <some_directory>.
                              You gave a wrong file name or you are
                              in the wrong directory.

                            * *Problem:*

                              `*ERROR*: /(write_option,1) is not a
                              regular type' (and similar ones)

                              *Possible reason and solution:*

                              This is not a problem, but rather the
                              type checker catching some minor
                              inconsistencies which may appear while
                              compiling the libraries. Bug us to
                              remove it, but ignore it for now.

                            * *Problem:*

                              `WARNING: Predicate
                              <some_predicate>/<N> undefined in
                              module <some_module>'

                              *Possible reason and solution:*

                              It can appear when the compiler is
                              compiling Ciao library modules. If so,
                              ignore it (we will fix it). If it
                              appears when compiling user programs or
                              modules, you may want to check your
                              program for those undefined predicates.

                            * *Problem:*

                              `gmake[1]: execve:










                              /home/clip/mcarro/ciao-0.7p2/etc/collect_modules:
                              No such file or directory'

                              *Possible reason and solution:*

                              Check if collect_modules is in
                              $(SRC)/etc and is executable. If it is
                              not here, your distribution is
                              incorrect: please let us know.

                            * *Problem:* `make: Fatal error in
                              reader: COMMON, line 12: Unexpected end
                              of line seen'

                              *Possible reason and solution:*

                              You are using standard Un*x make, not
                              GNU's make implementation (gmake).


File: ciao.info,  Node: References,  Next: Library/Module Definition Index,  Prev: Installing Ciao,  Up: Top

References
**********

                        *[AAF91]*
                              J. Almgren, S. Andersson, L. Flood, C.
                              Frisk, H. Nilsson, and J. Sundberg.
                              *Sicstus Prolog Library Manual*.
                              Po Box 1263, S-16313 Spanga, Sweden,
                              October 1991.

                        *[AKNL86]*
                              Hassan Ait-Kaci, Roger Nasr, and Pat
                              Lincoln.
                              E An Overview.
                              Technical Report AI-420-86-P,
                              Microelectronics and Computer Technology
                               Corporation, 9430 Research Boulevard,
                              Austin, TX 78759, December 1986.

                        *[BA82]*
                              M. Ben-Ari.
                              *Principles of Concurrent Programming*.
                              Prentice Hall International, 1982.

                        *[BBP81]*
                              D.L. Bowen, L. Byrd, L.M. Pereira,
                              F.C.N. Pereira, and D.H.D. Warren.
                              Decsystem-10 prolog user's manual.
                              Technical report, Department of
                              Artificial Intelligence, University of
                              Edinburgh, October 1981.

                        *[Byr80]*
                              L. Byrd.
                              Understanding the Control Flow of
                              Prolog Programs.
                              In S.-A. T\"arnlund, editor, *Workshop
                              on Logic Programming*,   Debrecen, 1980.

                        *[Car88]*
                              M. Carlsson.
                              *Sicstus Prolog User's Manual*.
                              Po Box 1263, S-16313 Spanga, Sweden,
                              February 1988.

                        *[CCG98]*
                              I. Caballero, D. Cabeza, S. Genaim,
                              J.M. Gomez, and M. Hermenegildo.
                              persdb\_sql: SQL Persistent Database
                              Interface.
                              Technical Report D3.1.M2-A2
                              CLIP10/98.0, RADIOWEB Project, December
                               1998.

                        *[CH97]*
                              D. Cabeza and M. Hermenegildo.
                              WWW Programming using Computational
                              Logic Systems (and the   PILLOW/CIAO
                              Library).
                              In *Proceedings of the Workshop on
                              Logic Programming and the WWW at
                              WWW6*, San Francisco, CA, April 1997.

                        *[CH99a]*
                              D. Cabeza and M. Hermenegildo.
                              A New Module System for Prolog.
                              In *ICLP'99 WS on Parallelism and
                              Implementation of (C)LP Systems*.
                              N.M. State U., December 1999.

                        *[CH99b]*
                              D. Cabeza and M. Hermenegildo.
                              The Ciao Modular Compiler and Its
                              Generic Program Processing   Library.
                              In *ICLP'99 WS on Parallelism and
                              Implementation of (C)LP Systems*.
                              N.M. State U., December 1999.

                        *[CHGT98]*
                              D. Cabeza, M. Hermenegildo, S. Genaim,
                              and C. Taboch.
                              Design of a Generic, Homogeneous
                              Interface to Relational   Databases.
                              Technical Report D3.1.M1-A1,
                              CLIP7/98.0, RADIOWEB Project, September
                               1998.

                        *[CHV96a]*
                              D. Cabeza, M. Hermenegildo, and S.
                              Varma.
                              The PiLLoW/CIAO Library for
                              INTERNET/WWW Programming using
                              Computational Logic Systems.
                              In *Proceedings of the 1st Workshop on
                              Logic Programming Tools for   INTERNET
                              Applications*, pages 72-90, JICSLP'96,
                              Bonn, September 1996.
                              Text and code available from
                              \htmladdnormallink\tt

















                              http://www.clip.dia.fi.upm.es/miscdocs/pillow/pillow.html



















                              http://www.clip.dia.fi.upm.es/miscdocs/pillow/pillow.html.

                        *[CHV96b]*
                              D. Cabeza, M. Hermenegildo, and S.
                              Varma.
                              The \sf P\em i\sf LL\em o\sf W/CIAO
                              Library for   INTERNET/WWW Programming
                              using Computational Logic Systems.
                              In *Proceedings of the 1st Workshop on
                              Logic Programming Tools for   INTERNET
                              Applications*, JICSLP'96, Bonn,
                              September 1996.
                              Available from \htmladdnormallink\tt
                              http://clement.info.umoncton.ca/\~lpnet

                              http://clement.info.umoncton.ca/\~lpnet.

                        *[Col78]*
                              A. Colmerauer.
                              Metamorphosis grammars.
                              In *Natural language communication with
                              computers*, pages 133-189.    Springer
                              LNCS 63, 1978.

                        *[DEDC96]*
                              P. Deransart, A. Ed-Dbali, and L.
                              Cervoni.
                              *Prolog: The Standard*.
                              Springer-Verlag, 1996.

                        *[Dij65]*
                              E.W. Dijkstra.
                              Co-operating sequential processes.
                              In F. Genuys, editor, *Programming
                              Languages*. Academic Press, London,
                              1965.

                        *[DL93]*
                              S.K. Debray and N.W. Lin.
                              Cost analysis of logic programs.
                              *ACM Transactions on Programming
                              Languages and Systems*,
                              15(5):826-875, November 1993.

                        *[DLH97]*
                              S.~K. Debray, P. L\'opez Garc\'\ia, and
                              M. Hermenegildo.
                              Non-Failure Analysis for Logic Programs.
                              In *1997 International Conference on
                              Logic Programming*, pages 48-62,
                              Cambridge, MA, June 1997. MIT Press,
                              Cambridge, MA.

                        *[DLHL97]*
                              S.~K. Debray, P. L\'opez-Garc\'\ia, M.
                              Hermenegildo, and N.-W. Lin.
                              Lower Bound Cost Estimation for Logic
                              Programs.
                              In *1997 International Logic
                              Programming Symposium*, pages 291-305.
                               MIT Press, Cambridge, MA, October
                              1997.

                        *[GCH98]*
                              J.M. Gomez, D. Cabeza, and M.
                              Hermenegildo.
                              WebDB: A Database WWW Interface.
                              Technical Report D3.1.M2-A3
                              CLIP11/98.0, RADIOWEB Project, December
                               1998.

                        *[GdW94]*
                              J.P. Gallagher and D.A. de Waal.
                              Fast and precise regular approximations
                              of logic programs.
                              In Pascal Van~Hentenryck, editor,
                              *Proc.~of the 11th International
                              Conference on Logic Programming*, pages
                              599-613. MIT Press, 1994.

                        *[GHD96]*
                              P.~L\'opez Garc\'\ia, M. Hermenegildo,
                              and S.~K. Debray.
                              A Methodology for Granularity Based
                              Control of Parallelism in   Logic
                              Programs.
                              *Journal of Symbolic Computation,
                              Special Issue on Parallel Symbolic
                              Computation*, 22:715-734, 1996.

                        *[Her96]*
                              M. Hermenegildo.
                              Writing "Shell Scripts" in SICStus
                              Prolog, April 1996.
                              Posting in \tt comp.lang.prolog.
                              Available from \htmladdnormallink\tt
                              http://www.clip.dia.fi.upm.es/
                              http://www.clip.dia.fi.upm.es/.

                        *[Her99a]*
                              M. Hermenegildo.
                              A Documentation Generator for Logic
                              Programming Systems.
                              Technical Report CLIP10/99.0, Facultad
                              de Inform\'atica, UPM,   September 1999.

                        *[Her99b]*
                              M. Hermenegildo.
                              A Documentation Generator for Logic
                              Programming Systems.
                              In *ICLP'99 Workshop on Logic
                              Programming Environments*. N.M. State
                              University, December 1999.

                        *[HG90]*
                              M. Hermenegildo and K. Greene.
                              \&-Prolog and its Performance:
                              Exploiting Independent
                              And-Parallelism.
                              In *1990 International Conference on
                              Logic Programming*, pages   253-268.
                              MIT Press, June 1990.

                        *[Hol90]*
                              C. Holzbaur.
                              *Specification of Constraint Based
                              Inference Mechanisms   through Extended
                              Unification*.
                              PhD thesis, University of Vienna, 1990.

                        *[Hol92]*
                              C. Holzbaur.
                              Metastructures vs. Attributed Variables
                              in the Context of   Extensible
                              Unification.
                              In *1992 International Symposium on
                              Programming Language Implementation
                              and Logic Programming*, pages 260-268.
                              LNCS631, Springer Verlag, August   1992.

                        *[Hol94]*
                              C. Holzbaur.
                              *SICStus 2.1/DMCAI Clp 2.1.1 User's
                              Manual*.
                              University of Vienna, 1994.

                        *[JL88]*
                              D. Jacobs and A. Langen.
                              Compilation of Logic Programs for
                              Restricted And-Parallelism.
                              In *European Symposium on Programming*,
                              pages 284-297, 1988.

                        *[Knu84]*
                              D. Knuth.
                              Literate programming.
                              *Computer Journal*, 27:97-111, 1984.

                        *[MH89]*
                              K. Muthukumar and M. Hermenegildo.
                              Determination of Variable Dependence
                              Information at Compile-Time   Through
                              Abstract Interpretation.
                              In *1989 North American Conference on
                              Logic Programming*, pages   166-189.
                              MIT Press, October 1989.

                        *[Par97]*
                              The RADIOWEB~Project Partners.
                              RADIOWEB EP25562: Automatic Generation
                              of Web Sites for the   Radio
                              Brodcasting Industry - Project
                              Description / Technical   Annex.
                              Technical Report, RADIOWEB Project,
                              July 1997.

                        *[PH99]*
                              G. Puebla and M. Hermenegildo.
                              Some Issues in Analysis and
                              Specialization of Modular   Ciao-Prolog
                              Programs.
                              In *ICLP'99 Workshop on Optimization
                              and Implementation of Declarative
                              Languages*. N.M. State U., Las Cruces,
                              NM, November 1999.

                        *[PW80]*
                              F.C.N. Pereira and D.H.D. Warren.
                              Definite clause grammars for language
                              analysis - a survey of the formalism
                              and a comparison with augmented
                              transition networks.
                              *Artificial Intelligence*, 13:231-278,
                              1980.

                        *[Swe95]*
                              Swedish Institute of Computer Science,
                              P.O. Box 1263, S-16313 Spanga, Sweden.
                              *Sicstus Prolog V3.0 User's Manual*,
                              1995.


File: ciao.info,  Node: Library/Module Definition Index,  Next: Predicate/Method Definition Index,  Prev: References,  Up: Top

Library/Module Definition Index
*******************************

* Menu:
                         
                         * actmods:                               actmods (library).
* aggregates:                            All solutions predicates.
* andprolog:                             Independent and-parallel execution.
* argnames:                              argnames (library).
* arithmetic:                            Arithmetic.
* assertions:                            The Ciao assertion package.
* assertions_props:                      Types and properties related to assertions.
* assrt_write:                           Pretty-printing assertions.
* atom2term:                             atom2term (library).
* atomic_basic:                          Basic predicates handling names of constants.
* attributes:                            Attributed variables.
* basic_props:                           Basic data types and properties.
* basiccontrol:                          Control constructs/predicates.
* basicmodes:                            Classical Prolog modes.
* bf:                                    Breadth-first execution.
* builtin_directives:                    Basic builtin directives.
* ciaosh:                                The interactive top-level shell.
* class:                                 Declaring classes and interfaces.
* class_error:                           Error reporting when compiling classes and interfaces.
* classic:                               Classic Prolog package.
* clpq:                                  Constraint programming over rationals.
* clpr:                                  Constraint programming over reals.
* conc_aggregates:                       conc_aggregates (library).
* concurrency:                           Concurrency/multithreading primitives.
* counters:                              counters (library).
* ctrlcclean:                            ctrlcclean (library).
* data_facts:                            Fast/concurrent update of facts.
* db_client:                             Low-level socket interface to SQL/ODBC databases.
* dcg:                                   Definite clause grammars.
* dcg_expansion:                         Definite clause grammars (expansion).
* debugger:                              Predicates controlling the interactive debugger.
* dec10_io:                              DEC-10 Prolog file IO.
* dict:                                  Dictionaries.
* dynamic:                               Dynamic predicates.
* dynclasses:                            Using classes from the CIAO toplevel shell.
* dynmods:                               dynmods (library).
* errhandle:                             errhandle (library).
* exceptions:                            Exception handling.
* expansion_tools:                       Code translation utilities.
* fastrw:                                fastrw (library).
* file_locks:                            file_locks (library).
* file_utils:                            file_utils (library).
* filenames:                             File name manipulation.
* foreign_compilation:                   Utilities for on-demand compilation of foreign files.
* foreign_interface:                     Foreign interface.
* format:                                Formatted output.
* functions:                             functions (library).
* global:                                global (library).
* html:                                  html (library).
* http:                                  http (library).
* idlists:                               Identity lists.
* io_aux:                                Message printing primitives.
* io_basic:                              Basic input/output.
* iso:                                   ISO-Prolog package.
* iso_byte_char:                         iso_byte_char (library).
* iso_incomplete:                        iso_incomplete (library).
* iso_misc:                              iso_misc (library).
* isomodes:                              ISO-Prolog modes.
* javart:                                Low-level Prolog to Java interface.
* javasock:                              Low-level Prolog to Java socket connection.
* jtopl:                                 Low-level Java to Prolog interface.
* libpaths:                              Customizing library paths and path aliases.
* librowser:                             The Ciao library browser.
* linda:                                 linda (library).
* lists:                                 List processing.
* loading_code:                          Directives for using code in other files.
* messages:                              Printing status and error messages.
* meta_props:                            Meta-properties.
* metaterms:                             Term manipulation.
* modules:                               The module system.
* native_props:                          Properties which are native to analyzers.
* numlists:                              Lists of numbers.
* objects:                               Using OCIAO objects.
* objects_error:                         Error reporting when using objects.
* objects_rt:                            Run time usage of objects.
* odd:                                   Miscellaneous predicates.
* old_database:                          Quintus-like internal database.
* operators:                             Standard operators.
* patterns:                              Pattern (regular expression) matching.
* persdbrt:                              Persistent predicate database.
* persdbrtsql:                           SQL persistent database interface.
* pillow:                                Connecting with the Web.
* pl2sql:                                Prolog to SQL translator.
* pretty_print:                          A simple pretty-printer for Ciao programs.
* prolog_flags:                          Changing system behaviour and various flags.
* prolog_sys:                            Prolog system internal predicates.
* pure:                                  Pure Prolog package.
* queues:                                queues (library).
* random:                                Random numbers.
* read:                                  Term input.
* regtypes:                              Declaring regular types.
* rtchecks:                              Run-time checking of assertions.
* runtime_ops:                           runtime_ops (library).
* sets:                                  sets (library).
* sockets:                               The socket interface.
* sort:                                  Sorting lists.
* streams:                               Structured stream handling.
* streams_basic:                         Basic file/stream handling.
* strings:                               String processing.
* syntax_extensions:                     Extending the syntax.
* system:                                Operating system utilities.
* system_info:                           Gathering some basic internal info.
* tcltk:                                 The tcl/tk interface.
* term_basic:                            Basic term manipulation.
* term_compare:                          Comparing terms.
* term_typing:                           Extra-logical properties for typing.
* terms:                                 terms (library).
* tokenize:                              tokenize (library).
* ttyout:                                ttyout (library).
* vndict:                                Variable names dictionaries.
* write:                                 Term output.


File: ciao.info,  Node: Predicate/Method Definition Index,  Next: Property Definition Index,  Prev: Library/Module Definition Index,  Up: Top

Predicate/Method Definition Index
*********************************

* Menu:
                         
                         * !/0:                                   Documentation on exports (basiccontrol).
* $is_persistent/2:                      Documentation on multifiles (persdbrt).
* &/2:                                   Documentation on exports (andprolog).
* ,/2:                                   Documentation on exports (basiccontrol).
* ->/2:                                  Documentation on exports (basiccontrol).
* ./2:                                   Documentation on exports (ciaosh).
* ;/2:                                   Documentation on exports (basiccontrol).
* </2:                                   Documentation on exports (arithmetic).
* =../2:                                 Documentation on exports (term_basic).
* =:=/2:                                 Documentation on exports (arithmetic).
* =</2:                                  Documentation on exports (arithmetic).
* =>/2:                                  Documentation on exports (andprolog).
* =\=/2:                                 Documentation on exports (arithmetic).
* >/2:                                   Documentation on exports (arithmetic).
* >=/2:                                  Documentation on exports (arithmetic).
* \+/1:                                  Documentation on exports (basiccontrol).
* \=/2:                                  Documentation on exports (iso_misc).
* ^/2:                                   Documentation on exports (aggregates).
* abolish/1:                             Documentation on exports (dynamic).
* abort/0:                               Documentation on exports (exceptions).
* absolute_file_name/2:                  Documentation on exports (streams_basic).
* absolute_file_name/7:                  Documentation on exports (streams_basic).
* active_agents/1:                       Documentation on exports (andprolog).
* add_after/4 <1>:                       Documentation on exports (idlists).
* add_after/4:                           Documentation on exports (lists).
* add_before/4 <1>:                      Documentation on exports (idlists).
* add_before/4:                          Documentation on exports (lists).
* aggregate_function/3:                  Documentation on internals (pl2sql).
* aggregate_functor/2:                   Documentation on internals (pl2sql).
* append/3:                              Documentation on exports (lists).
* apropos/1:                             Documentation on exports (librowser).
* arg/2:                                 Documentation on exports (terms).
* arg/3:                                 Documentation on exports (term_basic).
* arg_expander/6:                        Documentation on exports (expansion_tools).
* arithmetic_functor/2:                  Documentation on internals (pl2sql).
* ask/2:                                 Documentation on exports (metaterms).
* assert/1:                              Documentation on exports (dynamic).
* assert/2:                              Documentation on exports (dynamic).
* asserta/1:                             Documentation on exports (dynamic).
* asserta/2:                             Documentation on exports (dynamic).
* asserta_fact/1:                        Documentation on exports (data_facts).
* asserta_fact/2:                        Documentation on exports (data_facts).
* assertz/1:                             Documentation on exports (dynamic).
* assertz/2:                             Documentation on exports (dynamic).
* assertz_fact/1:                        Documentation on exports (data_facts).
* assertz_fact/2:                        Documentation on exports (data_facts).
* atom2term/2:                           Documentation on exports (atom2term).
* atom_chars/2:                          Documentation on exports (iso_byte_char).
* atom_codes/2:                          Documentation on exports (atomic_basic).
* atom_concat/2:                         Documentation on exports (terms).
* atom_concat/3:                         Documentation on exports (atomic_basic).
* atom_length/2:                         Documentation on exports (atomic_basic).
* atom_lock_state/2:                     Documentation on exports (concurrency).
* attach_attribute/2:                    Documentation on exports (attributes).
* attribute/4:                           Documentation on multifiles (pl2sql).
* bagof/3:                               Documentation on exports (aggregates).
* basename/2:                            Documentation on exports (filenames).
* bind_socket/3:                         Documentation on exports (sockets).
* body_expander/6:                       Documentation on exports (expansion_tools).
* browse/2:                              Documentation on exports (librowser).
* build_foreign_interface/1:             Documentation on exports (foreign_interface).
* build_foreign_interface_explicit_decls/2: Documentation on exports (foreign_interface).
* build_foreign_interface_object/1:      Documentation on exports (foreign_interface).
* C/3:                                   Documentation on exports (term_basic).
* call/1:                                Documentation on exports (basiccontrol).
* call/2:                                Documentation on internals (basiccontrol).
* call_in_module/2:                      Documentation on exports (debugger).
* callme/2 <1>:                          Documentation on multifiles (messages).
* callme/2 <2>:                          Documentation on multifiles (rtchecks).
* callme/2:                              Documentation on multifiles (meta_props).
* case_insensitive_match/2:              Documentation on exports (patterns).
* catch/3:                               Documentation on exports (exceptions).
* cd/1:                                  Documentation on exports (system).
* char_code/2:                           Documentation on exports (iso_byte_char).
* character_count/2:                     Documentation on exports (streams_basic).
* check/1 <1>:                           Documentation on exports (rtchecks).
* check/1:                               Documentation on exports (assertions).
* chmod/2:                               Documentation on exports (system).
* chmod/3:                               Documentation on exports (system).
* ciaolibdir/1:                          Documentation on exports (system_info).
* clause/2:                              Documentation on exports (dynamic).
* clause/3:                              Documentation on exports (dynamic).
* clearerr/1:                            Documentation on exports (streams_basic).
* close/1:                               Documentation on exports (streams_basic).
* close/2:                               Documentation on exports (iso_incomplete).
* close_client/0:                        Documentation on exports (linda).
* close_file/1:                          Documentation on exports (dec10_io).
* close_input/1:                         Documentation on exports (streams).
* close_output/1:                        Documentation on exports (streams).
* close_predicate/1:                     Documentation on exports (data_facts).
* code_class/2:                          Documentation on exports (io_basic).
* compare/3:                             Documentation on exports (term_compare).
* comparison/2:                          Documentation on internals (pl2sql).
* compile/1:                             Documentation on exports (ciaosh).
* compiler_and_opts/2:                   Documentation on exports (foreign_compilation).
* complete_dict/3:                       Documentation on exports (vndict).
* complete_vars_dict/3:                  Documentation on exports (vndict).
* compound/1:                            Documentation on exports (iso_misc).
* connect_to_socket/3:                   Documentation on exports (sockets).
* connect_to_socket_type/4:              Documentation on exports (sockets).
* constructor/0:                         Documentation on exports (class).
* consult/1:                             Documentation on exports (ciaosh).
* contains1/2:                           Documentation on exports (lists).
* contains_ro/2:                         Documentation on exports (lists).
* copy_args/3:                           Documentation on exports (terms).
* copy_stdout/1:                         Documentation on exports (file_utils).
* copy_term/2:                           Documentation on exports (term_basic).
* create_dict/2:                         Documentation on exports (vndict).
* ctrlc_clean/1:                         Documentation on exports (ctrlcclean).
* ctrlcclean/0:                          Documentation on exports (ctrlcclean).
* current_atom/1:                        Documentation on exports (prolog_sys).
* current_executable/1:                  Documentation on exports (system).
* current_fact/1:                        Documentation on exports (data_facts).
* current_fact/2:                        Documentation on exports (data_facts).
* current_fact_nb/1:                     Documentation on exports (data_facts).
* current_host/1:                        Documentation on exports (system).
* current_infixop/4:                     Documentation on exports (operators).
* current_input/1:                       Documentation on exports (streams_basic).
* current_key/2:                         Documentation on exports (old_database).
* current_module/1:                      Documentation on exports (system_info).
* current_op/3:                          Documentation on exports (operators).
* current_output/1:                      Documentation on exports (streams_basic).
* current_postfixop/3:                   Documentation on exports (operators).
* current_predicate/1:                   Documentation on exports (dynamic).
* current_predicate/2:                   Documentation on exports (prolog_sys).
* current_prefixop/3:                    Documentation on exports (operators).
* current_prolog_flag/2:                 Documentation on exports (prolog_flags).
* current_stream/3:                      Documentation on exports (streams_basic).
* data/1:                                Documentation on exports (dynamic).
* datime/1:                              Documentation on exports (system).
* datime/9:                              Documentation on exports (system).
* db_eval_sql/3:                         Documentation on exports (db_client).
* db_get_tables/2:                       Documentation on exports (db_client).
* db_login/5:                            Documentation on exports (db_client).
* db_logoff/1:                           Documentation on exports (db_client).
* db_one_tuple/2:                        Documentation on exports (db_client).
* db_query/4:                            Documentation on internals (persdbrtsql).
* db_query_one_tuple/4:                  Documentation on internals (persdbrtsql).
* db_stmt_handle/3:                      Documentation on exports (db_client).
* db_table_types/3:                      Documentation on exports (db_client).
* dbassertz_fact/1:                      Documentation on exports (persdbrtsql).
* dbcall/2:                              Documentation on exports (persdbrtsql).
* dbcurrent_fact/1:                      Documentation on exports (persdbrtsql).
* dbfindall/4:                           Documentation on exports (persdbrtsql).
* dbretract_fact/1:                      Documentation on exports (persdbrtsql).
* dbretractall_fact/1:                   Documentation on exports (persdbrtsql).
* dcg_translation/2:                     Documentation on exports (dcg_expansion).
* debug/0:                               Documentation on exports (debugger).
* debug/1:                               Documentation on exports (io_aux).
* debug_goal/2:                          Documentation on exports (messages).
* debug_goal/3:                          Documentation on exports (messages).
* debug_message/1:                       Documentation on exports (messages).
* debug_message/2:                       Documentation on exports (messages).
* debug_module/1:                        Documentation on exports (debugger).
* debugging/0:                           Documentation on exports (debugger).
* define_flag/3 <1>:                     Documentation on multifiles (tokenize).
* define_flag/3 <2>:                     Documentation on multifiles (write).
* define_flag/3:                         Documentation on multifiles (prolog_flags).
* del_global/1:                          Documentation on exports (global).
* delete/3 <1>:                          Documentation on exports (idlists).
* delete/3:                              Documentation on exports (lists).
* delete_file/1:                         Documentation on exports (system).
* delete_on_ctrlc/2:                     Documentation on exports (ctrlcclean).
* derived_from/2:                        Documentation on exports (objects_rt).
* describe/1:                            Documentation on exports (librowser).
* destroy/1:                             Documentation on exports (objects_rt).
* destructor/0:                          Documentation on exports (class).
* detach_attribute/1:                    Documentation on exports (attributes).
* dic_get/3:                             Documentation on exports (dict).
* dic_lookup/3:                          Documentation on exports (dict).
* dic_lookup/4:                          Documentation on exports (dict).
* dic_node/2:                            Documentation on exports (dict).
* dic_replace/4:                         Documentation on exports (dict).
* dict2varnamesl/2:                      Documentation on exports (vndict).
* difference/3:                          Documentation on exports (lists).
* directory_files/2:                     Documentation on exports (system).
* display/1:                             Documentation on exports (io_basic).
* display/2:                             Documentation on exports (io_basic).
* display_list/1:                        Documentation on exports (io_aux).
* display_string/1:                      Documentation on exports (io_aux).
* display_term/1:                        Documentation on exports (io_aux).
* displayq/1:                            Documentation on exports (io_basic).
* displayq/2:                            Documentation on exports (io_basic).
* dlist/3:                               Documentation on exports (lists).
* do_interface/1:                        Documentation on exports (foreign_interface).
* do_on_abolish/1:                       Documentation on multifiles (dynamic).
* dynamic/1:                             Documentation on exports (dynamic).
* dynamic_search_path/1:                 Documentation on exports (ciaosh).
* eng_backtrack/2:                       Documentation on exports (concurrency).
* eng_call/3:                            Documentation on exports (concurrency).
* eng_call/4:                            Documentation on exports (concurrency).
* eng_cut/1:                             Documentation on exports (concurrency).
* eng_kill/1:                            Documentation on exports (concurrency).
* eng_killothers/0:                      Documentation on exports (concurrency).
* eng_release/1:                         Documentation on exports (concurrency).
* eng_self/1:                            Documentation on exports (concurrency).
* eng_status/0:                          Documentation on exports (concurrency).
* eng_wait/1:                            Documentation on exports (concurrency).
* ensure_loaded/1:                       Documentation on exports (ciaosh).
* equal_lists/2:                         Documentation on exports (lists).
* erase/1:                               Documentation on exports (data_facts).
* error/1:                               Documentation on exports (io_aux).
* error_message/1:                       Documentation on exports (messages).
* error_message/2:                       Documentation on exports (messages).
* error_message/3:                       Documentation on exports (messages).
* error_protect/1:                       Documentation on exports (errhandle).
* exec/3:                                Documentation on exports (system).
* exec/4:                                Documentation on exports (system).
* extension/2:                           Documentation on exports (filenames).
* extract_paths/2:                       Documentation on exports (system).
* fail/0:                                Documentation on exports (basiccontrol).
* false/1:                               Documentation on exports (assertions).
* fast_read/1:                           Documentation on exports (fastrw).
* fast_write/1:                          Documentation on exports (fastrw).
* fast_write_to_string/3:                Documentation on exports (fastrw).
* fetch_url/3:                           Documentation on exports (http).
* file_exists/1:                         Documentation on exports (system).
* file_exists/2:                         Documentation on exports (system).
* file_name_extension/3:                 Documentation on exports (filenames).
* file_properties/6:                     Documentation on exports (system).
* file_property/2:                       Documentation on exports (system).
* file_search_path/2 <1>:                Documentation on multifiles (streams_basic).
* file_search_path/2:                    Documentation on multifiles (libpaths).
* file_terms/2:                          Documentation on exports (file_utils).
* file_to_string/2:                      Documentation on exports (file_utils).
* fileerrors/0:                          Documentation on exports (prolog_flags).
* find_name/4:                           Documentation on exports (vndict).
* findall/3 <1>:                         Documentation on exports (conc_aggregates).
* findall/3:                             Documentation on exports (aggregates).
* findall/4:                             Documentation on exports (aggregates).
* flush_output/0:                        Documentation on exports (streams_basic).
* flush_output/1:                        Documentation on exports (streams_basic).
* fmode/2:                               Documentation on exports (system).
* force_lazy/1:                          Documentation on exports (ciaosh).
* form_default/3:                        Documentation on exports (html).
* form_empty_value/1:                    Documentation on exports (html).
* form_request_method/1:                 Documentation on exports (html).
* format/2:                              Documentation on exports (format).
* format/3:                              Documentation on exports (format).
* functor/3:                             Documentation on exports (term_basic).
* garbage_collect/0:                     Documentation on exports (prolog_sys).
* gc/0:                                  Documentation on exports (prolog_flags).
* get1_code/1:                           Documentation on exports (io_basic).
* get1_code/2:                           Documentation on exports (io_basic).
* get_alias_path/0:                      Documentation on exports (libpaths).
* get_arch/1:                            Documentation on exports (system_info).
* get_attribute/2:                       Documentation on exports (attributes).
* get_byte/1:                            Documentation on exports (iso_byte_char).
* get_byte/2:                            Documentation on exports (iso_byte_char).
* get_char/1:                            Documentation on exports (iso_byte_char).
* get_char/2:                            Documentation on exports (iso_byte_char).
* get_code/1:                            Documentation on exports (io_basic).
* get_code/2:                            Documentation on exports (io_basic).
* get_form_input/1:                      Documentation on exports (html).
* get_form_value/3:                      Documentation on exports (html).
* get_global/2:                          Documentation on exports (global).
* get_line/1:                            Documentation on exports (strings).
* get_line/2:                            Documentation on exports (strings).
* get_os/1:                              Documentation on exports (system_info).
* get_pid/1:                             Documentation on exports (system).
* get_primes/2:                          Documentation on exports (numlists).
* getcounter/2:                          Documentation on exports (counters).
* getct/2:                               Documentation on exports (io_basic).
* getct1/2:                              Documentation on exports (io_basic).
* getenvstr/2:                           Documentation on exports (system).
* halt/0:                                Documentation on exports (exceptions).
* halt/1:                                Documentation on exports (exceptions).
* halt_server/0:                         Documentation on exports (linda).
* handle_error/2:                        Documentation on exports (errhandle).
* html2terms/2:                          Documentation on exports (html).
* html_protect/1:                        Documentation on exports (html).
* html_report_error/1:                   Documentation on exports (html).
* html_template/3:                       Documentation on exports (html).
* http_lines/3:                          Documentation on exports (html).
* icon_address/2:                        Documentation on exports (html).
* if/3:                                  Documentation on exports (basiccontrol).
* imports_meta_pred/3:                   Documentation on exports (expansion_tools).
* in/1:                                  Documentation on exports (linda).
* in/2:                                  Documentation on exports (linda).
* in_noblock/1:                          Documentation on exports (linda).
* in_stream/2:                           Documentation on exports (linda).
* inccounter/2:                          Documentation on exports (counters).
* include/1:                             Documentation on exports (ciaosh).
* inform_user/1:                         Documentation on exports (io_aux).
* inherited/1:                           Documentation on exports (class).
* init_persdb/0:                         Documentation on exports (persdbrt).
* init_sql_persdb/0:                     Documentation on exports (persdbrtsql).
* initialize_db/0:                       Documentation on exports (persdbrt).
* insert/3:                              Documentation on exports (sets).
* insert_last/3:                         Documentation on exports (lists).
* instance/2:                            Documentation on exports (metaterms).
* instance_codes/2:                      Documentation on exports (objects_rt).
* instance_of/2 <1>:                     Documentation on exports (objects_rt).
* instance_of/2:                         Documentation on exports (objects).
* intercept/3:                           Documentation on exports (exceptions).
* interface/2:                           Documentation on exports (objects_rt).
* intersection/3:                        Documentation on exports (lists).
* intset_delete/3:                       Documentation on exports (lists).
* intset_in/2:                           Documentation on exports (lists).
* intset_insert/3:                       Documentation on exports (lists).
* intset_sequence/3:                     Documentation on exports (lists).
* is/2:                                  Documentation on exports (arithmetic).
* issue_debug_messages/1:                Documentation on multifiles (messages).
* java_add_listener/3:                   Documentation on exports (javart).
* java_connection/0:                     Documentation on exports (javart).
* java_create_object/2:                  Documentation on exports (javart).
* java_delete_object/1:                  Documentation on exports (javart).
* java_disconnection/0:                  Documentation on exports (javart).
* java_fast_read/2:                      Documentation on exports (javasock).
* java_fast_write/2:                     Documentation on exports (javasock).
* java_get_value/2:                      Documentation on exports (javart).
* java_invoke_method/2:                  Documentation on exports (javart).
* java_remote_connection/1:              Documentation on exports (javart).
* java_remove_listener/3:                Documentation on exports (javart).
* java_set_value/2:                      Documentation on exports (javart).
* java_stream/3:                         Documentation on exports (javasock).
* keysort/2:                             Documentation on exports (sort).
* last/2:                                Documentation on exports (lists).
* leash/1:                               Documentation on exports (debugger).
* length/2:                              Documentation on exports (lists).
* letter_match/2:                        Documentation on exports (patterns).
* library_directory/1 <1>:               Documentation on multifiles (streams_basic).
* library_directory/1:                   Documentation on multifiles (libpaths).
* linda_client/1:                        Documentation on exports (linda).
* linda_timeout/2:                       Documentation on exports (linda).
* line_count/2:                          Documentation on exports (streams_basic).
* line_position/2:                       Documentation on exports (streams_basic).
* linker_and_opts/2:                     Documentation on exports (foreign_compilation).
* list_concat/2:                         Documentation on exports (lists).
* list_insert/2 <1>:                     Documentation on exports (idlists).
* list_insert/2:                         Documentation on exports (lists).
* list_lookup/3:                         Documentation on exports (lists).
* list_lookup/4:                         Documentation on exports (lists).
* list_to_list_of_lists/2:               Documentation on exports (lists).
* lock_atom/1:                           Documentation on exports (concurrency).
* lock_file/3:                           Documentation on exports (file_locks).
* make_actmod/2:                         Documentation on exports (ciaosh).
* make_persistent/2:                     Documentation on exports (persdbrt).
* make_po/1:                             Documentation on exports (ciaosh).
* make_sql_persistent/3:                 Documentation on exports (persdbrtsql).
* match_pattern/2:                       Documentation on exports (patterns).
* match_pattern/3:                       Documentation on exports (patterns).
* match_pattern_pred/2:                  Documentation on exports (patterns).
* match_string/3:                        Documentation on exports (db_client).
* maxdepth/1:                            Documentation on exports (debugger).
* member_0/2:                            Documentation on exports (idlists).
* memberchk/2:                           Documentation on exports (idlists).
* merge/3:                               Documentation on exports (sets).
* message/1:                             Documentation on exports (io_aux).
* message/2:                             Documentation on exports (io_aux).
* message_lns/4:                         Documentation on exports (io_aux).
* mktemp/2:                              Documentation on exports (system).
* modif_time/2:                          Documentation on exports (system).
* modif_time0/2:                         Documentation on exports (system).
* multifile/1:                           Documentation on exports (ciaosh).
* my_url/1:                              Documentation on exports (html).
* name/2:                                Documentation on exports (atomic_basic).
* negated_comparison/2:                  Documentation on internals (pl2sql).
* new/2 <1>:                             Documentation on exports (objects_rt).
* new/2:                                 Documentation on exports (objects).
* nl/0:                                  Documentation on exports (io_basic).
* nl/1:                                  Documentation on exports (io_basic).
* no_path_file_name/2:                   Documentation on exports (filenames).
* nocontainsx/2:                         Documentation on exports (lists).
* nodebug/0:                             Documentation on exports (debugger).
* nodebug_module/1:                      Documentation on exports (debugger).
* nofileerrors/0:                        Documentation on exports (prolog_flags).
* nogc/0:                                Documentation on exports (prolog_flags).
* nonsingle/1:                           Documentation on exports (lists).
* nospy/1:                               Documentation on exports (debugger).
* nospyall/0:                            Documentation on exports (debugger).
* note/1:                                Documentation on exports (io_aux).
* note_message/1:                        Documentation on exports (messages).
* note_message/2:                        Documentation on exports (messages).
* note_message/3:                        Documentation on exports (messages).
* notrace/0:                             Documentation on exports (debugger).
* nth/3:                                 Documentation on exports (lists).
* number_chars/2:                        Documentation on exports (iso_byte_char).
* number_codes/2:                        Documentation on exports (atomic_basic).
* number_codes/3:                        Documentation on exports (atomic_basic).
* numbervars/3:                          Documentation on exports (write).
* odbc_connect/2:                        Documentation on exports (db_client).
* odbc_disconnect/1:                     Documentation on exports (db_client).
* once/1:                                Documentation on exports (iso_misc).
* op/3:                                  Documentation on exports (operators).
* open/3:                                Documentation on exports (streams_basic).
* open/4:                                Documentation on exports (iso_incomplete).
* open_client/2:                         Documentation on exports (linda).
* open_input/2:                          Documentation on exports (streams).
* open_null_stream/1:                    Documentation on exports (streams).
* open_output/2:                         Documentation on exports (streams).
* open_predicate/1:                      Documentation on exports (data_facts).
* optional_message/2:                    Documentation on exports (messages).
* optional_message/3:                    Documentation on exports (messages).
* ord_delete/3:                          Documentation on exports (sets).
* ord_disjoint/2:                        Documentation on exports (sets).
* ord_intersect/2:                       Documentation on exports (sets).
* ord_intersection/3:                    Documentation on exports (sets).
* ord_intersection_diff/4:               Documentation on exports (sets).
* ord_member/2:                          Documentation on exports (sets).
* ord_subset/2:                          Documentation on exports (sets).
* ord_subset_diff/3:                     Documentation on exports (sets).
* ord_subtract/3:                        Documentation on exports (sets).
* ord_test_member/3:                     Documentation on exports (sets).
* ord_union/3:                           Documentation on exports (sets).
* ord_union_change/3:                    Documentation on exports (sets).
* ord_union_diff/4:                      Documentation on exports (sets).
* ord_union_symdiff/4:                   Documentation on exports (sets).
* out/1:                                 Documentation on exports (linda).
* out_stream/2:                          Documentation on exports (linda).
* output_html/1:                         Documentation on exports (html).
* parse_term/3:                          Documentation on exports (atom2term).
* passertz_fact/1:                       Documentation on exports (persdbrt).
* pause/1:                               Documentation on exports (system).
* pcurrent_fact/1:                       Documentation on exports (persdbrt).
* peek_byte/1:                           Documentation on exports (iso_byte_char).
* peek_byte/2:                           Documentation on exports (iso_byte_char).
* peek_char/1:                           Documentation on exports (iso_byte_char).
* peek_char/2:                           Documentation on exports (iso_byte_char).
* peek_code/1:                           Documentation on exports (io_basic).
* peek_code/2:                           Documentation on exports (io_basic).
* persistent_dir/2:                      Documentation on multifiles (persdbrt).
* phrase/2:                              Documentation on exports (dcg_expansion).
* phrase/3:                              Documentation on exports (dcg_expansion).
* pl2sqlstring/3:                        Documentation on exports (pl2sql).
* pl2sqlterm/3:                          Documentation on exports (pl2sql).
* pop_global/2:                          Documentation on exports (global).
* pop_prolog_flag/1:                     Documentation on exports (prolog_flags).
* popen/3:                               Documentation on exports (system).
* portray/1:                             Documentation on multifiles (write).
* portray_attribute/2:                   Documentation on multifiles (write).
* portray_clause/1:                      Documentation on exports (write).
* portray_clause/2:                      Documentation on exports (write).
* powerset/2:                            Documentation on exports (lists).
* predicate_property/2:                  Documentation on exports (prolog_sys).
* pretract_fact/1:                       Documentation on exports (persdbrt).
* pretty_print/2:                        Documentation on exports (pretty_print).
* pretty_print/3:                        Documentation on exports (pretty_print).
* prettyvars/1:                          Documentation on exports (write).
* print/1:                               Documentation on exports (write).
* print/2:                               Documentation on exports (write).
* printable_char/1:                      Documentation on exports (write).
* printqueries/1:                        Documentation on exports (pl2sql).
* prolog_flag/3:                         Documentation on exports (prolog_flags).
* prolog_parse/2:                        Documentation on exports (jtopl).
* prolog_server/0:                       Documentation on exports (jtopl).
* prompt/2:                              Documentation on exports (prolog_flags).
* prune_dict/3:                          Documentation on exports (vndict).
* push_global/2:                         Documentation on exports (global).
* push_prolog_flag/2:                    Documentation on exports (prolog_flags).
* put_byte/1:                            Documentation on exports (iso_byte_char).
* put_byte/2:                            Documentation on exports (iso_byte_char).
* put_char/1:                            Documentation on exports (iso_byte_char).
* put_char/2:                            Documentation on exports (iso_byte_char).
* put_code/1:                            Documentation on exports (io_basic).
* put_code/2:                            Documentation on exports (io_basic).
* q_delete/3:                            Documentation on exports (queues).
* q_empty/1:                             Documentation on exports (queues).
* q_insert/3:                            Documentation on exports (queues).
* q_member/2:                            Documentation on exports (queues).
* query_generation/3:                    Documentation on internals (pl2sql).
* random/1:                              Documentation on exports (random).
* random/3:                              Documentation on exports (random).
* rd/1:                                  Documentation on exports (linda).
* rd/2:                                  Documentation on exports (linda).
* rd_findall/3:                          Documentation on exports (linda).
* rd_noblock/1:                          Documentation on exports (linda).
* read/1:                                Documentation on exports (read).
* read/2:                                Documentation on exports (read).
* read_term/2:                           Documentation on exports (read).
* read_term/3:                           Documentation on exports (read).
* read_tokens/2:                         Documentation on exports (tokenize).
* read_top_level/3:                      Documentation on exports (read).
* rebuild_foreign_interface/1:           Documentation on exports (foreign_interface).
* rebuild_foreign_interface_object/1:    Documentation on exports (foreign_interface).
* recorda/3:                             Documentation on exports (old_database).
* recorded/3:                            Documentation on exports (old_database).
* recordz/3:                             Documentation on exports (old_database).
* relation/3:                            Documentation on multifiles (pl2sql).
* rename/2:                              Documentation on exports (vndict).
* repeat/0:                              Documentation on exports (basiccontrol).
* retract/1:                             Documentation on exports (dynamic).
* retract_fact/1:                        Documentation on exports (data_facts).
* retract_fact_nb/1:                     Documentation on exports (data_facts).
* retractall/1:                          Documentation on exports (dynamic).
* retractall_fact/1:                     Documentation on exports (data_facts).
* reverse/2:                             Documentation on exports (lists).
* reverse/3:                             Documentation on exports (lists).
* second_prompt/2:                       Documentation on exports (read).
* see/1:                                 Documentation on exports (dec10_io).
* seeing/1:                              Documentation on exports (dec10_io).
* seen/0:                                Documentation on exports (dec10_io).
* select/3:                              Documentation on exports (lists).
* select_socket/5:                       Documentation on exports (sockets).
* self/1:                                Documentation on exports (class).
* set_debug_mode/1:                      Documentation on exports (ciaosh).
* set_fact/1:                            Documentation on exports (data_facts).
* set_global/2:                          Documentation on exports (global).
* set_input/1:                           Documentation on exports (streams_basic).
* set_nodebug_mode/1:                    Documentation on exports (ciaosh).
* set_output/1:                          Documentation on exports (streams_basic).
* set_prolog_flag/2:                     Documentation on exports (prolog_flags).
* setarg/3:                              Documentation on exports (odd).
* setcounter/2:                          Documentation on exports (counters).
* setof/3:                               Documentation on exports (aggregates).
* setproduct/3:                          Documentation on exports (sets).
* shell/0:                               Documentation on exports (system).
* shell/1:                               Documentation on exports (system).
* shell/2:                               Documentation on exports (system).
* simple_message/1:                      Documentation on exports (messages).
* simple_message/2:                      Documentation on exports (messages).
* skip_code/1:                           Documentation on exports (io_basic).
* skip_code/2:                           Documentation on exports (io_basic).
* socket_accept/2:                       Documentation on exports (sockets).
* socket_connection/2:                   Documentation on exports (javasock).
* socket_disconnection/0:                Documentation on exports (javasock).
* socket_recv/2:                         Documentation on exports (sockets).
* socket_recv_code/3:                    Documentation on exports (sockets).
* socket_send/2:                         Documentation on exports (sockets).
* sort/2:                                Documentation on exports (sort).
* spy/1:                                 Documentation on exports (debugger).
* sql_get_tables/2:                      Documentation on exports (persdbrtsql).
* sql_persistent/3:                      Documentation on exports (persdbrtsql).
* sql_persistent_location/2:             Documentation on multifiles (persdbrtsql).
* sql_query/3:                           Documentation on exports (persdbrtsql).
* sql_query_one_tuple/3:                 Documentation on internals (persdbrtsql).
* sql_table_types/3:                     Documentation on exports (persdbrtsql).
* sqlterm2string/2:                      Documentation on exports (pl2sql).
* srandom/1:                             Documentation on exports (random).
* statistics/0:                          Documentation on exports (prolog_sys).
* statistics/2:                          Documentation on exports (prolog_sys).
* stream_code/2:                         Documentation on exports (streams_basic).
* stream_property/2:                     Documentation on exports (iso_incomplete).
* string/3:                              Documentation on exports (strings).
* string2term/2:                         Documentation on exports (atom2term).
* sub_atom/4:                            Documentation on exports (atomic_basic).
* sub_atom/5:                            Documentation on exports (iso_misc).
* subtract/3:                            Documentation on exports (idlists).
* sum_list/2:                            Documentation on exports (numlists).
* sum_list/3:                            Documentation on exports (numlists).
* sum_list_of_lists/2:                   Documentation on exports (numlists).
* sum_list_of_lists/3:                   Documentation on exports (numlists).
* system/1:                              Documentation on exports (system).
* system/2:                              Documentation on exports (system).
* system_lib/1:                          Documentation on exports (librowser).
* tab/1:                                 Documentation on exports (io_basic).
* tab/2:                                 Documentation on exports (io_basic).
* tcl_delete/1:                          Documentation on exports (tcltk).
* tcl_eval/3:                            Documentation on exports (tcltk).
* tcl_event/3:                           Documentation on exports (tcltk).
* tcl_new/1:                             Documentation on exports (tcltk).
* tell/1:                                Documentation on exports (dec10_io).
* telling/1:                             Documentation on exports (dec10_io).
* text_lines/2:                          Documentation on exports (html).
* this_module/1:                         Documentation on exports (system_info).
* throw/1:                               Documentation on exports (exceptions).
* time/1:                                Documentation on exports (system).
* tk_event_loop/1:                       Documentation on exports (tcltk).
* tk_new/2:                              Documentation on exports (tcltk).
* tk_new/4:                              Documentation on exports (tcltk).
* told/0:                                Documentation on exports (dec10_io).
* trace/0:                               Documentation on exports (debugger).
* translate_arithmetic_function/5:       Documentation on internals (pl2sql).
* translate_comparison/5:                Documentation on internals (pl2sql).
* translate_conjunction/5:               Documentation on internals (pl2sql).
* translate_goal/5:                      Documentation on internals (pl2sql).
* true/0:                                Documentation on exports (basiccontrol).
* true/1:                                Documentation on exports (assertions).
* trust/1:                               Documentation on exports (assertions).
* ttydisplay/1:                          Documentation on exports (ttyout).
* ttydisplay_string/1:                   Documentation on exports (ttyout).
* ttydisplayq/1:                         Documentation on exports (ttyout).
* ttyflush/0:                            Documentation on exports (ttyout).
* ttyget/1:                              Documentation on exports (ttyout).
* ttyget1/1:                             Documentation on exports (ttyout).
* ttynl/0:                               Documentation on exports (ttyout).
* ttyput/1:                              Documentation on exports (ttyout).
* ttyskip/1:                             Documentation on exports (ttyout).
* ttyskipeol/0:                          Documentation on exports (ttyout).
* ttytab/1:                              Documentation on exports (ttyout).
* umask/2:                               Documentation on exports (system).
* undo/1:                                Documentation on exports (odd).
* undo_force_lazy/1:                     Documentation on exports (ciaosh).
* unify_with_occurs_check/2:             Documentation on exports (iso_misc).
* union/3:                               Documentation on exports (lists).
* union_idlists/3:                       Documentation on exports (idlists).
* unload/1:                              Documentation on exports (ciaosh).
* unlock_atom/1:                         Documentation on exports (concurrency).
* unlock_file/2:                         Documentation on exports (file_locks).
* update/0:                              Documentation on exports (librowser).
* update_attribute/2:                    Documentation on exports (attributes).
* update_files/2:                        Documentation on exports (persdbrt).
* url_info/2:                            Documentation on exports (html).
* url_info_relative/3:                   Documentation on exports (html).
* url_query/2:                           Documentation on exports (html).
* use_class/1 <1>:                       Documentation on exports (dynclasses).
* use_class/1:                           Documentation on exports (objects).
* use_module/1 <1>:                      Documentation on exports (dynmods).
* use_module/1:                          Documentation on exports (ciaosh).
* use_module/2:                          Documentation on exports (ciaosh).
* use_package/1:                         Documentation on exports (ciaosh).
* variant/2:                             Documentation on exports (metaterms).
* varnamesl2dict/2:                      Documentation on exports (vndict).
* vars_names_dict/3:                     Documentation on exports (vndict).
* varsbag/3:                             Documentation on exports (metaterms).
* varset/2:                              Documentation on exports (metaterms).
* warning/1:                             Documentation on exports (io_aux).
* warning_message/1:                     Documentation on exports (messages).
* warning_message/2:                     Documentation on exports (messages).
* warning_message/3:                     Documentation on exports (messages).
* wellformed_body/3:                     Documentation on exports (dynamic).
* where/1:                               Documentation on exports (librowser).
* whitespace/2:                          Documentation on exports (strings).
* whitespace0/2:                         Documentation on exports (strings).
* working_directory/2:                   Documentation on exports (system).
* write/1:                               Documentation on exports (write).
* write/2:                               Documentation on exports (write).
* write_assertion/6:                     Documentation on exports (assrt_write).
* write_assertion_as_comment/6:          Documentation on exports (assrt_write).
* write_canonical/1:                     Documentation on exports (write).
* write_canonical/2:                     Documentation on exports (write).
* write_list1/1:                         Documentation on exports (write).
* write_string/1:                        Documentation on exports (strings).
* write_string/2:                        Documentation on exports (strings).
* write_term/2:                          Documentation on exports (write).
* write_term/3:                          Documentation on exports (write).
* writeq/1:                              Documentation on exports (write).
* writeq/2:                              Documentation on exports (write).
* xml2terms/2:                           Documentation on exports (html).
* |/2:                                   Documentation on internals (basiccontrol).


File: ciao.info,  Node: Property Definition Index,  Next: Regular Type Definition Index,  Prev: Predicate/Method Definition Index,  Up: Top

Property Definition Index
*************************

* Menu:
                         
                         * =/2:                                   Documentation on exports (term_basic).
* ==/2:                                  Documentation on exports (term_compare).
* @</2:                                  Documentation on exports (term_compare).
* @=</2:                                 Documentation on exports (term_compare).
* @>/2:                                  Documentation on exports (term_compare).
* @>=/2:                                 Documentation on exports (term_compare).
* \==/2:                                 Documentation on exports (term_compare).
* atom/1:                                Documentation on exports (term_typing).
* atomic/1:                              Documentation on exports (term_typing).
* call/2:                                Documentation on exports (meta_props).
* class_name/1 <1>:                      Documentation on exports (objects_rt).
* class_name/1:                          Documentation on exports (objects).
* class_source/1 <1>:                    Documentation on exports (objects_rt).
* class_source/1:                        Documentation on exports (objects).
* compat/2:                              Documentation on exports (basic_props).
* constructor/1 <1>:                     Documentation on exports (objects_rt).
* constructor/1:                         Documentation on exports (objects).
* covered/1:                             Documentation on exports (native_props).
* disjoint/1:                            Documentation on exports (native_props).
* docstring/1:                           Documentation on exports (assertions_props).
* expander_pred/1:                       Documentation on internals (expansion_tools).
* fails/1:                               Documentation on exports (native_props).
* float/1:                               Documentation on exports (term_typing).
* ground/1:                              Documentation on exports (term_typing).
* hard/1:                                Documentation on exports (native_props).
* head_pattern/1:                        Documentation on exports (assertions_props).
* indep/1 <1>:                           Documentation on exports (andprolog).
* indep/1:                               Documentation on exports (native_props).
* indep/2 <1>:                           Documentation on exports (andprolog).
* indep/2:                               Documentation on exports (native_props).
* instance_id/1 <1>:                     Documentation on exports (objects_rt).
* instance_id/1:                         Documentation on exports (objects).
* integer/1:                             Documentation on exports (term_typing).
* interface_name/1:                      Documentation on exports (objects_rt).
* interface_source/1:                    Documentation on exports (objects_rt).
* internal_module_id/1:                  Documentation on internals (system_info).
* is_det/1:                              Documentation on exports (native_props).
* iso/1:                                 Documentation on exports (basic_props).
* linear/1:                              Documentation on exports (native_props).
* list1/2:                               Documentation on exports (lists).
* lower_size/2:                          Documentation on exports (native_props).
* lower_time/2:                          Documentation on exports (native_props).
* member/2:                              Documentation on exports (basic_props).
* method_spec/1:                         Documentation on exports (objects_rt).
* mshare/1:                              Documentation on exports (native_props).
* multpredspec/1:                        Documentation on internals (debugger).
* nonvar/1:                              Documentation on exports (term_typing).
* not_covered/1:                         Documentation on exports (native_props).
* not_disjoint/1:                        Documentation on exports (native_props).
* not_fail/1:                            Documentation on exports (native_props).
* not_further_inst/2:                    Documentation on exports (basic_props).
* number/1:                              Documentation on exports (term_typing).
* possible_fail/1:                       Documentation on exports (native_props).
* possible_nondet/1:                     Documentation on exports (native_props).
* prop/2:                                Documentation on exports (meta_props).
* prop_abs/1:                            Documentation on internals (meta_props).
* pure/1:                                Documentation on exports (native_props).
* regtype/1:                             Documentation on exports (basic_props).
* regtype/2:                             Documentation on exports (meta_props).
* soft/1:                                Documentation on exports (native_props).
* sourcenames/1:                         Documentation on internals (ciaosh).
* sublist/2:                             Documentation on exports (lists).
* type/2:                                Documentation on exports (term_typing).
* upper_size/2:                          Documentation on exports (native_props).
* upper_time/2:                          Documentation on exports (native_props).
* var/1:                                 Documentation on exports (term_typing).
* virtual_method_spec/1:                 Documentation on exports (objects_rt).
* write_option/1:                        Documentation on exports (write).


File: ciao.info,  Node: Regular Type Definition Index,  Next: Declaration Definition Index,  Prev: Property Definition Index,  Up: Top

Regular Type Definition Index
*****************************

* Menu:
                         
                         * answertableterm/1:                     Documentation on exports (db_client).
* answertupleterm/1:                     Documentation on exports (db_client).
* apropos_spec/1:                        Documentation on internals (librowser).
* arithexpression/1:                     Documentation on exports (arithmetic).
* assrt_body/1:                          Documentation on exports (assertions_props).
* assrt_status/1:                        Documentation on exports (assertions_props).
* assrt_type/1:                          Documentation on exports (assertions_props).
* atm/1:                                 Documentation on exports (basic_props).
* atm_or_atm_list/1:                     Documentation on exports (basic_props).
* body/1:                                Documentation on internals (pretty_print).
* c_assrt_body/1:                        Documentation on exports (assertions_props).
* callable/1:                            Documentation on exports (basic_props).
* character_code/1:                      Documentation on exports (basic_props).
* clause/1:                              Documentation on internals (pretty_print).
* clauses/1:                             Documentation on internals (pretty_print).
* clterm/1:                              Documentation on internals (pretty_print).
* complex_arg_property/1:                Documentation on exports (assertions_props).
* complex_goal_property/1:               Documentation on exports (assertions_props).
* constant/1:                            Documentation on exports (basic_props).
* datime_struct/1:                       Documentation on exports (system).
* dbconnection/1 <1>:                    Documentation on exports (db_client).
* dbconnection/1:                        Documentation on internals (persdbrtsql).
* dbhandle/1:                            Documentation on internals (db_client).
* dbname/1 <1>:                          Documentation on exports (db_client).
* dbname/1:                              Documentation on exports (persdbrtsql).
* dbqueryconnection/1:                   Documentation on exports (db_client).
* directoryname/1:                       Documentation on internals (persdbrt).
* fact/1:                                Documentation on internals (data_facts).
* flag/1:                                Documentation on internals (pretty_print).
* flt/1:                                 Documentation on exports (basic_props).
* format_control/1:                      Documentation on exports (format).
* g_assrt_body/1:                        Documentation on exports (assertions_props).
* garbage_collection_option/1:           Documentation on internals (prolog_sys).
* gc_result/1:                           Documentation on internals (prolog_sys).
* gnd/1:                                 Documentation on exports (basic_props).
* int/1:                                 Documentation on exports (basic_props).
* intlist/1:                             Documentation on exports (numlists).
* io_mode/1:                             Documentation on exports (streams_basic).
* java_constructor/1:                    Documentation on exports (javart).
* java_event/1:                          Documentation on exports (javart).
* java_field/1:                          Documentation on exports (javart).
* java_method/1:                         Documentation on exports (javart).
* java_object/1:                         Documentation on exports (javart).
* keypair/1:                             Documentation on internals (sort).
* keyword/1:                             Documentation on internals (persdbrt).
* list/1:                                Documentation on exports (basic_props).
* list/2:                                Documentation on exports (basic_props).
* machine_name/1:                        Documentation on exports (javart).
* memory_option/1:                       Documentation on internals (prolog_sys).
* memory_result/1:                       Documentation on internals (prolog_sys).
* metaspec/1:                            Documentation on internals (modules).
* modulename/1:                          Documentation on internals (modules).
* nnegint/1:                             Documentation on exports (basic_props).
* null_dict/1:                           Documentation on exports (vndict).
* num/1:                                 Documentation on exports (basic_props).
* numlist/1:                             Documentation on exports (numlists).
* operator_specifier/1:                  Documentation on exports (basic_props).
* passwd/1 <1>:                          Documentation on exports (db_client).
* passwd/1:                              Documentation on exports (persdbrtsql).
* pattern/1:                             Documentation on exports (patterns).
* popen_mode/1:                          Documentation on exports (system).
* predfunctor/1:                         Documentation on exports (assertions_props).
* predname/1:                            Documentation on exports (basic_props).
* projterm/1 <1>:                        Documentation on exports (pl2sql).
* projterm/1:                            Documentation on exports (persdbrtsql).
* prolog_predicate/1:                    Documentation on exports (javart).
* property_conjunction/1:                Documentation on exports (assertions_props).
* property_starterm/1:                   Documentation on exports (assertions_props).
* propfunctor/1:                         Documentation on exports (assertions_props).
* querybody/1 <1>:                       Documentation on exports (pl2sql).
* querybody/1:                           Documentation on exports (persdbrtsql).
* reference/1:                           Documentation on internals (data_facts).
* s_assrt_body/1:                        Documentation on exports (assertions_props).
* sequence/2:                            Documentation on exports (basic_props).
* sequence_or_list/2:                    Documentation on exports (basic_props).
* socket_type/1:                         Documentation on exports (sockets).
* socketname/1 <1>:                      Documentation on exports (db_client).
* socketname/1:                          Documentation on exports (persdbrtsql).
* sourcename/1:                          Documentation on exports (streams_basic).
* sqlstring/1:                           Documentation on exports (pl2sql).
* stmthandle/1:                          Documentation on internals (db_client).
* stream/1:                              Documentation on exports (streams_basic).
* string/1:                              Documentation on exports (basic_props).
* struct/1:                              Documentation on exports (basic_props).
* symbol_option/1:                       Documentation on internals (prolog_sys).
* symbol_result/1:                       Documentation on internals (prolog_sys).
* tclCommand/1:                          Documentation on exports (tcltk).
* tclInterpreter/1:                      Documentation on exports (tcltk).
* term/1:                                Documentation on exports (basic_props).
* time_option/1:                         Documentation on internals (prolog_sys).
* time_result/1:                         Documentation on internals (prolog_sys).
* translation_predname/1:                Documentation on internals (syntax_extensions).
* tuple/1 <1>:                           Documentation on exports (db_client).
* tuple/1:                               Documentation on internals (persdbrtsql).
* user/1 <1>:                            Documentation on exports (db_client).
* user/1:                                Documentation on exports (persdbrtsql).
* varname/1:                             Documentation on exports (vndict).
* varnamedict/1:                         Documentation on exports (vndict).
* varnamesl/1:                           Documentation on exports (vndict).


File: ciao.info,  Node: Declaration Definition Index,  Next: Concept Definition Index,  Prev: Regular Type Definition Index,  Up: Top

Declaration Definition Index
****************************

* Menu:
                         
                         * add_clause_trans/1:                    Documentation on internals (syntax_extensions).
* add_goal_trans/1:                      Documentation on internals (syntax_extensions).
* add_sentence_trans/1:                  Documentation on internals (syntax_extensions).
* add_term_trans/1:                      Documentation on internals (syntax_extensions).
* calls/1:                               Documentation on new declarations (assertions).
* calls/2:                               Documentation on new declarations (assertions).
* comment/2:                             Documentation on new declarations (assertions).
* comp/1:                                Documentation on new declarations (assertions).
* comp/2:                                Documentation on new declarations (assertions).
* concurrent/1:                          Documentation on new declarations (class).
* data/1:                                Documentation on new declarations (class).
* decl/1:                                Documentation on new declarations (assertions).
* decl/2:                                Documentation on new declarations (assertions).
* discontiguous/1:                       Documentation on internals (builtin_directives).
* dynamic/1:                             Documentation on new declarations (class).
* ensure_loaded/1:                       Documentation on internals (loading_code).
* entry/1:                               Documentation on new declarations (assertions).
* export/1 <1>:                          Documentation on new declarations (class).
* export/1:                              Documentation on internals (modules).
* impl_defined/1:                        Documentation on internals (builtin_directives).
* implements/1:                          Documentation on new declarations (class).
* import/2:                              Documentation on internals (modules).
* include/1:                             Documentation on internals (loading_code).
* inherit_class/1:                       Documentation on new declarations (class).
* inheritable/1:                         Documentation on new declarations (class).
* initialization/1:                      Documentation on internals (builtin_directives).
* instance_of/2:                         Documentation on new declarations (objects).
* load_compilation_module/1:             Documentation on internals (syntax_extensions).
* meta_predicate/1:                      Documentation on internals (modules).
* modedef/1:                             Documentation on new declarations (assertions).
* module/2:                              Documentation on internals (modules).
* module/3:                              Documentation on internals (modules).
* multifile/1:                           Documentation on internals (builtin_directives).
* new/2:                                 Documentation on new declarations (objects).
* new_declaration/1:                     Documentation on internals (syntax_extensions).
* new_declaration/2:                     Documentation on internals (syntax_extensions).
* on_abort/1:                            Documentation on internals (builtin_directives).
* op/3:                                  Documentation on internals (syntax_extensions).
* pred/1:                                Documentation on new declarations (assertions).
* pred/2:                                Documentation on new declarations (assertions).
* prop/1:                                Documentation on new declarations (assertions).
* prop/2:                                Documentation on new declarations (assertions).
* public/1:                              Documentation on new declarations (class).
* redefining/1:                          Documentation on internals (builtin_directives).
* reexport/1:                            Documentation on internals (modules).
* reexport/2:                            Documentation on internals (modules).
* regtype/1:                             Documentation on new declarations (regtypes).
* regtype/2:                             Documentation on new declarations (regtypes).
* success/1:                             Documentation on new declarations (assertions).
* success/2:                             Documentation on new declarations (assertions).
* use_class/1:                           Documentation on new declarations (objects).
* use_module/1:                          Documentation on internals (modules).
* use_module/2:                          Documentation on internals (modules).
* use_package/1:                         Documentation on internals (loading_code).
* virtual/1:                             Documentation on new declarations (class).


File: ciao.info,  Node: Concept Definition Index,  Next: Global Index,  Prev: Declaration Definition Index,  Up: Top

Concept Definition Index
************************

* Menu:
                         
                         * &-Prolog:                              Acknowledgments.
* abort:                                 Options available during debugging.
* abstract methods:                      Documentation on new declarations (class).
* acceptable modes:                      Documentation on exports (assertions_props).
* acknowledgments:                       Acknowledgments.
* addmodule and pred(N) meta-arguments:  Usage and interface (class).
* Anne Mulkers:                          Acknowledgments.
* answer variable:                       Shell interaction.
* assertion body syntax:                 Documentation on exports (assertions_props).
* assertion language:                    Preprocessing programs.
* assertions:                            Using Ciao inside GNU emacs.
* attribute:                             Documentation on new declarations (class).
* attributed variables:                  Attributed variables.
* Austrian Research Institute for AI:    Acknowledgments.
* auto-fill:                             Using Ciao inside GNU emacs.
* auto-indentation:                      Using Ciao inside GNU emacs.
* binary directory:                      Un*x full installation instructions.
* break:                                 Options available during debugging.
* Bristol University:                    Acknowledgments.
* bugs, reporting:                       Reporting bugs.
* calls assertion:                       Documentation on new declarations (assertions).
* CGI executables:                       The script interpreter.
* change log:                            Using Ciao inside GNU emacs.
* change, author:                        Version control.
* change, comment:                       Version control.
* changing the executables used:         Setting the top-level and preprocessor executables.
* check assertion:                       Documentation on exports (assertions).
* checking the assertions:               Preprocessing programs.
* Christian Holzbauer:                   Acknowledgments.
* Ciao engine:                           Acknowledgments.
* Ciao engine builtins:                  *** PART II - The Ciao basic language (engine).
* Ciao preprocessor <1>:                 Preprocessing programs.
* Ciao preprocessor <2>:                 Using Ciao inside GNU emacs.
* Ciao preprocessor:                     Acknowledgments.
* Ciao top-level:                        Using Ciao inside GNU emacs.
* ciao, global description:              About the Ciao Prolog development system.
* ciao-users:                            Keeping up to date: the Ciao users mailing list.
* Ciao/Prolog mode version:              Getting the Ciao/Prolog mode version.
* client installation:                   Server installation under Windows.
* CLIP group:                            Acknowledgments.
* closed:                                Documentation on exports (data_facts).
* coloring, syntax:                      Using Ciao inside GNU emacs.
* command:                               Options available during debugging.
* comment assertion:                     Documentation on new declarations (assertions).
* comments, machine readable:            The Ciao assertion package.
* comp assertion:                        Documentation on new declarations (assertions).
* compatibility properties:              Defining properties.
* compiling:                             Loading debugging and compiling programs.
* compiling, Win32:                      Windows installation from the standard source distribution.
* computational cost:                    Preprocessing programs.
* concurrency:                           Concurrency/multithreading primitives.
* concurrent attribute:                  Documentation on new declarations (class).
* concurrent predicate:                  Fast/concurrent update of facts.
* constructor:                           Documentation on exports (class).
* consult mode:                          Marking modules and files for debugging.
* consulting:                            Loading debugging and compiling programs.
* creating executables:                  Loading debugging and compiling programs.
* creep:                                 Options available during debugging.
* csh-compatible shell <1>:              Un*x full installation instructions.
* csh-compatible shell:                  Un*x installation summary.
* current input stream:                  Documentation on exports (streams_basic).
* current output stream:                 Documentation on exports (streams_basic).
* Cygnus Win32:                          Windows installation from the standard source distribution.
* D.H.D. Warren:                         Acknowledgments.
* D.L. Bowen:                            Acknowledgments.
* Daniel Cabeza:                         Acknowledgments.
* data predicate:                        Fast/concurrent update of facts.
* database initialization:               Documentation on exports (persdbrt).
* debug options:                         Options available during debugging.
* debugger:                              The interactive debugger.
* debugging:                             Loading debugging and compiling programs.
* decl assertion:                        Documentation on new declarations (assertions).
* declarations, user defined:            Basic builtin directives.
* DECsystem-10 Prolog User's Manual:     Acknowledgments.
* destructor:                            Documentation on exports (class).
* determinacy:                           Preprocessing programs.
* downloading emacs <1>:                 Using the emacs environment under Windows.
* downloading emacs:                     Un*x full installation instructions.
* downloading, latest versions:          Downloading new versions.
* emacs mode:                            Using Ciao inside GNU emacs.
* emacs mode, loading several:           Coexistence with other Prolog interfaces.
* emacs, download <1>:                   Using the emacs environment under Windows.
* emacs, download:                       Un*x full installation instructions.
* emacs, under Win32:                    Using the emacs environment under Windows.
* engine directory:                      *** PART II - The Ciao basic language (engine).
* engine module:                         Pure Prolog package.
* Enrico Pontelli:                       Acknowledgments.
* entry assertion:                       Documentation on new declarations (assertions).
* environment variable definitions:      Un*x installation summary.
* environment variables:                 Installation of the Ciao/Prolog emacs interface.
* equi join in the WHERE-clause:         Documentation on internals (pl2sql).
* executable:                            Building executables.
* executables, dynamic:                  Types of executables generated.
* executables, how to run:               Running the executables generated by the compiler.
* executables, lazy load:                Types of executables generated.
* executables, static:                   Types of executables generated.
* executables, types:                    Types of executables generated.
* existential quantification:            Documentation on exports (pl2sql).
* F.C.N. Pereira:                        Acknowledgments.
* fail:                                  Options available during debugging.
* false assertion:                       Documentation on exports (assertions).
* formatting commands:                   Some attention points.
* Francisco Bueno:                       Acknowledgments.
* Gerda Janssens:                        Acknowledgments.
* German Puebla:                         Acknowledgments.
* Gopal Gupta:                           Acknowledgments.
* granularity control:                   Preprocessing programs.
* H. Ait-Kaci:                           Entering recursive (conjunctive) shell levels.
* hard side-effects:                     Documentation on exports (native_props).
* independent:                           Documentation on exports (andprolog).
* Inference of properties:               Preprocessing programs.
* INFOPATH:                              Un*x full installation instructions.
* inheritable interface:                 Documentation on new declarations (class).
* inheritance relationship:              Documentation on new declarations (class).
* initialization clauses:                Documentation on new declarations (class).
* INRIA:                                 Acknowledgments.
* installation, checking the:            Checking for correct installation.
* installation, network based:           Un*x full installation instructions.
* installation, Un*x, full instructions: Un*x full installation instructions.
* installation, Un*x, summary:           Un*x installation summary.
* installation, Windows clients:         Server installation under Windows.
* installation, Windows server:          Server installation under Windows.
* installation, Windows, from binaries:  Installation and compilation under Windows.
* installation, Windows, from sources:   Windows installation from the standard source distribution.
* instantiation properties:              Defining properties.
* interface inheritance:                 Documentation on new declarations (class).
* interfaces:                            Declaring classes and interfaces.
* iso:                                   *** PART III - ISO-Prolog library (iso).
* ISO-Prolog <1>:                        Documentation on exports (arithmetic).
* ISO-Prolog:                            ISO-Prolog compliance.
* ISO-Prolog builtins:                   *** PART III - ISO-Prolog library (iso).
* iso-prolog, compliance:                ISO-Prolog compliance.
* Jan Maluzynski:                        Acknowledgments.
* Johan Andersson:                       Acknowledgments (ciao.el).
* Johan Bevemyr:                         Acknowledgments (ciao.el).
* Johan Widen:                           Acknowledgments.
* John Gallagher:                        Acknowledgments.
* K.U. Leuven:                           Acknowledgments.
* Kalyan Muthukumar:                     Acknowledgments.
* Kevin Greene:                          Acknowledgments.
* key sequences:                         Functionality and associated key sequences (bindings).
* keyboard:                              Characters and character strings.
* Kim Marriott:                          Acknowledgments.
* L. Byrd:                               Acknowledgments.
* L.M. Pereira:                          Acknowledgments.
* leap:                                  Options available during debugging.
* lib library:                           *** PART II - The Ciao basic language (engine).
* library directory:                     Un*x full installation instructions.
* Linkoping U.:                          Acknowledgments.
* loading programs:                      Loading debugging and compiling programs.
* locating errors:                       Locating errors and checking the syntax of assertions.
* LogIn:                                 Entering recursive (conjunctive) shell levels.
* mailing list:                          Keeping up to date: the Ciao users mailing list.
* MANPATH:                               Un*x full installation instructions.
* manual, printing:                      Getting started after Windows installation.
* Manuel Carro:                          Acknowledgments.
* Manuel Hermenegildo:                   Acknowledgments.
* Maria Jose Garcia de la Banda:         Acknowledgments.
* Masanobu Umeda:                        Acknowledgments (ciao.el).
* Mats Carlsson <1>:                     Acknowledgments (ciao.el).
* Mats Carlsson:                         Acknowledgments.
* Maurice Bruynooghe:                    Acknowledgments.
* MCC:                                   Acknowledgments.
* Melbourne U.:                          Acknowledgments.
* modes:                                 Preprocessing programs.
* modular interface:                     Intermediate files in the compilation process.
* module qualification:                  The module system.
* Monash U.:                             Acknowledgments.
* moving change log entries:             Version control.
* multi-evaluated:                       Documentation on new declarations (class).
* multiarchitecture support:             Multiarchitecture support.
* New Mexico State University:           Acknowledgments.
* non-failure:                           Preprocessing programs.
* nospy:                                 Options available during debugging.
* notation:                              Syntax terminology and notational conventions.
* overriden:                             Documentation on new declarations (class).
* P. Lincoln:                            Entering recursive (conjunctive) shell levels.
* parallel Prolog:                       Acknowledgments.
* parallelizing compiler:                Acknowledgments.
* parametric property:                   Documentation on internals (meta_props).
* parametric regular type abstractions:  Documentation on internals (meta_props).
* parametric type functor:               Documentation on new declarations (regtypes).
* PATH:                                  Un*x full installation instructions.
* path alias:                            Documentation on exports (streams_basic).
* patterns:                              Pattern (regular expression) matching.
* Pawel Pietrzak:                        Acknowledgments.
* Pedro Lopez:                           Acknowledgments.
* Peter Olin:                            Acknowledgments (ciao.el).
* Peter Stuckey:                         Acknowledgments.
* Pierre Deransart:                      Acknowledgments.
* Polymorphism:                          Object oriented programming.
* pred assertion:                        Documentation on new declarations (assertions).
* preprocessing programs:                Preprocessing programs.
* preprocessor command args, setting:    Setting the top-level and preprocessor executables.
* preprocessor command, setting:         Setting the top-level and preprocessor executables.
* printdepth:                            Options available during debugging.
* printing, manual:                      Getting started after Windows installation.
* program development environment:       Using Ciao inside GNU emacs.
* program parallelization:               Preprocessing programs.
* program specialization:                Preprocessing programs.
* program transformations <1>:           Preprocessing programs.
* program transformations:               Using Ciao inside GNU emacs.
* prolog flag <1>:                       Documentation on exports (io_aux).
* prolog flag:                           Changing system behaviour and various flags.
* Prolog shell scripts:                  The script interpreter.
* prop assertion:                        Documentation on new declarations (assertions).
* properties of computations:            Defining properties.
* properties of execution states:        Defining properties.
* properties, basic:                     Basic data types and properties.
* properties, native:                    Properties which are native to analyzers.
* property abstraction:                  Documentation on internals (meta_props).
* protected:                             Documentation on new declarations (class).
* public domain <1>:                     Summary.
* public domain:                         (none).
* public interface:                      Documentation on new declarations (class).
* pure Prolog:                           Pure Prolog package.
* query:                                 Shell interaction.
* records:                               *** PART VII - Ciao Prolog extensions.
* recursive level:                       Entering recursive (conjunctive) shell levels.
* regtype assertion:                     Documentation on new declarations (regtypes).
* regular expressions:                   Pattern (regular expression) matching.
* regular type expression:               Documentation on new declarations (regtypes).
* reporting bugs:                        Reporting bugs.
* retry:                                 Options available during debugging.
* Roger Nasr <1>:                        Entering recursive (conjunctive) shell levels.
* Roger Nasr:                            Acknowledgments.
* run-time checks:                       Run-time checking of assertions.
* run-time tests:                        Preprocessing programs.
* Saumya Debray:                         Acknowledgments.
* scripts:                               Un*x full installation instructions.
* Seif Haridi:                           Acknowledgments.
* sh-compatible shell <1>:               Un*x full installation instructions.
* sh-compatible shell:                   Un*x installation summary.
* sharing sets:                          Documentation on exports (native_props).
* shortcut, windows:                     Installation of the precompiled distribution.
* SICS <1>:                              Acknowledgments (ciao.el).
* SICS:                                  Acknowledgments.
* SICStus Prolog:                        Acknowledgments.
* sizes of terms:                        Preprocessing programs.
* skip:                                  Options available during debugging.
* soft side-effects:                     Documentation on exports (native_props).
* source directory:                      Un*x full installation instructions.
* specifications:                        Preprocessing programs.
* spy:                                   Options available during debugging.
* standard total ordering:               Comparing terms.
* static checks:                         Using Ciao inside GNU emacs.
* static debugging:                      Preprocessing programs.
* style sheets:                          Getting started after Windows installation.
* subterm:                               Options available during debugging.
* success assertion:                     Documentation on new declarations (assertions).
* super class:                           Documentation on new declarations (class).
* Swedish Institute of Computer Science: Acknowledgments.
* Syntax highlighting:                   Using Ciao inside GNU emacs.
* tar:                                   Un*x full installation instructions.
* Technical University of Madrid:        Acknowledgments.
* toplevel command args, setting:        Setting the top-level and preprocessor executables.
* toplevel command, setting:             Setting the top-level and preprocessor executables.
* troubleshooting <1>:                   Troubleshooting (nasty messages and nifty workarounds).
* troubleshooting:                       Installing Ciao.
* true assertion:                        Documentation on exports (assertions).
* trust assertion:                       Documentation on exports (assertions).
* types:                                 Preprocessing programs.
* U. of Arizona:                         Acknowledgments.
* unify:                                 Options available during debugging.
* uninstalling <1>:                      Un*x full installation instructions.
* uninstalling:                          Un*x installation summary.
* UPM:                                   Acknowledgments.
* user module:                           The module system.
* users mailing list:                    Keeping up to date: the Ciao users mailing list.
* variable instantiation:                Preprocessing programs.
* Veroniek Dumortier:                    Acknowledgments.
* version control:                       Using Ciao inside GNU emacs.
* version maintenance mode for packages: Version control.
* version number:                        Version control.
* virtual:                               Documentation on new declarations (class).
* WAM:                                   Acknowledgments.
* windows shortcut:                      Installation of the precompiled distribution.
* Wlodek Drabent:                        Acknowledgments.
* writing programs:                      Commands which help in typing in programs.
* WWW, interfacing with:                 Connecting with the Web.


File: ciao.info,  Node: Global Index,  Prev: Concept Definition Index,  Up: Top

Global Index
************

                            This is a global index containing
pointers to places where concepts,  predicates, modes, properties,
types, applications, etc., are referred to  in the text of the
document. Note that due to limitations of the  `info' format
unfortunately only the first reference will appear in  online
versions of the document.

* Menu:
                         
                         * !/0 <1>:                               Documentation on exports (basiccontrol).
* !/0:                                   Usage and interface (basiccontrol).
* # /2:                                  Documentation on exports (arithmetic).
* $/1:                                   Usage and interface (pillow).
* $/2 <1>:                               Usage and interface (pillow).
* $/2:                                   Usage and interface (argnames).
* $is_persistent/2 <1>:                  Documentation on multifiles (persdbrt).
* $is_persistent/2:                      Usage and interface (persdbrt).
* &-Prolog <1>:                          Acknowledgments (ciao.el).
* &-Prolog:                              Acknowledgments.
* &/2:                                   Documentation on exports (andprolog).
* ','/2:                                 Documentation on exports (basic_props).
* '<-'/1:                                Breadth-first execution.
* '<-'/2:                                Breadth-first execution.
* * /2:                                  Documentation on exports (arithmetic).
* * projection:                          Documentation on internals (pl2sql).
* ** /2:                                 Documentation on exports (arithmetic).
* */1 <1>:                               Documentation on new modes (isomodes).
* */1:                                   Usage and interface (isomodes).
* */2 <1>:                               Documentation on new modes (isomodes).
* */2 <2>:                               Usage and interface (isomodes).
* */2:                                   Documentation on exports (assertions_props).
* *assertion language*:                  Modes.
* *mode*:                                Modes.
* *predicate spec*:                      Predicate specs.
* + /1:                                  Documentation on exports (arithmetic).
* + /2:                                  Documentation on exports (arithmetic).
* ++ /1:                                 Documentation on exports (arithmetic).
* +/1 <1>:                               Documentation on new modes (basicmodes).
* +/1 <2>:                               Usage and interface (basicmodes).
* +/1 <3>:                               Documentation on new modes (isomodes).
* +/1 <4>:                               Usage and interface (isomodes).
* +/1:                                   Documentation on exports (assertions_props).
* +/2 <1>:                               Documentation on new modes (basicmodes).
* +/2 <2>:                               Usage and interface (basicmodes).
* +/2 <3>:                               Documentation on new modes (isomodes).
* +/2:                                   Usage and interface (isomodes).
* ,/2 <1>:                               Documentation on exports (basiccontrol).
* ,/2:                                   Usage and interface (basiccontrol).
* - /1:                                  Documentation on exports (arithmetic).
* - /2:                                  Documentation on exports (arithmetic).
* -- /1:                                 Documentation on exports (arithmetic).
* -->/2:                                 Usage and interface (classic).
* -/1 <1>:                               Documentation on new modes (basicmodes).
* -/1 <2>:                               Usage and interface (basicmodes).
* -/1 <3>:                               Documentation on new modes (isomodes).
* -/1:                                   Usage and interface (isomodes).
* -/2 <1>:                               Documentation on new modes (basicmodes).
* -/2 <2>:                               Usage and interface (basicmodes).
* -/2 <3>:                               Documentation on new modes (isomodes).
* -/2:                                   Usage and interface (isomodes).
* ->/2 <1>:                              Documentation on exports (basiccontrol).
* ->/2:                                  Usage and interface (basiccontrol).
* ./2 <1>:                               Documentation on exports (ciaosh).
* ./2:                                   Usage and interface (ciaosh).
* .bat:                                  Running the executables generated by the compiler.
* .ciaorc <1>:                           Getting started after Windows installation.
* .ciaorc:                               Shell invocation and startup.
* .emacs <1>:                            Getting started after Windows installation.
* .emacs:                                Installation of the Ciao/Prolog emacs interface.
* .tar files:                            Gathering the dependent files for a file.
* / /2:                                  Documentation on exports (arithmetic).
* // /2:                                 Documentation on exports (arithmetic).
* /\ /2:                                 Documentation on exports (arithmetic).
* /bin/sh:                               Documentation on exports (system).
* /bin/sh.exe:                           Windows installation from the standard source distribution.
* /etc/bashrc <1>:                       Un*x full installation instructions.
* /etc/bashrc:                           Un*x installation summary.
* /etc/csh.cshrc <1>:                    Un*x full installation instructions.
* /etc/csh.cshrc:                        Un*x installation summary.
* /etc/cshrc <1>:                        Un*x full installation instructions.
* /etc/cshrc:                            Un*x installation summary.
* /usr/share/emacs/.../lisp/site-init.pl <1>: Un*x full installation instructions.
* /usr/share/emacs/.../lisp/site-init.pl: Un*x installation summary.
* ::/2:                                  Usage and interface (assertions).
* :=/2:                                  Usage and interface (functions).
* ;/2 <1>:                               Documentation on exports (basiccontrol).
* ;/2:                                   Usage and interface (basiccontrol).
* <-/1:                                  Usage and interface (bf).
* <-/2:                                  Usage and interface (bf).
* </2 <1>:                               Documentation on exports (arithmetic).
* </2:                                   Usage and interface (arithmetic).
* << /2:                                 Documentation on exports (arithmetic).
* <LIBROOT>/ciao/DOTcshrc:               Multiarchitecture support.
* =../2 <1>:                             Documentation on exports (term_basic).
* =../2:                                 Usage and interface (term_basic).
* =/2 <1>:                               Documentation on exports (term_basic).
* =/2:                                   Usage and interface (term_basic).
* =:=/2 <1>:                             Documentation on exports (arithmetic).
* =:=/2:                                 Usage and interface (arithmetic).
* =</2 <1>:                              Documentation on exports (arithmetic).
* =</2:                                  Usage and interface (arithmetic).
* ==/2 <1>:                              Documentation on exports (term_compare).
* ==/2:                                  Usage and interface (term_compare).
* =>/2 <1>:                              Documentation on exports (andprolog).
* =>/2 <2>:                              Usage and interface (andprolog).
* =>/2 <3>:                              Usage and interface (argnames).
* =>/2:                                  Usage and interface (assertions).
* =\=/2 <1>:                             Documentation on exports (arithmetic).
* =\=/2:                                 Usage and interface (arithmetic).
* >/2 <1>:                               Documentation on exports (arithmetic).
* >/2:                                   Usage and interface (arithmetic).
* >=/2 <1>:                              Documentation on exports (arithmetic).
* >=/2:                                  Usage and interface (arithmetic).
* >> /2:                                 Documentation on exports (arithmetic).
* ?/1 <1>:                               Documentation on new modes (basicmodes).
* ?/1 <2>:                               Usage and interface (basicmodes).
* ?/1 <3>:                               Documentation on new modes (isomodes).
* ?/1:                                   Usage and interface (isomodes).
* ?/2 <1>:                               Documentation on new modes (basicmodes).
* ?/2 <2>:                               Usage and interface (basicmodes).
* ?/2 <3>:                               Documentation on new modes (isomodes).
* ?/2:                                   Usage and interface (isomodes).
* @/1 <1>:                               Documentation on new modes (basicmodes).
* @/1 <2>:                               Usage and interface (basicmodes).
* @/1 <3>:                               Documentation on new modes (isomodes).
* @/1:                                   Usage and interface (isomodes).
* @/2 <1>:                               Documentation on new modes (basicmodes).
* @/2 <2>:                               Usage and interface (basicmodes).
* @/2 <3>:                               Documentation on new modes (isomodes).
* @/2:                                   Usage and interface (isomodes).
* @</2 <1>:                              Documentation on exports (term_compare).
* @</2:                                  Usage and interface (term_compare).
* @=</2 <1>:                             Documentation on exports (term_compare).
* @=</2:                                 Usage and interface (term_compare).
* @>/2 <1>:                              Documentation on exports (term_compare).
* @>/2:                                  Usage and interface (term_compare).
* @>=/2 <1>:                             Documentation on exports (term_compare).
* @>=/2:                                 Usage and interface (term_compare).
* \ /1:                                  Documentation on exports (arithmetic).
* \+/1 <1>:                              Documentation on exports (basiccontrol).
* \+/1:                                  Usage and interface (basiccontrol).
* \/ /2:                                 Documentation on exports (arithmetic).
* \=/2:                                  Documentation on exports (iso_misc).
* \==/2 <1>:                             Documentation on exports (term_compare).
* \==/2:                                 Usage and interface (term_compare).
* ^/2 <1>:                               Documentation on exports (pl2sql).
* ^/2 <2>:                               Documentation on exports (aggregates).
* ^/2:                                   Usage and interface (aggregates).
* abolish/1 <1>:                         Documentation on exports (dynamic).
* abolish/1:                             Usage and interface (dynamic).
* abort:                                 Options available during debugging.
* abort/0:                               Documentation on exports (exceptions).
* abs/1:                                 Documentation on exports (arithmetic).
* absolute_file_name/2 <1>:              Operating system utilities.
* absolute_file_name/2 <2>:              Documentation on exports (streams_basic).
* absolute_file_name/2:                  Usage and interface (streams_basic).
* absolute_file_name/7 <1>:              Documentation on exports (streams_basic).
* absolute_file_name/7:                  Usage and interface (streams_basic).
* abstract methods:                      Documentation on new declarations (class).
* acceptable modes:                      Documentation on exports (assertions_props).
* ACCLAIM:                               Acknowledgments.
* acknowledgments:                       Acknowledgments.
* acrobat reader:                        Getting started after Windows installation.
* active module:                         Documentation on exports (ciaosh).
* active_agents/1 <1>:                   Documentation on exports (andprolog).
* active_agents/1:                       Usage and interface (andprolog).
* activemod:                             Loading debugging and compiling programs.
* actmods/actmodrt:                      Usage and interface (actmods).
* add_after/4 <1>:                       Documentation on exports (idlists).
* add_after/4 <2>:                       Usage and interface (idlists).
* add_after/4 <3>:                       Documentation on exports (lists).
* add_after/4:                           Usage and interface (lists).
* add_before/4 <1>:                      Documentation on exports (idlists).
* add_before/4 <2>:                      Usage and interface (idlists).
* add_before/4:                          Documentation on exports (lists).
* add_clause_trans/1:                    Documentation on internals (syntax_extensions).
* add_goal_trans/1:                      Documentation on internals (syntax_extensions).
* add_sentence_trans/1:                  Documentation on internals (syntax_extensions).
* add_term_trans/1:                      Documentation on internals (syntax_extensions).
* addmodule and pred(N) meta-arguments:  Usage and interface (class).
* aggregate function (sub)queries:       Documentation on internals (pl2sql).
* aggregate function terms:              Documentation on internals (pl2sql).
* aggregate_function/3:                  Documentation on internals (pl2sql).
* aggregate_functor/2 <1>:               Documentation on internals (pl2sql).
* aggregate_functor/2:                   Documentation on exports (pl2sql).
* aggregates <1>:                        Usage and interface (pl2sql).
* aggregates <2>:                        Usage and interface (persdbrtsql).
* aggregates <3>:                        Usage and interface (foreign_interface).
* aggregates <4>:                        Usage and interface (actmods).
* aggregates <5>:                        Usage and interface (functions).
* aggregates <6>:                        Usage and interface (argnames).
* aggregates <7>:                        conc_aggregates (library).
* aggregates <8>:                        Usage and interface (runtime_ops).
* aggregates <9>:                        Usage and interface (dynmods).
* aggregates <10>:                       Usage and interface (iso).
* aggregates:                            Usage and interface (debugger).
* aggregation operations:                SQL persistent database interface.
* aggregation predicates:                Documentation on exports (aggregates).
* analyzer output:                       Documentation on exports (assertions).
* andprolog/andprolog:                   Usage and interface (native_props).
* Anne Mulkers:                          Acknowledgments.
* answer variable:                       Shell interaction.
* answertableterm:                       Documentation on exports (db_client).
* answertableterm/1 <1>:                 Documentation on exports (db_client).
* answertableterm/1 <2>:                 Usage and interface (db_client).
* answertableterm/1:                     Documentation on exports (persdbrtsql).
* answertupleterm/1 <1>:                 Documentation on exports (db_client).
* answertupleterm/1:                     Usage and interface (db_client).
* append/3 <1>:                          Documentation on exports (lists).
* append/3:                              Usage and interface (lists).
* apropos/1 <1>:                         Documentation on exports (librowser).
* apropos/1:                             Usage and interface (librowser).
* apropos_spec/1:                        Documentation on internals (librowser).
* arg/2:                                 Documentation on exports (terms).
* arg/3 <1>:                             Documentation on exports (term_basic).
* arg/3:                                 Usage and interface (term_basic).
* arg_expander/6 <1>:                    Documentation on exports (expansion_tools).
* arg_expander/6:                        Usage and interface (expansion_tools).
* argnames/1:                            Usage and interface (argnames).
* arithexpression/1 <1>:                 Documentation on exports (arithmetic).
* arithexpression/1 <2>:                 Usage and interface (arithmetic).
* arithexpression/1:                     Arithmetic.
* arithmetic goal:                       Documentation on internals (pl2sql).
* arithmetic_functor/2 <1>:              Documentation on internals (pl2sql).
* arithmetic_functor/2:                  Documentation on exports (pl2sql).
* ASCII code:                            Documentation on exports (arithmetic).
* ask/2:                                 Documentation on exports (metaterms).
* assert/1 <1>:                          Documentation on exports (dynamic).
* assert/1:                              Usage and interface (dynamic).
* assert/2 <1>:                          Documentation on exports (dynamic).
* assert/2:                              Usage and interface (dynamic).
* asserta/1 <1>:                         Documentation on exports (dynamic).
* asserta/1:                             Usage and interface (dynamic).
* asserta/2 <1>:                         Documentation on exports (dynamic).
* asserta/2:                             Usage and interface (dynamic).
* asserta_fact/1 <1>:                    Documentation on exports (data_facts).
* asserta_fact/1:                        Usage and interface (data_facts).
* asserta_fact/2 <1>:                    Documentation on exports (data_facts).
* asserta_fact/2:                        Usage and interface (data_facts).
* assertion body syntax:                 Documentation on exports (assertions_props).
* assertion language:                    Preprocessing programs.
* assertion normalizer:                  Printing the declarations and code in a file.
* assertions <1>:                        Types and properties related to assertions.
* assertions <2>:                        Usage and interface (assertions).
* assertions <3>:                        The Ciao assertion package.
* assertions <4>:                        Version control.
* assertions:                            Using Ciao inside GNU emacs.
* assertions/assertions_props <1>:       Usage and interface (regtypes).
* assertions/assertions_props:           Usage and interface (assertions).
* assertions/assrt_lib <1>:              Usage and interface (foreign_interface).
* assertions/assrt_lib:                  Usage and interface (assrt_write).
* assertions/assrt_props:                Usage and interface (assrt_write).
* assertions/doc_props <1>:              Usage and interface (andprolog).
* assertions/doc_props <2>:              Usage and interface (format).
* assertions/doc_props <3>:              Usage and interface (dcg_expansion).
* assertions/doc_props <4>:              Usage and interface (read).
* assertions/doc_props <5>:              Usage and interface (dynamic).
* assertions/doc_props:                  Usage and interface (operators).
* assertions/meta_props <1>:             Usage and interface (messages).
* assertions/meta_props <2>:             Usage and interface (rtchecks).
* assertions/meta_props <3>:             Usage and interface (basicmodes).
* assertions/meta_props:                 Usage and interface (isomodes).
* assertz/1 <1>:                         Documentation on exports (dynamic).
* assertz/1:                             Usage and interface (dynamic).
* assertz/2 <1>:                         Documentation on exports (dynamic).
* assertz/2:                             Usage and interface (dynamic).
* assertz_fact/1 <1>:                    Documentation on exports (persdbrtsql).
* assertz_fact/1 <2>:                    SQL persistent database interface.
* assertz_fact/1 <3>:                    Documentation on exports (persdbrt).
* assertz_fact/1 <4>:                    Introduction to persistent predicates.
* assertz_fact/1 <5>:                    Documentation on exports (data_facts).
* assertz_fact/1:                        Usage and interface (data_facts).
* assertz_fact/2 <1>:                    Documentation on exports (data_facts).
* assertz_fact/2:                        Usage and interface (data_facts).
* assrt_body/1 <1>:                      Documentation on exports (assertions_props).
* assrt_body/1 <2>:                      Usage and interface (assertions_props).
* assrt_body/1:                          Documentation on new declarations (assertions).
* assrt_status/1 <1>:                    Documentation on exports (assertions_props).
* assrt_status/1:                        Usage and interface (assertions_props).
* assrt_type/1 <1>:                      Documentation on exports (assertions_props).
* assrt_type/1:                          Usage and interface (assertions_props).
* atan/1:                                Documentation on exports (arithmetic).
* atm/1 <1>:                             Documentation on exports (basic_props).
* atm/1:                                 Usage and interface (basic_props).
* atm_or_atm_list/1 <1>:                 Documentation on exports (basic_props).
* atm_or_atm_list/1:                     Usage and interface (basic_props).
* atom/1 <1>:                            Documentation on exports (term_typing).
* atom/1:                                Usage and interface (term_typing).
* atom2term:                             Usage and interface (jtopl).
* atom2term/2 <1>:                       Documentation on exports (atom2term).
* atom2term/2:                           Usage and interface (atom2term).
* atom_chars/2:                          Documentation on exports (iso_byte_char).
* atom_codes/2 <1>:                      Documentation on exports (atomic_basic).
* atom_codes/2:                          Usage and interface (atomic_basic).
* atom_concat/2:                         Documentation on exports (terms).
* atom_concat/3 <1>:                     Documentation on exports (atomic_basic).
* atom_concat/3:                         Usage and interface (atomic_basic).
* atom_length/2 <1>:                     Documentation on exports (atomic_basic).
* atom_length/2:                         Usage and interface (atomic_basic).
* atom_lock_state/2 <1>:                 Documentation on exports (concurrency).
* atom_lock_state/2:                     Usage and interface (concurrency).
* Atomic goals:                          Documentation on exports (pl2sql).
* atomic/1 <1>:                          Documentation on exports (term_typing).
* atomic/1:                              Usage and interface (term_typing).
* attach_attribute/2 <1>:                Documentation on exports (attributes).
* attach_attribute/2:                    Usage and interface (attributes).
* attribute:                             Documentation on new declarations (class).
* attribute/4 <1>:                       Documentation on multifiles (pl2sql).
* attribute/4 <2>:                       Documentation on exports (pl2sql).
* attribute/4 <3>:                       Usage and interface (pl2sql).
* attribute/4:                           Prolog to SQL translator.
* attributed variables:                  Attributed variables.
* attributes:                            Documentation on exports (term_basic).
* Austrian Research Institute for AI:    Acknowledgments.
* auto-fill:                             Using Ciao inside GNU emacs.
* auto-indentation:                      Using Ciao inside GNU emacs.
* backup file:                           Implementation Issues.
* bagof/3 <1>:                           Known bugs and planned improvements (conc_aggregates).
* bagof/3 <2>:                           Documentation on exports (aggregates).
* bagof/3:                               Usage and interface (aggregates).
* basename/2 <1>:                        Documentation on exports (filenames).
* basename/2:                            Usage and interface (filenames).
* bash <1>:                              Windows installation from the standard source distribution.
* bash <2>:                              Un*x full installation instructions.
* bash <3>:                              Un*x installation summary.
* bash <4>:                              Installation of the Ciao/Prolog emacs interface.
* bash:                                  Running the executables generated by the compiler.
* basic_props:regtype/1:                 Declaring regular types.
* between:                               Usage and interface (iso_misc).
* binary directory:                      Un*x full installation instructions.
* bind_socket/3 <1>:                     Documentation on exports (sockets).
* bind_socket/3:                         Usage and interface (sockets).
* body/1:                                Documentation on internals (pretty_print).
* body_expander/6 <1>:                   Documentation on exports (expansion_tools).
* body_expander/6:                       Usage and interface (expansion_tools).
* break:                                 Options available during debugging.
* Bristol University:                    Acknowledgments.
* browse/2 <1>:                          Documentation on exports (librowser).
* browse/2:                              Usage and interface (librowser).
* buffer:                                Installation of the Ciao/Prolog emacs interface.
* bugs, reporting:                       Reporting bugs.
* build_foreign_interface/1 <1>:         Documentation on exports (foreign_interface).
* build_foreign_interface/1 <2>:         Usage and interface (foreign_interface).
* build_foreign_interface/1:             Foreign interface.
* build_foreign_interface_explicit_decls/2 <1>: Documentation on exports (foreign_interface).
* build_foreign_interface_explicit_decls/2: Usage and interface (foreign_interface).
* build_foreign_interface_object/1 <1>:  Documentation on exports (foreign_interface).
* build_foreign_interface_object/1:      Usage and interface (foreign_interface).
* building standalone distributions:     Gathering the dependent files for a file.
* builtin directives <1>:                Extending the syntax.
* builtin directives:                    Basic builtin directives.
* builtin modules:                       The module system.
* byte_list/1:                           Equivalence between Ciao Prolog and C types.
* bytecode object files:                 Un*x full installation instructions.
* C:                                     Un*x full installation instructions.
* C/3 <1>:                               Documentation on exports (term_basic).
* C/3:                                   Usage and interface (term_basic).
* c:/.emacs:                             Using the emacs environment under Windows.
* c_assrt_body/1 <1>:                    Documentation on exports (assertions_props).
* c_assrt_body/1:                        Usage and interface (assertions_props).
* c_itf:                                 Code translation utilities.
* call/1 <1>:                            Documentation on exports (assertions_props).
* call/1 <2>:                            Documentation on exports (basiccontrol).
* call/1:                                Usage and interface (basiccontrol).
* call/2 <1>:                            Documentation on exports (meta_props).
* call/2 <2>:                            Usage and interface (meta_props).
* call/2 <3>:                            Documentation on internals (basiccontrol).
* call/2:                                Documentation on internals (modules).
* call/N:                                Documentation on internals (basiccontrol).
* call_in_module/2 <1>:                  Documentation on exports (debugger).
* call_in_module/2:                      Usage and interface (debugger).
* callable/1 <1>:                        Documentation on exports (basic_props).
* callable/1:                            Usage and interface (basic_props).
* callme/2 <1>:                          Documentation on multifiles (messages).
* callme/2 <2>:                          Usage and interface (messages).
* callme/2 <3>:                          Documentation on multifiles (rtchecks).
* callme/2 <4>:                          Usage and interface (rtchecks).
* callme/2 <5>:                          Documentation on multifiles (meta_props).
* callme/2:                              Usage and interface (meta_props).
* calls assertion:                       Documentation on new declarations (assertions).
* calls/1 <1>:                           Documentation on new declarations (assertions).
* calls/1:                               Usage and interface (assertions).
* calls/2 <1>:                           Documentation on new declarations (assertions).
* calls/2:                               Usage and interface (assertions).
* case_insensitive_match/2 <1>:          Documentation on exports (patterns).
* case_insensitive_match/2:              Usage and interface (patterns).
* catch/3 <1>:                           Documentation on exports (exceptions).
* catch/3:                               Usage and interface (exceptions).
* cd/1 <1>:                              Getting started after Windows installation.
* cd/1 <2>:                              Documentation on exports (system).
* cd/1:                                  Usage and interface (system).
* ceiling/1:                             Documentation on exports (arithmetic).
* CGI executables:                       The script interpreter.
* change log:                            Using Ciao inside GNU emacs.
* change, author:                        Version control.
* change, comment:                       Version control.
* changelog entry:                       Version control.
* changing the executables used:         Setting the top-level and preprocessor executables.
* char_code/2:                           Documentation on exports (iso_byte_char).
* char_conversion/2:                     Extending the syntax.
* character string:                      Some attention points.
* character_code/1 <1>:                  Documentation on exports (basic_props).
* character_code/1:                      Usage and interface (basic_props).
* character_count/2 <1>:                 Documentation on exports (streams_basic).
* character_count/2:                     Usage and interface (streams_basic).
* check assertion <1>:                   Documentation on exports (rtchecks).
* check assertion:                       Documentation on exports (assertions).
* check/1 <1>:                           Documentation on exports (rtchecks).
* check/1 <2>:                           Usage and interface (rtchecks).
* check/1 <3>:                           Documentation on exports (assertions).
* check/1:                               Usage and interface (assertions).
* checking the assertions:               Preprocessing programs.
* chmod/2 <1>:                           Documentation on exports (system).
* chmod/2:                               Usage and interface (system).
* chmod/3 <1>:                           Documentation on exports (system).
* chmod/3:                               Usage and interface (system).
* Christian Holzbauer:                   Acknowledgments.
* ciao <1>:                              Checking for correct installation.
* ciao <2>:                              Using the emacs environment under Windows.
* ciao <3>:                              Un*x full installation instructions.
* ciao:                                  Installation of the Ciao/Prolog emacs interface.
* Ciao engine <1>:                       Types of executables generated.
* Ciao engine <2>:                       Running the executables generated by the compiler.
* Ciao engine:                           Acknowledgments.
* CIAO engine builtins:                  Documentation on multifiles (streams_basic).
* Ciao engine builtins:                  *** PART II - The Ciao basic language (engine).
* Ciao preprocessor <1>:                 Preprocessing programs.
* Ciao preprocessor <2>:                 Using Ciao inside GNU emacs.
* Ciao preprocessor:                     Acknowledgments.
* Ciao top-level:                        Using Ciao inside GNU emacs.
* ciao, global description:              About the Ciao Prolog development system.
* ciao-shell <1>:                        Checking for correct installation.
* ciao-shell <2>:                        Un*x full installation instructions.
* ciao-shell <3>:                        Customizing library paths and path aliases.
* ciao-shell <4>:                        How it works.
* ciao-shell:                            The script interpreter.
* ciao-users:                            Keeping up to date: the Ciao users mailing list.
* ciao.el:                               Un*x full installation instructions.
* ciao.html:                             Installation of the precompiled distribution.
* ciao.reg:                              Uninstallation under Windows.
* Ciao/Prolog mode version:              Getting the Ciao/Prolog mode version.
* ciaoc <1>:                             Porting to currently unsupported operating systems.
* ciaoc <2>:                             Checking for correct installation.
* ciaoc <3>:                             Starting executables from the Windows command line.
* ciaoc <4>:                             Un*x full installation instructions.
* ciaoc <5>:                             Basic builtin directives.
* ciaoc <6>:                             Customizing library paths and path aliases.
* ciaoc <7>:                             Usage (ciaoc).
* ciaoc <8>:                             Types of executables generated.
* ciaoc <9>:                             Building executables.
* ciaoc:                                 The stand-alone command-line compiler.
* ciaoc.cpx <1>:                         Checking for correct installation.
* ciaoc.cpx:                             Getting started after Windows installation.
* ciaolibdir/1 <1>:                      Documentation on exports (system_info).
* ciaolibdir/1:                          Usage and interface (system_info).
* ciaopp <1>:                            Properties which are native to analyzers.
* ciaopp <2>:                            Preprocessing programs.
* ciaopp <3>:                            Using Ciao inside GNU emacs.
* ciaopp <4>:                            The interactive debugger.
* ciaopp <5>:                            Types of executables generated.
* ciaopp <6>:                            *** PART I - The program development environment.
* ciaopp <7>:                            Acknowledgments.
* ciaopp <8>:                            Summary.
* ciaopp:                                (none).
* ciaosh <1>:                            Porting to currently unsupported operating systems.
* ciaosh <2>:                            Checking for correct installation.
* ciaosh <3>:                            Usage and interface (librowser).
* ciaosh <4>:                            Using Ciao inside GNU emacs.
* ciaosh <5>:                            Customizing library paths and path aliases.
* ciaosh <6>:                            The interactive top-level shell.
* ciaosh:                                *** PART I - The program development environment.
* ciaosh.cpx <1>:                        Getting started after Windows installation.
* ciaosh.cpx:                            Installation of the precompiled distribution.
* CICYT/MEC:                             Acknowledgments.
* class constructor:                     Documentation on exports (objects_rt).
* class instances:                       Run time usage of objects.
* class_name/1 <1>:                      Documentation on exports (objects_rt).
* class_name/1 <2>:                      Usage and interface (objects_rt).
* class_name/1 <3>:                      Documentation on exports (objects).
* class_name/1:                          Usage and interface (objects).
* class_source/1 <1>:                    Documentation on exports (objects_rt).
* class_source/1 <2>:                    Usage and interface (objects_rt).
* class_source/1 <3>:                    Documentation on exports (objects).
* class_source/1:                        Usage and interface (objects).
* clause/1:                              Documentation on internals (pretty_print).
* clause/2 <1>:                          Documentation on exports (dynamic).
* clause/2:                              Usage and interface (dynamic).
* clause/3 <1>:                          Documentation on exports (dynamic).
* clause/3:                              Usage and interface (dynamic).
* clauses/1:                             Documentation on internals (pretty_print).
* clearerr/1 <1>:                        Documentation on exports (streams_basic).
* clearerr/1:                            Usage and interface (streams_basic).
* client installation:                   Server installation under Windows.
* client.bat:                            Server installation under Windows.
* CLIP group:                            Acknowledgments.
* close/1 <1>:                           Documentation on exports (db_client).
* close/1 <2>:                           Documentation on exports (system).
* close/1 <3>:                           Documentation on exports (streams_basic).
* close/1:                               Usage and interface (streams_basic).
* close/2:                               Documentation on exports (iso_incomplete).
* close_client/0:                        Documentation on exports (linda).
* close_file/1:                          Documentation on exports (dec10_io).
* close_input/1:                         Documentation on exports (streams).
* close_output/1:                        Documentation on exports (streams).
* close_predicate/1 <1>:                 Documentation on exports (data_facts).
* close_predicate/1:                     Usage and interface (data_facts).
* closed:                                Documentation on exports (data_facts).
* clterm/1:                              Documentation on internals (pretty_print).
* code_class/2 <1>:                      Documentation on exports (io_basic).
* code_class/2:                          Usage and interface (io_basic).
* coloring, syntax:                      Using Ciao inside GNU emacs.
* command:                               Options available during debugging.
* comment assertion:                     Documentation on new declarations (assertions).
* comment string:                        Documentation on exports (assertions_props).
* comment/2 <1>:                         Documentation on new declarations (assertions).
* comment/2 <2>:                         Usage and interface (assertions).
* comment/2:                             Version control.
* comments, machine readable:            The Ciao assertion package.
* comp assertion:                        Documentation on new declarations (assertions).
* comp/1 <1>:                            Documentation on exports (assertions_props).
* comp/1 <2>:                            Documentation on new declarations (assertions).
* comp/1:                                Usage and interface (assertions).
* comp/2 <1>:                            Documentation on new declarations (assertions).
* comp/2:                                Usage and interface (assertions).
* compare/3 <1>:                         Documentation on exports (term_compare).
* compare/3:                             Usage and interface (term_compare).
* comparison goal:                       Documentation on internals (pl2sql).
* comparison operations:                 Documentation on internals (pl2sql).
* comparison/2 <1>:                      Documentation on internals (pl2sql).
* comparison/2:                          Documentation on exports (pl2sql).
* compat/2 <1>:                          Documentation on exports (basic_props).
* compat/2:                              Usage and interface (basic_props).
* compatibility properties:              Defining properties.
* compatible:                            Documentation on exports (assertions_props).
* compile/1 <1>:                         Documentation on exports (ciaosh).
* compile/1:                             Usage and interface (ciaosh).
* compiler:                              Un*x full installation instructions.
* compiler/c_itf <1>:                    Usage and interface (foreign_interface).
* compiler/c_itf <2>:                    Usage and interface (expansion_tools).
* compiler/c_itf:                        Usage and interface (ciaosh).
* compiler/compiler <1>:                 Usage and interface (dynmods).
* compiler/compiler:                     Usage and interface (ciaosh).
* compiler/exemaker:                     Usage and interface (ciaosh).
* compiler_and_opts/2 <1>:               Documentation on exports (foreign_compilation).
* compiler_and_opts/2:                   Usage and interface (foreign_compilation).
* compiling:                             Loading debugging and compiling programs.
* compiling, Win32:                      Windows installation from the standard source distribution.
* complete_dict/3 <1>:                   Documentation on exports (vndict).
* complete_dict/3:                       Usage and interface (vndict).
* complete_vars_dict/3 <1>:              Documentation on exports (vndict).
* complete_vars_dict/3:                  Usage and interface (vndict).
* complex argument property:             Documentation on exports (assertions_props).
* complex goal property:                 Documentation on exports (assertions_props).
* complex_arg_property/1 <1>:            Documentation on exports (assertions_props).
* complex_arg_property/1:                Usage and interface (assertions_props).
* complex_goal_property/1 <1>:           Documentation on exports (assertions_props).
* complex_goal_property/1:               Usage and interface (assertions_props).
* compound/1:                            Documentation on exports (iso_misc).
* computational cost:                    Preprocessing programs.
* concurrency:                           Concurrency/multithreading primitives.
* concurrent:                            Documentation on exports (data_facts).
* concurrent attribute:                  Documentation on new declarations (class).
* concurrent predicate <1>:              Documentation on exports (data_facts).
* concurrent predicate:                  Fast/concurrent update of facts.
* concurrent predicates:                 Concurrency/multithreading primitives.
* concurrent updates <1>:                SQL persistent database interface.
* concurrent updates:                    Introduction to persistent predicates.
* concurrent/1 <1>:                      Documentation on new declarations (class).
* concurrent/1:                          Usage and interface (class).
* conjunctions:                          Documentation on exports (pl2sql).
* connect_to_socket/3 <1>:               Documentation on exports (db_client).
* connect_to_socket/3 <2>:               Documentation on exports (sockets).
* connect_to_socket/3:                   Usage and interface (sockets).
* connect_to_socket_type/4 <1>:          Documentation on exports (sockets).
* connect_to_socket_type/4:              Usage and interface (sockets).
* constant arguments:                    Documentation on internals (pl2sql).
* constant/1 <1>:                        Documentation on exports (basic_props).
* constant/1:                            Usage and interface (basic_props).
* constructor:                           Documentation on exports (class).
* constructor/0 <1>:                     Documentation on exports (class).
* constructor/0:                         Usage and interface (class).
* constructor/1 <1>:                     Documentation on exports (objects_rt).
* constructor/1 <2>:                     Usage and interface (objects_rt).
* constructor/1 <3>:                     Documentation on exports (objects).
* constructor/1:                         Usage and interface (objects).
* consult mode:                          Marking modules and files for debugging.
* consult/1 <1>:                         Documentation on exports (ciaosh).
* consult/1:                             Usage and interface (ciaosh).
* consulting:                            Loading debugging and compiling programs.
* contains1/2:                           Documentation on exports (lists).
* contains_ro/2 <1>:                     Documentation on exports (lists).
* contains_ro/2:                         Usage and interface (lists).
* control:                               Documentation on exports (odd).
* copy_args/3:                           Documentation on exports (terms).
* copy_stdout/1 <1>:                     Documentation on exports (file_utils).
* copy_stdout/1:                         Usage and interface (file_utils).
* copy_term/2 <1>:                       Documentation on exports (term_basic).
* copy_term/2:                           Usage and interface (term_basic).
* cos/1:                                 Documentation on exports (arithmetic).
* covered/1 <1>:                         Documentation on exports (native_props).
* covered/1:                             Usage and interface (native_props).
* create_dict/2 <1>:                     Documentation on exports (vndict).
* create_dict/2:                         Usage and interface (vndict).
* creating executables:                  Loading debugging and compiling programs.
* creep:                                 Options available during debugging.
* csh <1>:                               Un*x full installation instructions.
* csh <2>:                               Un*x installation summary.
* csh:                                   Installation of the Ciao/Prolog emacs interface.
* csh-compatible shell <1>:              Un*x full installation instructions.
* csh-compatible shell:                  Un*x installation summary.
* ctrlc_clean/1:                         Documentation on exports (ctrlcclean).
* ctrlcclean:                            Usage and interface (foreign_interface).
* ctrlcclean/0:                          Documentation on exports (ctrlcclean).
* current input stream:                  Documentation on exports (streams_basic).
* current output stream:                 Documentation on exports (streams_basic).
* current_atom/1:                        Documentation on exports (prolog_sys).
* current_executable/1 <1>:              Documentation on exports (system).
* current_executable/1:                  Usage and interface (system).
* current_fact/1 <1>:                    Documentation on exports (persdbrtsql).
* current_fact/1 <2>:                    Documentation on exports (persdbrt).
* current_fact/1 <3>:                    Documentation on exports (data_facts).
* current_fact/1:                        Usage and interface (data_facts).
* current_fact/2 <1>:                    Documentation on exports (data_facts).
* current_fact/2:                        Usage and interface (data_facts).
* current_fact_nb/1 <1>:                 Documentation on exports (data_facts).
* current_fact_nb/1:                     Usage and interface (data_facts).
* current_host/1 <1>:                    Documentation on exports (system).
* current_host/1:                        Usage and interface (system).
* current_infixop/4:                     Documentation on exports (operators).
* current_input/1 <1>:                   Documentation on exports (streams_basic).
* current_input/1:                       Usage and interface (streams_basic).
* current_key/2:                         Documentation on exports (old_database).
* current_module/1 <1>:                  Documentation on exports (system_info).
* current_module/1:                      Usage and interface (system_info).
* current_op/3 <1>:                      Documentation on exports (operators).
* current_op/3:                          Usage and interface (operators).
* current_output/1 <1>:                  Documentation on exports (streams_basic).
* current_output/1:                      Usage and interface (streams_basic).
* current_postfixop/3:                   Documentation on exports (operators).
* current_predicate/1 <1>:               Documentation on exports (dynamic).
* current_predicate/1:                   Usage and interface (dynamic).
* current_predicate/2:                   Documentation on exports (prolog_sys).
* current_prefixop/3:                    Documentation on exports (operators).
* current_prolog_flag/2 <1>:             Documentation on exports (prolog_flags).
* current_prolog_flag/2:                 Usage and interface (prolog_flags).
* current_stream/3 <1>:                  Documentation on exports (streams_basic).
* current_stream/3:                      Usage and interface (streams_basic).
* Cygnus Win32:                          Windows installation from the standard source distribution.
* D.H.D. Warren:                         Acknowledgments.
* D.L. Bowen:                            Acknowledgments.
* Daniel Cabeza:                         Acknowledgments.
* data file:                             Implementation Issues.
* data predicate <1>:                    Documentation on exports (data_facts).
* data predicate:                        Fast/concurrent update of facts.
* data/1 <1>:                            Using file-based persistent predicates.
* data/1 <2>:                            Error reporting at compile time.
* data/1 <3>:                            Documentation on new declarations (class).
* data/1 <4>:                            Usage and interface (class).
* data/1 <5>:                            Declaring classes and interfaces.
* data/1:                                Documentation on exports (dynamic).
* Database aggregation functions:        Documentation on exports (pl2sql).
* Database arithmetic expressions:       Documentation on exports (pl2sql).
* Database arithmetic functions:         Documentation on exports (pl2sql).
* Database calls to is/2:                Documentation on exports (pl2sql).
* Database comparison goals:             Documentation on exports (pl2sql).
* database comparison operator:          Documentation on exports (pl2sql).
* database initialization:               Documentation on exports (persdbrt).
* database mediator server <1>:          Documentation on exports (db_client).
* database mediator server:              Low-level socket interface to SQL/ODBC databases.
* datime/1 <1>:                          Documentation on exports (system).
* datime/1:                              Usage and interface (system).
* datime/9 <1>:                          Documentation on exports (system).
* datime/9:                              Usage and interface (system).
* datime_struct/1 <1>:                   Documentation on exports (system).
* datime_struct/1:                       Usage and interface (system).
* db_client:                             SQL persistent database interface.
* db_eval_sql/3 <1>:                     Documentation on exports (db_client).
* db_eval_sql/3:                         Usage and interface (db_client).
* db_get_tables/2 <1>:                   Documentation on exports (db_client).
* db_get_tables/2:                       Usage and interface (db_client).
* db_login/5 <1>:                        Documentation on exports (db_client).
* db_login/5:                            Usage and interface (db_client).
* db_logoff/1 <1>:                       Documentation on exports (db_client).
* db_logoff/1 <2>:                       Usage and interface (db_client).
* db_logoff/1:                           Documentation on internals (persdbrtsql).
* db_one_tuple/2 <1>:                    Documentation on exports (db_client).
* db_one_tuple/2:                        Usage and interface (db_client).
* db_query/4:                            Documentation on internals (persdbrtsql).
* db_query_one_tuple/4:                  Documentation on internals (persdbrtsql).
* db_stmt_handle/3 <1>:                  Documentation on exports (db_client).
* db_stmt_handle/3:                      Usage and interface (db_client).
* db_table_types/3 <1>:                  Documentation on exports (db_client).
* db_table_types/3:                      Usage and interface (db_client).
* dbassertz_fact/1 <1>:                  Documentation on exports (persdbrtsql).
* dbassertz_fact/1:                      Usage and interface (persdbrtsql).
* dbcall/2 <1>:                          Documentation on exports (persdbrtsql).
* dbcall/2:                              Usage and interface (persdbrtsql).
* dbconnection/1 <1>:                    Documentation on exports (db_client).
* dbconnection/1 <2>:                    Usage and interface (db_client).
* dbconnection/1:                        Documentation on internals (persdbrtsql).
* dbcurrent_fact/1 <1>:                  Documentation on exports (persdbrtsql).
* dbcurrent_fact/1:                      Usage and interface (persdbrtsql).
* dbfindall/4 <1>:                       Documentation on exports (persdbrtsql).
* dbfindall/4:                           Usage and interface (persdbrtsql).
* dbhandle/1:                            Documentation on internals (db_client).
* dbname/1 <1>:                          Documentation on exports (db_client).
* dbname/1 <2>:                          Usage and interface (db_client).
* dbname/1:                              Documentation on exports (persdbrtsql).
* dbqueryconnection/1 <1>:               Documentation on exports (db_client).
* dbqueryconnection/1:                   Usage and interface (db_client).
* dbretract_fact/1 <1>:                  Documentation on exports (persdbrtsql).
* dbretract_fact/1:                      Usage and interface (persdbrtsql).
* dbretractall_fact/1 <1>:               Documentation on exports (persdbrtsql).
* dbretractall_fact/1:                   Usage and interface (persdbrtsql).
* dcg_expansion:                         Usage and interface (assertions_props).
* dcg_translation/2:                     Documentation on exports (dcg_expansion).
* debug options:                         Options available during debugging.
* debug/0 <1>:                           Documentation on exports (debugger).
* debug/0:                               Usage and interface (debugger).
* debug/1:                               Documentation on exports (io_aux).
* debug_goal/2 <1>:                      Documentation on exports (messages).
* debug_goal/2:                          Usage and interface (messages).
* debug_goal/3 <1>:                      Documentation on exports (messages).
* debug_goal/3:                          Usage and interface (messages).
* debug_message/1 <1>:                   Documentation on exports (messages).
* debug_message/1:                       Usage and interface (messages).
* debug_message/2 <1>:                   Documentation on exports (messages).
* debug_message/2:                       Usage and interface (messages).
* debug_module/1 <1>:                    Documentation on exports (debugger).
* debug_module/1 <2>:                    Usage and interface (debugger).
* debug_module/1:                        Marking modules and files for debugging.
* debugger <1>:                          The debugging process.
* debugger <2>:                          The interactive debugger.
* debugger:                              Usage and interface (ciaosh).
* debugging:                             Loading debugging and compiling programs.
* debugging/0 <1>:                       Documentation on exports (debugger).
* debugging/0:                           Usage and interface (debugger).
* dec10_io <1>:                          Usage and interface (pl2sql).
* dec10_io:                              Usage and interface (classic).
* decl assertion:                        Documentation on new declarations (assertions).
* decl/1 <1>:                            Documentation on new declarations (assertions).
* decl/1:                                Usage and interface (assertions).
* decl/2 <1>:                            Documentation on new declarations (assertions).
* decl/2:                                Usage and interface (assertions).
* declarations, user defined:            Basic builtin directives.
* DECsystem-10 Prolog User's Manual:     Acknowledgments.
* deductive database:                    Persistent predicates.
* default constructor <1>:               Documentation on exports (objects_rt).
* default constructor:                   Error reporting at compile time (objects).
* define_flag/3 <1>:                     Documentation on multifiles (tokenize).
* define_flag/3 <2>:                     Documentation on multifiles (write).
* define_flag/3 <3>:                     Usage and interface (write).
* define_flag/3 <4>:                     Documentation on multifiles (prolog_flags).
* define_flag/3:                         Usage and interface (prolog_flags).
* del_global/1:                          Documentation on exports (global).
* delete/3 <1>:                          Documentation on exports (idlists).
* delete/3 <2>:                          Usage and interface (idlists).
* delete/3 <3>:                          Documentation on exports (lists).
* delete/3:                              Usage and interface (lists).
* delete_file/1 <1>:                     Documentation on exports (system).
* delete_file/1:                         Usage and interface (system).
* delete_on_ctrlc/2:                     Documentation on exports (ctrlcclean).
* dependent files:                       Gathering the dependent files for a file.
* derived_from/2 <1>:                    Documentation on exports (objects_rt).
* derived_from/2:                        Usage and interface (objects_rt).
* describe/1 <1>:                        Documentation on exports (librowser).
* describe/1:                            Usage and interface (librowser).
* destroy/1 <1>:                         Documentation on exports (objects_rt).
* destroy/1:                             Usage and interface (objects_rt).
* destructor:                            Documentation on exports (class).
* destructor/0 <1>:                      Documentation on exports (class).
* destructor/0:                          Usage and interface (class).
* detach_attribute/1 <1>:                Documentation on exports (attributes).
* detach_attribute/1:                    Usage and interface (attributes).
* determinacy:                           Preprocessing programs.
* dic_get/3:                             Documentation on exports (dict).
* dic_lookup/3:                          Documentation on exports (dict).
* dic_lookup/4:                          Documentation on exports (dict).
* dic_node/2:                            Documentation on exports (dict).
* dic_replace/4:                         Documentation on exports (dict).
* dict <1>:                              Usage and interface (tokenize).
* dict <2>:                              Usage and interface (fastrw).
* dict:                                  Usage and interface (classic).
* dict2varnamesl/2 <1>:                  Documentation on exports (vndict).
* dict2varnamesl/2:                      Usage and interface (vndict).
* difference/3 <1>:                      Documentation on exports (lists).
* difference/3:                          Usage and interface (lists).
* directives:                            Basic builtin directives.
* directory_files/2 <1>:                 Documentation on exports (system).
* directory_files/2:                     Usage and interface (system).
* directoryname/1:                       Documentation on internals (persdbrt).
* DISCIPL:                               Acknowledgments.
* discontiguous/1 <1>:                   Usage and interface (class).
* discontiguous/1:                       Documentation on internals (builtin_directives).
* disjoint/1 <1>:                        Documentation on exports (native_props).
* disjoint/1:                            Usage and interface (native_props).
* disjunctions:                          Documentation on exports (pl2sql).
* display/1 <1>:                         Term output.
* display/1 <2>:                         Documentation on exports (io_aux).
* display/1 <3>:                         Documentation on exports (io_basic).
* display/1:                             Usage and interface (io_basic).
* display/2 <1>:                         Term output.
* display/2 <2>:                         Documentation on exports (io_basic).
* display/2:                             Usage and interface (io_basic).
* display_list/1:                        Documentation on exports (io_aux).
* display_string/1 <1>:                  Documentation on exports (io_aux).
* display_string/1:                      Usage and interface (io_aux).
* display_term/1:                        Documentation on exports (io_aux).
* displayq/1 <1>:                        Documentation on exports (io_aux).
* displayq/1 <2>:                        Documentation on exports (io_basic).
* displayq/1:                            Usage and interface (io_basic).
* displayq/2 <1>:                        Documentation on exports (io_basic).
* displayq/2:                            Usage and interface (io_basic).
* dlist/3 <1>:                           Documentation on exports (lists).
* dlist/3:                               Usage and interface (lists).
* do_interface/1 <1>:                    Documentation on exports (foreign_interface).
* do_interface/1:                        Usage and interface (foreign_interface).
* do_not_free/2:                         Equivalence between Ciao Prolog and C types.
* do_on_abolish/1 <1>:                   Documentation on multifiles (dynamic).
* do_on_abolish/1:                       Usage and interface (dynamic).
* docstring/1 <1>:                       Documentation on exports (assertions_props).
* docstring/1 <2>:                       Usage and interface (assertions_props).
* docstring/1:                           Some attention points.
* documentation generator:               *** PART I - The program development environment.
* DOTemacs:                              Un*x full installation instructions.
* downloading emacs <1>:                 Using the emacs environment under Windows.
* downloading emacs:                     Un*x full installation instructions.
* downloading, latest versions:          Downloading new versions.
* dynamic <1>:                           Usage and interface (javasock).
* dynamic <2>:                           Usage and interface (jtopl).
* dynamic <3>:                           Usage and interface (persdbrtsql).
* dynamic <4>:                           Usage and interface (actmods).
* dynamic <5>:                           Usage and interface (functions).
* dynamic <6>:                           Usage and interface (argnames).
* dynamic <7>:                           Usage and interface (runtime_ops).
* dynamic <8>:                           Usage and interface (dynmods).
* dynamic:                               Usage and interface (iso).
* dynamic predicate:                     Fast/concurrent update of facts.
* dynamic/1 <1>:                         Documentation on new declarations (class).
* dynamic/1 <2>:                         Usage and interface (class).
* dynamic/1:                             Documentation on exports (dynamic).
* dynamic_search_path/1 <1>:             Documentation on exports (ciaosh).
* dynamic_search_path/1:                 Usage and interface (ciaosh).
* dynmods <1>:                           Usage and interface (jtopl).
* dynmods <2>:                           Usage and interface (dynclasses).
* dynmods:                               Usage and interface (classic).
* ELLA:                                  Acknowledgments.
* emacs <1>:                             Checking for correct installation.
* emacs <2>:                             Using the emacs environment under Windows.
* emacs <3>:                             Getting started after Windows installation.
* emacs <4>:                             Installation of the precompiled distribution.
* emacs <5>:                             Un*x full installation instructions.
* emacs <6>:                             Un*x installation summary.
* emacs <7>:                             Coexistence with other Prolog interfaces.
* emacs <8>:                             Version control.
* emacs <9>:                             Getting on-line help.
* emacs <10>:                            Installation of the Ciao/Prolog emacs interface.
* emacs <11>:                            Using Ciao inside GNU emacs.
* emacs <12>:                            How it works.
* emacs <13>:                            Marking modules and files for debugging.
* emacs <14>:                            Introduction.
* emacs <15>:                            Summary.
* emacs:                                 (none).
* emacs Ciao/Prolog mode:                Version control.
* emacs interface <1>:                   Using Ciao inside GNU emacs.
* emacs interface <2>:                   The interactive top-level shell.
* emacs interface:                       *** PART I - The program development environment.
* emacs menu bar:                        Installation of the Ciao/Prolog emacs interface.
* emacs mode <1>:                        Using Ciao inside GNU emacs.
* emacs mode:                            How it works.
* emacs mode setup:                      Un*x full installation instructions.
* emacs mode, loading several:           Coexistence with other Prolog interfaces.
* emacs, download <1>:                   Using the emacs environment under Windows.
* emacs, download:                       Un*x full installation instructions.
* emacs, under Win32:                    Using the emacs environment under Windows.
* eng_backtrack/2 <1>:                   Documentation on exports (concurrency).
* eng_backtrack/2:                       Usage and interface (concurrency).
* eng_call/3 <1>:                        Documentation on exports (concurrency).
* eng_call/3:                            Usage and interface (concurrency).
* eng_call/4 <1>:                        Documentation on exports (concurrency).
* eng_call/4:                            Usage and interface (concurrency).
* eng_cut/1 <1>:                         Documentation on exports (concurrency).
* eng_cut/1:                             Usage and interface (concurrency).
* eng_kill/1 <1>:                        Documentation on exports (concurrency).
* eng_kill/1:                            Usage and interface (concurrency).
* eng_killothers:                        Documentation on exports (concurrency).
* eng_killothers/0 <1>:                  Documentation on exports (concurrency).
* eng_killothers/0:                      Usage and interface (concurrency).
* eng_release/1 <1>:                     Documentation on exports (concurrency).
* eng_release/1:                         Usage and interface (concurrency).
* eng_self/1 <1>:                        Documentation on exports (concurrency).
* eng_self/1:                            Usage and interface (concurrency).
* eng_status/0 <1>:                      Documentation on exports (concurrency).
* eng_status/0:                          Usage and interface (concurrency).
* eng_wait/1 <1>:                        Documentation on exports (concurrency).
* eng_wait/1:                            Usage and interface (concurrency).
* engine:                                Un*x full installation instructions.
* engine directory:                      *** PART II - The Ciao basic language (engine).
* engine module:                         Pure Prolog package.
* Enrico Pontelli:                       Acknowledgments.
* ensure_loaded/1 <1>:                   Documentation on internals (loading_code).
* ensure_loaded/1 <2>:                   Documentation on exports (ciaosh).
* ensure_loaded/1 <3>:                   Usage and interface (ciaosh).
* ensure_loaded/1 <4>:                   Types of executables generated.
* ensure_loaded/1:                       Paths used by the compiler during compilation.
* entry assertion:                       Documentation on new declarations (assertions).
* entry/1 <1>:                           Documentation on exports (assertions_props).
* entry/1 <2>:                           Documentation on new declarations (assertions).
* entry/1:                               Usage and interface (assertions).
* environment variable:                  Un*x full installation instructions.
* environment variable definitions <1>:  Un*x full installation instructions.
* environment variable definitions:      Un*x installation summary.
* environment variables <1>:             Un*x full installation instructions.
* environment variables:                 Installation of the Ciao/Prolog emacs interface.
* equal_lists/2 <1>:                     Documentation on exports (lists).
* equal_lists/2:                         Usage and interface (lists).
* equality comparisons in the WHERE-clause: Documentation on internals (pl2sql).
* equi join in the WHERE-clause:         Documentation on internals (pl2sql).
* erase/1 <1>:                           Documentation on exports (data_facts).
* erase/1:                               Usage and interface (data_facts).
* errhandle:                             Usage and interface (foreign_interface).
* error term:                            Changing system behaviour and various flags.
* error/1:                               Documentation on exports (io_aux).
* error_message/1 <1>:                   Documentation on exports (messages).
* error_message/1:                       Usage and interface (messages).
* error_message/2 <1>:                   Documentation on exports (messages).
* error_message/2:                       Usage and interface (messages).
* error_message/3 <1>:                   Documentation on exports (messages).
* error_message/3:                       Usage and interface (messages).
* error_protect/1:                       Documentation on exports (errhandle).
* etc <1>:                               Compiling the miscellaneous utilities under Windows.
* etc:                                   Un*x full installation instructions.
* evaluable functors:                    Documentation on exports (arithmetic).
* exec/3 <1>:                            Documentation on exports (system).
* exec/3:                                Usage and interface (system).
* exec/4 <1>:                            Documentation on exports (system).
* exec/4:                                Usage and interface (system).
* executable:                            Building executables.
* Executables:                           Getting started after Windows installation.
* executables:                           Un*x full installation instructions.
* executables, dynamic:                  Types of executables generated.
* executables, how to run:               Running the executables generated by the compiler.
* executables, lazy load:                Types of executables generated.
* executables, static:                   Types of executables generated.
* executables, types:                    Types of executables generated.
* existential quantification:            Documentation on exports (pl2sql).
* exp/1:                                 Documentation on exports (arithmetic).
* expander_pred/1:                       Documentation on internals (expansion_tools).
* expansion:                             Documentation on internals (syntax_extensions).
* Explorer:                              Getting started after Windows installation.
* export/1 <1>:                          Documentation on new declarations (class).
* export/1 <2>:                          Usage and interface (class).
* export/1 <3>:                          Declaring classes and interfaces.
* export/1:                              Documentation on internals (modules).
* exports:                               Printing the declarations and code in a file.
* extension/2 <1>:                       Documentation on exports (filenames).
* extension/2:                           Usage and interface (filenames).
* extract_paths/2 <1>:                   Documentation on exports (system).
* extract_paths/2:                       Usage and interface (system).
* F.C.N. Pereira:                        Acknowledgments.
* fact/1:                                Documentation on internals (data_facts).
* fail:                                  Options available during debugging.
* fail/0 <1>:                            Documentation on exports (basiccontrol).
* fail/0:                                Usage and interface (basiccontrol).
* fails/1 <1>:                           Documentation on exports (native_props).
* fails/1:                               Usage and interface (native_props).
* false assertion:                       Documentation on exports (assertions).
* false/1 <1>:                           Documentation on exports (assertions).
* false/1:                               Usage and interface (assertions).
* fast_read/1:                           Documentation on exports (fastrw).
* fast_write/1:                          Documentation on exports (fastrw).
* fast_write_to_string/3:                Documentation on exports (fastrw).
* fastrw <1>:                            Usage and interface (linda).
* fastrw:                                Usage and interface (javasock).
* fetch_url/3:                           Documentation on exports (http).
* file_exists/1 <1>:                     Documentation on exports (system).
* file_exists/1:                         Usage and interface (system).
* file_exists/2 <1>:                     Documentation on exports (system).
* file_exists/2:                         Usage and interface (system).
* file_locks/file_locks:                 Usage and interface (persdbrt).
* file_name_extension/3 <1>:             Documentation on exports (filenames).
* file_name_extension/3:                 Usage and interface (filenames).
* file_properties/6 <1>:                 Documentation on exports (system).
* file_properties/6:                     Usage and interface (system).
* file_property/2 <1>:                   Documentation on exports (system).
* file_property/2:                       Usage and interface (system).
* file_search_path/2 <1>:                Documentation on multifiles (streams_basic).
* file_search_path/2 <2>:                Documentation on exports (streams_basic).
* file_search_path/2 <3>:                Usage and interface (streams_basic).
* file_search_path/2 <4>:                Documentation on multifiles (libpaths).
* file_search_path/2 <5>:                Documentation on exports (libpaths).
* file_search_path/2 <6>:                Types of executables generated.
* file_search_path/2:                    Paths used by the compiler during compilation.
* file_terms/2 <1>:                      Documentation on exports (file_utils).
* file_terms/2:                          Usage and interface (file_utils).
* file_to_string/2 <1>:                  Documentation on exports (file_utils).
* file_to_string/2:                      Usage and interface (file_utils).
* fileerrors/0 <1>:                      Documentation on exports (prolog_flags).
* fileerrors/0:                          Usage and interface (prolog_flags).
* fileinfo:                              More detailed explanation of options (fileinfo).
* filenames <1>:                         Usage and interface (dynclasses).
* filenames <2>:                         Usage and interface (librowser).
* filenames:                             Usage and interface (messages).
* find_name/4:                           Documentation on exports (vndict).
* findall/3 <1>:                         Documentation on exports (persdbrtsql).
* findall/3 <2>:                         Documentation on exports (conc_aggregates).
* findall/3 <3>:                         Usage and interface (conc_aggregates).
* findall/3 <4>:                         Documentation on exports (aggregates).
* findall/3:                             Usage and interface (aggregates).
* findall/4:                             Documentation on exports (aggregates).
* flag/1:                                Documentation on internals (pretty_print).
* float/1 <1>:                           Documentation on exports (arithmetic).
* float/1 <2>:                           Documentation on exports (term_typing).
* float/1:                               Usage and interface (term_typing).
* float_fractional_part/1:               Documentation on exports (arithmetic).
* float_integer_part/1:                  Documentation on exports (arithmetic).
* floor/1:                               Documentation on exports (arithmetic).
* flt/1 <1>:                             Documentation on exports (arithmetic).
* flt/1 <2>:                             Documentation on exports (basic_props).
* flt/1:                                 Usage and interface (basic_props).
* flush_output/0 <1>:                    Documentation on exports (streams_basic).
* flush_output/0:                        Usage and interface (streams_basic).
* flush_output/1 <1>:                    Documentation on exports (streams_basic).
* flush_output/1:                        Usage and interface (streams_basic).
* fmode/2 <1>:                           Documentation on exports (system).
* fmode/2:                               Usage and interface (system).
* force_lazy/1 <1>:                      Documentation on exports (ciaosh).
* force_lazy/1:                          Usage and interface (ciaosh).
* foreign_compilation:                   Usage and interface (foreign_interface).
* form_default/3:                        Documentation on exports (html).
* form_empty_value/1:                    Documentation on exports (html).
* form_request_method/1:                 Documentation on exports (html).
* format <1>:                            Usage and interface (javasock).
* format <2>:                            Usage and interface (jtopl).
* format <3>:                            Usage and interface (javart).
* format <4>:                            Usage and interface (foreign_interface).
* format <5>:                            Usage and interface (assrt_write).
* format <6>:                            Usage and interface (messages).
* format <7>:                            Usage and interface (classic).
* format:                                Usage and interface (debugger).
* format/2 <1>:                          Documentation on exports (format).
* format/2:                              Usage and interface (format).
* format/3 <1>:                          Documentation on exports (format).
* format/3:                              Usage and interface (format).
* format_control/1 <1>:                  Documentation on exports (format).
* format_control/1:                      Usage and interface (format).
* formatting commands:                   Some attention points.
* Francisco Bueno:                       Acknowledgments.
* FROM-clauses:                          Documentation on internals (pl2sql).
* func/1:                                Documentation on exports (assertions_props).
* function/1:                            Usage and interface (functions).
* functions:                             The Ciao lpmake scripting facility.
* functor of a goal:                     Documentation on internals (pl2sql).
* functor/3 <1>:                         Documentation on exports (term_basic).
* functor/3:                             Usage and interface (term_basic).
* g_assrt_body/1 <1>:                    Documentation on exports (assertions_props).
* g_assrt_body/1:                        Usage and interface (assertions_props).
* garbage collection <1>:                Documentation on internals (prolog_sys).
* garbage collection:                    Documentation on exports (prolog_sys).
* garbage_collect/0:                     Documentation on exports (prolog_sys).
* garbage_collection_option/1:           Documentation on internals (prolog_sys).
* gc/0 <1>:                              Documentation on exports (prolog_flags).
* gc/0:                                  Usage and interface (prolog_flags).
* gc_result/1:                           Documentation on internals (prolog_sys).
* gcc:                                   Troubleshooting (nasty messages and nifty workarounds).
* gcd/2:                                 Documentation on exports (arithmetic).
* Gerda Janssens:                        Acknowledgments.
* German Puebla:                         Acknowledgments.
* get1_code/1 <1>:                       Documentation on exports (io_basic).
* get1_code/1:                           Usage and interface (io_basic).
* get1_code/2 <1>:                       Documentation on exports (io_basic).
* get1_code/2:                           Usage and interface (io_basic).
* get_alias_path/0:                      Documentation on exports (libpaths).
* get_arch/1 <1>:                        Documentation on exports (system_info).
* get_arch/1:                            Usage and interface (system_info).
* get_attribute/2 <1>:                   Documentation on exports (attributes).
* get_attribute/2:                       Usage and interface (attributes).
* get_byte/1:                            Documentation on exports (iso_byte_char).
* get_byte/2:                            Documentation on exports (iso_byte_char).
* get_char/1:                            Documentation on exports (iso_byte_char).
* get_char/2:                            Documentation on exports (iso_byte_char).
* get_code/1 <1>:                        Documentation on exports (io_basic).
* get_code/1:                            Usage and interface (io_basic).
* get_code/2 <1>:                        Documentation on exports (io_basic).
* get_code/2:                            Usage and interface (io_basic).
* get_form_input/1:                      Documentation on exports (html).
* get_form_value/3:                      Documentation on exports (html).
* get_global/2:                          Documentation on exports (global).
* get_line/1 <1>:                        Documentation on exports (strings).
* get_line/1:                            Usage and interface (strings).
* get_line/2 <1>:                        Documentation on exports (strings).
* get_line/2:                            Usage and interface (strings).
* get_os/1 <1>:                          Documentation on exports (system_info).
* get_os/1:                              Usage and interface (system_info).
* get_pid/1 <1>:                         Documentation on exports (system).
* get_pid/1:                             Usage and interface (system).
* get_primes/2 <1>:                      Documentation on exports (numlists).
* get_primes/2:                          Usage and interface (numlists).
* getcounter/2:                          Documentation on exports (counters).
* getct/2 <1>:                           Documentation on exports (io_basic).
* getct/2:                               Usage and interface (io_basic).
* getct1/2 <1>:                          Documentation on exports (io_basic).
* getct1/2:                              Usage and interface (io_basic).
* getenvstr/2 <1>:                       Documentation on exports (system).
* getenvstr/2:                           Usage and interface (system).
* ghostview:                             Getting started after Windows installation.
* GlobalChangeLog:                       Version control.
* gmake:                                 Un*x full installation instructions.
* gnd/1 <1>:                             Documentation on exports (basic_props).
* gnd/1:                                 Usage and interface (basic_props).
* GNU:                                   Un*x installation summary.
* GNU emacs:                             Version information.
* GNU general public license:            Preprocessing programs.
* GNU General Public License <1>:        Summary.
* GNU General Public License:            (none).
* GNU make:                              Un*x full installation instructions.
* go/1 <1>:                              Documentation on new modes (basicmodes).
* go/1:                                  Usage and interface (basicmodes).
* go/2 <1>:                              Documentation on new modes (basicmodes).
* go/2:                                  Usage and interface (basicmodes).
* Gopal Gupta:                           Acknowledgments.
* grammar rule:                          Documentation on exports (strings).
* granularity control:                   Preprocessing programs.
* ground/1 <1>:                          Known bugs and planned improvements (andprolog).
* ground/1 <2>:                          Documentation on exports (native_props).
* ground/1 <3>:                          Documentation on exports (term_typing).
* ground/1:                              Usage and interface (term_typing).
* gunzip <1>:                            Un*x full installation instructions.
* gunzip:                                Un*x installation summary.
* H. Ait-Kaci:                           Entering recursive (conjunctive) shell levels.
* halt/0 <1>:                            Documentation on exports (exceptions).
* halt/0:                                Usage and interface (exceptions).
* halt/1 <1>:                            Documentation on exports (exceptions).
* halt/1:                                Usage and interface (exceptions).
* halt_server/0:                         Documentation on exports (linda).
* handle_error/2:                        Documentation on exports (errhandle).
* hard side-effects:                     Documentation on exports (native_props).
* hard/1 <1>:                            Documentation on exports (native_props).
* hard/1:                                Usage and interface (native_props).
* head pattern:                          Documentation on exports (assertions_props).
* head_pattern/1 <1>:                    Documentation on exports (assertions_props).
* head_pattern/1:                        Usage and interface (assertions_props).
* hello:                                 How it works.
* html2terms/2:                          Documentation on exports (html).
* html_protect/1:                        Documentation on exports (html).
* html_report_error/1:                   Documentation on exports (html).
* html_template/3:                       Documentation on exports (html).
* http_lines/3:                          Documentation on exports (html).
* hw.pls:                                Getting started after Windows installation.
* icon_address/2:                        Documentation on exports (html).
* idlists <1>:                           Usage and interface (vndict).
* idlists:                               Usage and interface (metaterms).
* if/3 <1>:                              Documentation on exports (basiccontrol).
* if/3:                                  Usage and interface (basiccontrol).
* impl_defined/1:                        Documentation on internals (builtin_directives).
* implements/1 <1>:                      Error reporting at compile time.
* implements/1 <2>:                      Documentation on new declarations (class).
* implements/1 <3>:                      Usage and interface (class).
* implements/1:                          Declaring classes and interfaces.
* import/2:                              Documentation on internals (modules).
* imports:                               Printing the declarations and code in a file.
* imports_meta_pred/3 <1>:               Documentation on exports (expansion_tools).
* imports_meta_pred/3:                   Usage and interface (expansion_tools).
* in/1 <1>:                              Documentation on exports (linda).
* in/1 <2>:                              Documentation on new modes (basicmodes).
* in/1:                                  Usage and interface (basicmodes).
* in/2 <1>:                              Documentation on exports (linda).
* in/2 <2>:                              Documentation on new modes (basicmodes).
* in/2:                                  Usage and interface (basicmodes).
* in_noblock/1:                          Documentation on exports (linda).
* in_stream/2:                           Documentation on exports (linda).
* inccounter/2:                          Documentation on exports (counters).
* include/1 <1>:                         Documentation on internals (loading_code).
* include/1 <2>:                         Documentation on internals (modules).
* include/1 <3>:                         Documentation on exports (ciaosh).
* include/1:                             Usage and interface (ciaosh).
* indep/1 <1>:                           Known bugs and planned improvements (andprolog).
* indep/1 <2>:                           Documentation on exports (andprolog).
* indep/1 <3>:                           Usage and interface (andprolog).
* indep/1:                               Documentation on exports (native_props).
* indep/2 <1>:                           Known bugs and planned improvements (andprolog).
* indep/2 <2>:                           Documentation on exports (andprolog).
* indep/2 <3>:                           Usage and interface (andprolog).
* indep/2:                               Documentation on exports (native_props).
* independent:                           Documentation on exports (andprolog).
* Inference of properties:               Preprocessing programs.
* info <1>:                              Checking for correct installation.
* info <2>:                              Un*x full installation instructions.
* info <3>:                              Un*x installation summary.
* info <4>:                              Getting on-line help.
* info:                                  Using Ciao inside GNU emacs.
* INFOPATH:                              Un*x full installation instructions.
* inform_user/1:                         Documentation on exports (io_aux).
* inherit_class/1 <1>:                   Documentation on new declarations (class).
* inherit_class/1:                       Usage and interface (class).
* inheritable interface:                 Documentation on new declarations (class).
* inheritable/1 <1>:                     Documentation on new declarations (class).
* inheritable/1:                         Usage and interface (class).
* inheritance relationship:              Documentation on new declarations (class).
* inherited/1 <1>:                       Documentation on exports (class).
* inherited/1:                           Usage and interface (class).
* init_persdb/0 <1>:                     Documentation on exports (persdbrt).
* init_persdb/0:                         Usage and interface (persdbrt).
* init_sql_persdb/0 <1>:                 Documentation on exports (persdbrtsql).
* init_sql_persdb/0:                     Usage and interface (persdbrtsql).
* initialization clauses:                Documentation on new declarations (class).
* initialization/1:                      Documentation on internals (builtin_directives).
* initialize_db/0 <1>:                   Documentation on exports (persdbrt).
* initialize_db/0:                       Usage and interface (persdbrt).
* INRIA:                                 Acknowledgments.
* insert/3 <1>:                          Documentation on exports (sets).
* insert/3:                              Usage and interface (sets).
* insert_last/3 <1>:                     Documentation on exports (lists).
* insert_last/3:                         Usage and interface (lists).
* installation, checking the:            Checking for correct installation.
* installation, network based:           Un*x full installation instructions.
* installation, Un*x, full instructions: Un*x full installation instructions.
* installation, Un*x, summary:           Un*x installation summary.
* installation, Windows clients:         Server installation under Windows.
* installation, Windows server:          Server installation under Windows.
* installation, Windows, from binaries:  Installation and compilation under Windows.
* installation, Windows, from sources:   Windows installation from the standard source distribution.
* instance/2:                            Documentation on exports (metaterms).
* instance_codes/2 <1>:                  Documentation on exports (objects_rt).
* instance_codes/2:                      Usage and interface (objects_rt).
* instance_id/1 <1>:                     Documentation on exports (objects_rt).
* instance_id/1 <2>:                     Usage and interface (objects_rt).
* instance_id/1 <3>:                     Documentation on exports (objects).
* instance_id/1:                         Usage and interface (objects).
* instance_of/2 <1>:                     Documentation on exports (objects_rt).
* instance_of/2 <2>:                     Usage and interface (objects_rt).
* instance_of/2 <3>:                     Error reporting at compile time (objects).
* instance_of/2 <4>:                     Documentation on exports (objects).
* instance_of/2 <5>:                     Documentation on new declarations (objects).
* instance_of/2:                         Usage and interface (objects).
* instances:                             Run time usage of objects.
* instantiation properties:              Defining properties.
* instantiation state:                   Modes.
* int/1 <1>:                             Changing system behaviour and various flags.
* int/1 <2>:                             Documentation on exports (arithmetic).
* int/1 <3>:                             Documentation on exports (basic_props).
* int/1:                                 Usage and interface (basic_props).
* integer/1 <1>:                         Documentation on exports (assertions_props).
* integer/1 <2>:                         Documentation on exports (arithmetic).
* integer/1 <3>:                         Documentation on exports (term_typing).
* integer/1:                             Usage and interface (term_typing).
* intercept/3 <1>:                       Documentation on exports (exceptions).
* intercept/3:                           Usage and interface (exceptions).
* interface file:                        Documentation on internals (syntax_extensions).
* interface inheritance:                 Documentation on new declarations (class).
* interface/2 <1>:                       Documentation on exports (objects_rt).
* interface/2:                           Usage and interface (objects_rt).
* interface_doc:                         Documentation on new declarations (class).
* interface_name/1 <1>:                  Documentation on exports (objects_rt).
* interface_name/1:                      Usage and interface (objects_rt).
* interface_source/1 <1>:                Documentation on exports (objects_rt).
* interface_source/1:                    Usage and interface (objects_rt).
* interfaces <1>:                        Usage and interface (class).
* interfaces:                            Declaring classes and interfaces.
* internal_module_id/1:                  Documentation on internals (system_info).
* intersection/3 <1>:                    Documentation on exports (lists).
* intersection/3:                        Usage and interface (lists).
* intlist/1 <1>:                         Documentation on exports (numlists).
* intlist/1:                             Usage and interface (numlists).
* intset_delete/3:                       Documentation on exports (lists).
* intset_in/2:                           Documentation on exports (lists).
* intset_insert/3:                       Documentation on exports (lists).
* intset_sequence/3:                     Documentation on exports (lists).
* io_aux:                                Changing system behaviour and various flags.
* io_mode/1 <1>:                         Documentation on exports (streams_basic).
* io_mode/1:                             Usage and interface (streams_basic).
* is/2 <1>:                              Documentation on exports (pl2sql).
* is/2 <2>:                              Documentation on exports (arithmetic).
* is/2:                                  Usage and interface (arithmetic).
* is_det/1 <1>:                          Documentation on exports (native_props).
* is_det/1:                              Usage and interface (native_props).
* iso <1>:                               *** PART III - ISO-Prolog library (iso).
* iso:                                   Shell invocation and startup.
* ISO-Prolog <1>:                        Extending the syntax.
* ISO-Prolog <2>:                        Documentation on exports (io_basic).
* ISO-Prolog <3>:                        Basic input/output.
* ISO-Prolog <4>:                        Documentation on exports (arithmetic).
* ISO-Prolog <5>:                        Documentation on internals (loading_code).
* ISO-Prolog <6>:                        Documentation on internals (modules).
* ISO-Prolog <7>:                        Shell invocation and startup.
* ISO-Prolog <8>:                        Modes.
* ISO-Prolog:                            ISO-Prolog compliance.
* ISO-Prolog builtins <1>:               *** PART III - ISO-Prolog library (iso).
* ISO-Prolog builtins:                   *** PART II - The Ciao basic language (engine).
* iso-prolog, compliance:                ISO-Prolog compliance.
* iso/1 <1>:                             Documentation on exports (basic_props).
* iso/1:                                 Usage and interface (basic_props).
* iso_byte_char <1>:                     Usage and interface (actmods).
* iso_byte_char <2>:                     Usage and interface (functions).
* iso_byte_char <3>:                     Usage and interface (argnames).
* iso_byte_char <4>:                     Usage and interface (runtime_ops).
* iso_byte_char <5>:                     Usage and interface (dynmods).
* iso_byte_char:                         Usage and interface (iso).
* iso_incomplete <1>:                    Usage and interface (actmods).
* iso_incomplete <2>:                    Usage and interface (functions).
* iso_incomplete <3>:                    Usage and interface (argnames).
* iso_incomplete <4>:                    Usage and interface (runtime_ops).
* iso_incomplete <5>:                    Usage and interface (dynmods).
* iso_incomplete:                        Usage and interface (iso).
* iso_misc <1>:                          Usage and interface (pl2sql).
* iso_misc <2>:                          Usage and interface (actmods).
* iso_misc <3>:                          Usage and interface (functions).
* iso_misc <4>:                          Usage and interface (argnames).
* iso_misc <5>:                          Usage and interface (runtime_ops).
* iso_misc <6>:                          Usage and interface (dynmods).
* iso_misc:                              Usage and interface (iso).
* isomodes:                              Modes.
* issue_debug_messages/1 <1>:            Documentation on multifiles (messages).
* issue_debug_messages/1 <2>:            Documentation on exports (messages).
* issue_debug_messages/1:                Usage and interface (messages).
* Jan Maluzynski:                        Acknowledgments.
* java_add_listener/3 <1>:               Documentation on exports (javart).
* java_add_listener/3:                   Usage and interface (javart).
* java_connection/0 <1>:                 Documentation on exports (javart).
* java_connection/0:                     Usage and interface (javart).
* java_constructor/1 <1>:                Documentation on exports (javart).
* java_constructor/1:                    Usage and interface (javart).
* java_create_object/2 <1>:              Documentation on exports (javart).
* java_create_object/2:                  Usage and interface (javart).
* java_delete_object/1 <1>:              Documentation on exports (javart).
* java_delete_object/1:                  Usage and interface (javart).
* java_disconnection/0 <1>:              Documentation on exports (javart).
* java_disconnection/0:                  Usage and interface (javart).
* java_event/1 <1>:                      Documentation on exports (javart).
* java_event/1:                          Usage and interface (javart).
* java_fast_read/2:                      Documentation on exports (javasock).
* java_fast_write/2 <1>:                 Documentation on exports (javasock).
* java_fast_write/2:                     Usage and interface (javasock).
* java_field/1 <1>:                      Documentation on exports (javart).
* java_field/1:                          Usage and interface (javart).
* java_get_value/2 <1>:                  Documentation on exports (javart).
* java_get_value/2:                      Usage and interface (javart).
* java_invoke_method/2 <1>:              Documentation on exports (javart).
* java_invoke_method/2:                  Usage and interface (javart).
* java_method/1 <1>:                     Documentation on exports (javart).
* java_method/1:                         Usage and interface (javart).
* java_object/1 <1>:                     Documentation on exports (javart).
* java_object/1:                         Usage and interface (javart).
* java_remote_connection/1 <1>:          Documentation on exports (javart).
* java_remote_connection/1:              Usage and interface (javart).
* java_remove_listener/3 <1>:            Documentation on exports (javart).
* java_remove_listener/3:                Usage and interface (javart).
* java_set_value/2 <1>:                  Documentation on exports (javart).
* java_set_value/2:                      Usage and interface (javart).
* java_stream/3 <1>:                     Documentation on exports (javasock).
* java_stream/3:                         Usage and interface (javasock).
* javasock <1>:                          Usage and interface (jtopl).
* javasock:                              Usage and interface (javart).
* Johan Andersson:                       Acknowledgments (ciao.el).
* Johan Bevemyr:                         Acknowledgments (ciao.el).
* Johan Widen:                           Acknowledgments.
* John Gallagher:                        Acknowledgments.
* K.U. Leuven:                           Acknowledgments.
* Kalyan Muthukumar:                     Acknowledgments.
* Kevin Greene:                          Acknowledgments.
* key sequences:                         Functionality and associated key sequences (bindings).
* keyboard:                              Characters and character strings.
* keypair/1:                             Documentation on internals (sort).
* keysort/2 <1>:                         Documentation on exports (sort).
* keysort/2:                             Usage and interface (sort).
* keyword/1:                             Documentation on internals (persdbrt).
* Kim Marriott:                          Acknowledgments.
* L. Byrd:                               Acknowledgments.
* L.M. Pereira:                          Acknowledgments.
* last/2 <1>:                            Documentation on exports (lists).
* last/2:                                Usage and interface (lists).
* leap:                                  Options available during debugging.
* leash/1 <1>:                           Documentation on exports (debugger).
* leash/1:                               Usage and interface (debugger).
* length/2 <1>:                          Documentation on exports (lists).
* length/2:                              Usage and interface (lists).
* letter_match/2:                        Documentation on exports (patterns).
* lib library:                           *** PART II - The Ciao basic language (engine).
* libpaths:                              Usage and interface (ciaosh).
* libraries used:                        Printing the declarations and code in a file.
* library directory:                     Un*x full installation instructions.
* library(iso_byte_char):                Basic input/output.
* library(modes):                        Documentation on exports (assertions_props).
* library(pure):                         The module system.
* library_directory/1 <1>:               Documentation on multifiles (streams_basic).
* library_directory/1 <2>:               Usage and interface (streams_basic).
* library_directory/1 <3>:               Documentation on multifiles (libpaths).
* library_directory/1 <4>:               Documentation on exports (libpaths).
* library_directory/1:                   Paths used by the compiler during compilation.
* librowser:                             The Ciao library browser.
* linda_client/1:                        Documentation on exports (linda).
* linda_timeout/2:                       Documentation on exports (linda).
* line_count/2 <1>:                      Documentation on exports (streams_basic).
* line_count/2:                          Usage and interface (streams_basic).
* line_position/2 <1>:                   Documentation on exports (streams_basic).
* line_position/2:                       Usage and interface (streams_basic).
* linear/1 <1>:                          Documentation on exports (native_props).
* linear/1:                              Usage and interface (native_props).
* linker_and_opts/2 <1>:                 Documentation on exports (foreign_compilation).
* linker_and_opts/2:                     Usage and interface (foreign_compilation).
* Linkoping U.:                          Acknowledgments.
* Linux:                                 Multiarchitecture support.
* list/1 <1>:                            Documentation on exports (basic_props).
* list/1:                                Usage and interface (basic_props).
* list/2 <1>:                            Documentation on exports (assertions_props).
* list/2 <2>:                            Documentation on exports (basic_props).
* list/2:                                Usage and interface (basic_props).
* list1/2 <1>:                           Documentation on exports (lists).
* list1/2:                               Usage and interface (lists).
* list_concat/2 <1>:                     Documentation on exports (lists).
* list_concat/2:                         Usage and interface (lists).
* list_insert/2 <1>:                     Documentation on exports (idlists).
* list_insert/2 <2>:                     Usage and interface (idlists).
* list_insert/2 <3>:                     Documentation on exports (lists).
* list_insert/2:                         Usage and interface (lists).
* list_lookup/3:                         Documentation on exports (lists).
* list_lookup/4 <1>:                     Documentation on exports (lists).
* list_lookup/4:                         Usage and interface (lists).
* list_to_list_of_lists/2 <1>:           Documentation on exports (lists).
* list_to_list_of_lists/2:               Usage and interface (lists).
* lists <1>:                             Usage and interface (patterns).
* lists <2>:                             Usage and interface (numlists).
* lists <3>:                             Usage and interface (metaterms).
* lists <4>:                             Usage and interface (jtopl).
* lists <5>:                             Usage and interface (javart).
* lists <6>:                             Usage and interface (db_client).
* lists <7>:                             Usage and interface (pl2sql).
* lists <8>:                             Usage and interface (persdbrtsql).
* lists <9>:                             Usage and interface (persdbrt).
* lists <10>:                            Usage and interface (http).
* lists <11>:                            Usage and interface (html).
* lists <12>:                            Usage and interface (foreign_interface).
* lists <13>:                            Usage and interface (librowser).
* lists <14>:                            Usage and interface (messages).
* lists <15>:                            Usage and interface (filenames).
* lists <16>:                            Usage and interface (classic).
* lists <17>:                            Usage and interface (read).
* lists <18>:                            Usage and interface (aggregates).
* lists:                                 Usage and interface (libpaths).
* llists:                                Usage and interface (foreign_interface).
* load_compilation_module/1:             Documentation on internals (syntax_extensions).
* loading programs:                      Loading debugging and compiling programs.
* locating errors:                       Locating errors and checking the syntax of assertions.
* lock_atom/1 <1>:                       Documentation on exports (concurrency).
* lock_atom/1:                           Usage and interface (concurrency).
* lock_file/3:                           Documentation on exports (file_locks).
* log of changes:                        Version control.
* log/1:                                 Documentation on exports (arithmetic).
* LogIn:                                 Entering recursive (conjunctive) shell levels.
* lower_size/2 <1>:                      Documentation on exports (native_props).
* lower_size/2:                          Usage and interface (native_props).
* lower_time/2 <1>:                      Documentation on exports (native_props).
* lower_time/2:                          Usage and interface (native_props).
* lpdoc <1>:                             Documentation on exports (assertions_props).
* lpdoc <2>:                             Documentation on new declarations (assertions).
* lpdoc <3>:                             The Ciao assertion package.
* lpdoc <4>:                             Using Ciao/Prolog mode capabilities in standard shells.
* lpdoc <5>:                             Version control.
* lpdoc <6>:                             Preprocessing programs.
* lpdoc <7>:                             Using Ciao inside GNU emacs.
* lpdoc <8>:                             *** PART I - The program development environment.
* lpdoc <9>:                             Summary.
* lpdoc:                                 (none).
* lpmake:                                The Ciao lpmake scripting facility.
* machine_name/1 <1>:                    Documentation on exports (javart).
* machine_name/1:                        Usage and interface (javart).
* mailing list:                          Keeping up to date: the Ciao users mailing list.
* main/0 <1>:                            Checking for correct installation.
* main/0 <2>:                            Getting started after Windows installation.
* main/0 <3>:                            Loading debugging and compiling programs.
* main/0:                                Building executables.
* main/1 <1>:                            Checking for correct installation.
* main/1 <2>:                            Getting started after Windows installation.
* main/1 <3>:                            Changing system behaviour and various flags.
* main/1 <4>:                            Loading debugging and compiling programs.
* main/1 <5>:                            How it works.
* main/1:                                Building executables.
* major version number:                  Version control.
* make <1>:                              Un*x full installation instructions.
* make <2>:                              Un*x installation summary.
* make:                                  The Ciao lpmake scripting facility.
* make_actmod/2 <1>:                     Documentation on exports (ciaosh).
* make_actmod/2:                         Usage and interface (ciaosh).
* make_exec/2 <1>:                       Getting started after Windows installation.
* make_exec/2:                           Documentation on exports (ciaosh).
* make_persistent/2 <1>:                 Documentation on exports (persdbrt).
* make_persistent/2 <2>:                 Usage and interface (persdbrt).
* make_persistent/2:                     Using file-based persistent predicates.
* make_po/1 <1>:                         Documentation on exports (ciaosh).
* make_po/1:                             Usage and interface (ciaosh).
* make_sql_persistent/3 <1>:             Documentation on exports (persdbrtsql).
* make_sql_persistent/3:                 Usage and interface (persdbrtsql).
* Makefile.pl:                           The Ciao lpmake scripting facility.
* man:                                   Un*x full installation instructions.
* MANPATH:                               Un*x full installation instructions.
* manual, printing:                      Getting started after Windows installation.
* manuals:                               Un*x full installation instructions.
* Manuel Carro:                          Acknowledgments.
* Manuel Hermenegildo:                   Acknowledgments.
* Maria Jose Garcia de la Banda:         Acknowledgments.
* Masanobu Umeda:                        Acknowledgments (ciao.el).
* match_pattern/2 <1>:                   Documentation on exports (patterns).
* match_pattern/2:                       Usage and interface (patterns).
* match_pattern/3 <1>:                   Documentation on exports (patterns).
* match_pattern/3:                       Usage and interface (patterns).
* match_pattern_pred/2 <1>:              Documentation on exports (patterns).
* match_pattern_pred/2:                  Usage and interface (patterns).
* match_string/3:                        Documentation on exports (db_client).
* Mats Carlsson <1>:                     Acknowledgments (ciao.el).
* Mats Carlsson:                         Acknowledgments.
* Maurice Bruynooghe:                    Acknowledgments.
* maxdepth/1 <1>:                        Documentation on exports (debugger).
* maxdepth/1:                            Usage and interface (debugger).
* MCC:                                   Acknowledgments.
* Melbourne U.:                          Acknowledgments.
* member/2 <1>:                          Documentation on exports (basic_props).
* member/2:                              Usage and interface (basic_props).
* member_0/2:                            Documentation on exports (idlists).
* memberchk/2:                           Documentation on exports (idlists).
* memory management <1>:                 Documentation on internals (prolog_sys).
* memory management:                     Documentation on exports (prolog_sys).
* memory_option/1:                       Documentation on internals (prolog_sys).
* memory_result/1:                       Documentation on internals (prolog_sys).
* merge/3 <1>:                           Documentation on exports (sets).
* merge/3:                               Usage and interface (sets).
* message/1:                             Documentation on exports (io_aux).
* message/2 <1>:                         Known bugs and planned improvements (io_aux).
* message/2 <2>:                         Documentation on exports (io_aux).
* message/2:                             Usage and interface (io_aux).
* message_lns/4 <1>:                     Documentation on exports (io_aux).
* message_lns/4:                         Usage and interface (io_aux).
* messages <1>:                          Usage and interface (db_client).
* messages <2>:                          Usage and interface (pl2sql).
* messages <3>:                          Usage and interface (persdbrtsql).
* messages <4>:                          Usage and interface (foreign_interface).
* messages:                              Usage and interface (assrt_write).
* meta_predicate/1 <1>:                  Usage and interface (class).
* meta_predicate/1:                      Documentation on internals (modules).
* metaspec/1:                            Documentation on internals (modules).
* metaterms <1>:                         Usage and interface (vndict).
* metaterms <2>:                         Usage and interface (persdbrtsql).
* metaterms:                             Usage and interface (rtchecks).
* method_spec/1 <1>:                     Documentation on exports (objects_rt).
* method_spec/1:                         Usage and interface (objects_rt).
* minor version number:                  Version control.
* mkf-CIAOARCH:                          Porting to currently unsupported operating systems.
* mktemp/2 <1>:                          Documentation on exports (system).
* mktemp/2:                              Usage and interface (system).
* mod/2:                                 Documentation on exports (arithmetic).
* mode <1>:                              Documentation on exports (assertions_props).
* mode:                                  Documentation on new declarations (assertions).
* mode spec:                             Modes.
* modedef/1 <1>:                         Documentation on exports (assertions_props).
* modedef/1 <2>:                         Documentation on new declarations (assertions).
* modedef/1 <3>:                         Usage and interface (assertions).
* modedef/1:                             Modes.
* modes <1>:                             Classical Prolog modes.
* modes <2>:                             ISO-Prolog modes.
* modes:                                 Preprocessing programs.
* modif_time/2 <1>:                      Documentation on exports (system).
* modif_time/2:                          Usage and interface (system).
* modif_time0/2 <1>:                     Documentation on exports (system).
* modif_time0/2:                         Usage and interface (system).
* modular interface:                     Intermediate files in the compilation process.
* module qualification:                  The module system.
* module/2 <1>:                          ISO-Prolog package.
* module/2:                              Documentation on internals (modules).
* module/3 <1>:                          Usage and interface (class).
* module/3 <2>:                          Documentation on internals (loading_code).
* module/3:                              Documentation on internals (modules).
* modulename/1:                          Documentation on internals (modules).
* Monash U.:                             Acknowledgments.
* moving change log entries:             Version control.
* mshare/1 <1>:                          Documentation on exports (native_props).
* mshare/1:                              Usage and interface (native_props).
* multi-evaluated:                       Documentation on new declarations (class).
* multiarchitecture support:             Multiarchitecture support.
* multifile predicate:                   Documentation on internals (builtin_directives).
* multifile/1 <1>:                       Usage and interface (class).
* multifile/1 <2>:                       Documentation on internals (builtin_directives).
* multifile/1 <3>:                       The module system.
* multifile/1 <4>:                       Documentation on exports (ciaosh).
* multifile/1:                           Usage and interface (ciaosh).
* multpredspec/1:                        Documentation on internals (debugger).
* my_url/1:                              Documentation on exports (html).
* n_assrt_body/5:                        Documentation on exports (assertions_props).
* name/2 <1>:                            Documentation on exports (atomic_basic).
* name/2:                                Usage and interface (atomic_basic).
* negated comparison goal:               Documentation on internals (pl2sql).
* negated database goal:                 Documentation on internals (pl2sql).
* negated goals:                         Documentation on internals (pl2sql).
* negated_comparison/2:                  Documentation on internals (pl2sql).
* negations:                             Documentation on exports (pl2sql).
* netscape:                              Checking for correct installation.
* New Mexico State University:           Acknowledgments.
* new/1:                                 Documentation on exports (dynclasses).
* new/2 <1>:                             Documentation on exports (objects_rt).
* new/2 <2>:                             Usage and interface (objects_rt).
* new/2 <3>:                             Error reporting at compile time (objects).
* new/2 <4>:                             Documentation on exports (objects).
* new/2 <5>:                             Documentation on new declarations (objects).
* new/2 <6>:                             Usage and interface (objects).
* new/2:                                 Documentation on exports (class).
* new_declaration/1 <1>:                 Documentation on internals (syntax_extensions).
* new_declaration/1:                     Basic builtin directives.
* new_declaration/2 <1>:                 Documentation on internals (syntax_extensions).
* new_declaration/2:                     Basic builtin directives.
* nl/0 <1>:                              Documentation on exports (io_basic).
* nl/0:                                  Usage and interface (io_basic).
* nl/1 <1>:                              Documentation on exports (io_basic).
* nl/1:                                  Usage and interface (io_basic).
* nnegint/1 <1>:                         Documentation on exports (basic_props).
* nnegint/1:                             Usage and interface (basic_props).
* no_path_file_name/2 <1>:               Documentation on exports (filenames).
* no_path_file_name/2:                   Usage and interface (filenames).
* nocontainsx/2 <1>:                     Documentation on exports (lists).
* nocontainsx/2:                         Usage and interface (lists).
* nodebug/0 <1>:                         Documentation on exports (debugger).
* nodebug/0:                             Usage and interface (debugger).
* nodebug_module/1 <1>:                  Documentation on exports (debugger).
* nodebug_module/1 <2>:                  Usage and interface (debugger).
* nodebug_module/1:                      Marking modules and files for debugging.
* nofileerrors/0 <1>:                    Documentation on exports (prolog_flags).
* nofileerrors/0:                        Usage and interface (prolog_flags).
* nogc/0 <1>:                            Documentation on exports (prolog_flags).
* nogc/0:                                Usage and interface (prolog_flags).
* non-failure:                           Preprocessing programs.
* nonsingle/1 <1>:                       Documentation on exports (lists).
* nonsingle/1:                           Usage and interface (lists).
* nonvar/1 <1>:                          Documentation on exports (term_typing).
* nonvar/1:                              Usage and interface (term_typing).
* nospy:                                 Options available during debugging.
* nospy/1 <1>:                           Documentation on exports (debugger).
* nospy/1 <2>:                           Usage and interface (debugger).
* nospy/1:                               The debugging process.
* nospyall/0 <1>:                        Documentation on exports (debugger).
* nospyall/0:                            Usage and interface (debugger).
* NOT EXISTS-subqueries:                 Documentation on internals (pl2sql).
* not_covered/1 <1>:                     Documentation on exports (native_props).
* not_covered/1:                         Usage and interface (native_props).
* not_disjoint/1 <1>:                    Documentation on exports (native_props).
* not_disjoint/1:                        Usage and interface (native_props).
* not_fail/1 <1>:                        Documentation on exports (native_props).
* not_fail/1:                            Usage and interface (native_props).
* not_further_inst/1:                    Documentation on exports (assertions_props).
* not_further_inst/2 <1>:                Documentation on exports (basic_props).
* not_further_inst/2:                    Usage and interface (basic_props).
* notation:                              Syntax terminology and notational conventions.
* note/1:                                Documentation on exports (io_aux).
* note_message/1 <1>:                    Documentation on exports (messages).
* note_message/1:                        Usage and interface (messages).
* note_message/2 <1>:                    Documentation on exports (messages).
* note_message/2:                        Usage and interface (messages).
* note_message/3 <1>:                    Documentation on exports (messages).
* note_message/3:                        Usage and interface (messages).
* notrace/0 <1>:                         Documentation on exports (debugger).
* notrace/0:                             Usage and interface (debugger).
* nth/3 <1>:                             Documentation on exports (lists).
* nth/3:                                 Usage and interface (lists).
* null_dict/1 <1>:                       Documentation on exports (vndict).
* null_dict/1:                           Usage and interface (vndict).
* num/1 <1>:                             Documentation on exports (basic_props).
* num/1:                                 Usage and interface (basic_props).
* number/1 <1>:                          Documentation on exports (term_typing).
* number/1:                              Usage and interface (term_typing).
* number_chars/2:                        Documentation on exports (iso_byte_char).
* number_codes/2 <1>:                    Documentation on exports (atomic_basic).
* number_codes/2:                        Usage and interface (atomic_basic).
* number_codes/3 <1>:                    Documentation on exports (atomic_basic).
* number_codes/3:                        Usage and interface (atomic_basic).
* numbervars/3 <1>:                      Documentation on exports (write).
* numbervars/3:                          Usage and interface (write).
* numlist/1 <1>:                         Documentation on exports (numlists).
* numlist/1:                             Usage and interface (numlists).
* object:                                Run time usage of objects.
* objects/objects_rt <1>:                Usage and interface (dynclasses).
* objects/objects_rt:                    Usage and interface (class).
* ODBC:                                  Low-level socket interface to SQL/ODBC databases.
* odbc_connect/2 <1>:                    Documentation on exports (db_client).
* odbc_connect/2:                        Usage and interface (db_client).
* odbc_disconnect/1 <1>:                 Documentation on exports (db_client).
* odbc_disconnect/1 <2>:                 Usage and interface (db_client).
* odbc_disconnect/1:                     Documentation on internals (persdbrtsql).
* old_database:                          Usage and interface (classic).
* on-line help:                          Using Ciao inside GNU emacs.
* on_abort/1:                            Documentation on internals (builtin_directives).
* once/1:                                Documentation on exports (iso_misc).
* op/3 <1>:                              Documentation on exports (operators).
* op/3 <2>:                              Usage and interface (operators).
* op/3:                                  Documentation on internals (syntax_extensions).
* open/3 <1>:                            Documentation on exports (streams_basic).
* open/3:                                Usage and interface (streams_basic).
* open/4:                                Documentation on exports (iso_incomplete).
* open_client/2:                         Documentation on exports (linda).
* open_input/2:                          Documentation on exports (streams).
* open_null_stream/1:                    Documentation on exports (streams).
* open_output/2:                         Documentation on exports (streams).
* open_predicate/1 <1>:                  Documentation on exports (data_facts).
* open_predicate/1:                      Usage and interface (data_facts).
* operations file:                       Implementation Issues.
* operator table:                        Documentation on internals (syntax_extensions).
* operator_specifier/1 <1>:              Documentation on exports (basic_props).
* operator_specifier/1:                  Usage and interface (basic_props).
* operators <1>:                         Usage and interface (actmods).
* operators <2>:                         Usage and interface (functions).
* operators <3>:                         Usage and interface (argnames).
* operators <4>:                         Usage and interface (runtime_ops).
* operators <5>:                         Usage and interface (dynmods).
* operators <6>:                         Usage and interface (classic).
* operators <7>:                         Usage and interface (write).
* operators <8>:                         Usage and interface (read).
* operators:                             Usage and interface (iso).
* optional_message/2 <1>:                Documentation on exports (messages).
* optional_message/2:                    Usage and interface (messages).
* optional_message/3 <1>:                Documentation on exports (messages).
* optional_message/3:                    Usage and interface (messages).
* ord_delete/3 <1>:                      Documentation on exports (sets).
* ord_delete/3:                          Usage and interface (sets).
* ord_disjoint/2 <1>:                    Documentation on exports (sets).
* ord_disjoint/2:                        Usage and interface (sets).
* ord_intersect/2 <1>:                   Documentation on exports (sets).
* ord_intersect/2:                       Usage and interface (sets).
* ord_intersection/3 <1>:                Documentation on exports (sets).
* ord_intersection/3:                    Usage and interface (sets).
* ord_intersection_diff/4 <1>:           Documentation on exports (sets).
* ord_intersection_diff/4:               Usage and interface (sets).
* ord_member/2 <1>:                      Documentation on exports (sets).
* ord_member/2:                          Usage and interface (sets).
* ord_subset/2 <1>:                      Documentation on exports (sets).
* ord_subset/2:                          Usage and interface (sets).
* ord_subset_diff/3 <1>:                 Documentation on exports (sets).
* ord_subset_diff/3:                     Usage and interface (sets).
* ord_subtract/3 <1>:                    Documentation on exports (sets).
* ord_subtract/3:                        Usage and interface (sets).
* ord_test_member/3 <1>:                 Documentation on exports (sets).
* ord_test_member/3:                     Usage and interface (sets).
* ord_union/3 <1>:                       Documentation on exports (sets).
* ord_union/3:                           Usage and interface (sets).
* ord_union_change/3 <1>:                Documentation on exports (sets).
* ord_union_change/3:                    Usage and interface (sets).
* ord_union_diff/4 <1>:                  Documentation on exports (sets).
* ord_union_diff/4:                      Usage and interface (sets).
* ord_union_symdiff/4 <1>:               Documentation on exports (sets).
* ord_union_symdiff/4:                   Usage and interface (sets).
* out/1 <1>:                             Documentation on exports (linda).
* out/1 <2>:                             Documentation on new modes (basicmodes).
* out/1:                                 Usage and interface (basicmodes).
* out/2 <1>:                             Documentation on new modes (basicmodes).
* out/2:                                 Usage and interface (basicmodes).
* out_stream/2:                          Documentation on exports (linda).
* output_html/1:                         Documentation on exports (html).
* overriden:                             Documentation on new declarations (class).
* P. Lincoln:                            Entering recursive (conjunctive) shell levels.
* package file <1>:                      Documentation on internals (syntax_extensions).
* package file <2>:                      Documentation on internals (loading_code).
* package file:                          Documentation on internals (modules).
* parallel Prolog:                       Acknowledgments.
* parallelizing compiler:                Acknowledgments.
* parametric property:                   Documentation on internals (meta_props).
* parametric regular type abstractions:  Documentation on internals (meta_props).
* parametric type functor:               Documentation on new declarations (regtypes).
* PARFORCE:                              Acknowledgments.
* parse_term/3:                          Documentation on exports (atom2term).
* passertz_fact/1 <1>:                   Documentation on exports (persdbrt).
* passertz_fact/1:                       Usage and interface (persdbrt).
* passwd/1 <1>:                          Documentation on exports (db_client).
* passwd/1 <2>:                          Usage and interface (db_client).
* passwd/1:                              Documentation on exports (persdbrtsql).
* patch number:                          Version control.
* PATH:                                  Un*x full installation instructions.
* path alias <1>:                        Operating system utilities.
* path alias <2>:                        Documentation on multifiles (streams_basic).
* path alias <3>:                        Documentation on exports (streams_basic).
* path alias <4>:                        Documentation on internals (modules).
* path alias <5>:                        Documentation on exports (libpaths).
* path alias <6>:                        Customizing library paths and path aliases.
* path alias:                            Documentation on exports (ciaosh).
* path aliases:                          Types of executables generated.
* pattern/1 <1>:                         Documentation on exports (patterns).
* pattern/1:                             Usage and interface (patterns).
* patterns <1>:                          Pattern (regular expression) matching.
* patterns <2>:                          Documentation on exports (librowser).
* patterns:                              Usage and interface (librowser).
* pause/1 <1>:                           Documentation on exports (system).
* pause/1:                               Usage and interface (system).
* Pawel Pietrzak:                        Acknowledgments.
* pcurrent_fact/1 <1>:                   Documentation on exports (persdbrt).
* pcurrent_fact/1:                       Usage and interface (persdbrt).
* Pedro Lopez:                           Acknowledgments.
* peek_byte/1:                           Documentation on exports (iso_byte_char).
* peek_byte/2:                           Documentation on exports (iso_byte_char).
* peek_char/1:                           Documentation on exports (iso_byte_char).
* peek_char/2:                           Documentation on exports (iso_byte_char).
* peek_code/1 <1>:                       Documentation on exports (io_basic).
* peek_code/1:                           Usage and interface (io_basic).
* peek_code/2 <1>:                       Documentation on exports (io_basic).
* peek_code/2:                           Usage and interface (io_basic).
* perl:                                  Installation of the Ciao/Prolog emacs interface.
* persdb <1>:                            Prolog to SQL translator.
* persdb <2>:                            SQL persistent database interface.
* persdb:                                Persistent predicates.
* persdb_sql:                            Persistent predicates.
* persdb_sql/db_client:                  Usage and interface (persdbrtsql).
* persdb_sql/insert_compiler/pl2sqlinsert: Usage and interface (persdbrtsql).
* persdb_sql/pl2sql:                     Usage and interface (persdbrtsql).
* persdb_sql/sqltypes <1>:               Usage and interface (pl2sql).
* persdb_sql/sqltypes:                   Usage and interface (persdbrtsql).
* persdb_sql/string2term:                Usage and interface (db_client).
* persistence set:                       Implementation Issues.
* persistent:                            Documentation on exports (persdbrt).
* persistent predicate:                  Introduction to persistent predicates.
* persistent predicates <1>:             Prolog to SQL translator.
* persistent predicates:                 SQL persistent database interface.
* persistent/2 <1>:                      Using file-based persistent predicates.
* persistent/2:                          Persistent predicates.
* persistent_dir/2 <1>:                  Documentation on internals (persdbrt).
* persistent_dir/2 <2>:                  Documentation on multifiles (persdbrt).
* persistent_dir/2 <3>:                  Usage and interface (persdbrt).
* persistent_dir/2:                      Using file-based persistent predicates.
* Peter Olin:                            Acknowledgments (ciao.el).
* Peter Stuckey:                         Acknowledgments.
* phrase/2:                              Documentation on exports (dcg_expansion).
* phrase/3 <1>:                          Documentation on exports (dcg_expansion).
* phrase/3:                              Usage and interface (dcg_expansion).
* Pierre Deransart:                      Acknowledgments.
* pillow:                                Persistent predicates.
* pillow/common <1>:                     Usage and interface (http).
* pillow/common:                         Usage and interface (html).
* pillow/html:                           Usage and interface (pillow).
* pillow/http:                           Usage and interface (pillow).
* pkunzip:                               Installation of the precompiled distribution.
* pl2sql <1>:                            Documentation on exports (pl2sql).
* pl2sql:                                SQL persistent database interface.
* pl2sqlstring/3 <1>:                    Documentation on exports (pl2sql).
* pl2sqlstring/3 <2>:                    Usage and interface (pl2sql).
* pl2sqlstring/3 <3>:                    Prolog to SQL translator.
* pl2sqlstring/3:                        Documentation on internals (persdbrtsql).
* pl2sqlterm/3 <1>:                      Documentation on exports (pl2sql).
* pl2sqlterm/3 <2>:                      Usage and interface (pl2sql).
* pl2sqlterm/3:                          Prolog to SQL translator.
* platform-independent:                  Types of executables generated.
* Polymorphism:                          Object oriented programming.
* pop_global/2:                          Documentation on exports (global).
* pop_prolog_flag/1 <1>:                 Documentation on exports (prolog_flags).
* pop_prolog_flag/1:                     Usage and interface (prolog_flags).
* popen/3 <1>:                           Documentation on exports (system).
* popen/3:                               Usage and interface (system).
* popen_mode/1 <1>:                      Documentation on exports (system).
* popen_mode/1:                          Usage and interface (system).
* portray/1 <1>:                         Documentation on multifiles (write).
* portray/1 <2>:                         Documentation on exports (write).
* portray/1:                             Usage and interface (write).
* portray_attribute/1:                   Documentation on exports (write).
* portray_attribute/2 <1>:               Documentation on multifiles (write).
* portray_attribute/2:                   Usage and interface (write).
* portray_clause/1 <1>:                  Documentation on exports (write).
* portray_clause/1:                      Usage and interface (write).
* portray_clause/2 <1>:                  Documentation on exports (write).
* portray_clause/2:                      Usage and interface (write).
* positive database goal:                Documentation on internals (pl2sql).
* Posix threads:                         Troubleshooting (nasty messages and nifty workarounds).
* possible_fail/1 <1>:                   Documentation on exports (native_props).
* possible_fail/1:                       Usage and interface (native_props).
* possible_nondet/1 <1>:                 Documentation on exports (native_props).
* possible_nondet/1:                     Usage and interface (native_props).
* powerset/2 <1>:                        Documentation on exports (lists).
* powerset/2:                            Usage and interface (lists).
* pred assertion:                        Documentation on new declarations (assertions).
* pred/1 <1>:                            Documentation on exports (assertions_props).
* pred/1 <2>:                            Documentation on new declarations (assertions).
* pred/1:                                Usage and interface (assertions).
* pred/2 <1>:                            Documentation on new declarations (assertions).
* pred/2:                                Usage and interface (assertions).
* predfunctor/1 <1>:                     Documentation on exports (assertions_props).
* predfunctor/1:                         Usage and interface (assertions_props).
* predicate declarations:                Printing the declarations and code in a file.
* predicate_property/2 <1>:              Documentation on exports (prolog_sys).
* predicate_property/2:                  Usage and interface (prolog_sys).
* predname/1 <1>:                        Documentation on exports (assertions_props).
* predname/1 <2>:                        Documentation on exports (basic_props).
* predname/1:                            Usage and interface (basic_props).
* preprocessing programs:                Preprocessing programs.
* preprocessor:                          *** PART I - The program development environment.
* preprocessor command args, setting:    Setting the top-level and preprocessor executables.
* preprocessor command, setting:         Setting the top-level and preprocessor executables.
* pretract_fact/1 <1>:                   Documentation on exports (persdbrt).
* pretract_fact/1:                       Usage and interface (persdbrt).
* pretty_print/2 <1>:                    Documentation on exports (pretty_print).
* pretty_print/2:                        Usage and interface (pretty_print).
* pretty_print/3 <1>:                    Documentation on exports (pretty_print).
* pretty_print/3:                        Usage and interface (pretty_print).
* prettyvars/1 <1>:                      Documentation on exports (write).
* prettyvars/1:                          Usage and interface (write).
* print/1 <1>:                           Documentation on exports (write).
* print/1:                               Usage and interface (write).
* print/2 <1>:                           Documentation on exports (write).
* print/2:                               Usage and interface (write).
* printable_char/1:                      Documentation on exports (write).
* printdepth:                            Options available during debugging.
* printing assertion information:        Printing the declarations and code in a file.
* printing code-related information:     Printing the declarations and code in a file.
* printing, manual:                      Getting started after Windows installation.
* printqueries/1 <1>:                    Documentation on exports (pl2sql).
* printqueries/1:                        Usage and interface (pl2sql).
* Procedure Box:                         The interactive debugger.
* program assertions:                    The Ciao assertion package.
* program development environment:       Using Ciao inside GNU emacs.
* program development tools:             Un*x full installation instructions.
* program parallelization:               Preprocessing programs.
* program specialization:                Preprocessing programs.
* program transformations <1>:           Preprocessing programs.
* program transformations:               Using Ciao inside GNU emacs.
* projterm/1 <1>:                        Documentation on exports (pl2sql).
* projterm/1 <2>:                        Usage and interface (pl2sql).
* projterm/1:                            Documentation on exports (persdbrtsql).
* prolog flag <1>:                       Documentation on exports (io_aux).
* prolog flag <2>:                       Changing system behaviour and various flags.
* prolog flag <3>:                       Documentation on exports (streams_basic).
* prolog flag <4>:                       Documentation on internals (builtin_directives).
* prolog flag <5>:                       How it works.
* prolog flag:                           Shell invocation and startup.
* Prolog predicate argument positions:   Documentation on multifiles (pl2sql).
* Prolog predicate names:                Documentation on multifiles (pl2sql).
* Prolog scripts:                        Un*x full installation instructions.
* Prolog shell:                          Un*x full installation instructions.
* Prolog shell scripts:                  The script interpreter.
* Prolog to SQL compiler:                Prolog to SQL translator.
* Prolog to SQL translation:             Documentation on internals (persdbrtsql).
* Prolog to SQL translator:              SQL persistent database interface.
* prolog.el:                             Acknowledgments (ciao.el).
* prolog_flag/3 <1>:                     Documentation on exports (prolog_flags).
* prolog_flag/3:                         Usage and interface (prolog_flags).
* prolog_parse/2 <1>:                    Documentation on exports (jtopl).
* prolog_parse/2:                        Usage and interface (jtopl).
* prolog_predicate/1 <1>:                Documentation on exports (javart).
* prolog_predicate/1:                    Usage and interface (javart).
* prolog_predicate/N:                    Foreign interface.
* prolog_server/0 <1>:                   Documentation on exports (jtopl).
* prolog_server/0:                       Usage and interface (jtopl).
* prolog_sys <1>:                        Usage and interface (objects_rt).
* prolog_sys:                            Usage and interface (debugger).
* prompt/2 <1>:                          Documentation on exports (prolog_flags).
* prompt/2:                              Usage and interface (prolog_flags).
* prop assertion:                        Documentation on new declarations (assertions).
* prop/1 <1>:                            Documentation on new declarations (assertions).
* prop/1:                                Usage and interface (assertions).
* prop/2 <1>:                            Documentation on exports (meta_props).
* prop/2 <2>:                            Usage and interface (meta_props).
* prop/2 <3>:                            Documentation on new declarations (assertions).
* prop/2:                                Usage and interface (assertions).
* prop_abs/1:                            Documentation on internals (meta_props).
* properties of computations:            Defining properties.
* properties of execution states:        Defining properties.
* properties, basic:                     Basic data types and properties.
* properties, native:                    Properties which are native to analyzers.
* property:                              Documentation on new declarations (assertions).
* property abstraction:                  Documentation on internals (meta_props).
* property compatibility:                Documentation on exports (basic_props).
* property declarations:                 Printing the declarations and code in a file.
* property_conjunction/1 <1>:            Documentation on exports (assertions_props).
* property_conjunction/1:                Usage and interface (assertions_props).
* property_starterm/1 <1>:               Documentation on exports (assertions_props).
* property_starterm/1:                   Usage and interface (assertions_props).
* propfunctor/1 <1>:                     Documentation on exports (assertions_props).
* propfunctor/1:                         Usage and interface (assertions_props).
* protected:                             Documentation on new declarations (class).
* providing information to the compiler <1>: Documentation on exports (assertions).
* providing information to the compiler: Documentation on new declarations (assertions).
* prune_dict/3 <1>:                      Documentation on exports (vndict).
* prune_dict/3:                          Usage and interface (vndict).
* public:                                Documentation on new declarations (class).
* public domain <1>:                     Summary.
* public domain:                         (none).
* public interface:                      Documentation on new declarations (class).
* public/1 <1>:                          Error reporting at compile time.
* public/1 <2>:                          Documentation on new declarations (class).
* public/1:                              Usage and interface (class).
* pure Prolog:                           Pure Prolog package.
* pure/1 <1>:                            Documentation on exports (native_props).
* pure/1:                                Usage and interface (native_props).
* push_global/2:                         Documentation on exports (global).
* push_prolog_flag/2 <1>:                Documentation on exports (prolog_flags).
* push_prolog_flag/2:                    Usage and interface (prolog_flags).
* put_byte/1:                            Documentation on exports (iso_byte_char).
* put_byte/2:                            Documentation on exports (iso_byte_char).
* put_char/1:                            Documentation on exports (iso_byte_char).
* put_char/2:                            Documentation on exports (iso_byte_char).
* put_code/1 <1>:                        Documentation on exports (io_basic).
* put_code/1:                            Usage and interface (io_basic).
* put_code/2 <1>:                        Documentation on exports (io_basic).
* put_code/2:                            Usage and interface (io_basic).
* q_delete/3:                            Documentation on exports (queues).
* q_empty/1:                             Documentation on exports (queues).
* q_insert/3:                            Documentation on exports (queues).
* q_member/2:                            Documentation on exports (queues).
* qualified attributes:                  Documentation on internals (pl2sql).
* query:                                 Shell interaction.
* query_generation/3:                    Documentation on internals (pl2sql).
* querybody/1 <1>:                       Documentation on internals (pl2sql).
* querybody/1 <2>:                       Documentation on exports (pl2sql).
* querybody/1 <3>:                       Usage and interface (pl2sql).
* querybody/1:                           Documentation on exports (persdbrtsql).
* quoted string:                         Documentation on exports (arithmetic).
* random/1 <1>:                          Documentation on exports (random).
* random/1:                              Usage and interface (random).
* random/3 <1>:                          Documentation on exports (random).
* random/3:                              Usage and interface (random).
* range variable:                        Documentation on internals (pl2sql).
* rd/1:                                  Documentation on exports (linda).
* rd/2:                                  Documentation on exports (linda).
* rd_findall/3:                          Documentation on exports (linda).
* rd_noblock/1:                          Documentation on exports (linda).
* read <1>:                              Usage and interface (linda).
* read <2>:                              Usage and interface (javasock).
* read <3>:                              Usage and interface (jtopl).
* read <4>:                              Usage and interface (javart).
* read <5>:                              Usage and interface (pl2sql).
* read <6>:                              Usage and interface (persdbrt).
* read <7>:                              Usage and interface (actmods).
* read <8>:                              Usage and interface (functions).
* read <9>:                              Usage and interface (argnames).
* read <10>:                             Usage and interface (librowser).
* read <11>:                             Usage and interface (tokenize).
* read <12>:                             Usage and interface (file_utils).
* read <13>:                             Usage and interface (runtime_ops).
* read <14>:                             Usage and interface (dynmods).
* read <15>:                             Usage and interface (iso).
* read:                                  Usage and interface (debugger).
* read/1 <1>:                            Documentation on exports (read).
* read/1:                                Documentation on exports (io_aux).
* read/2 <1>:                            Documentation on exports (sockets).
* read/2 <2>:                            Documentation on exports (read).
* read/2:                                Usage and interface (read).
* read_term/2 <1>:                       Documentation on exports (write).
* read_term/2:                           Documentation on exports (read).
* read_term/3 <1>:                       Documentation on exports (write).
* read_term/3 <2>:                       Documentation on exports (read).
* read_term/3:                           Documentation on exports (io_basic).
* read_tokens/2:                         Documentation on exports (tokenize).
* read_top_level/3:                      Documentation on exports (read).
* rebuild_foreign_interface/1 <1>:       Documentation on exports (foreign_interface).
* rebuild_foreign_interface/1 <2>:       Usage and interface (foreign_interface).
* rebuild_foreign_interface/1:           Foreign interface.
* rebuild_foreign_interface_object/1 <1>: Documentation on exports (foreign_interface).
* rebuild_foreign_interface_object/1:    Usage and interface (foreign_interface).
* recorda/3:                             Documentation on exports (old_database).
* recorded/3:                            Documentation on exports (old_database).
* records:                               *** PART VII - Ciao Prolog extensions.
* recordz/3:                             Documentation on exports (old_database).
* recursive level <1>:                   Entering recursive (conjunctive) shell levels.
* recursive level:                       Shell interaction.
* redefined:                             Documentation on exports (class).
* redefining/1:                          Documentation on internals (builtin_directives).
* RedHat 5.0:                            Troubleshooting (nasty messages and nifty workarounds).
* reexport/1:                            Documentation on internals (modules).
* reexport/2:                            Documentation on internals (modules).
* reference/1:                           Documentation on internals (data_facts).
* regedit:                               Uninstallation under Windows.
* regtype assertion:                     Documentation on new declarations (regtypes).
* regtype/1 <1>:                         Documentation on new declarations (regtypes).
* regtype/1 <2>:                         Usage and interface (regtypes).
* regtype/1 <3>:                         Documentation on exports (basic_props).
* regtype/1:                             Usage and interface (basic_props).
* regtype/2 <1>:                         Documentation on exports (meta_props).
* regtype/2 <2>:                         Usage and interface (meta_props).
* regtype/2 <3>:                         Documentation on new declarations (regtypes).
* regtype/2:                             Usage and interface (regtypes).
* regular expresions:                    Documentation on exports (librowser).
* regular expressions:                   Pattern (regular expression) matching.
* regular type:                          Documentation on new declarations (regtypes).
* regular type abstractions:             Documentation on new declarations (regtypes).
* regular type definitions:              Declaring regular types.
* regular type expression:               Documentation on new declarations (regtypes).
* regular types:                         Declaring regular types.
* relation name:                         Documentation on internals (pl2sql).
* relation/3 <1>:                        Documentation on multifiles (pl2sql).
* relation/3 <2>:                        Documentation on exports (pl2sql).
* relation/3 <3>:                        Usage and interface (pl2sql).
* relation/3:                            Prolog to SQL translator.
* relational databases:                  SQL persistent database interface.
* rem/2:                                 Documentation on exports (arithmetic).
* rename/2 <1>:                          Documentation on exports (vndict).
* rename/2:                              Usage and interface (vndict).
* repeat/0 <1>:                          Documentation on exports (basiccontrol).
* repeat/0:                              Usage and interface (basiccontrol).
* reporting bugs:                        Reporting bugs.
* retract/1 <1>:                         Documentation on exports (dynamic).
* retract/1:                             Usage and interface (dynamic).
* retract_fact/1 <1>:                    Documentation on exports (persdbrtsql).
* retract_fact/1 <2>:                    SQL persistent database interface.
* retract_fact/1 <3>:                    Documentation on exports (persdbrt).
* retract_fact/1 <4>:                    Introduction to persistent predicates.
* retract_fact/1 <5>:                    Documentation on exports (data_facts).
* retract_fact/1:                        Usage and interface (data_facts).
* retract_fact_nb/1 <1>:                 Documentation on exports (data_facts).
* retract_fact_nb/1:                     Usage and interface (data_facts).
* retractall/1 <1>:                      Documentation on exports (dynamic).
* retractall/1:                          Usage and interface (dynamic).
* retractall_fact/1 <1>:                 Documentation on exports (persdbrtsql).
* retractall_fact/1 <2>:                 SQL persistent database interface.
* retractall_fact/1 <3>:                 Documentation on exports (data_facts).
* retractall_fact/1:                     Usage and interface (data_facts).
* retry:                                 Options available during debugging.
* reverse/2 <1>:                         Documentation on exports (lists).
* reverse/2:                             Usage and interface (lists).
* reverse/3:                             Documentation on exports (lists).
* Roger Nasr <1>:                        Entering recursive (conjunctive) shell levels.
* Roger Nasr:                            Acknowledgments.
* round/1:                               Documentation on exports (arithmetic).
* run-time checks <1>:                   Run-time checking of assertions.
* run-time checks:                       Documentation on new declarations (assertions).
* run-time libraries:                    Un*x full installation instructions.
* run-time tests:                        Preprocessing programs.
* s_assrt_body/1 <1>:                    Documentation on exports (assertions_props).
* s_assrt_body/1:                        Usage and interface (assertions_props).
* Saumya Debray:                         Acknowledgments.
* scripts <1>:                           Checking for correct installation.
* scripts:                               Un*x full installation instructions.
* second_prompt/2:                       Documentation on exports (read).
* see/1:                                 Documentation on exports (dec10_io).
* seeing/1:                              Documentation on exports (dec10_io).
* seen/0:                                Documentation on exports (dec10_io).
* Seif Haridi:                           Acknowledgments.
* select/3 <1>:                          Documentation on exports (lists).
* select/3:                              Usage and interface (lists).
* select_socket/5 <1>:                   Documentation on exports (sockets).
* select_socket/5:                       Usage and interface (sockets).
* self/1 <1>:                            Documentation on exports (class).
* self/1:                                Usage and interface (class).
* semantic analisys:                     Documentation on exports (objects_rt).
* semaphore:                             Documentation on exports (concurrency).
* sequence/2 <1>:                        Documentation on exports (basic_props).
* sequence/2:                            Usage and interface (basic_props).
* sequence_or_list/2 <1>:                Documentation on exports (basic_props).
* sequence_or_list/2:                    Usage and interface (basic_props).
* set at a time:                         Low-level socket interface to SQL/ODBC databases.
* set_debug_mode/1 <1>:                  Marking modules and files for debugging.
* set_debug_mode/1 <2>:                  Documentation on exports (ciaosh).
* set_debug_mode/1:                      Usage and interface (ciaosh).
* set_fact/1 <1>:                        Documentation on exports (data_facts).
* set_fact/1:                            Usage and interface (data_facts).
* set_global/2:                          Documentation on exports (global).
* set_input/1 <1>:                       Documentation on exports (streams_basic).
* set_input/1:                           Usage and interface (streams_basic).
* set_nodebug_mode/1 <1>:                Marking modules and files for debugging.
* set_nodebug_mode/1 <2>:                Documentation on exports (ciaosh).
* set_nodebug_mode/1:                    Usage and interface (ciaosh).
* set_output/1 <1>:                      Documentation on exports (streams_basic).
* set_output/1:                          Usage and interface (streams_basic).
* set_prolog_flag/1:                     Normal Prolog module system interaction.
* set_prolog_flag/2 <1>:                 Documentation on exports (prolog_flags).
* set_prolog_flag/2:                     Usage and interface (prolog_flags).
* setarg/3 <1>:                          Documentation on exports (odd).
* setarg/3:                              Usage and interface (odd).
* setcounter/2:                          Documentation on exports (counters).
* setof/3 <1>:                           Documentation on exports (pl2sql).
* setof/3 <2>:                           Known bugs and planned improvements (conc_aggregates).
* setof/3 <3>:                           Documentation on exports (aggregates).
* setof/3:                               Usage and interface (aggregates).
* setproduct/3 <1>:                      Documentation on exports (sets).
* setproduct/3:                          Usage and interface (sets).
* sets:                                  Usage and interface (vndict).
* SETTINGS <1>:                          Troubleshooting (nasty messages and nifty workarounds).
* SETTINGS <2>:                          Architecture specific notes and limitations.
* SETTINGS <3>:                          Un*x full installation instructions.
* SETTINGS:                              Un*x installation summary.
* sh <1>:                                Un*x full installation instructions.
* sh <2>:                                Un*x installation summary.
* sh:                                    Installation of the Ciao/Prolog emacs interface.
* sh-compatible shell <1>:               Un*x full installation instructions.
* sh-compatible shell:                   Un*x installation summary.
* sharing sets:                          Documentation on exports (native_props).
* shell:                                 Starting executables from the Windows command line.
* shell/0 <1>:                           Documentation on exports (system).
* shell/0:                               Usage and interface (system).
* shell/1 <1>:                           Documentation on exports (system).
* shell/1:                               Usage and interface (system).
* shell/2 <1>:                           Documentation on exports (system).
* shell/2:                               Usage and interface (system).
* shortcut, windows:                     Installation of the precompiled distribution.
* SICS <1>:                              Acknowledgments (ciao.el).
* SICS:                                  Acknowledgments.
* SICStus <1>:                           Coexistence with other Prolog interfaces.
* SICStus:                               The debugging process.
* SICStus Prolog:                        Acknowledgments.
* sign/1:                                Documentation on exports (arithmetic).
* simple_message/1 <1>:                  Documentation on exports (messages).
* simple_message/1:                      Usage and interface (messages).
* simple_message/2 <1>:                  Documentation on exports (messages).
* simple_message/2:                      Usage and interface (messages).
* sin/1:                                 Documentation on exports (arithmetic).
* site-specific programs:                Un*x full installation instructions.
* size_of/3:                             Equivalence between Ciao Prolog and C types.
* sizes of terms:                        Preprocessing programs.
* skip:                                  Options available during debugging.
* skip_code/1 <1>:                       Documentation on exports (io_basic).
* skip_code/1:                           Usage and interface (io_basic).
* skip_code/2 <1>:                       Documentation on exports (io_basic).
* skip_code/2:                           Usage and interface (io_basic).
* socket_accept/2 <1>:                   Documentation on exports (sockets).
* socket_accept/2:                       Usage and interface (sockets).
* socket_connection/2 <1>:               Documentation on exports (javasock).
* socket_connection/2:                   Usage and interface (javasock).
* socket_disconnection/0 <1>:            Documentation on exports (javasock).
* socket_disconnection/0:                Usage and interface (javasock).
* socket_recv/2 <1>:                     Documentation on exports (sockets).
* socket_recv/2:                         Usage and interface (sockets).
* socket_recv_code/3 <1>:                Documentation on exports (sockets).
* socket_recv_code/3:                    Usage and interface (sockets).
* socket_send/2 <1>:                     Documentation on exports (sockets).
* socket_send/2:                         Usage and interface (sockets).
* socket_type/1 <1>:                     Documentation on exports (sockets).
* socket_type/1:                         Usage and interface (sockets).
* socketname/1 <1>:                      Documentation on exports (db_client).
* socketname/1 <2>:                      Usage and interface (db_client).
* socketname/1:                          Documentation on exports (persdbrtsql).
* sockets:                               Porting to currently unsupported operating systems.
* sockets/sockets <1>:                   Usage and interface (linda).
* sockets/sockets <2>:                   Usage and interface (javasock).
* sockets/sockets <3>:                   Usage and interface (db_client).
* sockets/sockets:                       Usage and interface (http).
* sockets/sockets_c:                     Usage and interface (sockets).
* soft side-effects:                     Documentation on exports (native_props).
* soft/1 <1>:                            Documentation on exports (native_props).
* soft/1:                                Usage and interface (native_props).
* Solaris:                               Multiarchitecture support.
* sort <1>:                              Usage and interface (vndict).
* sort <2>:                              Usage and interface (sets).
* sort <3>:                              Usage and interface (metaterms).
* sort <4>:                              Usage and interface (classic).
* sort <5>:                              Usage and interface (write).
* sort <6>:                              Usage and interface (aggregates).
* sort:                                  Usage and interface (debugger).
* sort/2 <1>:                            Documentation on exports (sort).
* sort/2:                                Usage and interface (sort).
* source directory:                      Un*x full installation instructions.
* sourcename/1 <1>:                      Documentation on exports (streams_basic).
* sourcename/1 <2>:                      Usage and interface (streams_basic).
* sourcename/1:                          Documentation on internals (ciaosh).
* sourcenames/1:                         Documentation on internals (ciaosh).
* specifications <1>:                    The Ciao assertion package.
* specifications:                        Preprocessing programs.
* spy:                                   Options available during debugging.
* spy-points:                            The interactive debugger.
* spy/1 <1>:                             Documentation on exports (debugger).
* spy/1 <2>:                             Usage and interface (debugger).
* spy/1:                                 The debugging process.
* SQL <1>:                               Prolog to SQL translator.
* SQL:                                   SQL persistent database interface.
* SQL attributes:                        Documentation on multifiles (pl2sql).
* SQL Databases:                         Low-level socket interface to SQL/ODBC databases.
* SQL queries:                           Low-level socket interface to SQL/ODBC databases.
* SQL query <1>:                         Documentation on exports (pl2sql).
* SQL query <2>:                         Documentation on internals (persdbrtsql).
* SQL query:                             Documentation on exports (persdbrtsql).
* SQL server:                            Documentation on exports (pl2sql).
* SQL table names:                       Documentation on multifiles (pl2sql).
* SQL tables <1>:                        Documentation on multifiles (pl2sql).
* SQL tables:                            Prolog to SQL translator.
* sql_get_tables/2 <1>:                  Documentation on exports (persdbrtsql).
* sql_get_tables/2:                      Usage and interface (persdbrtsql).
* sql_persistent/3:                      Documentation on exports (persdbrtsql).
* sql_persistent_location/2 <1>:         Documentation on multifiles (persdbrtsql).
* sql_persistent_location/2:             Usage and interface (persdbrtsql).
* sql_query/3 <1>:                       Documentation on internals (persdbrtsql).
* sql_query/3 <2>:                       Documentation on exports (persdbrtsql).
* sql_query/3:                           Usage and interface (persdbrtsql).
* sql_query_one_tuple/3:                 Documentation on internals (persdbrtsql).
* sql_table_types/3 <1>:                 Documentation on exports (persdbrtsql).
* sql_table_types/3:                     Usage and interface (persdbrtsql).
* sqlstring/1 <1>:                       Documentation on exports (pl2sql).
* sqlstring/1:                           Usage and interface (pl2sql).
* sqlterm2string/2 <1>:                  Documentation on exports (pl2sql).
* sqlterm2string/2:                      Usage and interface (pl2sql).
* sqltype/1 <1>:                         Documentation on multifiles (pl2sql).
* sqltype/1 <2>:                         Documentation on exports (pl2sql).
* sqltype/1:                             Documentation on exports (persdbrtsql).
* sqltypes <1>:                          Documentation on exports (pl2sql).
* sqltypes:                              Documentation on exports (persdbrtsql).
* sqrt/1:                                Documentation on exports (arithmetic).
* srandom/1 <1>:                         Documentation on exports (random).
* srandom/1:                             Usage and interface (random).
* standalone compiler <1>:               Checking for correct installation.
* standalone compiler:                   Un*x full installation instructions.
* standard total ordering:               Comparing terms.
* static checks:                         Using Ciao inside GNU emacs.
* static debugging:                      Preprocessing programs.
* statistics/0:                          Documentation on exports (prolog_sys).
* statistics/2 <1>:                      Documentation on exports (prolog_sys).
* statistics/2:                          Usage and interface (prolog_sys).
* status bar:                            Installation of the Ciao/Prolog emacs interface.
* stmthandle/1:                          Documentation on internals (db_client).
* stream/1 <1>:                          Documentation on exports (streams_basic).
* stream/1:                              Usage and interface (streams_basic).
* stream_code/2 <1>:                     Documentation on exports (streams_basic).
* stream_code/2:                         Usage and interface (streams_basic).
* stream_property/2:                     Documentation on exports (iso_incomplete).
* streams <1>:                           Usage and interface (persdbrt).
* streams <2>:                           Usage and interface (actmods).
* streams <3>:                           Usage and interface (functions).
* streams <4>:                           Usage and interface (argnames).
* streams <5>:                           Usage and interface (librowser).
* streams <6>:                           Usage and interface (file_utils).
* streams <7>:                           Usage and interface (runtime_ops).
* streams <8>:                           Usage and interface (dynmods).
* streams <9>:                           Usage and interface (dec10_io).
* streams:                               Usage and interface (iso).
* string/1 <1>:                          Documentation on exports (basic_props).
* string/1:                              Usage and interface (basic_props).
* string/3 <1>:                          Documentation on exports (strings).
* string/3:                              Usage and interface (strings).
* string2term/2 <1>:                     Documentation on exports (atom2term).
* string2term/2:                         Usage and interface (atom2term).
* stringcommand/1 <1>:                   Documentation on exports (assertions_props).
* stringcommand/1:                       Documentation on new declarations (assertions).
* strings <1>:                           Usage and interface (db_client).
* strings <2>:                           Usage and interface (http).
* strings <3>:                           Usage and interface (html).
* strings <4>:                           Usage and interface (tcltk).
* strings:                               Usage and interface (classic).
* struct/1 <1>:                          Documentation on exports (basic_props).
* struct/1:                              Usage and interface (basic_props).
* style sheets:                          Getting started after Windows installation.
* sub-shell:                             Using Ciao inside GNU emacs.
* sub_atom/4 <1>:                        Documentation on exports (atomic_basic).
* sub_atom/4:                            Usage and interface (atomic_basic).
* sub_atom/5:                            Documentation on exports (iso_misc).
* sublist/2 <1>:                         Documentation on exports (lists).
* sublist/2:                             Usage and interface (lists).
* subterm:                               Options available during debugging.
* subtract/3 <1>:                        Documentation on exports (idlists).
* subtract/3:                            Usage and interface (idlists).
* success assertion:                     Documentation on new declarations (assertions).
* success/1 <1>:                         Documentation on new declarations (assertions).
* success/1:                             Usage and interface (assertions).
* success/2 <1>:                         Documentation on new declarations (assertions).
* success/2:                             Usage and interface (assertions).
* sum_list/2 <1>:                        Documentation on exports (numlists).
* sum_list/2:                            Usage and interface (numlists).
* sum_list/3 <1>:                        Documentation on exports (numlists).
* sum_list/3:                            Usage and interface (numlists).
* sum_list_of_lists/2 <1>:               Documentation on exports (numlists).
* sum_list_of_lists/2:                   Usage and interface (numlists).
* sum_list_of_lists/3 <1>:               Documentation on exports (numlists).
* sum_list_of_lists/3:                   Usage and interface (numlists).
* super class:                           Documentation on new declarations (class).
* Swedish Institute of Computer Science: Acknowledgments.
* symbol_option/1:                       Documentation on internals (prolog_sys).
* symbol_result/1:                       Documentation on internals (prolog_sys).
* Syntax highlighting:                   Using Ciao inside GNU emacs.
* syntax of regular types:               Declaring regular types.
* syntax/1:                              Usage and interface (persdbrt).
* system <1>:                            Getting started after Windows installation.
* system <2>:                            Usage and interface (jtopl).
* system <3>:                            Usage and interface (javart).
* system <4>:                            Usage and interface (pl2sql).
* system <5>:                            Usage and interface (persdbrt).
* system <6>:                            Usage and interface (html).
* system <7>:                            Usage and interface (foreign_compilation).
* system <8>:                            Usage and interface (foreign_interface).
* system <9>:                            Usage and interface (objects_rt).
* system <10>:                           Usage and interface (librowser).
* system <11>:                           Usage and interface (ctrlcclean).
* system:                                Usage and interface (libpaths).
* system libraries:                      Documentation on exports (librowser).
* system/1 <1>:                          Documentation on exports (system).
* system/1:                              Usage and interface (system).
* system/2 <1>:                          Documentation on exports (system).
* system/2:                              Usage and interface (system).
* system_lib/1 <1>:                      Documentation on exports (librowser).
* system_lib/1:                          Usage and interface (librowser).
* tab/1 <1>:                             Documentation on exports (io_basic).
* tab/1:                                 Usage and interface (io_basic).
* tab/2 <1>:                             Documentation on exports (io_basic).
* tab/2:                                 Usage and interface (io_basic).
* tar:                                   Un*x full installation instructions.
* tcl_delete/1 <1>:                      Documentation on exports (tcltk).
* tcl_delete/1:                          Usage and interface (tcltk).
* tcl_eval/3 <1>:                        Documentation on exports (tcltk).
* tcl_eval/3:                            Usage and interface (tcltk).
* tcl_event/3 <1>:                       Documentation on exports (tcltk).
* tcl_event/3:                           Usage and interface (tcltk).
* tcl_new/1 <1>:                         Documentation on exports (tcltk).
* tcl_new/1:                             Usage and interface (tcltk).
* tclCommand/1 <1>:                      Documentation on exports (tcltk).
* tclCommand/1:                          Usage and interface (tcltk).
* tclInterpreter/1 <1>:                  Documentation on exports (tcltk).
* tclInterpreter/1:                      Usage and interface (tcltk).
* tcltk:                                 The tcl/tk interface.
* tcltk/tcltk_low_level:                 Usage and interface (tcltk).
* tcsh <1>:                              Un*x full installation instructions.
* tcsh <2>:                              Un*x installation summary.
* tcsh:                                  Installation of the Ciao/Prolog emacs interface.
* Technical University of Madrid:        Acknowledgments.
* tell/1:                                Documentation on exports (dec10_io).
* telling/1:                             Documentation on exports (dec10_io).
* term/1 <1>:                            Documentation on exports (basic_props).
* term/1:                                Usage and interface (basic_props).
* terms <1>:                             Usage and interface (persdbrtsql).
* terms <2>:                             Usage and interface (foreign_interface).
* terms:                                 Usage and interface (dcg_expansion).
* tests:                                 Getting started after Windows installation.
* text_lines/2:                          Documentation on exports (html).
* this_module/1 <1>:                     Documentation on exports (system_info).
* this_module/1:                         Usage and interface (system_info).
* throw/1 <1>:                           Documentation on exports (exceptions).
* throw/1:                               Usage and interface (exceptions).
* time stamp:                            Version control.
* time/1 <1>:                            Documentation on exports (system).
* time/1:                                Usage and interface (system).
* time_option/1:                         Documentation on internals (prolog_sys).
* time_result/1:                         Documentation on internals (prolog_sys).
* tk_event_loop/1:                       Documentation on exports (tcltk).
* tk_new/2 <1>:                          Documentation on exports (tcltk).
* tk_new/2:                              Usage and interface (tcltk).
* tk_new/4:                              Documentation on exports (tcltk).
* tokenize:                              Usage and interface (read).
* told/0:                                Documentation on exports (dec10_io).
* toplev <1>:                            Documentation on exports (ciaosh).
* toplev:                                Usage and interface (ciaosh).
* toplevel:                              Documentation on exports (system_info).
* toplevel command args, setting:        Setting the top-level and preprocessor executables.
* toplevel command, setting:             Setting the top-level and preprocessor executables.
* trace/0 <1>:                           Documentation on exports (debugger).
* trace/0:                               Usage and interface (debugger).
* transactional update:                  Introduction to persistent predicates.
* transient state:                       Implementation Issues.
* translate_arithmetic_function/5:       Documentation on internals (pl2sql).
* translate_comparison/5:                Documentation on internals (pl2sql).
* translate_conjunction/5:               Documentation on internals (pl2sql).
* translate_goal/5:                      Documentation on internals (pl2sql).
* translate_projection/3:                Documentation on exports (pl2sql).
* translation_predname/1:                Documentation on internals (syntax_extensions).
* troubleshooting <1>:                   Troubleshooting (nasty messages and nifty workarounds).
* troubleshooting:                       Installing Ciao.
* true assertion:                        Documentation on exports (assertions).
* true/0 <1>:                            Documentation on exports (basiccontrol).
* true/0 <2>:                            Usage and interface (basiccontrol).
* true/0:                                The module system.
* true/1 <1>:                            Documentation on exports (assertions).
* true/1:                                Usage and interface (assertions).
* truncate/1:                            Documentation on exports (arithmetic).
* trust assertion:                       Documentation on exports (assertions).
* trust/1 <1>:                           Documentation on exports (assertions).
* trust/1:                               Usage and interface (assertions).
* ttydisplay/1:                          Documentation on exports (ttyout).
* ttydisplay_string/1:                   Documentation on exports (ttyout).
* ttydisplayq/1:                         Documentation on exports (ttyout).
* ttyflush/0:                            Documentation on exports (ttyout).
* ttyget/1:                              Documentation on exports (ttyout).
* ttyget1/1:                             Documentation on exports (ttyout).
* ttynl/0:                               Documentation on exports (ttyout).
* ttyout <1>:                            Usage and interface (classic).
* ttyout:                                Usage and interface (debugger).
* ttyput/1:                              Documentation on exports (ttyout).
* ttyskip/1:                             Documentation on exports (ttyout).
* ttyskipeol/0:                          Documentation on exports (ttyout).
* ttytab/1:                              Documentation on exports (ttyout).
* tuple at a time:                       Low-level socket interface to SQL/ODBC databases.
* tuple/1 <1>:                           Documentation on exports (db_client).
* tuple/1 <2>:                           Usage and interface (db_client).
* tuple/1:                               Documentation on internals (persdbrtsql).
* tuples:                                Documentation on internals (persdbrtsql).
* type declarations:                     Printing the declarations and code in a file.
* type of version control:               Version control.
* type/2 <1>:                            Documentation on exports (term_typing).
* type/2:                                Usage and interface (term_typing).
* types:                                 Preprocessing programs.
* U. of Arizona:                         Acknowledgments.
* umask/2 <1>:                           Documentation on exports (system).
* umask/2:                               Usage and interface (system).
* undo/1 <1>:                            Documentation on exports (odd).
* undo/1:                                Usage and interface (odd).
* undo_force_lazy/1 <1>:                 Documentation on exports (ciaosh).
* undo_force_lazy/1:                     Usage and interface (ciaosh).
* unify:                                 Options available during debugging.
* unify_with_occurs_check/2:             Documentation on exports (iso_misc).
* uninstalling <1>:                      Un*x full installation instructions.
* uninstalling:                          Un*x installation summary.
* UNION-operator:                        Documentation on internals (pl2sql).
* union/3 <1>:                           Documentation on exports (lists).
* union/3:                               Usage and interface (lists).
* union_idlists/3 <1>:                   Documentation on exports (idlists).
* union_idlists/3:                       Usage and interface (idlists).
* UNIX make:                             Un*x full installation instructions.
* Unix/Linux machine:                    Low-level socket interface to SQL/ODBC databases.
* unload/1 <1>:                          Documentation on exports (ciaosh).
* unload/1:                              Usage and interface (ciaosh).
* unlock_atom/1 <1>:                     Documentation on exports (concurrency).
* unlock_atom/1:                         Usage and interface (concurrency).
* unlock_file/2:                         Documentation on exports (file_locks).
* unzip:                                 Installation of the precompiled distribution.
* update/0 <1>:                          Documentation on exports (librowser).
* update/0:                              Usage and interface (librowser).
* update_attribute/2 <1>:                Documentation on exports (attributes).
* update_attribute/2:                    Usage and interface (attributes).
* update_files/2 <1>:                    Documentation on exports (persdbrt).
* update_files/2 <2>:                    Usage and interface (persdbrt).
* update_files/2 <3>:                    Using persistent predicates from the top level.
* update_files/2:                        Implementation Issues.
* updated state:                         Implementation Issues.
* Updates to persistent predicates:      Introduction to persistent predicates.
* UPM:                                   Acknowledgments.
* upper_size/2 <1>:                      Documentation on exports (native_props).
* upper_size/2:                          Usage and interface (native_props).
* upper_time/2 <1>:                      Documentation on exports (native_props).
* upper_time/2:                          Usage and interface (native_props).
* url_info/2:                            Documentation on exports (html).
* url_info_relative/3:                   Documentation on exports (html).
* url_query/2:                           Documentation on exports (html).
* usage:                                 Documentation on new declarations (assertions).
* usage relationship <1>:                Documentation on exports (objects).
* usage relationship:                    Documentation on new declarations (objects).
* use_class/1 <1>:                       Documentation on exports (dynclasses).
* use_class/1 <2>:                       Usage and interface (dynclasses).
* use_class/1 <3>:                       Run time usage of objects.
* use_class/1 <4>:                       Error reporting at compile time (objects).
* use_class/1 <5>:                       Documentation on exports (objects).
* use_class/1 <6>:                       Documentation on new declarations (objects).
* use_class/1 <7>:                       Usage and interface (objects).
* use_class/1:                           Documentation on new declarations (class).
* use_module/1 <1>:                      Known bugs and planned improvements (dynclasses).
* use_module/1 <2>:                      Documentation on exports (dynclasses).
* use_module/1 <3>:                      Documentation on exports (objects).
* use_module/1 <4>:                      Documentation on new declarations (objects).
* use_module/1 <5>:                      Usage and interface (expansion_tools).
* use_module/1 <6>:                      Usage and interface (librowser).
* use_module/1 <7>:                      Documentation on exports (dynmods).
* use_module/1 <8>:                      Documentation on exports (streams_basic).
* use_module/1 <9>:                      Documentation on internals (modules).
* use_module/1 <10>:                     Documentation on exports (ciaosh).
* use_module/1 <11>:                     Usage and interface (ciaosh).
* use_module/1 <12>:                     Shell invocation and startup.
* use_module/1 <13>:                     Types of executables generated.
* use_module/1:                          Paths used by the compiler during compilation.
* use_module/2 <1>:                      Documentation on internals (modules).
* use_module/2 <2>:                      Documentation on exports (ciaosh).
* use_module/2:                          Usage and interface (ciaosh).
* use_package/1 <1>:                     Usage and interface (persdbrtsql).
* use_package/1 <2>:                     ISO-Prolog package.
* use_package/1 <3>:                     Documentation on internals (loading_code).
* use_package/1 <4>:                     Documentation on exports (ciaosh).
* use_package/1:                         Usage and interface (ciaosh).
* user module <1>:                       The module system.
* user module:                           Shell interaction.
* user/1 <1>:                            Documentation on exports (db_client).
* user/1 <2>:                            Usage and interface (db_client).
* user/1:                                Documentation on exports (persdbrtsql).
* users mailing list:                    Keeping up to date: the Ciao users mailing list.
* using alternate engines or libraries:  Environment variables used by Ciao executables.
* var/1 <1>:                             Documentation on exports (assertions_props).
* var/1 <2>:                             Documentation on exports (term_typing).
* var/1:                                 Usage and interface (term_typing).
* variable instantiation:                Preprocessing programs.
* variable names:                        Some attention points.
* variables occurring in several goals:  Documentation on internals (pl2sql).
* variant/2:                             Documentation on exports (metaterms).
* varname/1 <1>:                         Documentation on exports (vndict).
* varname/1:                             Usage and interface (vndict).
* varnamedict/1 <1>:                     Documentation on exports (vndict).
* varnamedict/1:                         Usage and interface (vndict).
* varnamesl/1 <1>:                       Documentation on exports (vndict).
* varnamesl/1:                           Usage and interface (vndict).
* varnamesl2dict/2 <1>:                  Documentation on exports (vndict).
* varnamesl2dict/2:                      Usage and interface (vndict).
* vars_names_dict/3 <1>:                 Documentation on exports (vndict).
* vars_names_dict/3:                     Usage and interface (vndict).
* varsbag/3:                             Documentation on exports (metaterms).
* varset/2:                              Documentation on exports (metaterms).
* Veroniek Dumortier:                    Acknowledgments.
* version control <1>:                   Version control.
* version control:                       Using Ciao inside GNU emacs.
* version maintenance mode for packages: Version control.
* version number:                        Version control.
* version numbering:                     Version control.
* views:                                 SQL persistent database interface.
* virtual:                               Documentation on new declarations (class).
* virtual/1 <1>:                         Documentation on new declarations (class).
* virtual/1:                             Usage and interface (class).
* virtual_method_spec/1 <1>:             Documentation on exports (objects_rt).
* virtual_method_spec/1:                 Usage and interface (objects_rt).
* vndict:                                Usage and interface (pretty_print).
* WAM:                                   Acknowledgments.
* warning/1:                             Documentation on exports (io_aux).
* warning_message/1 <1>:                 Documentation on exports (messages).
* warning_message/1:                     Usage and interface (messages).
* warning_message/2 <1>:                 Documentation on exports (messages).
* warning_message/2:                     Usage and interface (messages).
* warning_message/3 <1>:                 Documentation on exports (messages).
* warning_message/3:                     Usage and interface (messages).
* WebDB:                                 Persistent predicates.
* wellformed_body/3:                     Documentation on exports (dynamic).
* WHERE-clause:                          Documentation on internals (pl2sql).
* WHERE-clauses:                         Documentation on internals (pl2sql).
* where/1 <1>:                           Documentation on exports (librowser).
* where/1:                               Usage and interface (librowser).
* whitespace/2 <1>:                      Documentation on exports (strings).
* whitespace/2:                          Usage and interface (strings).
* whitespace0/2 <1>:                     Documentation on exports (strings).
* whitespace0/2:                         Usage and interface (strings).
* win32:                                 Running the executables generated by the compiler.
* Win95/NT machine:                      Low-level socket interface to SQL/ODBC databases.
* win95_skel.bat:                        Running the executables generated by the compiler.
* windows shortcut:                      Installation of the precompiled distribution.
* winNT_skel.bat:                        Running the executables generated by the compiler.
* WinZip:                                Installation of the precompiled distribution.
* Wlodek Drabent:                        Acknowledgments.
* word-help.el:                          Getting on-line help.
* working_directory/2 <1>:               Documentation on exports (system).
* working_directory/2:                   Usage and interface (system).
* write <1>:                             Usage and interface (metaterms).
* write <2>:                             Usage and interface (jtopl).
* write <3>:                             Usage and interface (javart).
* write <4>:                             Usage and interface (db_client).
* write <5>:                             Usage and interface (pl2sql).
* write <6>:                             Usage and interface (tcltk).
* write <7>:                             Usage and interface (actmods).
* write <8>:                             Usage and interface (functions).
* write <9>:                             Usage and interface (argnames).
* write <10>:                            Usage and interface (pretty_print).
* write <11>:                            Usage and interface (rtchecks).
* write <12>:                            Usage and interface (runtime_ops).
* write <13>:                            Usage and interface (dynmods).
* write <14>:                            Usage and interface (format).
* write <15>:                            Usage and interface (iso).
* write <16>:                            Documentation on exports (io_aux).
* write:                                 Usage and interface (debugger).
* write/1 <1>:                           Documentation on exports (write).
* write/1 <2>:                           Usage and interface (write).
* write/1:                               Documentation on exports (io_aux).
* write/2 <1>:                           Documentation on exports (sockets).
* write/2 <2>:                           Documentation on exports (write).
* write/2:                               Usage and interface (write).
* write_assertion/6 <1>:                 Documentation on exports (assrt_write).
* write_assertion/6:                     Usage and interface (assrt_write).
* write_assertion_as_comment/6 <1>:      Documentation on exports (assrt_write).
* write_assertion_as_comment/6:          Usage and interface (assrt_write).
* write_canonical/1 <1>:                 Documentation on exports (write).
* write_canonical/1:                     Usage and interface (write).
* write_canonical/2 <1>:                 Documentation on exports (write).
* write_canonical/2:                     Usage and interface (write).
* write_list1/1 <1>:                     Documentation on exports (write).
* write_list1/1:                         Usage and interface (write).
* write_option/1 <1>:                    Documentation on exports (write).
* write_option/1:                        Usage and interface (write).
* write_string/1 <1>:                    Documentation on exports (strings).
* write_string/1:                        Usage and interface (strings).
* write_string/2 <1>:                    Documentation on exports (strings).
* write_string/2:                        Usage and interface (strings).
* write_term/2 <1>:                      Documentation on exports (write).
* write_term/2:                          Usage and interface (write).
* write_term/3 <1>:                      Documentation on exports (write).
* write_term/3:                          Usage and interface (write).
* writeq/1 <1>:                          Documentation on exports (write).
* writeq/1 <2>:                          Usage and interface (write).
* writeq/1:                              Documentation on exports (io_aux).
* writeq/2 <1>:                          Documentation on exports (write).
* writeq/2:                              Usage and interface (write).
* writing programs:                      Commands which help in typing in programs.
* WWW <1>:                               Un*x full installation instructions.
* WWW:                                   Un*x installation summary.
* WWW browser:                           Checking for correct installation.
* WWW, interfacing with:                 Connecting with the Web.
* xml2terms/2:                           Documentation on exports (html).
* |/2:                                   Documentation on internals (basiccontrol).
* ~/.cshrc <1>:                          Un*x full installation instructions.
* ~/.cshrc:                              Un*x installation summary.
* ~/.emacs <1>:                          Using the emacs environment under Windows.
* ~/.emacs <2>:                          Un*x full installation instructions.
* ~/.emacs:                              Un*x installation summary.
* ~/.profile <1>:                        Un*x full installation instructions.
* ~/.profile:                            Un*x installation summary.
* ~/1:                                   Usage and interface (functions).



Tag Table:
Node: Top5881
Node: Summary10707
Node: Introduction13340
Node: About the Ciao Prolog development system14199
Node: ISO-Prolog compliance16815
Node: Syntax terminology and notational conventions19179
Node: Characters and character strings20448
Node: Predicate specs21309
Node: Modes21982
Node: Properties and types23000
Node: Declarations23986
Node: Operators24663
Node: Acknowledgments25386
Node: Known bugs and planned improvements (ciao)29170
Node: Version/Change Log (ciao)29524
Node: Getting started34414
Node: *** PART I - The program development environment34627
Node: The stand-alone command-line compiler36035
Node: Building executables36984
Node: Paths used by the compiler during compilation39874
Node: Running the executables generated by the compiler40621
Node: Types of executables generated42312
Node: Intermediate files in the compilation process47614
Node: Usage (ciaoc)48650
Node: The interactive top-level shell50120
Node: Shell invocation and startup51314
Node: Shell interaction52429
Node: Entering recursive (conjunctive) shell levels54921
Node: Usage and interface (ciaosh)56478
Node: Documentation on exports (ciaosh)57475
Node: Documentation on internals (ciaosh)64422
Node: The interactive debugger65025
Node: Marking modules and files for debugging66523
Node: The debugging process68956
Node: The procedure box control flow model69726
Node: Format of debugging messages74589
Node: Options available during debugging77226
Node: Predicates controlling the interactive debugger86466
Node: Usage and interface (debugger)87150
Node: Documentation on exports (debugger)87915
Node: Documentation on internals (debugger)92200
Node: The script interpreter93108
Node: How it works94715
Node: Command line arguments in scripts96943
Node: Customizing library paths and path aliases97610
Node: Usage and interface (libpaths)98418
Node: Documentation on exports (libpaths)98847
Node: Documentation on multifiles (libpaths)99816
Node: Using Ciao inside GNU emacs100337
Node: Installation of the Ciao/Prolog emacs interface103335
Node: Functionality and associated key sequences (bindings)107486
Node: Getting on-line help108431
Node: Loading debugging and compiling programs109934
Node: Locating errors and checking the syntax of assertions113663
Node: Commands which help in typing in programs114559
Node: Preprocessing programs115261
Node: Version control118223
Node: Setting the top-level and preprocessor executables127530
Node: Traditional Prolog Mode Commands129078
Node: Other commands129950
Node: Getting the Ciao/Prolog mode version130506
Node: Commands available in toplevel and preprocessor buffers130793
Node: Using Ciao/Prolog mode capabilities in standard shells131516
Node: Coexistence with other Prolog interfaces132652
Node: Version information133803
Node: Acknowledgments (ciao.el)134224
Node: *** PART II - The Ciao basic language (engine)134683
Node: The module system135192
Node: Usage and interface (modules)137911
Node: Documentation on internals (modules)138251
Node: Directives for using code in other files146427
Node: Usage and interface (loading_code)146892
Node: Documentation on internals (loading_code)147294
Node: Control constructs/predicates149614
Node: Usage and interface (basiccontrol)150278
Node: Documentation on exports (basiccontrol)150921
Node: Documentation on internals (basiccontrol)153031
Node: Basic builtin directives153800
Node: Usage and interface (builtin_directives)155053
Node: Documentation on internals (builtin_directives)155447
Node: Basic data types and properties159255
Node: Usage and interface (basic_props)160009
Node: Documentation on exports (basic_props)160801
Node: Extra-logical properties for typing169266
Node: Usage and interface (term_typing)169913
Node: Documentation on exports (term_typing)170463
Node: Basic term manipulation173094
Node: Usage and interface (term_basic)173463
Node: Documentation on exports (term_basic)173970
Node: Comparing terms175845
Node: Usage and interface (term_compare)177226
Node: Documentation on exports (term_compare)177729
Node: Basic predicates handling names of constants180796
Node: Usage and interface (atomic_basic)181404
Node: Documentation on exports (atomic_basic)181995
Node: Arithmetic185320
Node: Usage and interface (arithmetic)186305
Node: Documentation on exports (arithmetic)186806
Node: Basic input/output192526
Node: Usage and interface (io_basic)193308
Node: Documentation on exports (io_basic)194014
Node: Basic file/stream handling200247
Node: Usage and interface (streams_basic)200773
Node: Documentation on exports (streams_basic)201695
Node: Documentation on multifiles (streams_basic)211680
Node: Exception handling212985
Node: Usage and interface (exceptions)213391
Node: Documentation on exports (exceptions)213849
Node: Fast/concurrent update of facts216238
Node: Usage and interface (data_facts)217837
Node: Documentation on exports (data_facts)218559
Node: Documentation on internals (data_facts)223591
Node: Changing system behaviour and various flags224307
Node: Usage and interface (prolog_flags)227509
Node: Documentation on exports (prolog_flags)228221
Node: Documentation on multifiles (prolog_flags)231364
Node: Concurrency/multithreading primitives233526
Node: Usage and interface (concurrency)235424
Node: Documentation on exports (concurrency)236105
Node: Known bugs and planned improvements (concurrency)244197
Node: Extending the syntax245071
Node: Usage and interface (syntax_extensions)245627
Node: Documentation on internals (syntax_extensions)246009
Node: Message printing primitives254196
Node: Usage and interface (io_aux)254729
Node: Documentation on exports (io_aux)255182
Node: Known bugs and planned improvements (io_aux)258826
Node: Attributed variables259152
Node: Usage and interface (attributes)259643
Node: Documentation on exports (attributes)260143
Node: Gathering some basic internal info261889
Node: Usage and interface (system_info)262454
Node: Documentation on exports (system_info)262980
Node: Documentation on internals (system_info)266649
Node: *** PART III - ISO-Prolog library (iso)267190
Node: ISO-Prolog package267569
Node: Usage and interface (iso)268004
Node: Standard operators268460
Node: Usage and interface (operators)269495
Node: Documentation on exports (operators)269962
Node: All solutions predicates271702
Node: Usage and interface (aggregates)272573
Node: Documentation on exports (aggregates)273068
Node: Dynamic predicates276381
Node: Usage and interface (dynamic)277383
Node: Documentation on exports (dynamic)278056
Node: Documentation on multifiles (dynamic)285899
Node: iso_byte_char (library)286319
Node: Usage and interface (iso_byte_char)286584
Node: Documentation on exports (iso_byte_char)286905
Node: iso_incomplete (library)288465
Node: Usage and interface (iso_incomplete)288734
Node: Documentation on exports (iso_incomplete)289062
Node: iso_misc (library)289560
Node: Usage and interface (iso_misc)289825
Node: Documentation on exports (iso_misc)290198
Node: Term input290900
Node: Usage and interface (read)291222
Node: Documentation on exports (read)291668
Node: Structured stream handling293224
Node: Usage and interface (streams)293516
Node: Documentation on exports (streams)293813
Node: Term output294481
Node: Usage and interface (write)295467
Node: Documentation on exports (write)296287
Node: Documentation on multifiles (write)305883
Node: *** PART IV - Classic Prolog library (classic)306753
Node: Classic Prolog package307214
Node: Usage and interface (classic)307772
Node: Definite clause grammars308308
Node: Usage and interface (dcg)313370
Node: Definite clause grammars (expansion)313639
Node: Usage and interface (dcg_expansion)313988
Node: Documentation on exports (dcg_expansion)314508
Node: Quintus-like internal database315681
Node: Usage and interface (old_database)316882
Node: Documentation on exports (old_database)317212
Node: List processing318992
Node: Usage and interface (lists)319397
Node: Documentation on exports (lists)320151
Node: Sorting lists327427
Node: Usage and interface (sort)327769
Node: Documentation on exports (sort)328101
Node: Documentation on internals (sort)329422
Node: Dictionaries329893
Node: Usage and interface (dict)330264
Node: Documentation on exports (dict)330518
Node: String processing331146
Node: Usage and interface (strings)331580
Node: Documentation on exports (strings)332041
Node: DEC-10 Prolog file IO334343
Node: Usage and interface (dec10_io)334753
Node: Documentation on exports (dec10_io)335132
Node: Formatted output335937
Node: Usage and interface (format)337367
Node: Documentation on exports (format)337883
Node: ttyout (library)345271
Node: Usage and interface (ttyout)345525
Node: Documentation on exports (ttyout)345797
Node: dynmods (library)346964
Node: Usage and interface (dynmods)347194
Node: Documentation on exports (dynmods)347703
Node: runtime_ops (library)348080
Node: Usage and interface (runtime_ops)348317
Node: *** PART V - Annotated Prolog library (assertions)348829
Node: The Ciao assertion package349406
Node: More info351111
Node: Some attention points351942
Node: Usage and interface (assertions)353123
Node: Documentation on new declarations (assertions)354542
Node: Documentation on exports (assertions)366382
Node: Types and properties related to assertions370751
Node: Usage and interface (assertions_props)371344
Node: Documentation on exports (assertions_props)372215
Node: Declaring regular types387653
Node: Defining properties389021
Node: Usage and interface (regtypes)396696
Node: Documentation on new declarations (regtypes)397294
Node: Properties which are native to analyzers400797
Node: Usage and interface (native_props)401390
Node: Documentation on exports (native_props)402321
Node: Meta-properties408261
Node: Usage and interface (meta_props)409299
Node: Documentation on exports (meta_props)409854
Node: Documentation on multifiles (meta_props)411019
Node: Documentation on internals (meta_props)411639
Node: Known bugs and planned improvements (meta_props)412944
Node: ISO-Prolog modes413372
Node: Usage and interface (isomodes)413930
Node: Documentation on new modes (isomodes)414497
Node: Classical Prolog modes416574
Node: Usage and interface (basicmodes)417310
Node: Documentation on new modes (basicmodes)417933
Node: Run-time checking of assertions421982
Node: Usage and interface (rtchecks)422800
Node: Documentation on exports (rtchecks)423386
Node: Documentation on multifiles (rtchecks)424093
Node: Known bugs and planned improvements (rtchecks)424501
Node: *** PART VI - Ciao Prolog library miscellanea424971
Node: Operating system utilities425545
Node: Usage and interface (system)426360
Node: Documentation on exports (system)427313
Node: Prolog system internal predicates439925
Node: Usage and interface (prolog_sys)440637
Node: Documentation on exports (prolog_sys)441056
Node: Documentation on internals (prolog_sys)446166
Node: Known bugs and planned improvements (prolog_sys)449735
Node: ctrlcclean (library)450257
Node: Usage and interface (ctrlcclean)450550
Node: Documentation on exports (ctrlcclean)450936
Node: errhandle (library)451486
Node: Usage and interface (errhandle)451758
Node: Documentation on exports (errhandle)452051
Node: fastrw (library)452507
Node: Usage and interface (fastrw)452769
Node: Documentation on exports (fastrw)453125
Node: File name manipulation453598
Node: Usage and interface (filenames)454089
Node: Documentation on exports (filenames)454612
Node: file_utils (library)458335
Node: Usage and interface (file_utils)458635
Node: Documentation on exports (file_utils)459135
Node: file_locks (library)461445
Node: Usage and interface (file_locks)461688
Node: Documentation on exports (file_locks)461988
Node: terms (library)462382
Node: Usage and interface (terms)462650
Node: Documentation on exports (terms)462915
Node: tokenize (library)463458
Node: Usage and interface (tokenize)463781
Node: Documentation on exports (tokenize)464159
Node: Documentation on multifiles (tokenize)464501
Node: Printing status and error messages464846
Node: Usage and interface (messages)465447
Node: Documentation on exports (messages)466412
Node: Documentation on multifiles (messages)477525
Node: Known bugs and planned improvements (messages)478325
Node: A simple pretty-printer for Ciao programs478679
Node: Usage and interface (pretty_print)479259
Node: Documentation on exports (pretty_print)479794
Node: Documentation on internals (pretty_print)480984
Node: Pretty-printing assertions483420
Node: Usage and interface (assrt_write)483967
Node: Documentation on exports (assrt_write)484547
Node: The Ciao library browser486046
Node: Usage and interface (librowser)487213
Node: Documentation on exports (librowser)488585
Node: Documentation on internals (librowser)492912
Node: Code translation utilities493537
Node: Usage and interface (expansion_tools)494460
Node: Documentation on exports (expansion_tools)495205
Node: Documentation on internals (expansion_tools)500177
Node: Known bugs and planned improvements (expansion_tools)500965
Node: conc_aggregates (library)501310
Node: Usage and interface (conc_aggregates)502252
Node: Documentation on exports (conc_aggregates)502653
Node: Known bugs and planned improvements (conc_aggregates)503297
Node: *** PART VII - Ciao Prolog extensions503726
Node: Pure Prolog package504475
Node: Usage and interface (pure)506464
Node: argnames (library)506728
Node: Usage and interface (argnames)506939
Node: Independent and-parallel execution507516
Node: Usage and interface (andprolog)508296
Node: Documentation on exports (andprolog)508856
Node: Known bugs and planned improvements (andprolog)511099
Node: functions (library)511697
Node: Usage and interface (functions)511909
Node: global (library)512491
Node: Usage and interface (global)512755
Node: Documentation on exports (global)513027
Node: Miscellaneous predicates513672
Node: Usage and interface (odd)514167
Node: Documentation on exports (odd)514515
Node: actmods (library)516141
Node: Usage and interface (actmods)516342
Node: Breadth-first execution516846
Node: Usage and interface (bf)517687
Node: Known bugs and planned improvements (bf)518072
Node: Constraint programming over rationals518335
Node: Usage and interface (clpq)518703
Node: Constraint programming over reals519003
Node: Usage and interface (clpr)519367
Node: Object oriented programming519659
Node: Early examples:520854
Node: Recommendations on when to use objects:527139
Node: Limitations on object usage:528754
Node: Declaring classes and interfaces529185
Node: Usage and interface (class)530356
Node: Documentation on new declarations (class)532366
Node: Documentation on exports (class)540873
Node: Known bugs and planned improvements (class)545800
Node: Error reporting when compiling classes and interfaces546128
Node: Error reporting at compile time547310
Node: Error reporting at run time557753
Node: Normal Prolog module system interaction558175
Node: Usage and interface (class_error)559597
Node: Using OCIAO objects559917
Node: Usage and interface (objects)560573
Node: Documentation on new declarations (objects)561535
Node: Documentation on exports (objects)565522
Node: Error reporting when using objects568814
Node: Error reporting at compile time (objects)570316
Node: Error reporting at run time (objects)576890
Node: Usage and interface (objects_error)578103
Node: Run time usage of objects578420
Node: Usage and interface (objects_rt)579828
Node: Documentation on exports (objects_rt)580916
Node: Known bugs and planned improvements (objects_rt)593156
Node: Using classes from the CIAO toplevel shell593467
Node: Usage and interface (dynclasses)594325
Node: Documentation on exports (dynclasses)595456
Node: Known bugs and planned improvements (dynclasses)597694
Node: *** PART VIII - Interfaces to other languages and systems598394
Node: Foreign interface599138
Node: Equivalence between Ciao Prolog and C modes601241
Node: Equivalence between Ciao Prolog and C types601557
Node: Examples603161
Node: Mathematical functions603519
Node: Addresses and C pointers604485
Node: Lists of bytes and buffers606055
Node: Strings and atoms607799
Node: Usage and interface (foreign_interface)610121
Node: Documentation on exports (foreign_interface)611171
Node: Utilities for on-demand compilation of foreign files614580
Node: Usage and interface (foreign_compilation)615716
Node: Documentation on exports (foreign_compilation)616387
Node: The socket interface618268
Node: Usage and interface (sockets)619062
Node: Documentation on exports (sockets)619874
Node: The tcl/tk interface626262
Node: Usage and interface (tcltk)626961
Node: Documentation on exports (tcltk)627674
Node: Connecting with the Web634622
Node: Usage and interface (pillow)635332
Node: html (library)636015
Node: Usage and interface (html)636493
Node: Documentation on exports (html)637034
Node: http (library)640433
Node: Usage and interface (http)640917
Node: Documentation on exports (http)641467
Node: Persistent predicate database641820
Node: Introduction to persistent predicates643096
Node: Persistent predicates645277
Node: Using file-based persistent predicates648578
Node: Implementation Issues651026
Node: Using persistent predicates from the top level652999
Node: Usage and interface (persdbrt)654163
Node: Documentation on exports (persdbrt)656424
Node: Documentation on multifiles (persdbrt)663181
Node: Documentation on internals (persdbrt)665346
Node: Known bugs and planned improvements (persdbrt)666977
Node: Using the persdb library668298
Node: An example of persistent predicates (static version)669147
Node: An example of persistent predicates (dynamic version)670618
Node: A simple application: a persistent queue671923
Node: SQL persistent database interface673931
Node: Implementation of the Database Interface676273
Node: Example(s)679414
Node: Usage and interface (persdbrtsql)685450
Node: Documentation on exports (persdbrtsql)688106
Node: Documentation on multifiles (persdbrtsql)706367
Node: Documentation on internals (persdbrtsql)708714
Node: Known bugs and planned improvements (persdbrtsql)715120
Node: Prolog to SQL translator716059
Node: Usage and interface (pl2sql)719616
Node: Documentation on exports (pl2sql)720871
Node: Documentation on multifiles (pl2sql)733131
Node: Documentation on internals (pl2sql)737475
Node: Known bugs and planned improvements (pl2sql)749960
Node: Low-level socket interface to SQL/ODBC databases750490
Node: Usage and interface (db_client)762836
Node: Documentation on exports (db_client)764486
Node: Documentation on internals (db_client)781952
Node: Known bugs and planned improvements (db_client)783610
Node: Low-level Prolog to Java interface784068
Node: Usage and interface (javart)784637
Node: Documentation on exports (javart)786367
Node: Low-level Java to Prolog interface803125
Node: Usage and interface (jtopl)803686
Node: Documentation on exports (jtopl)804647
Node: Low-level Prolog to Java socket connection806526
Node: Usage and interface (javasock)807114
Node: Documentation on exports (javasock)808096
Node: linda (library)812055
Node: Usage and interface (linda)812486
Node: Documentation on exports (linda)813024
Node: *** PART IX - Abstract data types815732
Node: atom2term (library)816057
Node: Usage and interface (atom2term)816647
Node: Documentation on exports (atom2term)817150
Node: counters (library)818567
Node: Usage and interface (counters)818956
Node: Documentation on exports (counters)819292
Node: Identity lists820006
Node: Usage and interface (idlists)820581
Node: Documentation on exports (idlists)821195
Node: Term manipulation824288
Node: Usage and interface (metaterms)824688
Node: Documentation on exports (metaterms)825250
Node: Lists of numbers826770
Node: Usage and interface (numlists)827190
Node: Documentation on exports (numlists)828119
Node: Pattern (regular expression) matching833315
Node: Usage and interface (patterns)834005
Node: Documentation on exports (patterns)834963
Node: queues (library)840788
Node: Usage and interface (queues)841185
Node: Documentation on exports (queues)841507
Node: Random numbers842372
Node: Usage and interface (random)842839
Node: Documentation on exports (random)843357
Node: sets (library)845185
Node: Usage and interface (sets)845763
Node: Documentation on exports (sets)847055
Node: Variable names dictionaries853881
Node: Usage and interface (vndict)854484
Node: Documentation on exports (vndict)855654
Node: *** PART X - Miscellaneous standalone utilities863247
Node: Printing the declarations and code in a file863921
Node: Usage (fileinfo)865105
Node: More detailed explanation of options (fileinfo)866164
Node: Printing the contents of a bytecode file868322
Node: Usage (viewpo)869085
Node: Gathering the dependent files for a file869508
Node: Usage (get_deps)870632
Node: Finding differences between two Prolog files871201
Node: Usage (pldiff)872008
Node: Known bugs and planned improvements (pldiff)872647
Node: The Ciao lpmake scripting facility873222
Node: Find out which architecture we are running on875783
Node: Usage (ciao_get_arch)876729
Node: More details877005
Node: *** PART XI - Appendices877212
Node: Installing Ciao877510
Node: Un*x installation summary879697
Node: Un*x full installation instructions885389
Node: Installation and compilation under Windows902542
Node: Windows installation from the precompiled distribution903688
Node: Installation of the precompiled distribution904810
Node: Getting started after Windows installation908264
Node: Starting executables from the Windows command line916436
Node: Using the emacs environment under Windows917826
Node: Compiling the miscellaneous utilities under Windows921209
Node: Server installation under Windows921889
Node: Uninstallation under Windows922939
Node: Windows installation from the standard source distribution923935
Node: Checking for correct installation927521
Node: Cleaning up the source directory931428
Node: Environment variables used by Ciao executables932450
Node: Multiarchitecture support934081
Node: Architecture specific notes and limitations937687
Node: Downloading new versions939527
Node: Keeping up to date: the Ciao users mailing list940048
Node: Reporting bugs941140
Node: Porting to currently unsupported operating systems942658
Node: Troubleshooting (nasty messages and nifty workarounds)944316
Node: References953270
Node: Library/Module Definition Index968134
Node: Predicate/Method Definition Index975930
Node: Property Definition Index1025424
Node: Regular Type Definition Index1031179
Node: Declaration Definition Index1039420
Node: Concept Definition Index1044414
Node: Global Index1064989

End Tag Table
