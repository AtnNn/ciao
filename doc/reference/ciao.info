This is ciao.info, produced by makeinfo version 4.0 from ciao.texi.

   *Ciao* is a _public domain_, _next generation_ programming
environment with a unique set of features:

   * Ciao is a complete Prolog system, supporting _ISO-Prolog_, but
     its novel modular design allows both _restricting_ and
     _extending_ the language. As a result, it allows working with
     _fully declarative subsets_ of Prolog and also to _extend_ these
     subsets (or ISO-Prolog) both syntactically and semantically.
     Most importantly, these restrictions and extensions can be
     activated separately on each program module so that several
     extensions can coexist in the same application for different
     modules.

   * Ciao extensions currently include feature terms (records),
     higher-order (with predicate abstractions), functions,
     constraints, objects, persistence, several control rules
     (breadth-first search, iterative deepening, ...), concurrency
     (threads/engines), a good base for distributed execution
     (agents), and parallel execution. Libraries also support WWW
     programming, sockets, external interfaces (C, Java, TclTk,
     relational databases, etc.), etc.

   * *Ciao* offers support for _programming in the large_ with a
     robust module/object system, module-based separate/incremental
     compilation (automatically -no need for makefiles), an assertion
     language for declaring (_optional_) program properties
     (including types and modes, but also determinacy, non-failure,
     cost, etc.), automatic static inference and static/dynamic
     checking of such assertions, etc.

   * *Ciao* also offers support for _programming in the small_
     producing small executables (including only those builtins used
     by the program) and support for writing scripts in Prolog.

   * The *Ciao* programming environment includes a classical
     top-level and a rich emacs interface with an embeddable
     source-level debugger and a number of execution visualization
     tools.

   * The *Ciao* compiler (which can be run outside the top level
     shell) generates several forms of architecture-independent and
     stand-alone executables, which run with speed, efficiency and
     executable size which are very competive with other commercial
     and academic Prolog/CLP systems. Library modules can be compiled
     into compact bytecode or C source files, and linked statically,
     dynamically, or autoloaded.

   * The novel modular design of Ciao enables, in addition to modular
     program development, effective global program analysis and
     static debugging and optimization via source to source program
     transformation. These tasks are performed by the *Ciao
     preprocessor* ( `ciaopp', distributed separately).

   * The *Ciao* programming environment also includes `lpdoc', an
     automatic documentation generator for LP/CLP programs. It
     processes Prolog files adorned with (*Ciao*) assertions and
     machine-readable comments and generates manuals in many formats
     including `postscript', `pdf', `texinfo', `info', `HTML', `man',
     etc. , as well as on-line help, ascii `README' files, entries
     for indices of manuals (`info', WWW, ...), and maintains WWW
     distribution sites.


   *Ciao* is distributed under the GNU General Public License.


   This documentation corresponds to version 1.6#3 (2000/8/23,
11:27:29 CEST).

   Copyright (C) F. Bueno, D. Cabeza, M. Carro, M. Hermenegildo, P.
Lo'pez, and G. Puebla

   This document may be freely read, stored, reproduced,
disseminated, translated or quoted by any means and on any medium
provided the following conditions are met:

  1. Every reader or user of this document acknowledges that is aware
     that no guarantee is given regarding its contents, on any
     account, and specifically concerning veracity, accuracy and
     fitness for any purpose.

  2. No modification is made other than cosmetic, change of
     representation format, translation, correction of obvious
     syntactic errors, or as permitted by the clauses below.

  3. Comments and other additions may be inserted, provided they
     clearly appear as such; translations or fragments must clearly
     refer to an original complete version, preferably one that is
     easily accessed whenever possible.

  4. Translations, comments and other additions or modifications must
     be dated and their author(s) must be identifiable (possibly via
     an alias).

  5. This licence is preserved and applies to the whole document with
     modifications and additions (except for brief quotes),
     independently of the representation format.

  6. Any reference to the "official version", "original version" or
     "how to obtain original versions" of the document is preserved
     verbatim. Any copyright notice in the document is preserved
     verbatim. Also, the title and author(s) of the original document
     should be clearly mentioned as such.

  7. In the case of translations, verbatim sentences mentioned in
     (6.) are preserved in the language of the original document
     accompanied by verbatim translations to the language of the
     traslated document. All translations state clearly that the
     author is not responsible for the translated work. This license
     is included, at least in the language in which it is referenced
     in the original version.

  8. Whatever the mode of storage, reproduction or dissemination,
     anyone able to access a digitized version of this document must
     be able to make a digitized copy in a format directly usable,
     and if possible editable, according to accepted, and publicly
     documented, public standards.

  9. Redistributing this document to a third party requires
     simultaneous redistribution of this licence, without
     modification, and in particular without any further condition or
     restriction, expressed or implied, related or not to this
     redistribution. In particular, in case of inclusion in a
     database or collection, the owner or the manager of the database
     or the collection renounces any right related to this inclusion
     and concerning the possible uses of the document after
     extraction from the database or the collection, whether alone or
     in relation with other documents.


   Any incompatibility of the above clauses with legal, contractual
or judiciary decisions or constraints implies a corresponding
limitation of reading, usage, or redistribution rights for this
document, verbatim or modified.


File: ciao.info,  Node: Top,  Next: Summary,  Prev: (dir),  Up: (dir)

The Ciao Prolog System
**********************


   This documentation corresponds to version 1.6#3 (2000/8/23,
11:27:29 CEST).

* Menu:

* Summary::
* Introduction::
* Getting started on Un*x-like machines::
* Getting started on Windows machines::
* *** PART I - The program development environment::
* The stand-alone command-line compiler::
* The interactive top-level shell::
* The interactive debugger::
* Predicates controlling the interactive debugger::
* The script interpreter::
* Customizing library paths and path aliases::
* Using Ciao inside GNU emacs::
* *** PART II - The Ciao basic language (engine)::
* The module system::
* Directives for using code in other files::
* Control constructs/predicates::
* Basic builtin directives::
* Basic data types and properties::
* Extra-logical properties for typing::
* Basic term manipulation::
* Comparing terms::
* Basic predicates handling names of constants::
* Arithmetic::
* Basic file/stream handling::
* Basic input/output::
* Exception handling::
* Changing system behaviour and various flags::
* Fast/concurrent update of facts::
* Extending the syntax::
* Message printing primitives::
* Attributed variables::
* Gathering some basic internal info::
* *** PART III - ISO-Prolog library (iso)::
* ISO-Prolog package::
* All solutions predicates::
* Dynamic predicates::
* Term input::
* Term output::
* Defining operators::
* iso_byte_char (library)::
* iso_misc (library)::
* iso_incomplete (library)::
* *** PART IV - Classic Prolog library (classic)::
* Classic Prolog package::
* Definite clause grammars::
* Definite clause grammars (expansion)::
* List processing::
* Sorting lists::
* Dictionaries::
* String processing::
* Formatted output::
* DEC-10 Prolog file IO::
* ttyout (library)::
* dynmods (library)::
* Quintus-like internal database::
* runtime_ops (library)::
* *** PART V - Annotated Prolog library (assertions)::
* The Ciao assertion package::
* Types and properties related to assertions::
* Declaring regular types::
* Properties which are native to analyzers::
* Meta-properties::
* ISO-Prolog modes::
* Classical Prolog modes::
* Run-time checking of assertions::
* *** PART VI - Ciao Prolog library miscellanea::
* Structured stream handling::
* Operating system utilities::
* Prolog system internal predicates::
* Atom to Term Conversion::
* ctrlcclean (library)::
* errhandle (library)::
* Fast Reading and Writing of Terms::
* File name manipulation::
* file_utils (library)::
* terms (library)::
* Printing status and error messages::
* A simple pretty-printer for Ciao programs::
* Pretty-printing assertions::
* The Ciao library browser::
* Code translation utilities::
* Low-level concurrency/multithreading primitives::
* conc_aggregates (library)::
* The socket interface::
* *** PART VII - Ciao Prolog extensions::
* Pure Prolog package::
* argnames (library)::
* Independent and-parallel execution::
* functions (library)::
* Some Higher-Order Predicates::
* global (library)::
* Miscellaneous predicates::
* Delaying predicates (freeze)::
* Delaying predicates (when)::
* Active modules (high-level distributed execution)::
* Breadth-first execution::
* Iterative-deepening execution::
* Constraint programming over rationals::
* Constraint programming over reals::
* Object oriented programming::
* Declaring classes and interfaces::
* Compile-time usage of objects::
* Run time usage of objects::
* *** PART VIII - Interfaces to other languages and systems::
* foreign_interface (library)::
* Utilities for on-demand compilation of foreign files::
* davinci (library)::
* The Tcl/Tk interface::
* The PiLLoW Web Programming Library::
* HTML/XML/CGI programming::
* HTTP conectivity::
* PiLLoW types::
* Persistent predicate database::
* Using the persdb library::
* SQL persistent database interface::
* Prolog to SQL translator::
* Low-level socket interface to SQL/ODBC databases::
* Low-level Prolog to Java interface::
* Low-level Java to Prolog interface::
* Low-level Prolog to Java socket connection::
* Calling emacs from Prolog::
* linda (library)::
* *** PART IX - Abstract data types::
* counters (library)::
* Identity lists::
* Term manipulation::
* Lists of numbers::
* Pattern (regular expression) matching::
* Graphs::
* Unweighted graph-processing utilities::
* wgraphs (library)::
* Labeled graph-processing utilities::
* queues (library)::
* Random numbers::
* sets (library)::
* Variable name dictionaries::
* *** PART X - Miscellaneous standalone utilities::
* A Program to Help Cleaning your Directories ::
* Printing the declarations and code in a file::
* Printing the contents of a bytecode file::
* Crossed-references of a program::
* Gathering the dependent files for a file::
* Finding differences between two Prolog files::
* The Ciao lpmake scripting facility::
* Find out which architecture we are running on::
* *** PART XI - Contributed libraries::
* Programming MYCIN rules::
* A Chart Library::
* Low level Interface between Prolog and blt::
* chartlib_errhandle (library)::
* Color and Pattern Library::
* genbar1 (library)::
* genbar2 (library)::
* genbar3 (library)::
* genbar4 (library)::
* gengraph1 (library)::
* gengraph2 (library)::
* genmultibar (library)::
* table_widget1 (library)::
* table_widget2 (library)::
* table_widget3 (library)::
* table_widget4 (library)::
* test_format (library)::
* *** PART XII - Appendices::
* Installing Ciao from the source distribution::
* Installing Ciao from a Win32 binary distribution::
* Beyond installation::
* References::
* Library/Module Definition Index::
* Predicate/Method Definition Index::
* Property Definition Index::
* Regular Type Definition Index::
* Declaration Definition Index::
* Concept Definition Index::
* Global Index::


File: ciao.info,  Node: Summary,  Next: Introduction,  Prev: Top,  Up: Top

Summary
*******

   *Ciao* is a _public domain_, _next generation_ programming
environment with a unique set of features:

   * Ciao is a complete Prolog system, supporting _ISO-Prolog_, but
     its novel modular design allows both _restricting_ and
     _extending_ the language. As a result, it allows working with
     _fully declarative subsets_ of Prolog and also to _extend_ these
     subsets (or ISO-Prolog) both syntactically and semantically.
     Most importantly, these restrictions and extensions can be
     activated separately on each program module so that several
     extensions can coexist in the same application for different
     modules.

   * Ciao extensions currently include feature terms (records),
     higher-order (with predicate abstractions), functions,
     constraints, objects, persistence, several control rules
     (breadth-first search, iterative deepening, ...), concurrency
     (threads/engines), a good base for distributed execution
     (agents), and parallel execution. Libraries also support WWW
     programming, sockets, external interfaces (C, Java, TclTk,
     relational databases, etc.), etc.

   * *Ciao* offers support for _programming in the large_ with a
     robust module/object system, module-based separate/incremental
     compilation (automatically -no need for makefiles), an assertion
     language for declaring (_optional_) program properties
     (including types and modes, but also determinacy, non-failure,
     cost, etc.), automatic static inference and static/dynamic
     checking of such assertions, etc.

   * *Ciao* also offers support for _programming in the small_
     producing small executables (including only those builtins used
     by the program) and support for writing scripts in Prolog.

   * The *Ciao* programming environment includes a classical
     top-level and a rich emacs interface with an embeddable
     source-level debugger and a number of execution visualization
     tools.

   * The *Ciao* compiler (which can be run outside the top level
     shell) generates several forms of architecture-independent and
     stand-alone executables, which run with speed, efficiency and
     executable size which are very competive with other commercial
     and academic Prolog/CLP systems. Library modules can be compiled
     into compact bytecode or C source files, and linked statically,
     dynamically, or autoloaded.

   * The novel modular design of Ciao enables, in addition to modular
     program development, effective global program analysis and
     static debugging and optimization via source to source program
     transformation. These tasks are performed by the *Ciao
     preprocessor* ( `ciaopp', distributed separately).

   * The *Ciao* programming environment also includes `lpdoc', an
     automatic documentation generator for LP/CLP programs. It
     processes Prolog files adorned with (*Ciao*) assertions and
     machine-readable comments and generates manuals in many formats
     including `postscript', `pdf', `texinfo', `info', `HTML', `man',
     etc. , as well as on-line help, ascii `README' files, entries
     for indices of manuals (`info', WWW, ...), and maintains WWW
     distribution sites.


   *Ciao* is distributed under the GNU General Public License.


File: ciao.info,  Node: Introduction,  Next: Getting started on Un*x-like machines,  Prev: Summary,  Up: Top

Introduction
************

* Menu:

* About this manual::
* About the Ciao Prolog development system::
* ISO-Prolog compliance versus extensibility::
* About the name of the System::
* Referring to Ciao::
* Syntax terminology and notational conventions::
* A tour of the manual::
* Acknowledgments::
* Version/Change Log (ciao)::


File: ciao.info,  Node: About this manual,  Next: About the Ciao Prolog development system,  Prev: Introduction,  Up: Introduction

About this manual
=================

   This is the _Reference Manual_ for the Ciao Prolog development
system. It contains basic information on how to install Ciao Prolog
and how to write, debug, and run Ciao Prolog programs from the
command line, from inside GNU `emacs', or form a windowing desktop.
It also documents all the libraries available in the standard
distribution.

   This manual has been generated using the _LPdoc_ semi-automatic
documentation generator for LP/CLP programs [HC97,Her00].  `lpdoc'
processes Prolog files (and files in other CLP languages) adorned
with assertions and machine-readable comments, which should be
written in the Ciao assertion language [PBH97,PBH00]. From these, it
generates manuals in many formats including `postscript', `pdf',
`texinfo', `info', `HTML', `man', etc., as well as on-line help,
ascii `README' files, entries for indices of manuals (`info', WWW,
...), and maintains WWW distribution sites.

   The big advantage of this approach is that it is easier to keep
the on-line and printed documentation in sync with the source code
[Knu84]. As a result, _this manual changes continually as the source
code is modified_. Because of this, the manual has a version number.
You should make sure the manual you are reading, whether it be
printed or on-line, coincides with the version of the software that
you are using.

   The approach also implies that there is often a variability in the
degree to which different libraries or system components are
documented. Many libraries offer abundant documentation, but a few
will offer little. The latter is due to the fact that we tend to
include libraries in the manual if the code is found to be useful,
even if they may still contain sparse documentation. This is because
including a library in the manual will at the bare minimum provide
formal information (such as the names of exported predicates and
their arity, which other modules it loads, etc.), create index
entries, pointers for on-line help in the electronic versions of the
manuals, and command-line completion capabilities inside `emacs'.
Again, the manual is being updated continuously as the different
libraries (and machine-readable documentation in them) are improved.


File: ciao.info,  Node: About the Ciao Prolog development system,  Next: ISO-Prolog compliance versus extensibility,  Prev: About this manual,  Up: Introduction

About the Ciao Prolog development system
========================================

   The Ciao system is a full programming environment for developing
programs in the Prolog language and in several other languages which
are extensions and modifications of Prolog in several interesting and
useful directions. The programming environment offers a number of
tools such as the Ciao standalone compiler (`ciaoc'), a
traditional-style top-level interactive shell (`ciaosh' or `ciao'),
an interpreter of scripts written in Prolog (`ciao-shell'), a Prolog
`emacs' mode (which greatly helps the task of developing programs
with support for editing, debugging, version/change tracking, etc.),
numerous libraries, a powerful program preprocessor (`ciaopp'
[BdlBH99,BLGPH99,HBPLG99], which supports static debugging and
optimization from program analysis via source to source program
transformation), and an automatic documentation generator (`lpdoc')
[HC97,Her00]. A number of execution visualization tools
[CGH93,CH00d,CH00c] are also available.

   This manual documents the first four of the tools mentioned above
[see PART I - The program development environment], and the Ciao
Prolog language and libraries. The `ciaopp' and `lpdoc' tools are
documented in separate manuals.

   The Ciao language [see PART II - The Ciao basic language (engine)]
has been designed from the ground up to be small, but to also allow
extensions and restrictions in a modular way. The first objective
allows producing small executables (including only those builtins
used by the program), providing basic support for pure logic
programming, and being able to write scripts in Prolog. The second
one allows supporting standard ISO-Prolog [see PART III - ISO-Prolog
library (iso)], as well as powerful extensions such as constraint
logic programming, functional logic programming, and object-oriented
logic programming [see PART VII - Ciao Prolog extensions], and
restrictions such as working with pure horn clauses.

   The design of Ciao has also focused on allowing modular program
development, as well as automatic program manipulation and
optimization. Ciao includes a robust module system [CH00a],
module-based automatic incremental compilation [CH99], and modular
global program analysis, debugging and optimization [PH99], based on
a rich assertion language [see PART V - Annotated Prolog library
(assertions)] for declaring (optional) program properties (including
types and modes), which can be checked either statically or
dynamically. The program analysis, static debugging and optimization
tasks related to these assertions are performed by the `ciaopp'
preprocessor, as mentioned above. These assertions (together with
special comment-style declarations) are also the ones used by the
`lpdoc' autodocumenter to generate documentation for programs (the
comment-style declarations are documented in the `lpdoc' manual).

   Ciao also includes several other features and utilities, such as
support for several forms of executables, concurrency (threads),
distributed and parallel execution, higher-order, WWW programming
(PiLLoW [CHV96b]), interfaces to other languages like C and Java,
database interfaces, graphical interfaces, etc., etc. [see PARTS VI
to XI].


File: ciao.info,  Node: ISO-Prolog compliance versus extensibility,  Next: About the name of the System,  Prev: About the Ciao Prolog development system,  Up: Introduction

ISO-Prolog compliance versus extensibility
==========================================

   One of the innovative features of Ciao is that it has been
designed to subsume _ISO-Prolog_ (International Standard ISO/IEC
13211-1, PROLOG: Part 1-General Core [DEDC96]), while at the same
time extending it in many important ways. The intention is to ensure
that all ISO-compliant Prolog programs run correctly under Ciao. At
the same time, the Ciao module system (see [PART II - The Ciao basic
language (engine)] and [CH00a] for a discussion of the motivations
behind the design) allows selectively avoiding the loading of most
ISO-builtins (and changing some other ISO characteristics) when not
needed, so that it is possible to work with purer subsets of Prolog
and also to build small executables. Also, this module system makes
it possible to develop extensions using these purer subsets (or even
the full ISO-standard) as a starting point. Using these features, the
Ciao distribution includes libraries which significantly extend the
language both syntactically and semantically.

   Compliance with ISO is still not complete: currently there are
some minor deviations in, e.g., the treatment of characters, the
syntax, some of the arithmetic functions, and part of the error
system. On the other hand, Ciao has been reported by independent
sources (members of the standarization body) to be one of the most
conforming Prologs at the moment of this writing, and the first one
to be able to compile all the standard-conforming test cases. Also,
Ciao does not offer a strictly conforming mode which rejects uses of
non-ISO features. However, in order to aid programmers who wish to
write standard compliant programs, library predicates that correspond
to those in the ISO-Prolog standard are marked specially in the
manuals, and differences between the Ciao and the prescribed
ISO-Prolog behaviours, if any, are commented appropriately.

   The intention of the Ciao developers is to progressively complete
the compliance of Ciao with the published parts of the ISO standard
as well as with other reasonable extensions of the standard may be
published in the future. However, since one of the design objectives
of Ciao is to address some shortcomings of previous implementations
of Prolog and logic programming in general, we also hope that some of
the better ideas present in the system will make it eventually into
the standards.


File: ciao.info,  Node: About the name of the System,  Next: Referring to Ciao,  Prev: ISO-Prolog compliance versus extensibility,  Up: Introduction

About the name of the System
============================

   One of the innovative features of Ciao is that it has been
designed to subsume _ISO-Prolog_ (International Standard ISO/IEC
13211-1, PROLOG: Part 1-General Core [DEDC96]), while at the same
time extending it in many important ways. The intention is to ensure
that all ISO-compliant Prolog programs run correctly under Ciao. At
the same time, the Ciao module system (see [PART II - The Ciao basic
language (engine)] and [CH00a] for a discussion of the motivations
behind the design) allows selectively avoiding the loading of most
ISO-builtins (and changing some other ISO characteristics) when not
needed, so that it is possible to work with purer subsets of Prolog
and also to build small executables. Also, this module system makes
it possible to develop extensions using these purer subsets (or even
the full ISO-standard) as a starting point. Using these features, the
Ciao distribution includes libraries which significantly extend the
language both syntactically and semantically.

   Compliance with ISO is still not complete: currently there are
some minor deviations in, e.g., the treatment of characters, the
syntax, some of the arithmetic functions, and part of the error
system. On the other hand, Ciao has been reported by independent
sources (members of the standarization body) to be one of the most
conforming Prologs at the moment of this writing, and the first one
to be able to compile all the standard-conforming test cases. Also,
Ciao does not offer a strictly conforming mode which rejects uses of
non-ISO features. However, in order to aid programmers who wish to
write standard compliant programs, library predicates that correspond
to those in the ISO-Prolog standard are marked specially in the
manuals, and differences between the Ciao and the prescribed
ISO-Prolog behaviours, if any, are commented appropriately.

   The intention of the Ciao developers is to progressively complete
the compliance of Ciao with the published parts of the ISO standard
as well as with other reasonable extensions of the standard may be
published in the future. However, since one of the design objectives
of Ciao is to address some shortcomings of previous implementations
of Prolog and logic programming in general, we also hope that some of
the better ideas present in the system will make it eventually into
the standards.


File: ciao.info,  Node: Referring to Ciao,  Next: Syntax terminology and notational conventions,  Prev: About the name of the System,  Up: Introduction

Referring to Ciao
=================

   If you find Ciao or any of its components useful, we would
appreciate very much if you added a reference to this manual (i.e.,
the Ciao reference manual [BCC97]) in your work. The following is an
appropriate BiBTeX entry with the relevant data:

     @techreport{ciao-reference-manual-tr,
       author =       {F. Bueno and D. Cabeza and M. Carro and M. Hermenegildo
                       and P. L\'{o}pez-Garc\'{\i}a and G. Puebla},
       title =        {The Ciao Prolog system. Reference manual},
       institution =  {School of Computer Science,
                       Technical University of Madrid (UPM)},
       year =         1997,
       month =        {August},
       number =       {{CLIP}3/97.1},
       note =         {Available from http://www.clip.dia.fi.upm.es/}
     }


File: ciao.info,  Node: Syntax terminology and notational conventions,  Next: A tour of the manual,  Prev: Referring to Ciao,  Up: Introduction

Syntax terminology and notational conventions
=============================================

   This manual is not meant to be an introduction to the Prolog
language. The reader is referred to standard textbooks on Prolog such
as [SS86,CM81,Apt97,Hog84]. However, we would like to refresh herein
some concepts for the sake of establishing terminology. Also, we will
briefly introduce a few of the extensions that Ciao brings to the
Prolog language.

* Menu:

* Predicates and their components::
* Characters and character strings::
* Predicate specs::
* Modes::
* Properties and types::
* Declarations::
* Operators::


File: ciao.info,  Node: Predicates and their components,  Next: Characters and character strings,  Prev: Syntax terminology and notational conventions,  Up: Syntax terminology and notational conventions

Predicates and their components
-------------------------------

   In Prolog, procedures are called _predicates_ and predicate calls
_literals_. They all have the classical syntax of procedures (and of
logic predications and of mathematical functions). Predicates are
identified in this manual by a keyword 'PREDICATE' at the right
margin of the place where they are documented.

   Prolog instructions are expressions made up of control constructs
(*Note Control constructs/predicates::) and literals, and are called
_goals_. Literals are also (atomic) goals.

   A predicate definition is a sequence of clauses. A clause has the
form "`H :- B.'" (ending in '`.''), where `H' is syntactically the
same as a literal and is called the clause _head_, and `B' is a goal
and is called the clause _body_. A clause with no body is written
"`H.'" and is called a _fact_. Clauses with body are also called
_rules_. A Prolog program is a sequence of predicate definitions.


File: ciao.info,  Node: Characters and character strings,  Next: Predicate specs,  Prev: Predicates and their components,  Up: Syntax terminology and notational conventions

Characters and character strings
--------------------------------

   We adopt the following convention for delineating character
strings in the text of this manual: when a string is being used as a
Prolog atom it is written thus: `user' or `'user''; but in all other
circumstances double quotes are used (as in `"hello"').

   When referring to keyboard characters, printing characters are
written thus: <a>, while control characters are written like this:
<^A>. Thus <^C> is the character you get by holding down the <CTL>
key while you type <c>. Finally, the special control characters
carriage-return, line-feed and space are often abbreviated to <RET>,
<LFD> and <SPC> respectively.


File: ciao.info,  Node: Predicate specs,  Next: Modes,  Prev: Characters and character strings,  Up: Syntax terminology and notational conventions

Predicate specs
---------------

   Predicates in Prolog are distinguished by their name _and_ their
arity. We will call `name/arity' a _predicate spec_. The notation
`name/arity' is therefore used when it is necessary to refer to a
predicate unambiguously. For example, `concatenate/3' specifies the
predicate which is named "concatenate" and which takes 3 arguments.

   (Note that different predicates may have the same name and
different arity. Conversely, of course, they may have the same arity
and different name.)


File: ciao.info,  Node: Modes,  Next: Properties and types,  Prev: Predicate specs,  Up: Syntax terminology and notational conventions

Modes
-----

   When documenting a predicate, we will often describe its usage
with a mode spec which has the form `name(Arg1, ..., ArgN)' where
each `Arg' may be preceded by a _mode_. A mode is a functor which is
wrapped around an argument (or prepended if defined as an operator).
Such a mode allows documenting in a compact way the instantiation
state on call and exit of the argument to which it is applied. The
set of modes which can be used in Ciao is not fixed. Instead,
arbitrary modes can be defined by in programs using the `modedef/1'
declarations of the Ciao _assertion language_ (*Note The Ciao
assertion package:: for details). Modes are identified in this manual
by a keyword 'MODE'.

   Herein, we will use the set of modes defined in the Ciao
`isomodes' library, which is essentially the same as those used in the
ISO-Prolog standard (*Note ISO-Prolog modes::).


File: ciao.info,  Node: Properties and types,  Next: Declarations,  Prev: Modes,  Up: Syntax terminology and notational conventions

Properties and types
--------------------

   Although Ciao Prolog is _not_ a typed language, it allows writing
(and using) types, as well as (more general) properties. There may be
properties of the states and of the computation. Properties of the
states allow expressing characteristics of the program variables
during computation, like in `sorted(X)' (`X' is a sorted list).
Properties of the computation allow expressing characteristics of a
whole computation, like in `is_det(p(X,Y))' (such calls yield only
one solution). Properties are just a special form of predicates
(*Note Declaring regular types::) and are identified in this manual
by a keyword 'PROPERTY'.

   Ciao types are _regular types_ (*Note Declaring regular types::),
which are a special form of properties themselves. They are
identified in this manual by a keyword 'REGTYPE'.


File: ciao.info,  Node: Declarations,  Next: Operators,  Prev: Properties and types,  Up: Syntax terminology and notational conventions

Declarations
------------

   A _declaration_ provides information to one of the Ciao
environment tools. Declarations are interspersed in the code of a
program. Usually the target tool is either the compiler (telling it
that a predicate is dynamic, or a meta-predicate, etc.), the
preprocessor (which understands declarations of properties and types,
assertions, etc.), or the autodocumenter (which understands the
previous declarations and also certain "comment" declarations).

   A declaration has the form `:- D.' where `D' is syntactically the
same as a literal. Declarations are identified in this manual by a
keyword 'DECLARATION'.

   In Ciao users can define (and document) new declarations. New
declarations are typically useful when defining extensions to the
language (which in Ciao are called packages). Such extensions are
often implemented as expansions (see *Note Extending the syntax::).
There are many such extensions in Ciao. The `functions' library,
which provides fuctional syntax, is an example. The fact that in Ciao
expansions are local to modules (as operators, see below) makes it
possible to use a certain language extension in one module without
affecting other modules.


File: ciao.info,  Node: Operators,  Prev: Declarations,  Up: Syntax terminology and notational conventions

Operators
---------

   An _operator_ is a functor (or predicate name) which has been
declared as such, thus allowing its use in a prefix, infix, or suffix
fashion, instead of the standard procedure-like fashion. E.g.,
declaring `+' as an infix operator allows writing `X+Y' instead of
`'+'(X,Y)' (which may still, of course, be written).

   _Operators in Ciao are local to the module/file where they are
declared_. However, some operators are standard and allowed in every
program (see *Note Defining operators::). This manual documents the
operator declarations in each (library) module where they are
included. As with expansions, the fact that in Ciao operators are
local to modules makes it possible to use a certain language
extension in one module without affecting other modules.


File: ciao.info,  Node: A tour of the manual,  Next: Acknowledgments,  Prev: Syntax terminology and notational conventions,  Up: Introduction

A tour of the manual
====================

   The rest of the introductory chapters after this one provide a
first "getting started" introduction for newcomers to the Ciao
system. The rest of the chapters in the manual are organized into a
sequence of major parts as follows:

* Menu:

* PART I - The program development environment::
* PART II - The Ciao basic language (engine)::
* PART III - ISO-Prolog library (iso)::
* PART IV - Classic Prolog library (classic)::
* PART V - Annotated Prolog library (assertions)::
* PART VI - Ciao Prolog library miscellanea::
* PART VII - Ciao Prolog extensions::
* PART VIII - Interfaces to other languages and systems::
* PART IX - Abstract data types::
* PART X - Miscellaneous standalone utilities::
* PART XI - Contributed libraries::
* PART XII - Appendices::


File: ciao.info,  Node: PART I - The program development environment,  Next: PART II - The Ciao basic language (engine),  Prev: A tour of the manual,  Up: A tour of the manual

PART I - The program development environment
--------------------------------------------

   This part documents the components of the basic Ciao program
development environment. They include:

ciaoc:
     the standalone compiler, which creates executables without
     having to enter the interactive top-level.

ciaosh:
     (also invoked simply as `ciao') is an interactive top-level
     shell, similar to the one found on most Prolog systems (with
     some enhancements).

debugger.pl:
     a Byrd box-type debugger, similar to the one found on most
     Prolog systems (also with some enhancements, such as
     source-level debugging). This is not a standalone application,
     but is rather included in `ciaosh', as is done in other Prolog
     systems. However, it is also _embeddable_, in the sense that it
     can be included as a library in executables, and activated
     dynamically and conditionally while such executables are running.

ciao-shell:
     an interpreter/compiler for _Prolog scripts_ (i.e., files
     containing Prolog code which run without needing explicit
     compilation).

ciao.el:
     a _complete program development enviroment_, based on GNU emacs,
     with syntax coloring, direct access to all the tools described
     above (as well as the preprocessor and the documenter), atomatic
     location of errors, source-level debugging, context-sensitive
     access to on-line help/manuals, etc. The use of this environment
     is _very highly recommended_!

   The Ciao program development environment also includes `ciaopp',
the preprocessor, and `lpdoc', the documentation generator, which are
described in separate manuals.


File: ciao.info,  Node: PART II - The Ciao basic language (engine),  Next: PART III - ISO-Prolog library (iso),  Prev: PART I - The program development environment,  Up: A tour of the manual

PART II - The Ciao basic language (engine)
------------------------------------------

   This part documents the _Ciao basic builtins_. These predefined
predicates and declarations are available in every program, unless the
`pure' package is used (by using a `:- module(_,_,[pure]).'
declaration or `:- use_package(pure).'). These predicates are
contained in the `engine' directory within the `lib' library.  The
rest of the library predicates, including the packages that provide
most of the ISO-Prolog builtins, are documented in subsequent parts.


File: ciao.info,  Node: PART III - ISO-Prolog library (iso),  Next: PART IV - Classic Prolog library (classic),  Prev: PART II - The Ciao basic language (engine),  Up: A tour of the manual

PART III - ISO-Prolog library (iso)
-----------------------------------

   This part documents the _iso_ package which provides to Ciao
programs (most of) the ISO-Prolog functionality , including the
_ISO-Prolog builtins_ not covered by the basic library. All these
predicates are loaded by default in user files and in modules which
use standard module declarations such as:

   `:- module(_modulename_,_exports_).'

   which are equivalent to:

   `:- module(_modulename_,_exports_,[iso]).'

   or

   `:- module(_modulename_,_exports_).'

   `:- use_package([iso]).'

   If you do not want these ISO builtins loaded for a given file (in
order to make the executable smaller) you can ask for this explicitly
using:

   `:- module(_modulename_,_exports_,[]).'

   or

   `:- module(_modulename_,_exports_).'

   `:- use_package([]).'

   See the description of the declarations for declaring modules and
using other modules, and the documentation of the `iso' library for
details.


File: ciao.info,  Node: PART IV - Classic Prolog library (classic),  Next: PART V - Annotated Prolog library (assertions),  Prev: PART III - ISO-Prolog library (iso),  Up: A tour of the manual

PART IV - Classic Prolog library (classic)
------------------------------------------

   This part documents some Ciao libraries which provide additional
predicates and functionalities that, despite not being in the ISO
standard, are present in many popular Prolog systems. This includes
definite clause grammars (DCGs), "Quintus-style" internal database,
list processing predicates, dictionaries, string processing, DEC-10
Prolog-style input/output, formatted output, dynamic loading of
modules, activation of operators at run-time, etc.


File: ciao.info,  Node: PART V - Annotated Prolog library (assertions),  Next: PART VI - Ciao Prolog library miscellanea,  Prev: PART IV - Classic Prolog library (classic),  Up: A tour of the manual

PART V - Annotated Prolog library (assertions)
----------------------------------------------

   Ciao allows _annotating_ the program code with _assertions_. Such
assertions include type and instantiation mode declarations, but also
more general properties as well as comments in the style of the
_literate programming_. These assertions document predicates (and
modules and whole applications) and can be used by the Ciao
preprocessor/compiler while debugging and optimizing the program or
library, and by the Ciao documenter to build the program or library
reference manual.


File: ciao.info,  Node: PART VI - Ciao Prolog library miscellanea,  Next: PART VII - Ciao Prolog extensions,  Prev: PART V - Annotated Prolog library (assertions),  Up: A tour of the manual

PART VI - Ciao Prolog library miscellanea
-----------------------------------------

   This part documents several Ciao libraries which provide different
useful additional functionalities. Such functionalities include
performing operating system calls, gathering statistics from the
Prolog engine, file and file name manipulation, error and exception
handling, fast reading and writing of terms ( marshalling and
unmarshalling), file locking, program reporting messages,
pretty-printing programs and assertions, a browser of the system
libraries, additional expansion utilities, concurrent aggregates,
graph visualization, etc.


File: ciao.info,  Node: PART VII - Ciao Prolog extensions,  Next: PART VIII - Interfaces to other languages and systems,  Prev: PART VI - Ciao Prolog library miscellanea,  Up: A tour of the manual

PART VII - Ciao Prolog extensions
---------------------------------

   The libraries documented in this part extend the Ciao language in
several different ways. The extensions include:
   * pure Prolog programming (well, this can be viewed more as a
     restriction than an extension);

   * feature terms or _records_ (i.e., structures with names for each
     field);

   * parallel programming (e.g., &-Prolog style);

   * functional syntax;

   * higher-order library;

   * global variables;

   * `setarg' and `undo';

   * delaying predicate execution;

   * active modules;

   * breadth-first execution;

   * iterative deepening-based execution;

   * constraint logic programming;

   * object oriented programming.


File: ciao.info,  Node: PART VIII - Interfaces to other languages and systems,  Next: PART IX - Abstract data types,  Prev: PART VII - Ciao Prolog extensions,  Up: A tour of the manual

PART VIII - Interfaces to other languages and systems
-----------------------------------------------------

   The following interfaces to/from Ciao Prolog are documented in
this part:
   * External interface (e.g., to C).

   * Socket interface.

   * Tcl/tk interface.

   * Web interface (http, html, xml, etc.);

   * Persistent predicate databases (interface between the Prolog
     internal database and the external file system).

   * SQL-like database interface (interface between the Prolog
     internal database and external SQL/ODBC systems).

   * Java interface.

   * Calling emacs from Prolog.


File: ciao.info,  Node: PART IX - Abstract data types,  Next: PART X - Miscellaneous standalone utilities,  Prev: PART VIII - Interfaces to other languages and systems,  Up: A tour of the manual

PART IX - Abstract data types
-----------------------------

   This part includes libraries which implement some generic data
structures (abstract data types) that are used frequently in programs
or in the Ciao system itself.


File: ciao.info,  Node: PART X - Miscellaneous standalone utilities,  Next: PART XI - Contributed libraries,  Prev: PART IX - Abstract data types,  Up: A tour of the manual

PART X - Miscellaneous standalone utilities
-------------------------------------------

   This is the documentation for a set of miscellaneous standalone
utilities contained in the `etc' directory of the Ciao distribution.


File: ciao.info,  Node: PART XI - Contributed libraries,  Next: PART XII - Appendices,  Prev: PART X - Miscellaneous standalone utilities,  Up: A tour of the manual

PART XI - Contributed libraries
-------------------------------

   This part includes a number of libraries which have contributed by
users of the Ciao system. Over time, some of these libraries are
moved to the main library directories of the system.


File: ciao.info,  Node: PART XII - Appendices,  Prev: PART XI - Contributed libraries,  Up: A tour of the manual

PART XII - Appendices
---------------------

   These appendices describe the installation of the Ciao environment
on different systems and some other issues such as reporting bugs,
signing up on the Ciao user's mailing list, downloading new versions,
limitations, etc.


File: ciao.info,  Node: Acknowledgments,  Next: Version/Change Log (ciao),  Prev: A tour of the manual,  Up: Introduction

Acknowledgments
===============

   The Ciao system is a joint effort on one side of the present (
_Francisco Bueno_, _Daniel Cabeza_, _Manuel Carro_, _Manuel
Hermenegildo_, _Pedro Lo'pez_, and _Germa'n Puebla_) and past (
_Mari'a Jose' Garci'a de la Banda_) members of the _CLIP group_ at
the School of Computer Science, _Technical University of Madrid_ ,
and on the other side of several colleagues and students that have
collaborated with us over the years of its development. The following
is an (inevitably incomplete) list of those that have contributed to
the development of Ciao:

   * The _Ciao engine_, compiler, libraries and documentation,
     although completely rewritten at this point, have their origins
     in the _&-Prolog_ _parallel Prolog_ engine and _parallelizing
     compiler_, developed by _Manuel Hermenegildo_, _Kevin Greene_,
     _Kalyan Muthukumar_, and _Roger Nasr_ at _MCC_ and later at
     _UPM_. The &-Prolog engine and low-level ( _WAM_) compilers in
     turn were derived from early versions (0.5 to 0.7) of _SICStus
     Prolog_ [Car88]. SICStus is an excellent, high performance
     Prolog system, developed by _Mats Carlsson_ and colleagues at the
     _Swedish Institute of Computer Science_ ( _SICS_), that every
     user of Prolog should check out [Swe95,AAF91]. Very special
     thanks are due to _Seif Haridi_, _Mats Carlsson_, and colleagues
     at SICS for allowing the SICStus 0.5-0.7 components in
     _&-Prolog_ and its successor, Ciao, to be distributed freely.
     Parts of the parallel abstract machine have been developed in
     collaboration with _Gopal Gupta_ and _Enrico Pontelli_ ( _New
     Mexico State University_).

   * Many aspects of the analyzers in the _Ciao preprocessor_ (
     `ciaopp') have been developed in collaboration with _Peter
     Stuckey_ ( _Melbourne U._), _Kim Marriott_ ( _Monash U._),
     _Maurice Bruynooghe_, _Gerda Janssens_, _Anne Mulkers_, and
     _Veroniek Dumortier_ ( _K.U. Leuven_), and _Saumya Debray_ ( _U.
     of Arizona_). The assertion system has been developed in
     collaboration with _Jan Maluzynski_ and _Wlodek Drabent_ (
     _Linkoping U._) and _Pierre Deransart_ ( _INRIA_). The core of
     type inference system derives from the system developed by _John
     Gallagher_ [GdW94] ( _Bristol University_) and later adapted to
     CLP(FD) by _Pawel Pietrzak_ ( _Linkoping U._).

   * The constraint solvers for _R_ and _Q_ are derived from the code
     developed by _Christian Holzbauer_ ( _Austrian Research
     Institute for AI_ in Vienna) [Hol94,Hol90,Hol92].

   * The Ciao manuals include material from the _DECsystem-10 Prolog
     User's Manual_ by _D.L. Bowen_ (editor), _L. Byrd_, _F.C.N.
     Pereira_, _L.M. Pereira_, and _D.H.D. Warren_ [BBP81]. They also
     contain material from the SICStus Prolog user manuals for
     SICStus versions 0.5-0.7 by _Mats Carlsson_ and _Johan Widen_
     [Car88], as well as from the Prolog ISO standard documentation
     [DEDC96].

   * Ciao is designed to be highly extendable in a modular way. Many
     of the libraries distributed with Ciao have been developed by
     other people all of which is impossible to mention here.
     Individual author names are included in the documentation of
     each library and appear in the indices.

   * The development of the Ciao system has been supported in part by
     ESPRIT projects ACCLAIM, PARFORCE, and DISCIPL, and by CICYT/MEC
     projects ELLA and EDIPIA.


   If you feel you have contributed to the development of Ciao and we
have forgotten adding your name to this list or the acknowledgements
given in the different chapters, please let us know and we will be
glad to give proper credits.


File: ciao.info,  Node: Version/Change Log (ciao),  Prev: Acknowledgments,  Up: Introduction

Version/Change Log (`ciao')
===========================

*Version 1.6 (2000/7/12, 18:55:50 CEST)*
        * Source-level debugger in emacs, breakpts.

        * Emacs environment improved, added menus for Ciaopp and
          LPDoc.

        * Debugger embeddable in executables.

        * Stand-alone executables available for UNIX-like operating
          systems.

        * Many improvements to emacs interface.

        * Menu-based interface to autodocumenter.

        * Threads now available in Win32.

        * Many improvements to threads.

        * Modular clp(R) / clp(Q).

        * Libraries implementing And-fair breadth-first and iterative
          deepening included.

        * Improved syntax for predicate abstractions.

        * Library of higher-order list predicates.

        * Better code expansion facilities (macros).

        * New delay predicates (when/2).

        * Compressed object code/executables on demand.

        * The size of atoms is now unbound.

        * Fast creation of new unique atoms.

        * Number of clauses/predicates essentially unbound.

        * Delayed goals with freeze restored.

        * Faster compilation and startup.

        * Much faster fast write/read.

        * Improved documentation.

        * Other new libraries.

        * Improved installation/deinstallation on all platforms.

        * Many improvements to autodocumenter.

        * Many bug fixes in libraries and engine.

*Version 1.5 (1999/11/29, 16:16:23 MEST)*
     Development version following even 1.4 distribution.

*Version 1.4 (1999/11/27, 19:0:0 MEST)*
        * Documentation greatly improved.

        * Automatic (re)compilation of foreign files.

        * Concurrency primitives revamped; restored &Prolog-like
          multiengine capability.

        * Windows installation and overall operation greatly improved.

        * New version of O'Ciao class/object library, with improved
          performance.

        * Added support for "predicate abstractions" in call/N.

        * Implemented reexportation through reexport declarations.

        * Changed precedence of importations, last one is now higher.

        * Modules can now implicitly export all predicates.

        * Many minor bugs fixed.

*Version 1.3 (1999/6/16, 17:5:58 MEST)*
     Development version following even 1.2 distribution.

*Version 1.2 (1999/6/14, 16:54:55 MEST)*
     Temporary version distributed locally for extensive testing of
     reexportation and other 1.3 features.

*Version 1.1 (1999/6/4, 13:30:37 MEST)*
     Development version following even 1.0 distribution.

*Version 1.0 (1999/6/4, 13:27:42 MEST)*
        * Added Tcl/Tk interface library to distribution.

        * Added push_prolog_flag/2 and pop_prolog_flag/1
          declarations/builtins.

        * Filename processing in Windows improved.

        * Added redefining/1 declaration to avoid redefining warnings.

        * Changed syntax/1 declaration to use_package/1.

        * Added add_clause_trans/1 declaration.

        * Changed format of .itf files such that a '+' stands for all
          the standard imports from engine, which are included in
          c_itf source internally (from engine(builtin_exports)).
          Further changes in itf data handling, so that once an .itf
          file is read in a session, the file is cached and next time
          it is needed no access to the file system is required.

        * Many bugs fixed.

*Version 0.9 (1999/3/10, 17:3:49 CET)*
        * Test version before 1.0 release. Many bugs fixed.

*Version 0.8 (1998/10/27, 13:12:36 MET)*
        * Changed compiler so that only one pass is done, eliminated
          `.dep' files.

        * New concurrency primitives.

        * Changed assertion comment operator to #.

        * Implemented high-order with call/N.

        * Integrated SQL-interface to external databases with
          persistent predicate concept.

        * First implementation of object oriented programming package.

        * Some bugs fixed.

*Version 0.7 (1998/9/15, 12:12:33 MEST)*
        * Improved debugger capabilities and made easier to use.

        * Simplified assertion format.

        * New arithmetic functions added, which complete all ISO
          functions.

        * Some bugs fixed.

*Version 0.6 (1998/7/16, 21:12:7 MET DST)*
        * Defining other path aliases (in addition to 'library')
          which can be loaded dynamically in executables is now
          possible.

        * Added the posibility to define multifile predicates in the
          shell.

        * Added the posibility to define dynamic predicates
          dynamically.

        * Added addmodule meta-argument type.

        * Implemented persistent data predicates.

        * New version of PiLLoW WWW library (XML, templates, etc.).

        * Ported active modules from "distributed Ciao" (independent
          development version of Ciao).

        * Implemented lazy loading in executables.

        * Modularized engine(builtin).

        * Some bugs fixed.

*Version 0.5 (1998/3/23)*
        * First Windows version.

        * Integrated debugger in toplevel.

        * Implemented DCG's as (Ciao-style) expansions.

        * Builtins renamed to match ISO-Prolog.

        * Made ISO the default syntax/package.

*Version 0.4 (1998/2/24)*
        * First version with the new Ciao emacs mode.

        * Full integration of concurrent engine and compiler/library.

        * Added new_declaration/1 directive.

        * Added modular syntax enhancements.

        * Shell script interpreter separated from toplevel shell.

        * Added new compilation warnings.

*Version 0.3 (1997/8/20)*
        * Ciao builtins modularized.

        * New prolog flags can be defined by libraries.

        * Standalone comand-line compiler available, with automatic
          "make".

        * Added assertions and regular types.

        * First version using the automatic documentation generator.

*Version 0.2 (1997/4/16)*
        * First module system implemented.

        * Implemented exceptions using catch/3 and throw/1.

        * Added functional & record syntax.

        * Added modular sentence, term, and goal translations.

        * Implemented attributed variables.

        * First CLPQ/CLPR implementation.

        * Added the posibility of linking external .so files.

        * Changes in syntax to allow `P(X)' and `"string"||L'.

        * Changed to be more similar to ISO-Prolog.

        * Implemented Prolog shell scripts.

        * Implemented data predicates.

*Version 0.1 (1997/2/13)*
     First fully integrated, standalone Ciao distribution. Based on
     integrating into an evolution of the &-Prolog
     engine/libraries/preprocessor [Her86,HG91] many functionalities
     from several previous independent development versions of Ciao
     [HC93,HC94,HCC95,Bue95,CLI95,HBGP95,HBC96,CHV96b,HBC99].


File: ciao.info,  Node: Getting started on Un*x-like machines,  Next: Getting started on Windows machines,  Prev: Introduction,  Up: Top

Getting started on Un*x-like machines
*************************************

   *Author(s):* M.Hermenegildo.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   This part guides you through some very basic first steps with Ciao
on a Un*x system. It assumes that Ciao is already installed correctly
on your Windows system. If this is not the case, then follow the
instructions in *Note Installing Ciao from the source distribution::
first.

   We start with by describing the basics of using Ciao from a normal
command shell such as `sh/bash', `csh/tcsh', etc. We strongly
recommend reading also *Note An introduction to the Ciao emacs
environment (Un*x):: for the basics on using Ciao under `emacs',
which is a much simpler and much more powerful way of developing Ciao
programs, and has the advantage of offering an almost identical
environment under Windows and Un*x.

* Menu:

* Testing your Ciao Un*x installation::
* Un*x user setup::
* Using Ciao from a Un*x command shell::
* An introduction to the Ciao emacs environment (Un*x)::
* Keeping up to date (Un*x)::


File: ciao.info,  Node: Testing your Ciao Un*x installation,  Next: Un*x user setup,  Prev: Getting started on Un*x-like machines,  Up: Getting started on Un*x-like machines

Testing your Ciao Un*x installation
===================================

It is a good idea to start by performing some tests to check that
Ciao is installed correctly on your system (these are the same tests
that you are instructed to do during installation, so you can
obviously skip them if you have done them already at that time). If
any of these tests do not succeed either your environment variables
are not set properly (see *Note Un*x user setup:: for how to fix
this):

   * Typing `ciao' (or `ciaosh') should start the typical Prolog
     top-level shell.

   * In the top-level shell, Prolog library modules should load
     correctly. Type for example `use_module(library(dec10_io))' -you
     should get back a prompt with no errors reported.

   * To exit the top level shell, type `halt.' as usual, or <^D>.

   * Typing `ciaoc' should produce the help message from the Ciao
     standalone compiler.

   * Typing `ciao-shell' should produce a message saying that no code
     was found. This is a Ciao application which can be used to write
     scripts written in Prolog, i.e., files which do not need any
     explicit compilation to be run.


Also, the following documentation-related actions should work:

   * If the `info' program is installed, typing `info' should produce
     a list of manuals which _should include Ciao manual(s) in a
     separate area_ (you may need to log out and back in so that your
     shell variables are reinitialized for this to work).

   * Opening with a WWW browser (e.g., `netscape') the directory or
     `URL' corresponding to the `DOCROOT' setting should show a
     series of Ciao-related manuals. Note that _style sheets_ should
     be activated for correct formatting of the manual.

   * Typing `man ciao' should produce a man page with some very basic
     general information on Ciao (and pointing to the on-line
     manuals).

   * The `DOCROOT' directory should contain the manual also in the
     other formats such as `postscript' or `pdf' which specially
     useful for printing. See *Note Printing manuals (Un*x):: for
     instructions.



File: ciao.info,  Node: Un*x user setup,  Next: Using Ciao from a Un*x command shell,  Prev: Testing your Ciao Un*x installation,  Up: Getting started on Un*x-like machines

Un*x user setup
===============

   If the tests above have succeeded, the system is probably
installed correctly and your environment variables have been set
already. In that case you can skip to the next section.

   Otherwise, if you have not already done so, make the following
modifications in your startup scripts, so that these files are used
(`<LIBROOT>' must be replaced with the appropriate value, i.e., where
the Ciao library is installed):

   * For users a _csh-compatible shell_ ( `csh', `tcsh', ...), add to
     `~/.cshrc':

                  if ( -e <LIBROOT>/ciao/DOTcshrc ) then
                     source <LIBROOT>/ciao/DOTcshrc
                  endif

   * For users of an _sh-compatible shell_ ( `sh', `bash', ...), add
     to `~/.profile':

                  if [ -f <LIBROOT>/ciao/DOTprofile ]; then
                     . <LIBROOT>/ciao/DOTprofile
                  fi

     This will set up things so that the Ciao executables are found
     and you can access the Ciao system manuals using the `info'
     command. Note that, depending on your shell, _you may have to
     log out and back in_ for the changes to take effect.

   * Also, if you use `emacs' (highly recommended) add this line to
     your `~/.emacs' file:

                  (load-file "<LIBROOT>/ciao/DOTemacs.el")


   If after following these steps things do not work properly, then
the installation was probably not completed properly and you may want
to try reinstalling the system.


File: ciao.info,  Node: Using Ciao from a Un*x command shell,  Next: An introduction to the Ciao emacs environment (Un*x),  Prev: Un*x user setup,  Up: Getting started on Un*x-like machines

Using Ciao from a Un*x command shell
====================================

* Menu:

* Starting/exiting the top-level shell (Un*x)::
* Getting help (Un*x)::
* Compiling and running programs (Un*x)::
* Generating executables (Un*x)::
* Running Ciao scripts (Un*x)::
* The Ciao initialization file (Un*x)::
* Printing manuals (Un*x)::


File: ciao.info,  Node: Starting/exiting the top-level shell (Un*x),  Next: Getting help (Un*x),  Prev: Using Ciao from a Un*x command shell,  Up: Using Ciao from a Un*x command shell

Starting/exiting the top-level shell (Un*x)
-------------------------------------------

   The basic methods for starting/exiting the top-level shell have
been discussed above. If upon typing `ciao' you get a "command not
found" error or you get a longer message from Ciao before starting,
it means that either Ciao was not installed correctly or you
environment variables are not set up properly. Follow the
instructions on the message printed by Ciao or refer to the
installation instructions regarding user-setup for details.


File: ciao.info,  Node: Getting help (Un*x),  Next: Compiling and running programs (Un*x),  Prev: Starting/exiting the top-level shell (Un*x),  Up: Using Ciao from a Un*x command shell

Getting help (Un*x)
-------------------

   The basic methods for accessing the manual on-line have also been
discussed above. Use the table of contents and the indices of
_predicates_, _libraries_, _concepts_, etc. to find what you are
looking for.  Context-sensitive help is available within the `emacs'
environment (see below).


File: ciao.info,  Node: Compiling and running programs (Un*x),  Next: Generating executables (Un*x),  Prev: Getting help (Un*x),  Up: Using Ciao from a Un*x command shell

Compiling and running programs (Un*x)
-------------------------------------

   Once the shell is started, you can compile and execute Prolog
modules inside the interactive top-level shell in the standard way.
E.g., type `use_module(_file_).', `use_module(library(_file_)).' for
library modules, `ensure_loaded(_file_).' for files which are not
modules, and `use_package(_file_).' for library packages (these are
syntactic/semantic packages that extend the Ciao Prolog language in
many different ways). Note that the use of `compile/1' and
`consult/1' is discouraged in Ciao.

   For example, you may want to type `use_package(iso)' to ensure
Ciao has loaded all the ISO builtins (whether this is done by default
or not depends on your `.ciaorc' file). Do not worry about any
"module already in executable" messages -these are normal and simply
mean that a certain module is already pre-loaded in the top-level
shell. At this point, typing `write(hello).' should work.

   Note that some predicates that may be built-ins in other Prologs
are available through libraries in Ciao. This facilitates making
small executables.

   To change the working directory to, say, the `examples' directory
in the Ciao root directory, first do:

           ?- use_module(library(system)).

(loading the `system' library makes a number of system-related
predicates such as `cd/1' accessible) and then:

           ?- cd('$/examples').

(in Ciao the sequence `$/' _at the beginning of a path name_ is
replaced by the path of the Ciao root directory).

   For more information see *Note The interactive top-level shell::.


File: ciao.info,  Node: Generating executables (Un*x),  Next: Running Ciao scripts (Un*x),  Prev: Compiling and running programs (Un*x),  Up: Using Ciao from a Un*x command shell

Generating executables (Un*x)
-----------------------------

   Executables can be generated from the top-level shell (using
`make_exec/2') or using the standalone compiler ( `ciaoc'). To be
able to make an executable, the file should define the predicate
`main/1' (or `main/0'), which will be called upon startup (see the
corresponding manual section for details). In its simplest use, given
a top-level _foo_`.pl' file for an application, the compilation
process produces an executable `foo', automatically detecting which
other files used by `foo.pl' need recompilation.

For example, within the `examples' directory, you can type:

         ?- make_exec(hw,_).

which should produce an executable. Double-clicking on this
executable should execute it.

   Another way of creating Ciao executables from source files is by
right-clicking on `.pl' files and choosing "make executable". This
uses the standalone compiler (this has the disadvantage, however,
that it is sometimes difficult to see the error messages).

   For more information see *Note The interactive top-level shell::
and *Note The stand-alone command-line compiler::.


File: ciao.info,  Node: Running Ciao scripts (Un*x),  Next: The Ciao initialization file (Un*x),  Prev: Generating executables (Un*x),  Up: Using Ciao from a Un*x command shell

Running Ciao scripts (Un*x)
---------------------------

   Ciao allows writing Prolog scripts. These are files containing
Prolog source but which get executed without having to explicitly
compile them (in the same way as, e.g., `.bat' files or programs in
scripting languages). As an example, you can run the file `hw' in the
`examples' directory of the Ciao distribution and look at the source
with an editor. You can try changing the `Hello world' message and
running the program again (no need to recompile!).

   As you can see, the file should define the predicate `main/1' (not
`main/0'), which will be called upon startup. The two header lines
are necessary in Un*x in. In Windows you can leave them in or you can
take them out, but you need to rename the script to `hw.pls'. Leaving
the lines in has the advantage that the script will also work in Un*x
without any change.

   For more information see *Note The script interpreter::.


File: ciao.info,  Node: The Ciao initialization file (Un*x),  Next: Printing manuals (Un*x),  Prev: Running Ciao scripts (Un*x),  Up: Using Ciao from a Un*x command shell

The Ciao initialization file (Un*x)
-----------------------------------

   The Ciao toplevel can be made to execute upon startup a number of
commands (such as, e.g., loading certain files or setting certain
Prolog flags) contained in an initialization file. This file should
be called `.ciaorc' and placed in your _home_ directory (e.g., `~',
the same in which the `.emacs' file is put). You may need to set the
environment variable `HOME' to the path of this directory for the
Ciao toplevel shell to be able to locate this file on startup.


File: ciao.info,  Node: Printing manuals (Un*x),  Prev: The Ciao initialization file (Un*x),  Up: Using Ciao from a Un*x command shell

Printing manuals (Un*x)
-----------------------

   As mentioned before, the manual is available in several formats in
the `reference' directory within the `doc' directory in the Ciao
distribution, including `postscript' or `pdf', which are specially
useful for printing. These files are also available in the `DOCROOT'
directory specified during installation. Printing can be done using
an application such as `ghostview' (freely available from
`http://www.cs.wisc.edu/~ghost/index.html') or `acrobat reader'
(`http://www.adobe.com', only `pdf').


File: ciao.info,  Node: An introduction to the Ciao emacs environment (Un*x),  Next: Keeping up to date (Un*x),  Prev: Using Ciao from a Un*x command shell,  Up: Getting started on Un*x-like machines

An introduction to the Ciao emacs environment (Un*x)
====================================================

   While it is easy to use Ciao with any editor of your choice, using
it within the `emacs' editor/program development system is highly
recommended: Ciao includes an `emacs' _mode_ which provides a very
complete _application development environment_ which greatly
simplifies many program development tasks. See *Note Using Ciao
inside GNU emacs:: for details on the capabilities of `ciao'/ `emacs'
combination.

   If the (freely available) `emacs' editor/environment is not
installed in your system, we highly recommend that you also install
it at this point (there are instructions for where to find `emacs'
and how to install it in the Ciao installation instructions). After
having done this you can try for example the following things:

   * A few basic things:

        * Typing <^H> <i> (or in the menus `Help->Manuals->Browse
          Manuals with Info') should open a list of manuals in info
          format in which the Ciao manual(s) should appear.

        * When opening a Prolog file, i.e., a file with `.pl' or
          `.pls' ending, using <^X><^F>`filename' (or using the
          menus) the code should appear highlighted according to
          syntax (e.g., comments in red), and `Ciao/Prolog' menus
          should appear in the menu bar on top of the `emacs' window.

        * Loading the file using the `Ciao/Prolog' menu (or typing
          <^C> <l>) should start in another emacs buffer the Ciao
          toplevel shell and load the file. You should now be able to
          switch the the toplevel shell and make queries from within
          `emacs'.


     *Note:* when using `emacs' it is _very convenient_ to swap the
     locations of the (normally not very useful) <Caps Lock> key and
     the (very useful in `emacs') <Ctrl> key on the keyboard. How to
     do this is explained in the `emacs' frequently asked questions
     FAQs (see the `emacs' download instructions for their location).

     (if these things do not work the system or emacs may not be
     installed properly).

   * You can go to the location of most of the errors that may be
     reported during compilation by typing <^C> <`>.

   * You can also, e.g., create executables from the `Ciao/Prolog'
     menu, as well as compile individual files, or generate active
     modules.

   * Loading a file for source-level debugging using the
     `Ciao/Prolog' menu (or typing <^C> <d>) and then issuing a query
     should start the source-level debugger and move a marker on the
     code in a window while execution is stepped through in the
     window running the Ciao top level.

   * You can add the lines needed in Un*x for turning any file
     defining `main/1' into a script from the Ciao/Prolog menu or by
     typing <^C> <I> <S>.

   * You can also work with the preprocessor and auto-documenter
     directly from emacs: see their manuals or browse through the
     corresponding menus that appear when editing `.pl' files.


   We encourage you once more to read *Note Using Ciao inside GNU
emacs:: to discover the many other functionalities of this
environment.


File: ciao.info,  Node: Keeping up to date (Un*x),  Prev: An introduction to the Ciao emacs environment (Un*x),  Up: Getting started on Un*x-like machines

Keeping up to date (Un*x)
=========================

   You may want to read *Note Beyond installation:: for instructions
on how to sign up on the Ciao user's mailing list, receive
announcements regarding new versions, download new versions, report
bugs, etc.


File: ciao.info,  Node: Getting started on Windows machines,  Next: *** PART I - The program development environment,  Prev: Getting started on Un*x-like machines,  Up: Top

Getting started on Windows machines
***********************************

   *Author(s):* M.Hermenegildo.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   This part guides you through some very basic first steps with Ciao
on an MSWindows ("Win32") system. It assumes that Ciao is already
installed correctly on your Windows system. If this is not the case,
then follow the instructions in *Note Installing Ciao from a Win32
binary distribution:: (or *Note Installing Ciao from the source
distribution::) first.

   We start with by describing the basics of using Ciao from the
Windows explorer and/or a DOS command shell. We strongly recommend
reading also *Note An introduction to the Ciao emacs environment
(Win32):: for the basics on using Ciao under `emacs', which is a much
simpler and much more powerful way of developing Ciao programs, and
has the advantage of offering an almost identical environment under
Windows and Un*x.

* Menu:

* Testing your Ciao Win32 installation::
* Using Ciao from the Windows explorer and command shell::
* An introduction to the Ciao emacs environment (Win32)::
* Keeping up to date (Win32)::


File: ciao.info,  Node: Testing your Ciao Win32 installation,  Next: Using Ciao from the Windows explorer and command shell,  Prev: Getting started on Windows machines,  Up: Getting started on Windows machines

Testing your Ciao Win32 installation
====================================

It is a good idea to start by performing some tests to check that
Ciao is installed correctly on your system (these are the same tests
that you are instructed to do during installation, so you can
obviously skip them if you have done them already at that time):

   * Ciao-related file types (`.pl' source files, `.cpx' executables,
     `.itf,.po,.asr' interface files, `.pls' scripts, etc.) should
     have specific icons associated with them (you can look at the
     files in the folders in the Ciao distribution to check).

   * Double-clicking on the shortcut to `ciaosh'(`.cpx') on the
     desktop should start the typical Prolog top-level shell in a
     window. If this shortcut has not been created on the desktop,
     then double-clicking on the `ciaosh'(`.cpx') icon inside the
     `shell' folder within the Ciao source folder should have the
     same effect.

   * In the top-level shell, Prolog library modules should load
     correctly. Type for example `use_module(library(dec10_io))' at
     the Ciao top-level prompt -you should get back a prompt with no
     errors reported.

   * To exit the top level shell, type `halt.' as usual, or <^Z>.


Also, the following documentation-related actions should work:

   * Double-clicking on the shortcut to `ciao'(`.html') which appears
     on the desktop should show the Ciao manual in your default WWW
     browser. If this shortcut has not been created you can
     double-click on the `ciao'(`.html') file in the
     `doc\reference\ciao_html' folder inside the Ciao source folder.
     Make sure you configure your browser to use _style sheets_ for
     correct formatting of the manual (note, however, that some older
     versions of Explorer did not support style sheets well and will
     give better results turning them off).

   * The `doc\reference' folder contains the manual also in the other
     formats present in the distribution, such as `info' (very
     convenient for users of the `emacs' editor/program development
     system) and `postscript' or `pdf', which are specially useful
     for printing. See *Note Printing manuals (Win32):: for
     instructions.



File: ciao.info,  Node: Using Ciao from the Windows explorer and command shell,  Next: An introduction to the Ciao emacs environment (Win32),  Prev: Testing your Ciao Win32 installation,  Up: Getting started on Windows machines

Using Ciao from the Windows explorer and command shell
======================================================

* Menu:

* Starting/exiting the top-level shell (Win32)::
* Getting help (Win32)::
* Compiling and running programs (Win32)::
* Generating executables (Win32)::
* Running Ciao scripts (Win32)::
* The Ciao initialization file (Win32)::
* Printing manuals (Win32)::


File: ciao.info,  Node: Starting/exiting the top-level shell (Win32),  Next: Getting help (Win32),  Prev: Using Ciao from the Windows explorer and command shell,  Up: Using Ciao from the Windows explorer and command shell

Starting/exiting the top-level shell (Win32)
--------------------------------------------

   The basic methods for starting/exiting the top-level shell have
been discussed above. The installation script also leaves a
`ciaosh'(`.bat') file inside the `shell' folder of the Ciao
distribution which can be used to start the top-level shell from the
command line in Windows95/98/NT.


File: ciao.info,  Node: Getting help (Win32),  Next: Compiling and running programs (Win32),  Prev: Starting/exiting the top-level shell (Win32),  Up: Using Ciao from the Windows explorer and command shell

Getting help (Win32)
--------------------

   The basic methods for accessing the manual on-line have also been
discussed above. Use the table of contents and the indices of
_predicates_, _libraries_, _concepts_, etc. to find what you are
looking for.  Context-sensitive help is available within the `emacs'
environment (see below).


File: ciao.info,  Node: Compiling and running programs (Win32),  Next: Generating executables (Win32),  Prev: Getting help (Win32),  Up: Using Ciao from the Windows explorer and command shell

Compiling and running programs (Win32)
--------------------------------------

   Once the shell is started, you can compile and execute Prolog
modules inside the interactive toplevel shell in the standard way.
E.g., type `use_module(_file_).', `use_module(library(_file_)).' for
library modules, `ensure_loaded(_file_).' for files which are not
modules, and `use_package(_file_).' for library packages (these are
syntactic/semantic packages that extend the Ciao Prolog language in
many different ways). Note that the use of `compile/1' and
`consult/1' is discouraged in Ciao.

   For example, you may want to type `use_package(iso)' to ensure
Ciao has loaded all the ISO builtins (whether this is done by default
or not depends on your `.ciaorc' file). Do not worry about any
"module already in executable" messages -these are normal and simply
mean that a certain module is already pre-loaded in the toplevel
shell. At this point, typing `write(hello).' should work.

   Note that some predicates that may be built-ins in other Prologs
are available through libraries in Ciao. This facilitates making
small executables.

   To change the working directory to, say, the `examples' directory
in the Ciao source directory, first do:

           ?- use_module(library(system)).

(loading the `system' library makes a number of system-related
predicates such as `cd/1' accessible) and then:

           ?- cd('$/examples').

(in Ciao the sequence `$/' _at the beginning of a path name_ is
replaced by the path of the Ciao root directory).

   For more information see *Note The interactive top-level shell::.


File: ciao.info,  Node: Generating executables (Win32),  Next: Running Ciao scripts (Win32),  Prev: Compiling and running programs (Win32),  Up: Using Ciao from the Windows explorer and command shell

Generating executables (Win32)
------------------------------

   Executables can be generated from the toplevel shell (using
`make_exec/2') or using the standalone compiler ( `ciaoc'(`.cpx'),
located in the `ciaoc' folder). To be able to make an executable, the
file should define the predicate `main/1' (or `main/0'), which will
be called upon startup (see the corresponding manual section for
details).

For example, within the `examples' directory, you can type:

         ?- make_exec(hw,_).

which should produce an executable. Double-clicking on this
executable should execute it.

   Another way of creating Ciao executables from source files is by
right-clicking on `.pl' files and choosing "make executable". This
uses the standalone compiler (this has the disadvantage, however,
that it is sometimes difficult to see the error messages).

   For more information see *Note The interactive top-level shell::
and *Note The stand-alone command-line compiler::.


File: ciao.info,  Node: Running Ciao scripts (Win32),  Next: The Ciao initialization file (Win32),  Prev: Generating executables (Win32),  Up: Using Ciao from the Windows explorer and command shell

Running Ciao scripts (Win32)
----------------------------

   Double-clicking on files ending in `.pls', _Ciao Prolog scripts_,
will also execute them. These are files containing Prolog source but
which get executed without having to explicitly compile them (in the
same way as, e.g., `.bat' files or programs in scripting languages).
As an example, you can double-click on the file `hw.pls' in the
`examples' folder and look at the source with an editor. You can try
changing the `Hello world' message and double-clicking again (no need
to recompile!).

   As you can see, the file should define the predicate `main/1' (not
`main/0'), which will be called upon startup. The two header lines
are only necessary in Un*x. In Windows you can leave them in or you
can take them out, but leaving them in has the advantage that the
script will also work in Un*x without any change.

   For more information see *Note The script interpreter::.


File: ciao.info,  Node: The Ciao initialization file (Win32),  Next: Printing manuals (Win32),  Prev: Running Ciao scripts (Win32),  Up: Using Ciao from the Windows explorer and command shell

The Ciao initialization file (Win32)
------------------------------------

   The Ciao toplevel can be made to execute upon startup a number of
commands (such as, e.g., loading certain files or setting certain
Prolog flags) contained in an initialization file. This file should
be called `.ciaorc' and placed in your _home_ folder (e.g., the same
in which the `.emacs' file is put). You may need to set the
environment variable `HOME' to the path of this folder for the Ciao
toplevel shell to be able to locate this file on startup.


File: ciao.info,  Node: Printing manuals (Win32),  Prev: The Ciao initialization file (Win32),  Up: Using Ciao from the Windows explorer and command shell

Printing manuals (Win32)
------------------------

   As mentioned before, the manual is available in several formats in
the `reference' folder within Ciao's `doc' folder, including
`postscript' or `pdf', which are specially useful for printing. This
can be done using an application such as `ghostview' (freely
available from `http://www.cs.wisc.edu/~ghost/index.html') or
`acrobat reader' (`http://www.adobe.com', only `pdf').


File: ciao.info,  Node: An introduction to the Ciao emacs environment (Win32),  Next: Keeping up to date (Win32),  Prev: Using Ciao from the Windows explorer and command shell,  Up: Getting started on Windows machines

An introduction to the Ciao emacs environment (Win32)
=====================================================

   While it is easy to use Ciao with any editor of your choice, using
it within the `emacs' editor/program development system is highly
recommended: Ciao includes an `emacs' _mode_ which provides a very
complete _application development environment_ which greatly
simplifies many program development tasks. See *Note Using Ciao
inside GNU emacs:: for details on the capabilities of `ciao'/ `emacs'
combination.

   If the (freely available) `emacs' editor/environment is not
installed in your system, we highly recommend that you also install
it at this point (there are instructions for where to find `emacs'
and how to install it in the Ciao installation instructions). After
having done this you can try for example the following things:

   * A few basic things:

        * Typing <^H> <i> (or in the menus `Help->Manuals->Browse
          Manuals with Info') should open a list of manuals in info
          format in which the Ciao manual(s) should appear.

        * When opening a Prolog file, i.e., a file with `.pl' or
          `.pls' ending, using <^X><^F>`filename' (or using the
          menus) the code should appear highlighted according to
          syntax (e.g., comments in red), and `Ciao/Prolog' menus
          should appear in the menu bar on top of the `emacs' window.

        * Loading the file using the `Ciao/Prolog' menu (or typing
          <^C> <l>) should start in another emacs buffer the Ciao
          toplevel shell and load the file. You should now be able to
          switch the the toplevel shell and make queries from within
          `emacs'.


     *Note:* when using `emacs' it is _very convenient_ to swap the
     locations of the (normally not very useful) <Caps Lock> key and
     the (very useful in `emacs') <Ctrl> key on the keyboard. How to
     do this is explained in the `emacs' frequently asked questions
     FAQs (see the `emacs' download instructions for their location).

     (if these things do not work the system or emacs may not be
     installed properly).

   * You can go to the location of most of the errors that may be
     reported during compilation by typing <^C> <`>.

   * You can also, e.g., create executables from the `Ciao/Prolog'
     menu, as well as compile individual files, or generate active
     modules.

   * Loading a file for source-level debugging using the
     `Ciao/Prolog' menu (or typing <^C> <d>) and then issuing a query
     should start the source-level debugger and move a marker on the
     code in a window while execution is stepped through in the
     window running the Ciao top level.

   * You can add the lines needed in Un*x for turning any file
     defining `main/1' into a script from the Ciao/Prolog menu or by
     typing <^C> <I> <S>.

   * You can also work with the preprocessor and auto-documenter
     directly from emacs: see their manuals or browse through the
     corresponding menus that appear when editing `.pl' files.


   We encourage you once more to read *Note Using Ciao inside GNU
emacs:: to discover the many other functionalities of this
environment.


File: ciao.info,  Node: Keeping up to date (Win32),  Prev: An introduction to the Ciao emacs environment (Win32),  Up: Getting started on Windows machines

Keeping up to date (Win32)
==========================

   You may want to read *Note Beyond installation:: for instructions
on how to sign up on the Ciao user's mailing list, receive
announcements regarding new versions, download new versions, report
bugs, etc.


File: ciao.info,  Node: *** PART I - The program development environment,  Next: The stand-alone command-line compiler,  Prev: Getting started on Windows machines,  Up: Top

PART I - The program development environment
********************************************

   This part documents the components of the basic Ciao program
development environment. They include:

ciaoc:
     the standalone compiler, which creates executables without
     having to enter the interactive top-level.

ciaosh:
     (also invoked simply as `ciao') is an interactive top-level
     shell, similar to the one found on most Prolog systems (with
     some enhancements).

debugger.pl:
     a Byrd box-type debugger, similar to the one found on most
     Prolog systems (also with some enhancements, such as
     source-level debugging). This is not a standalone application,
     but is rather included in `ciaosh', as is done in other Prolog
     systems. However, it is also _embeddable_, in the sense that it
     can be included as a library in executables, and activated
     dynamically and conditionally while such executables are running.

ciao-shell:
     an interpreter/compiler for _Prolog scripts_ (i.e., files
     containing Prolog code which run without needing explicit
     compilation).

ciao.el:
     a _complete program development enviroment_, based on GNU emacs,
     with syntax coloring, direct access to all the tools described
     above (as well as the preprocessor and the documenter), atomatic
     location of errors, source-level debugging, context-sensitive
     access to on-line help/manuals, etc. The use of this environment
     is _very highly recommended_!

   The Ciao program development environment also includes `ciaopp',
the preprocessor, and `lpdoc', the documentation generator, which are
described in separate manuals.


File: ciao.info,  Node: The stand-alone command-line compiler,  Next: The interactive top-level shell,  Prev: *** PART I - The program development environment,  Up: Top

The stand-alone command-line compiler
*************************************

   *Author(s):* Daniel Cabeza and the CLIP Group.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#142 (2000/5/11, 14:11:20 CEST)

   `ciaoc' [CH00b] is the Ciao stand-alone command-line compiler.
`ciaoc' can be used to create executables or to compile individual
files to object code (to be later linked with other files).  `ciaoc'
is specially useful when working from the command line. Also, it can
be called to compile Ciao programs from other tools such as, e.g.,
shell scripts, `Makefile's, or project files. All the capabilities of
`ciaoc' are also available from the interactive top-level shell,
which uses the ciaoc modules as its components.

* Menu:

* Introduction to building executables::
* Paths used by the compiler during compilation::
* Running executables from the command line::
* Types of executables generated::
* Environment variables used by Ciao executables::
* Intermediate files in the compilation process::
* Usage (ciaoc)::


File: ciao.info,  Node: Introduction to building executables,  Next: Paths used by the compiler during compilation,  Prev: The stand-alone command-line compiler,  Up: The stand-alone command-line compiler

Introduction to building executables
====================================

   An _executable_ can be built from a single file or from a
collection of inter-related files. In the case of only one file, this
file must define the predicate `main/0' or `main/1'. This predicate
is the one which will be called when the executable is started. As an
example, consider the following file, called `hello.pl':

     main :-
          write('Hello world'),
          nl.

To compile it from the command line using the `ciaoc' standalone
compiler it suffices to type "`ciaoc hello'" (in Win32 you may have
to put the complete path to the `ciaoc' folder of the Ciao
distribution, where the installation process leaves a `ciaoc.bat'
file):

     /herme@clip:/tmp
     [60]> ciaoc hello
     
     /herme@clip:/tmp
     [61]>

This produces an executable called `hello' in Un*x-like systems and
`hello.cpx' under Win32 systems. This executable can then be run in
Win32 by double-clicking on it and on Un*x systems by simply typing
its name (see for *Note Running executables from the command line::
for how to run executables from the command line in Win32):

     /herme@clip:/tmp
     [61]> hello
     Hello world

   If the application is composed of several files the process is
identical. Assume `hello.pl' is now:

     :- use_module(aux,[p/1]).
     
     main :-
          p(X),
          write(X),
          nl.

where the file `aux.pl' contains:

     :- module(aux,[p/1]).
     
     p('Hello world').

This can again be compiled using the `ciaoc' standalone compiler as
before:

     /herme@clip:/tmp
     [60]> ciaoc hello
     
     /herme@clip:/tmp
     [61]> hello
     Hello world

The invocation of `ciaoc hello' compiles the file `hello.pl' and all
connected files that may need recompilation - in this case the file
`aux.pl'. Also, if any library files used had not been compiled
previously they would be compiled at this point (See *Note
Intermediate files in the compilation process::). Also, if, say,
`hello.pl' is changed and recompiled, the object code resulting from
the previous compilation of `aux.pl' will be reused. This is all done
without any need for `Makefile's, and considerably accelerates the
development process for large applications. This process can be
observed by selecting the `-v' option when invoking `ciaoc' (which is
equivalent to setting the `verbose_compilation' Prolog flag to `on'
in the top-level interpreter).

   If `main/1' is defined instead of `main/0' then when the
executable is started the argument of `main/1' will be instantiated
to a list of atoms, each one of them corresponding to a command line
option. Consider the file `say.pl':

     main(Argv) :-
          write_list(Argv), nl.
     
     write_list([]).
     write_list([Arg|Args]) :-
          write(Arg),
          write(' '),
          write_list(Args).

Compiling this program and running it results in the following output:

     /herme@clip:/tmp
     [91]> ciaoc say
     
     /herme@clip:/tmp
     [91]> say hello dolly
     hello dolly

   The name of the generated executable can be controlled with the
`-o' option (See *Note Usage (ciaoc)::).


File: ciao.info,  Node: Paths used by the compiler during compilation,  Next: Running executables from the command line,  Prev: Introduction to building executables,  Up: The stand-alone command-line compiler

Paths used by the compiler during compilation
=============================================

   The compiler will look for files mentioned in commands such as
`use_module/1' or `ensure_loaded/1' in the current directory. Other
paths can be added by including them in a file whose name is given to
`ciaoc' using the `-u' option. This file should contain facts of the
predicates `file_search_path/2' and `library_directory/1' (see the
documentation for these predicates and also *Note Customizing library
paths and path aliases:: for details).


File: ciao.info,  Node: Running executables from the command line,  Next: Types of executables generated,  Prev: Paths used by the compiler during compilation,  Up: The stand-alone command-line compiler

Running executables from the command line
=========================================

   As mentioned before, what the `ciaoc' compiler generates and how
it is started varies somewhat from OS to OS. In general, the product
of compiling an application with `ciaoc' is a file that contains the
bytecode (the product of the compilation) and invokes the Ciao engine
on it.

   * Un Un*x this is a _script_ (see the first lines of the file)
     which invokes the ciao engine on this file. To run the generated
     executable from a Un*x shell, or from the `bash' shell that
     comes with the Cygwin libraries (see *Note Installation and
     compilation under Windows::) it suffices to type its name at the
     shell command line, as in the examples above.

   * In a Win32 system, the compiler produces a similar file with a
     `.cpx' ending. The Ciao installation process typically makes
     sure that the Windows registry contains the right entries so
     that this executable will run upon double-cliking on it.

     In you want to run the executable from the command line an
     additional `.bat' file is typically needed. To help in doing
     this, the Win32 installation process creates a `.bat' skeleton
     file called `bat_skel' in the `Win32' folder of the
     distribution) which allows running Ciao executables from the
     command line. If you want to run a Ciao executable `file.cpx'
     from the command line, you normally copy the skeleton file to
     the folder were the executable is and rename it to `file.bat',
     then change its contents as explained in a comment inside the
     file itself.

     Note that this `.bat' file is usually not necessary in NT, as
     its command shell understands file extension associations. I.e.,
     in windows NT it is possible to run the `file.cpx' executable
     directly. Due to limitations of `.bat' files in Windows 95/98,
     in those OSs no more than 9 command line arguments can be passed
     to the executable (in NT there is no such restriction).

     Finally, in a system in which Cygnus Win32 is installed
     executables can also be used directly from the `bash' shell
     command line, without any associated `.bat' files, by simply
     typing their name at the `bash' shell command line, in the same
     way as in Un*x. This only requires that the `bash' shell which
     comes with Cygnus Win32 be installed and accessible: simply,
     make sure that `/bin/sh.exe' exists.


   Except for a couple of header lines, the contents of executables
are almost identical under different OSs (except for self-contained
ones). The bytecode they contain is architecture-independent. In
fact, it is possible to create an executable under Un*x and run it on
Windows or viceversa, by making only minor modifications (e.g.,
creating the `.bat' file and/or setting environment variables or
editing the start of the file to point to the correct engine
location).


File: ciao.info,  Node: Types of executables generated,  Next: Environment variables used by Ciao executables,  Prev: Running executables from the command line,  Up: The stand-alone command-line compiler

Types of executables generated
==============================

   While the default options used by `ciaoc' are sufficient for
normal use, by selecting other options `ciaoc' can generate several
different types of executables, which offer interesting tradeoffs
among size of the generated executable, portability, and startup time
[CH00b]:

Dynamic executables:
     `ciaoc' produces by default _dynamic_ executables. In this case
     the executable produced is a platform-independent file which
     includes in compiled form all the user defined files. On the
     other hand, any system libraries used by the application are
     loaded dynamically at startup. More precisely, any files that
     appear as `library(...)' in `use_module/1' and `ensure_loaded/1'
     declarations will not be included explicitly in the executable
     and will instead be loaded dynamically. Is is also possible to
     mark other path aliases (see the documentation for
     `file_search_path/2') for dynamic loading by using the `-d'
     option. Files accessed through such aliases will also be loaded
     dynamically.

     Dynamic loading allows making smaller executables. Such
     executables may be used directly in the same machine in which
     they were compiled, since suitable paths to the location of the
     libraries will be included as default in the executable by
     `ciaoc' during compilation.

     The executable can also be used in another machine, even if the
     architecture and OS are different. The requirement is that the
     Ciao libraries (which will also include the appropriate Ciao
     engine for that architecture and OS) be installed in the target
     machine, and that the `CIAOLIB' and `CIAOENGINE' environment
     variables are set appropriately for the executable to be able to
     find them (see *Note Environment variables used by Ciao
     executables::). How to do this differs slightly from OS to OS.

Static executables:
     Selecting the `-s' option `ciaoc' produces a _static_
     executable. In this case the executable produced (again a
     platform-independent file) will include in it all the auxiliary
     files and any system libraries needed by the application. Thus,
     such an executable is almost complete, needing in order to run
     only the Ciao engine, which is platform-specific.(1) Again, if
     the executable is run in the same machine in which it was
     compiled then the engine is found automatically. If the
     executable is moved to another machine, the executable only
     needs access to a suitable engine (which can be done by setting
     the `CIAOENGINE' environment variable to point to this engine).

     This type of compilation produces larger executables, but has
     the advantage that these executables can be installed and run in
     a different machine, with different architecture and OS, even if
     Ciao is not installed on that machine. To install (or
     distribute) such an executable, one only needs to copy the
     executable file itself and the appropriate engine for the target
     platform (See *Note Installing Ciao from the source
     distribution:: or *Note Installing Ciao from a Win32 binary
     distribution:: and *Note Multiarchitecture support::), and to
     set things so that the executable can find the engine. (2)

Dynamic executables, with lazy loading:
     Selecting the `-l' option is very similar to the case of dynamic
     executables above, except that the code in the library modules
     is not loaded when the program is started but rather it is done
     during execution, the first time a predicate defined in that
     file is called. This is advantageous if a large application is
     composed of many parts but is such that typically only some of
     the parts are used in each invocation. The Ciao preprocessor,
     `ciaopp', is a good example of this: it has many capabilitites
     but typically only some of them are used in a given session. An
     executable with lazy load has the advantage that it starts fast,
     loading a minimal functionality on startup, and then loads the
     different modules automatically as needed.

Self-contained executables:
     _Self-contained_ executables are static executables (i.e., this
     option also implies _static_ compilation) which include a Ciao
     engine along with the bytecode, so they do not depend on an
     external one for their execution. This is useful to create
     executables which run even if the machine where the program is
     to be executed does not have a Ciao engine installed and/or
     libraries. The disadvantage is that such execuatbles are
     platform-dependent (as well as larger than those that simply use
     an external library). This type of compilation is selected with
     the `-S' option. Cross-compilation is also possible with the
     `-SS' option, so you can specify the target OS and architecture
     (e.g. LINUXi86). To be able to use the latter option, it is
     necessary to have installed a ciaoengine for the target machine
     in the Ciao library (this requires compiling the engine in that
     OS/architecture and installing it, so that it is available in
     the library).

Compressed executables:
     In _compressed_ executables the bytecode is compressed. This
     allows producing smaller executables, at the cost of a slightly
     slower startup time. This is selected with the `-z' option. You
     can also produce compressed libraries if you use `-zl' along
     with the `-c' option. If you select `-zl' while generating an
     executable, any library which is compiled to accomplish this
     will be also compressed.

Active modules:
     The compiler can also compile (via the `-a' option) a given file
     into an _active module_ (see *Note Active modules (high-level
     distributed execution):: for a description of this).

   ---------- Footnotes ----------

   (1) Currently there is an exception to this related to libraries
which are written in languages other than Prolog, as, e.g., C. C
files are currently always compiled to dynamically loadable object
files (`.so' files), and they thus need to be included manually in a
distribution of an application. This will be automated in upcoming
versions of the Ciao system.

   (2) It is also possible to produce real standalone executables,
i.e., executables that do not need to have an engine around. However,
this is not automated yet, although it is planned for an upcoming
version of the compiler. In particular, the compiler can generate a
`.c' file for each `.pl' file. Then all the `.c' files can be
compiled together into a real executable (the engine is added one
more element during link time) producing a complete executable for a
given architecture. The downside of course is that such an executable
will not be portable to other architectures without recompilation.


File: ciao.info,  Node: Environment variables used by Ciao executables,  Next: Intermediate files in the compilation process,  Prev: Types of executables generated,  Up: The stand-alone command-line compiler

Environment variables used by Ciao executables
==============================================

   The executables generated by the Ciao compiler (including the ciao
development tools themselves) locate automatically where the Ciao
engine and libraries have been installed, since those paths are
stored as defaults in the engine and compiler at installation time.
Thus, there is no need for setting any environment variables in order
to _run_ Ciao executables (on a single architecture - see *Note
Multiarchitecture support:: for running on multiple architectures).

   However, the default paths can be overridden by using the
environment variables `CIAOENGINE' and `CIAOLIB'. The first one will
tell the Ciao executables where to look for an engine, and the second
will tell them where to look for the libraries. Thus, it is possible
to actually use the Ciao system without installing it by setting
these variables to the following values:
   * `CIAOENGINE': `$(SRC)/bin/$(CIAOARCH)/ciaoengine'

   * `CIAOLIB': `$(SRC)'


where `$(CIAOARCH)' is the string echoed by the command
`SRC/etc/ciao_get_arch' (or `BINROOT/ciao_get_arch', after
installation).

   This allows using alternate engines or libraries, which can be
very useful for system development and experimentation.


File: ciao.info,  Node: Intermediate files in the compilation process,  Next: Usage (ciaoc),  Prev: Environment variables used by Ciao executables,  Up: The stand-alone command-line compiler

Intermediate files in the compilation process
=============================================

   Compiling an individual source (i.e., `.pl') file produces a
`.itf' file and a `.po' file. The `.itf' file contains information of
the _modular interface_ of the file, such as information on exported
and imported predicates and on the other modules used by this module.
This information is used to know if a given file should be recompiled
at a given point in time and also to be able to detect more errors
statically including undefined predicates, mismatches on predicate
charaterictics across modules, etc. The `.po' file contains the
platform-independent object code for a file, ready for linking
(statically or dynamically).

   It is also possible to use `ciaoc' to explicitly generate the
`.po' file for one or more `.pl' files by using the `-c' option.


File: ciao.info,  Node: Usage (ciaoc),  Prev: Intermediate files in the compilation process,  Up: The stand-alone command-line compiler

Usage (ciaoc)
=============

   The following provides details on the different command line
options available when invoking `ciaoc':



     ciaoc <MiscOpts> <ExecOpts> [-o <execname>] <file> ...
     
       Make an executable from the listed files.  If there is
       more than one file, they must be non-module, and the
       first one must include the main predicate.  The -o
       option allows generating an arbitrary executable name.
     
     ciaoc <MiscOpts> <ExecOpts> -a <publishmod> <module>
     
       Make an active module executable from <module> with
       address publish module <publishmod>.
     
     ciaoc <MiscOpts> -c  <file> ...
     
       Compile listed files (make .po objects).
     
     <MiscOpts> can be: [-v] [-ri] [-u <file>]
     
     -v  verbose mode
     
     -ri generate readable .itf files
     
     -u  use <file> for compilation
     
     <ExecOpts> can be: [-s|-S|-SS <target>|-z|-zl|-e|-l|(-ll <module>)*]
                        (-d <alias>)* [-x]
     
     -s  make a static executable (otherwise dynamic files are not included)
     
     -S  make standalone executable for the current OS and architecture
     
     -SS make standalone executable for <target> OS and architecture
         valid <target> values may be: LINUXi86, SolarisSparc...
     
         (both -S and -SS imply -s)
     
     -z  generate executables with compressed bytecode
     
     -zl generate libraries with compressed bytecode - any library (re)compiled
         as consequence of normal executable compilation will also be affected
     
     -e  make executable with eager load of dynamic files at startup (default)
     
     -l  idem with lazy load of dynamic files (except insecure cases)
     
     -ll force <module> to be loaded lazily,  implies -l
     
     -d  files using this path alias are dynamic (default: library)
     
     -x  Extended recompilation: only useful for Ciao standard library developers
     
     default extension for files is '.pl'


File: ciao.info,  Node: The interactive top-level shell,  Next: The interactive debugger,  Prev: The stand-alone command-line compiler,  Up: Top

The interactive top-level shell
*******************************

   *Author(s):* Daniel Cabeza and the CLIP Group.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#11 (1999/12/14, 13:14:36 MET)

   `ciaosh' is the Ciao interactive top-level shell. It provides the
user with an interactive programming environment with tools for
incrementally building programs, debugging programs by following
their executions, and modifying parts of programs without having to
start again from scratch. If available, it is strongly recommended to
use it with the emacs interface provided, as it greatly simplifies
the operation. This chapter documents general operation in the shell
itself. Other chapters document the

* Menu:

* Shell invocation and startup::
* Shell interaction::
* Entering recursive (conjunctive) shell levels::
* Usage and interface (ciaosh)::
* Documentation on exports (ciaosh)::
* Documentation on internals (ciaosh)::


File: ciao.info,  Node: Shell invocation and startup,  Next: Shell interaction,  Prev: The interactive top-level shell,  Up: The interactive top-level shell

Shell invocation and startup
============================

   When invoked, the shell responds with a message of identification
and the prompt `?- ' as soon as it is ready to accept input, thus:

     Ciao-Prolog X.Y #PP: Thu Mar 25 17:20:55 MET 1999
     ?-

   When the shell is initialized it looks for a file `.ciaorc' in the
HOME directory and makes an `include' of it, if it exists. This file
is useful for including `use_module/1' declarations for the modules
one wants to be loaded by default, changing prolog flags, etc. If the
initialization file does not exist, the ISO-Prolog compatibility
package `iso' is included, to provide (almost) all the ISO builtins
by default. Two command-line options control the loading of the
initialization file:

`-f'
     Fast start, do not load any initialization file.

`-l' `File'
     Look for initialization file `File' instead of `~/.ciaorc'. If
     it does not exist, include the compatibility package `iso'.


File: ciao.info,  Node: Shell interaction,  Next: Entering recursive (conjunctive) shell levels,  Prev: Shell invocation and startup,  Up: The interactive top-level shell

Shell interaction
=================

   After the shell outputs the prompt, it is expecting either an
internal command (see the following sections) or a _query_ (a goal or
sequence of goals). When typing in the input, which must be a valid
prolog term, if the term does not end in the first line, subsequent
lines are indented. For example:

     ?- X =
        f(a,
        b).
     
     X = f(a,b) ?
     
     yes
     ?-

   The queries are executed by the shell as if they appeared in the
user module. Thus, in addition to builtin predicates, predicates
available to be executed directly are all predicates defined by
loaded user files (files with no module declaration), and imported
predicates from modules by the use of `use_module'.

   The possible answers of the shell, after executing an internal
command or query, are:

   * If the execution failed (or produced an error), the answer is
     `no'.

   * If the execution was successful, and no answer variable (see
     below) was bound (or constraints where imposed on such
     variables), the answer is simply `yes'.

   * If the execution was successful and bindings where made (or
     constraints where imposed) on answer variables, then the shell
     outputs the values of answer variables, as a sequence of
     bindings (or constraints), and then prints a `?' as a prompt. At
     this point it is expecting an input line from the user. By
     entering a carriage-return (<RET>) or any line starting with
     `y', the query terminates and the shell answer `yes'. Entering a
     ``,'' the shell enters a recursive level (see below). Finally,
     any other answer forces the system to backtrack and look for the
     next solution (answering as with the first solution).


   To allow using connection variables in queries without having to
report their results, variables whose name starts with `_' are not
considered in answers, the rest being the _answer variable_s. This
example illustrates the previous points:

     ?- member(a, [b, c]).
     
     no
     ?- member(a, [a, b]).
     
     yes
     ?- member(X, [a|L]).
     
     X = a ? ;
     
     L = [X|_] ?
     
     yes
     ?- atom_codes(ciao, _C), member(L, _C).
     
     L = 99 ? ;
     
     L = 105 ? ;
     
     L = 97 ? ;
     
     L = 111 ? ;
     
     no
     ?-


File: ciao.info,  Node: Entering recursive (conjunctive) shell levels,  Next: Usage and interface (ciaosh),  Prev: Shell interaction,  Up: The interactive top-level shell

Entering recursive (conjunctive) shell levels
=============================================

   As stated before, when the user answers with ``,'' after a
solution is presented, the shell enters a _recursive level_, changing
its prompt to _N_ `?- ' (where _N_ is the recursion level) and
keeping the bindings or constraints of the solution (this is inspired
by the _LogIn_ language developed by _H. Ait-Kaci_, _P. Lincoln_ and
_Roger Nasr_ [AKNL86]). Thus, the following queries will be executed
within that context, and all variables in the lower level solutions
will be reported in subsequent solutions at this level. To exit a
recursive level, input an <EOF> character or the command `up'. The
last solution after entering the level is repeated, to allow asking
for more solutions. Use command `top' to exit all recursive levels
and return to the top level. Example interaction:

     ?- directory_files('.',_Fs), member(F,_Fs).
     
     F = 'file_utils.po' ? ,
     
     1 ?- file_property(F, mod_time(T)).
     
     F = 'file_utils.po',
     T = 923497679 ?
     
     yes
     1 ?- up.
     
     F = 'file_utils.po' ? ;
     
     F = 'file_utils.pl' ? ;
     
     F = 'file_utils.itf' ? ,
     
     1 ?- file_property(F, mod_time(T)).
     
     F = 'file_utils.itf',
     T = 923497679 ?
     
     yes
     1 ?- ^D
     F = 'file_utils.itf' ?
     
     yes
     ?-


File: ciao.info,  Node: Usage and interface (ciaosh),  Next: Documentation on exports (ciaosh),  Prev: Entering recursive (conjunctive) shell levels,  Up: The interactive top-level shell

Usage and interface (`ciaosh')
==============================

   * *Library usage:*

     The following predicates can be used at the top-level shell
     natively (but see also the commands available in *Note The
     interactive debugger:: which are also available within the
     top-level shell).

   * *Exports:*
        - _Predicates:_

          `use_module/1', `use_module/2', `ensure_loaded/1',
          `make_exec/2', `include/1', `use_package/1', `consult/1',
          `compile/1', `./2', `make_po/1', `unload/1',
          `set_debug_mode/1', `set_nodebug_mode/1', `make_actmod/2',
          `force_lazy/1', `undo_force_lazy/1',
          `dynamic_search_path/1', `multifile/1'.


   * *Other modules used:*
        - _Application modules:_

          `toplev'.

        - _System library modules:_

          `libpaths', `compiler/compiler', `compiler/exemaker',
          `compiler/c_itf', `debugger/debugger'.




File: ciao.info,  Node: Documentation on exports (ciaosh),  Next: Documentation on internals (ciaosh),  Prev: Usage and interface (ciaosh),  Up: The interactive top-level shell

Documentation on exports (`ciaosh')
===================================

 - PREDICATE: use_module/1:
     *Usage:* `use_module(Module)'
        - _Description:_ Load into the top-level the module defined
          in `Module', importing all the predicates it exports.

        - _The following properties should hold at call time:_

          `Module' is a source name.   (`streams_basic:sourcename/1')



 - PREDICATE: use_module/2:
     *Usage:* `use_module(Module,Imports)'
        - _Description:_ Load into the top-level the module defined
          in `Module', importing the predicates in `Imports'.

        - _The following properties should hold at call time:_

          `Module' is a source name.   (`streams_basic:sourcename/1')

          `Imports' is a list of `predname's.   (`basic_props:list/2')



 - PREDICATE: ensure_loaded/1:
     *Usage:* `ensure_loaded(File)'
        - _Description:_ Load into the top-level the code residing in
          file (or files) `File', which is user (i.e. non-module)
          code.

        - _The following properties should hold at call time:_

          `File' is a source name or a list of source names.
          (`ciaosh_doc:sourcenames/1')



 - PREDICATE: make_exec/2:
     *Usage:* `make_exec(File,ExecName)'
        - _Description:_ Make a Ciao executable from file (or files)
          `File', giving it name `ExecName'. If `ExecName' is a
          variable, the compiler will choose a default name for the
          executable and will bind the variable `ExecName' to that
          name. The name is chosen as follows: if the main prolog
          file has no `.pl' extension or we are in Windows, the
          executable will have extension `.cpx'; else the executable
          will be named as the main prolog file without extension.

        - _The following properties should hold at call time:_

          `File' is a source name or a list of source names.
          (`ciaosh_doc:sourcenames/1')

        - _The following properties hold upon exit:_

          `ExecName' is an atom.   (`basic_props:atm/1')



 - PREDICATE: include/1:
     *Usage:* `include(File)'
        - _Description:_ The contents of the file `File' are included
          in the top-level shell. For the moment, it only works with
          some directives, which are interpreted by the shell, or
          with normal clauses (which are asserted), if
          library(dynamic) is loaded beforehand.

        - _The following properties should hold at call time:_

          `File' is a source name.   (`streams_basic:sourcename/1')



 - PREDICATE: use_package/1:
     *Usage:* `use_package(Package)'
        - _Description:_ Equivalent to issuing an
          include(library(`Package')) for each listed file. By now
          some package contents cannot be handled.

        - _The following properties should hold at call time:_

          `Package' is a source name or a list of source names.
          (`ciaosh_doc:sourcenames/1')



 - PREDICATE: consult/1:
     *Usage:* `consult(File)'
        - _Description:_ Provided for backward compatibility. Similar
          to `ensure_loaded/1', but ensuring each listed file is
          loaded in consult mode (see *Note The interactive
          debugger::).

        - _The following properties should hold at call time:_

          `File' is a source name or a list of source names.
          (`ciaosh_doc:sourcenames/1')



 - PREDICATE: compile/1:
     *Usage:* `compile(File)'
        - _Description:_ Provided for backward compatibility. Similar
          to `ensure_loaded/1', but ensuring each listed file is
          loaded in compile mode (see *Note The interactive
          debugger::).

        - _The following properties should hold at call time:_

          `File' is a source name or a list of source names.
          (`ciaosh_doc:sourcenames/1')



 - PREDICATE: ./2:
     *Usage:* `[File|Files]'
        - _Description:_ Provided for backward compatibility,
          obsoleted by `ensure_loaded/1'.

        - _The following properties should hold at call time:_

          `File' is a source name.   (`streams_basic:sourcename/1')

          `Files' is a list of `sourcename's.   (`basic_props:list/2')



 - PREDICATE: make_po/1:
     *Usage:* `make_po(Files)'
        - _Description:_ Make object (`.po') files from `Files'.
          Equivalent to executing "`ciaoc -c'" on the files.

        - _The following properties should hold at call time:_

          `Files' is a source name or a list of source names.
          (`ciaosh_doc:sourcenames/1')



 - PREDICATE: unload/1:
     *Usage:* `unload(File)'
        - _Description:_ Unloads dynamically loaded file `File'.

        - _The following properties should hold at call time:_

          `File' is a source name.   (`streams_basic:sourcename/1')



 - PREDICATE: set_debug_mode/1:
     *Usage:* `set_debug_mode(File)'
        - _Description:_ Set the loading mode of `File' to _consult_.
          See *Note The interactive debugger::.

        - _The following properties should hold at call time:_

          `File' is a source name.   (`streams_basic:sourcename/1')



 - PREDICATE: set_nodebug_mode/1:
     *Usage:* `set_nodebug_mode(File)'
        - _Description:_ Set the loading mode of `File' to _compile_.
          See *Note The interactive debugger::.

        - _The following properties should hold at call time:_

          `File' is a source name.   (`streams_basic:sourcename/1')



 - PREDICATE: make_actmod/2:
     *Usage:* `make_actmod(ModuleFile,PublishMod)'
        - _Description:_ Make an active module executable from the
          module residing in `ModuleFile', using address publish
          module of name `PublishMod' (which needs to be in the
          library paths).

        - _The following properties should hold at call time:_

          `ModuleFile' is a source name.
          (`streams_basic:sourcename/1')

          `PublishMod' is an atom.   (`basic_props:atm/1')



 - PREDICATE: force_lazy/1:
     *Usage:* `force_lazy(Module)'
        - _Description:_ Force module of name `Module' to be loaded
          lazily in the subsequent created executables.

        - _The following properties should hold at call time:_

          `Module' is an atom.   (`basic_props:atm/1')



 - PREDICATE: undo_force_lazy/1:
     *Usage:* `undo_force_lazy(Module)'
        - _Description:_ Disable a previous `force_lazy/1' on module
          `Module' (or, if it is uninstantiated, all previous
          `force_lazy/1').

        - _Calls should, and exit will be compatible with:_

          `Module' is an atom.   (`basic_props:atm/1')



 - PREDICATE: dynamic_search_path/1:
     *Usage:* `dynamic_search_path(Name)'
        - _Description:_ Asserting a fact to this data predicate,
          files using path alias `Name' will be treated as dynamic in
          the subsequent created executables.

        - _The following properties should hold at call time:_

          `Name' is an atom.   (`basic_props:atm/1')



 - PREDICATE: multifile/1:
     *Usage:* `multifile Pred'
        - _Description:_ Dynamically declare predicate `Pred' as
          multifile. This is useful at the top-level shell to be able
          to call multifile predicates of loaded files.

        - _The following properties should hold at call time:_

          `Pred' is a Name/Arity structure denoting a predicate name:
               predname(P/A) :-
                       atm(P),
                       int(A).

          (`basic_props:predname/1')




File: ciao.info,  Node: Documentation on internals (ciaosh),  Prev: Documentation on exports (ciaosh),  Up: The interactive top-level shell

Documentation on internals (`ciaosh')
=====================================

 - PROPERTY: sourcenames/1:
     Is defined as follows:
          sourcenames(File) :-
                  sourcename(File).
          sourcenames(Files) :-
                  list(Files,sourcename).
     See `sourcename/1' in *Note Basic file/stream handling::

     *Usage:* `sourcenames(Files)'
        - _Description:_ `Files' is a source name or a list of source
          names.




File: ciao.info,  Node: The interactive debugger,  Next: Predicates controlling the interactive debugger,  Prev: The interactive top-level shell,  Up: Top

The interactive debugger
************************

   *Author(s):* D. Cabeza, Manuel C. Rodriguez, (A. Ciepielewski, M.
Carlsson, T. Chikayama, K. Shen).

   The Ciao program development environment includes a number of
advanced debugging tools, such as a source-level debugger, the
`ciaopp' preprocessor, and some execution visualizers. Herein we
discuss the interactive debugger available in the standard top-level,
which allows tracing the control flow of programs, in a similar way
to other popular Prolog systems. This is a classical Byrd _box-type_
_debugger_ [Byr80,BBP81], with some enhancements, most notably being
able to track the execution on the source program. We also discuss the
embedded debugger, which is a version of the debugger which can be
embedded into executables so that an interactive debugging session
can be triggered at any time while running that executable without
needing the top-level shell.

   Byrd's Procedure Box model of debugging execution provides a
simple way of visualising control flow, including backtracking.
Control flow is in principle viewed at the predicate level, rather
than at the level of individual clauses. The Ciao debugger has the
ability to mark selected modules and/or files for debugging
(traditional and source debugging), rather than having to
exhaustively trace your program. It also allows to selectively set
spy-points and breakpoints. Spy-points allow the programmer to
nominate interesting predicates at which program execution is to
pause so that the programmer can interact with the debugger.
Breakpoints are similar to spy-points, but allow pausing at a
specific line in the code, corresponding to a particular literal.
There is a wide choice of control and information options available
during debugging interaction.

   *Note:* While the debugger described herein can be used in a
standalone way (i.e., from a operating system shell or terminal
window) in the same way as other Prolog debuggers, the most
convenient way of debugging Ciao programs is by using the emacs mode
(see *Note Using Ciao inside GNU emacs::), i.e., debugging from
within the `emacs' editor / programming environment.

* Menu:

* Marking modules and files for debugging in the top-level debugger::
* The debugging process::
* Marking modules and files for debugging with the embedded debugger::
* The procedure box control flow model::
* Format of debugging messages::
* Options available during debugging::
* Calling predicates that are not exported by a module::
* Acknowledgements::


File: ciao.info,  Node: Marking modules and files for debugging in the top-level debugger,  Next: The debugging process,  Prev: The interactive debugger,  Up: The interactive debugger

Marking modules and files for debugging in the top-level debugger
=================================================================

   Usually, when a program is not working properly, the programmer
has a feeling of which are the modules where the fault may be. Since
full-fledged debugging is only available on _interpreted_ (called
_interpreted mode_ in traditional Prolog systems) modules, which are
executed much slower than compiled modules, there is the posibility
of telling the top level which particular modules are to be loaded in
_interpreted mode_, with the aim of debugging them. The simplest way
of achieving this is by executing in the Ciao shell prompt, for each
suspicious module `Module' in the program, a command like this:

     ?- debug_module(Module).

   An alternative way of loading a module in interpreted mode exists
which will instruct the debugger to keep track of the line numbers in
the source file and to report them during debugging. This feature can
be selected for a suspicious module `Module' in the program by
executing a command such as:

     ?- debug_module_source(Module).

This is most useful when running the top-level inside the `emacs'
editor since in that case the Ciao emacs mode allows performing full
source-level debugging in each module marked as above, i.e., the
source lines being executed will be highlighted dynamically during
debugging in a window showing the source code of the module.

   Note that all files with no module declaration belong to the
pseudo-module `user', so the command to be issued for debugging a
user file, say `foo.pl', would be `debug_module(user)' or
`debug_module_source(user)', and not `debug_module(foo)'.

   The two ways of performing source-level debugging are fully
compatible between them, i.e., Ciao allows having some modules loaded
with `debug_module/1' and others with `debug_module_source/1'. To
change from one interpreted mode to the other mode it suffices to
select the module with the new interpreted mode (debugger mode),
using the appropiate command, and reload the module.

   The commands above perform in fact two related actions: first,
they let the compiler know that if a file containing a module with
this name is loaded, it should be loaded in interpreted mode (source
or traditional). In addition, they instruct the debugger to actually
prepare for debugging the code belonging to that module. After that,
the modules which are to be debugged have to be (re)loaded so that
they are compiled or loaded for interpretation in the appropriate
way. The nice thing is that, due to the modular behaviour of the
compiler/top-level, if the modules are part of a bigger application,
it suffices to load the main module of the application, since this
will automatically force the dependent modules which have changed to
be loaded in the appropriate way, including those whose _loading
mode_ has changed (i.e., changing the loading mode has the effect of
forcing the required re-loading of the module at the appropriate
time).

   Later in the debugging process, as the bug location is isolated,
typically one will want to restrict more and more the modules where
debugging takes place. To this end, and without the need for
reloading, one can tell the debugger to not consider a module for
debugging issuing a `nodebug_module/1' command, which counteracts a
`debug_module/1' or `debug_module_source/1' command with the same
module name, and reloading it (or the main file).

   There are also two top-level commands `set_debug_mode/1' and
`set_nodebug_mode/1', which accept as argument a file spec (i.e.,
`library(foo)' or `foo', even if it is a user file) to be able to
load a file in interpreted mode without changing the set of modules
that the debugger will try to spy.


File: ciao.info,  Node: The debugging process,  Next: Marking modules and files for debugging with the embedded debugger,  Prev: Marking modules and files for debugging in the top-level debugger,  Up: The interactive debugger

The debugging process
=====================

   Once modules or user files are marked for debugging and reloaded,
the traditional debugging shell commands can be used (the
documentation of the `debugger' library following this chapter
contains all the commands and their description), with the same
meaning as in other classical Prolog systems. The differences in
their behavior are:

   * Debugging takes place only in the modules in which it was
     activated,

   * `nospy/1' and `spy/1' accept sequences of predicate specs, and
     they will search for those predicates only in the modules marked
     for debugging (traditional or source-level debugging).

   * `breakpt/6' and `nobreakpt/6' allow setting breakpoints at
     selected clause literals and will search for those literals only
     in the modules marked for source-level debugging (modules marked
     with `debug_module_source/1').


   In particular, the system is initially in nodebug mode, in which
no tracing is performed. The system can be put in debug mode by a
call to `debug/0' in which execution of queries will proceed until
the first _spy-point_ or _breakpoint_. Alternatively, the system can
be put in trace mode by a call to `trace/0' in which all predicates
will be trace.


File: ciao.info,  Node: Marking modules and files for debugging with the embedded debugger,  Next: The procedure box control flow model,  Prev: The debugging process,  Up: The interactive debugger

Marking modules and files for debugging with the embedded debugger
==================================================================

   The embedded debugger, as the interpreted debugger, has three
different modes of operation: debug, trace or nodebug. These
debuggers modes can be set by adding a package declaration in the
module, as follows:

     :- use_package(debug).
     :- use_package(trace).
     :- use_package(nodebug).

and recompiling the application.

   In order to debug, or trace, correctly the complete code these
declarations _must_ be the last ones. Also it is possible to add the
package in the module declaration using the predicate `module/3'.

   The embedded debugger has limitations over the interpreted
debugger. The most important is that the "retry" option is not
available. But it is possible to add, and remove, spy-points and
breakpoins using the predicates `spy/1', `nospy/1', `breakpt/6' and
`nobreakpt/6', etc. These can be used in a clause declaration or as
declarations. Also it is possible to add in the code predicates for
issuing the debugger (i.e., use debug mode, and in a clause add the
predicate `trace/1').

   The nodebug mode allows keeping the spy-points and breakpoints in
the code instead of removing them from the code.

   Note that in order to use the embedded debugger the buffer where
the program will run must be in the Ciao inferior mode ( `M-x
ciao-inferior-mode').

   See the following example:
     :- module( foo,[main/1],[assertions, debug]).
     
     :- entry main/1.
     
     main(X) :-
              display(X),
              spy(foo),
              foo(X),
              notrace,
              nl.
     
     foo([]).
     foo([X|T]) :-
             trace,
             bar(X),
             foo(T).
     
     bar(X) :-
             display(X).


File: ciao.info,  Node: The procedure box control flow model,  Next: Format of debugging messages,  Prev: Marking modules and files for debugging with the embedded debugger,  Up: The interactive debugger

The procedure box control flow model
====================================

   During debugging the interpreter prints out a sequence of goals in
various states of instantiation in order to show the state that the
program has reached in its execution. However, in order to understand
what is occurring it is necessary to understand when and why the
interpreter prints out goals. As in other programming languages, key
points of interest are procedure entry and return, but in Prolog
there is the additional complexity of backtracking. One of the major
confusions that novice Prolog programmers have to face is the
question of what actually happens when a goal fails and the system
suddenly starts backtracking. The Procedure Box model of Prolog
execution views program control flow in terms of movement about the
program text. This model provides a basis for the debugging mechanism
in the interpreter, and enables the user to view the behaviour of the
program in a consistent way. It also provides the basis for the
visualization performed on the source level program when source level
program when source-level debugging is activated within `emacs'.

   Let us look at an example Prolog procedure:


[Image file: autofigbyrdbox.eps]

   The first clause states that `Y' is a descendant of `X' if `Y' is
an offspring of `X', and the second clause states that `Y' is a
descendant of `X' if `Z' is an offspring of `X' and `Y' is a
descendant of `Z'. In the diagram a box has been drawn around the
whole procedure and labelled arrows indicate the control flow in and
out of this box. There are four such arrows which we shall look at in
turn.

   * *Call*

     This arrow represents initial invocation of the procedure. When
     a goal of the form `descendant(X,Y)' is required to be
     satisfied, control passes through the Call port of the
     descendant box with the intention of matching a component clause
     and then satisfying any subgoals in the body of that clause.
     Note that this is independent of whether such a match is
     possible; i.e. first the box is called, and then the attempt to
     match takes place. Textually we can imagine moving to the code
     for descendant when meeting a call to descendant in some other
     part of the code.

   * *Exit*

     This arrow represents a successful return from the procedure.
     This occurs when the initial goal has been unified with one of
     the component clauses and any subgoals have been satisfied.
     Control now passes out of the Exit port of the descendant box.
     Textually we stop following the code for descendant and go back
     to the place we came from.

   * *Redo*

     This arrow indicates that a subsequent goal has failed and that
     the system is backtracking in an attempt to find alternatives to
     previous solutions. Control passes through the Redo port of the
     descendant box. An attempt will now be made to resatisfy one of
     the component subgoals in the body of the clause that last
     succeeded; or, if that fails, to completely rematch the original
     goal with an alternative clause and then try to satisfy any
     subgoals in the body of this new clause. Textually we follow the
     code backwards up the way we came looking for new ways of
     succeeding, possibly dropping down on to another clause and
     following that if necessary.

   * *Fail*

     This arrow represents a failure of the initial goal, which might
     occur if no clause is matched, or if subgoals are never
     satisfied, or if any solution produced is always rejected by
     later processing. Control now passes out of the Fail port of the
     descendant box and the system continues to backtrack. Textually
     we move back to the code which called this procedure and keep
     moving backwards up the code looking for choice points.

   In terms of this model, the information we get about the procedure
box is only the control flow through these four ports. This means
that at this level we are not concerned with which clause matches,
and how any subgoals are satisfied, but rather we only wish to know
the initial goal and the final outcome. However, it can be seen that
whenever we are trying to satisfy subgoals, what we are actually
doing is passing through the ports of _their_ respective boxes. If we
were following this (e.g., activating source-level debugging), then
we would have complete information about the control flow inside the
procedure box.

   Note that the box we have drawn around the procedure should really
be seen as an invocation box. That is, there will be a different box
for each different invocation of the procedure. Obviously, with
something like a recursive procedure, there will be many different
Calls and Exits in the control flow, but these will be for different
invocations. Since this might get confusing each invocation box is
given a unique integer identifier in the messages, as described below.

   Note that not all procedure calls are traced; there are a few
basic predicates which have been made invisible since it is more
convenient not to trace them. These include debugging directives,
basic control structures, and some builtins. This means that messages
will never be printed for these predicates during debugging.


File: ciao.info,  Node: Format of debugging messages,  Next: Options available during debugging,  Prev: The procedure box control flow model,  Up: The interactive debugger

Format of debugging messages
============================

   This section explains the two formats of the message output by the
debugger at a port. All trace messages are output to the terminal
regardless of where the current output stream is directed (which
allows tracing programs while they are performing file I/O). The
basic format, which will be shown in traditional debug and in
source-level debugging within Ciao `emacs' mode, is as follows:

     S  13  7  Call: T user:descendant(dani,_123) ?

   `S' is a spy-point or breakpoint indicator. It is printed as
'`+'', indicating that there is a spy-point on `descendant/2' in
module `user', as `'B'' denoting a breakpoint, or as ' ', denoting no
spy-point or breakpoint. If there is a spy-point and a breakpoint in
the same predicate the spy-point indicator takes preference over
breakpoint indicator.

   `T' is a subterm trace. This is used in conjunction with the `^'
command (set subterm), described below. If a subterm has been
selected, `T' is printed as the sequence of commands used to select
the subterm. Normally, however, `T' is printed as ' ', indicating
that no subterm has been selected.

   The first number is the unique invocation identifier. It is always
nondecreasing (provided that the debugger is switched on) regardless
of whether or not the invocations are being actually seen. This
number can be used to cross correlate the trace messages for the
various ports, since it is unique for every invocation. It will also
give an indication of the number of procedure calls made since the
start of the execution. The invocation counter starts again for every
fresh execution of a command, and it is also reset when retries (see
later) are performed.

   The number following this is the _current depth_; i.e., the number
of direct _ancestors_ this goal has. The next word specifies the
particular port (`Call', `Exit', `Redo' or `Fail'). The goal is then
printed so that its current instantiation state can be inspected. The
final `?' is the prompt indicating that the debugger is waiting for
user interaction. One of the option codes allowed (see below) can be
input at this point.

   The second format, quite similar to the format explained above, is
shown when using source-level debugging outside the Ciao `emacs'
mode, and it is as follows:

     	   In /home/mcarlos/ciao/foo.pl (5-9) descendant-1
     S  13  7  Call: T user:descendant(dani,_123) ?

   This format is identical to the format above except for the first
line, which contains the information for location of the point in the
source program text where execution is currently at. The first line
contains the name of the source file, the start and end lines where
the literal can be found, the substring to search for between those
lines and the number of substrings to locate. This information for
locating the point on the source file is not shown when executing the
source-level debugger from the Ciao `emacs' mode.

   Ports can be "unleashed" by calling the `leash/1' predicate
omiting that port in the argument. This means that the debugger will
stop but user interaction is not possible for an unleashed port.
Obviously, the `?' prompt will not be shown in such messages, since
the user has specified that no interaction is desired at this point.


File: ciao.info,  Node: Options available during debugging,  Next: Calling predicates that are not exported by a module,  Prev: Format of debugging messages,  Up: The interactive debugger

Options available during debugging
==================================

   This section describes the particular options that are available
when the debugger prompts after printing out a debugging message. All
the options are one letter mnemonics, some of which can be optionally
followed by a decimal integer. They are read from the terminal with
any blanks being completely ignored up to the next terminator
(carriage-return, line-feed, or escape). Some options only actually
require the terminator; e.g., the creep option, only requires <RET>.

   The only option which really needs to be remembered is '`h''
(followed by <RET>). This provides help in the form of the following
list of available options.

     <cr>   creep            c      creep
      l     leap             s      skip
      r     retry            r <i>  retry i
      f     fail             f <i>  fail i
      d     display          p      print
      w     write
      g     ancestors        g <n>  ancestors n
      n     nodebug          =      debugging
      +     spy this         -      nospy this
      a     abort
      @     command          u      unify
      <     reset printdepth < <n>  set printdepth
      ^     reset subterm    ^ <n>  set subterm
      ?     help             h      help

   * `c' ( _creep_)

     causes the debugger to single-step to the very next port and
     print a message. Then if the port is leashed the user is
     prompted for further interaction. Otherwise it continues
     creeping. If leashing is off, creep is the same as leap (see
     below) except that a complete trace is printed on the terminal.

   * `l' ( _leap_)

     causes the interpreter to resume running the program, only
     stopping when a spy-point or breakpoint is reached (or when the
     program terminates). Leaping can thus be used to follow the
     execution at a higher level than exhaustive tracing. All that is
     needed to do is to set spy-points and breakpoints on an evenly
     spread set of pertinent predicates or lines, and then follow the
     control flow through these by leaping from one to the other.

   * `s' ( _skip_)

     is only valid for Call and Redo ports, if it is issued in Exit
     or Fail ports it is equivalent to creep. It skips over the
     entire execution of the predicate. That is, no message will be
     seen until control comes back to this predicate (at either the
     Exit port or the Fail port). Skip is particularly useful while
     creeping since it guarantees that control will be returned after
     the (possibly complex) execution within the box. With skip then
     no message at all will appear until control returns to the Exit
     port or Fail port corresponding to this Call port or Redo port.
     This includes calls to predicates with spy-points and
     breakpoints set: they will be masked out during the skip. There
     is a way of overriding this: the `t' option after a <^C>
     interrupt will disable the masking. Normally, however, this
     masking is just what is required!

   * `r' ( _retry_)

     can be used at any of the four ports (although at the Call port
     it has no effect). It transfers control back to the Call port of
     the box. This allows restarting an invocation when, for example,
     it has left the programmer with some weird result. The state of
     execution is exactly the same as in the original call (unless
     the invocation has performed side effects, which will not be
     undone). When a retry is performed the invocation counter is
     reset so that counting will continue from the current invocation
     number regardless of what happened before the retry. This is in
     accord with the fact that execution has, in operational terms,
     returned to the state before anything else was called.

     If an integer is supplied after the retry command, then this is
     taken as specifying an invocation number and the system tries to
     get to the Call port, not of the current box, but of the
     invocation box specified. It does this by continuously failing
     until it reaches the right place. Unfortunately this process
     cannot be guaranteed: it may be the case that the invocation the
     programmer is looking for has been cut out of the search space
     by cuts in the program. In this case the system fails to the
     latest surviving Call port before the correct one.

   * `f' ( _fail_)

     can be used at any of the four ports (although at the Fail port
     it has no effect). It transfers control to the Fail port of the
     box, forcing the invocation to fail prematurely. If an integer
     is supplied after the command, then this is taken as specifying
     an invocation number and the system tries to get to the Fail
     port of the invocation box specified. It does this by
     continuously failing until it reaches the right place.
     Unfortunately, as before, this process cannot be guaranteed.

   * `d' ( _display_)

     displays the current goal using `display/1'. See `w' below.

   * `p' ( _print_)

     re-prints the current goal using `print/1'. Nested structures
     will be printed to the specified _printdepth_ (see below).

   * `w' ( _write_)

     writes the current goal on the terminal using `write/1'.

   * `g' ( _ancestors_)

     provides a list of ancestors to the current goal, i.e., all
     goals that are hierarchically above the current goal in the
     calling sequence. It is always possible to jump to any goal in
     the ancestor list (by using retry, etc.). If an integer `n' is
     supplied, then only `n' ancestors will be printed. That is to
     say, the last `n' ancestors will be printed counting back from
     the current goal. Each entry in the list is preceded by the
     invocation number followed by the depth number (as would be
     given in a trace message).

   * `n' ( _nodebug_)

     switches the debugger off. Note that this is the correct way to
     switch debugging off at a trace point. The `@' option cannot be
     used because it always returns to the debugger.

   * `=' ( _debugging_)

     outputs information concerning the status of the current
     debugging session.

   * `+' _spy_

     sets a spy-point on the current goal.

   * `-' ( _nospy_)

     removes the spy-point from the current goal.

   * `a' ( _abort_)

     causes an abort of the current execution. All the execution
     states built so far are destroyed and the system is put right
     back at the top-level of the interpreter. (This is the same as
     the built-in predicate `abort/0'.)

   * `@' ( _command_)

     allows calling arbitrary goals. The initial message `| ?- ' will
     be output on the terminal, and a command is then read from the
     terminal and executed as if it was at top-level.

   * `u' ( _unify_()

     is available at the Call port and gives the option of providing
     a solution to the goal from the terminal rather than executing
     the goal. This is convenient, e.g., for providing a "stub" for a
     predicate that has not yet been written. A prompt `|: ' will be
     output on the terminal, and the solution is then read from the
     terminal and unified with the goal.

   * `<' ( _printdepth_)

     sets a limit for the subterm nesting level that is printed in
     messages. While in the debugger, a printdepth is in effect for
     limiting the subterm nesting level when printing the current
     goal. When displaying or writing the current goal, all nesting
     levels are shown. The limit is initially 10. This command,
     without arguments, resets the limit to 10. With an argument of
     `n' the limit is set to `n'.

   * `^' ( _subterm_)

     sets the subterm to be printed in messages. While at a
     particular port, a current subterm of the current goal is
     maintained. It is the current subterm which is displayed,
     printed, or written when prompting for a debugger command. Used
     in combination with the printdepth, this provides a means for
     navigating in the current goal for focusing on the part which is
     of interest. The current subterm is set to the current goal when
     arriving at a new port. This command, without arguments, resets
     the current subterm to the current goal. With an argument of `n'
     (greater than 0 and less or equal to the number of subterms of
     the current subterm), the current subterm is replaced by its
     `n''th subterm. With an argument of `0', the current subterm is
     replaced by its parent term.

   * `?' or `h' ( _help_)

     displays the table of options given above.



File: ciao.info,  Node: Calling predicates that are not exported by a module,  Next: Acknowledgements,  Prev: Options available during debugging,  Up: The interactive debugger

Calling predicates that are not exported by a module
====================================================

   The Ciao module system does not allow calling predicates which are
not exported during debugging. However, as an aid during debuggig,
this is allowed (only from the top-level and for modules which are in
debug mode or source-level debug mode) using the `call_in_module/2'
predicate.

   Note that this does not affect analysis or optimization issues,
since it only works on modules which are loaded in debug mode or
source-level debug mode, i.e. unoptimized.


File: ciao.info,  Node: Acknowledgements,  Prev: Calling predicates that are not exported by a module,  Up: The interactive debugger

Acknowledgements
================

   Originally written by Andrzej Ciepielewski. Minor modifications by
Mats Carlsson. Later modifications (17 Dec 87) by Takashi Chikayama
(making tracer to use `print/1' rather than `write/1', temporarily
switching debugging flag off while writing trace message and within
"break" level). Additional modifications by Kish Shen (May 88):
subterm navigation, handle unbound args in `spy/1' and `nospy/1',
trapping arithmetics errors in debug mode. Adapted then to &-Prolog
and Ciao by D. Cabeza and included in the Ciao version control
system. Extended for source-level debugging by Manuel C. Rodri'guez.
(See changelog if included in the document for more detailed
documentation of the later changes.)


File: ciao.info,  Node: Predicates controlling the interactive debugger,  Next: The script interpreter,  Prev: The interactive debugger,  Up: Top

Predicates controlling the interactive debugger
***********************************************

   *Author(s):* A. Ciepielewski, M. Carlsson, T. Chikayama, K. Shen,
D. Cabeza, M. Rodriguez.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#148 (2000/5/24, 11:26:32 CEST)

   This library implements predicates which are normally used in the
interactive top-level shell to debug programs. A subset of them are
available in the embeddable debugger.

* Menu:

* Usage and interface (debugger)::
* Documentation on exports (debugger)::
* Documentation on internals (debugger)::
* Known bugs and planned improvements (debugger)::


File: ciao.info,  Node: Usage and interface (debugger),  Next: Documentation on exports (debugger),  Prev: Predicates controlling the interactive debugger,  Up: Predicates controlling the interactive debugger

Usage and interface (`debugger')
================================

   * *Library usage:*

     `:- use_module(library(debugger)).'

   * *Exports:*
        - _Predicates:_

          `debug_module/1', `nodebug_module/1',
          `debug_module_source/1', `debug/0', `nodebug/0', `trace/0',
          `notrace/0', `spy/1', `nospy/1', `nospyall/0', `breakpt/6',
          `nobreakpt/6', `nobreakall/0', `list_breakpt/0',
          `debugging/0', `leash/1', `maxdepth/1', `call_in_module/2'.


   * *Other modules used:*
        - _System library modules:_

          `debugger/debugger_lib', `format', `ttyout', `read',
          `write', `aggregates', `sort', `prolog_sys'.




File: ciao.info,  Node: Documentation on exports (debugger),  Next: Documentation on internals (debugger),  Prev: Usage and interface (debugger),  Up: Predicates controlling the interactive debugger

Documentation on exports (`debugger')
=====================================

 - PREDICATE: debug_module/1:
     *Usage:* `debug_module(Module)'
        - _Description:_ The debugger will take into acount module
          `Module' (assuming it is loaded in interpreted mode). When
          issuing this command at the toplevel shell, the compiler is
          instructed also to set to _interpret_ the loading mode of
          files defining that module and also to mark it as
          'modified' so that (re)loading this file or a main file
          that uses this module will force it to be reloaded for
          source-level debugging.

        - _The following properties should hold at call time:_

          `Module' is an atom.   (`basic_props:atm/1')



 - PREDICATE: nodebug_module/1:
     *Usage:* `nodebug_module(Module)'
        - _Description:_ The debugger will not take into acount
          module `Module'. When issuing this command at the toplevel
          shell, the compiler is instructed also to set to _compile_
          the loading mode of files defining that module.

        - _The following properties should hold at call time:_

          `Module' is an atom.   (`basic_props:atm/1')



 - PREDICATE: debug_module_source/1:
     *Usage:* `debug_module_source(Module)'
        - _Description:_ The debugger will take into acount module
          `Module' (assuming it is is loaded in source-level debug
          mode). When issuing this command at the toplevel shell, the
          compiler is instructed also to set to _interpret_ the
          loading mode of files defining that module and also to mark
          it as 'modified' so that (re)loading this file or a main
          file that uses this module will force it to be reloaded for
          source-level debugging.

        - _The following properties should hold at call time:_

          `Module' is an atom.   (`basic_props:atm/1')



 - PREDICATE: debug/0:
     *Usage:*
        - _Description:_ Switches the debugger on. The interpreter
          will stop at all ports of procedure boxes of spied
          predicates.



 - PREDICATE: nodebug/0:
     *Usage:*
        - _Description:_ Switches the debugger off. If there are any
          spy-points set then they will be kept but disabled.



 - PREDICATE: trace/0:
     *Usage:*
        - _Description:_ Start tracing, switching the debugger on if
          needed. The interpreter will stop at all leashed ports of
          procedure boxes of predicates either belonging to debugged
          modules or called from clauses of debugged modules. A
          message is printed at each stop point, expecting input from
          the user (write `h' to see the available options).



 - PREDICATE: notrace/0:
     *Usage:*
        - _Description:_ Equivalent to `nodebug/0'.



 - PREDICATE: spy/1:
     *Usage:* `spy(PredSpec)'
        - _Description:_ Set spy-points on predicates belonging to
          debugged modules and which match `PredSpec', switching the
          debugger on if needed. This predicate is defined as a
          prefix operator by the toplevel.

        - _The following properties should hold at call time:_

          `PredSpec' is a sequence of `multpredspec's.
          (`basic_props:sequence/2')



 - PREDICATE: nospy/1:
     *Usage:* `nospy(PredSpec)'
        - _Description:_ Remove spy-points on predicates belonging to
          debugged modules which match `PredSpec'. This predicate is
          defined as a prefix operator by the toplevel.

        - _The following properties should hold at call time:_

          `PredSpec' is a sequence of `multpredspec's.
          (`basic_props:sequence/2')



 - PREDICATE: nospyall/0:
     *Usage:*
        - _Description:_ Remove all spy-points.



 - PREDICATE: breakpt/6:
     *Usage:* `breakpt(Pred,Src,Ln0,Ln1,Number,RealLine)'
        - _Description:_ Set a _breakpoint_ in file `Src' between
          lines `Ln0' and `Ln1' at the literal corresponding to the
          `Number''th occurence of (predicate) name `Pred'. The pair
          `Ln0'-`Ln1' uniquely identifies a program clause and must
          correspond to the start and end line numbers for the
          clause. The rest of the arguments provide enough
          information to be able to locate the exact literal that the
          `RealLine' line refers to. This is normally not issued by
          users but rather by the `emacs' mode, which automatically
          computes the different argument after selecting a point in
          the source file.

        - _The following properties should hold at call time:_

          `Pred' is an atom.   (`basic_props:atm/1')

          `Src' is a source name.   (`streams_basic:sourcename/1')

          `Ln0' is an integer.   (`basic_props:int/1')

          `Ln1' is an integer.   (`basic_props:int/1')

          `Number' is an integer.   (`basic_props:int/1')

          `RealLine' is an integer.   (`basic_props:int/1')



 - PREDICATE: nobreakpt/6:
     *Usage:* `nobreakpt(Pred,Src,Ln0,Ln1,Number,RealLine)'
        - _Description:_ Remove a breakpoint in file `Src' between
          lines `Ln0' and `Ln1' at the `Number''th occurence of
          (predicate) name `Pred' (see `breakpt/6'). Also normally
          used from de `emacs' mode.

        - _The following properties should hold at call time:_

          `Pred' is an atom.   (`basic_props:atm/1')

          `Src' is a source name.   (`streams_basic:sourcename/1')

          `Ln0' is an integer.   (`basic_props:int/1')

          `Ln1' is an integer.   (`basic_props:int/1')

          `Number' is an integer.   (`basic_props:int/1')

          `RealLine' is an integer.   (`basic_props:int/1')



 - PREDICATE: nobreakall/0:
     *Usage:*
        - _Description:_ Remove all breakpoints.



 - PREDICATE: list_breakpt/0:
     *Usage:*
        - _Description:_ Prints out the location of all breakpoints.
          The location of the breakpoints is showed usual by
          referring to the source file, the lines between which the
          predicate can be found, the predicate name and the number
          of ocurrence of the predicate name of the literal.



 - PREDICATE: debugging/0:
     *Usage:*
        - _Description:_ Display debugger state.



 - PREDICATE: leash/1:
     *Usage:* `leash(Ports)'
        - _Description:_ Leash on ports `Ports', some of `call',
          `exit', `redo', `fail'. By default, all ports are on leash.

        - _The following properties should hold at call time:_

          `Ports' is a list of `port's.   (`basic_props:list/2')



 - PREDICATE: maxdepth/1:
     *Usage:* `maxdepth(MaxDepth)'
        - _Description:_ Set maximum invocation depth in debugging to
          `MaxDepth'. Calls to compiled predicates are not included
          in the computation of the depth.

        - _The following properties should hold at call time:_

          `MaxDepth' is an integer.   (`basic_props:int/1')



 - PREDICATE: call_in_module/2:
     *Usage:* `call_in_module(Module,Predicate)'
        - _Description:_ Calls predicate `Predicate' belonging to
          module `Module', even if that module does not export the
          predicate. This only works for modules which are in debug
          (interpreted) mode (i.e., they are not optimized).

        - _The following properties should hold at call time:_

          `Module' is an atom.   (`basic_props:atm/1')

          `Predicate' is a term which represents a goal, i.e., an
          atom or a structure.   (`basic_props:callable/1')




File: ciao.info,  Node: Documentation on internals (debugger),  Next: Known bugs and planned improvements (debugger),  Prev: Documentation on exports (debugger),  Up: Predicates controlling the interactive debugger

Documentation on internals (`debugger')
=======================================

 - PROPERTY: multpredspec/1:
     A property, defined as follows:
               multpredspec(Mod:Spec) :-
                       atm(Mod),
                       multpredspec(Spec).
               multpredspec(Name/Low-High) :-
                       atm(Name),
                       int(Low),
                       int(High).
               multpredspec(Name/(Low-High)) :-
                       atm(Name),
                       int(Low),
                       int(High).
               multpredspec(Name/Arity) :-
                       atm(Name),
                       int(Arity).
               multpredspec(Name) :-
                       atm(Name).





File: ciao.info,  Node: Known bugs and planned improvements (debugger),  Prev: Documentation on internals (debugger),  Up: Predicates controlling the interactive debugger

Known bugs and planned improvements (`debugger')
================================================

   * Add an option to the emacs menu to automatically select all
     modules in a project.

   * Consider the possibility to show debugging messages directly in
     the source code emacs buffer.


File: ciao.info,  Node: The script interpreter,  Next: Customizing library paths and path aliases,  Prev: Predicates controlling the interactive debugger,  Up: Top

The script interpreter
**********************

   *Author(s):* Daniel Cabeza, Manuel Hermenegildo.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#130 (2000/5/3, 20:19:4 CEST)

   `ciao-shell' is the Ciao script interpreter. It can be used to
write _Prolog shell scripts_ (see [Her96,CHV96b]), that is,
executable files containing source code, which are compiled on demand.

   Writing Prolog scripts can sometimes be advantageous with respect
to creating binary executables for small- to medium-sized programs
that are modified often and perform relatively simple tasks. The
advantage is that no explicit compilation is necessary, and thus
changes and updates to the program imply only editing the source
file. The disadvantage is that startup of the script (the first time
after it is modified) is slower than for an application that has been
compiled previously.

   An area of application is, for example, writing _CGI executables_:
the slow speed of the network connection in comparison with that of
executing a program makes program execution speed less important and
has made scripting languages very popular for writing these
applications. Logic languages are, a priori, excellent candidates to
be used as scripting languages. For example, the built-in grammars
and databases can sometimes greatly simplify many typical
script-based applications.

* Menu:

* How it works::
* Command line arguments in scripts::


File: ciao.info,  Node: How it works,  Next: Command line arguments in scripts,  Prev: The script interpreter,  Up: The script interpreter

How it works
============

   Essentially, `ciao-shell' is a smaller version of the Ciao
top-level, which starts by loading the file given to it as the first
argument and then starts execution at `main/1' (the argument is
instantiated to a list containing the command line options, in the
usual way). However, while doing this, `ciao-shell' changes the
prolog flag `quiet' so that no informational or warning messages are
printed (error messages will be reported to `user_error', however).
The operation of `ciao-shell' in Unix-like systems is based in a
special compiler feature: when the first character of a file is
'`#'', the compiler skips the first lines until an empty line is
found. In Windows, its use is as easy as naming the file with a
`.pls' extension, which will launch `ciao-shell' appropriately (the
name of the module has to include that extension, as in `:-
module('test.pls',[main/1])').

   For example, in a Linux/Unix system, assume a file called `hello'
contains the following program:

     #!/bin/sh
     exec ciao-shell $0 "$@" # -*- mode: ciao; -*-
     
     main(_) :-
          write('Hello world'), nl.

   Then, the file `hello' can be _run_ by simply making it executable
and invoking it from the command line:

     /herme@clip:/tmp
     [86]> chmod +x hello
     
     /herme@clip:/tmp
     [87]> hello
     Hello world

   The line:
     #!/bin/sh

invokes the `/bin/sh' shell which will interpret the following line:
     exec ciao-shell $0 "$@" # -*- mode: ciao; -*-

and invoke `ciao-shell', instructing it to read this same file
(`$0'), passing it the rest of the arguments to `hello' as arguments
to the prolog program. The second part of the line `# -*- mode: ciao;
-*-' is simply a comment which is seen by `emacs' and instructs it to
edit this file in Ciao mode (this is needed because these script
files typically do not have a `.pl' ending). When `ciao-shell'
starts, if it is the first time, it compiles the program (skipping
the first lines, as explained above), or else at successive runs
loads the `.po' object file, and then calls `main/1'.

   Note that the process of creating Prolog scripts is made very
simple by the Ciao emacs mode, which automatically inserts the header
and makes the file executable (See *Note Using Ciao inside GNU
emacs::).


File: ciao.info,  Node: Command line arguments in scripts,  Prev: How it works,  Up: The script interpreter

Command line arguments in scripts
=================================

The following example illustrates the use of command-line arguments
in scripts. Assume that a file called `say' contains the following
lines:

     #!/bin/sh
     exec ciao-shell $0 "$@" # -*- mode: ciao; -*-
     
     main(Argv) :-
          write_list(Argv), nl.
     
     write_list([]).
     write_list([Arg|Args]) :-
          write(Arg),
          write(' '),
          write_list(Args).

An example of use is:

     /herme@clip:/tmp
     [91]> say hello dolly
     hello dolly


File: ciao.info,  Node: Customizing library paths and path aliases,  Next: Using Ciao inside GNU emacs,  Prev: The script interpreter,  Up: Top

Customizing library paths and path aliases
******************************************

   *Author(s):* D.Cabeza.

   This library provides means for customizing, from environment
variables, the libraries and path aliases known by an executable.
Many applications of Ciao, including `ciaoc', `ciaosh', and
`ciao-shell' make use of this library. Note that if an executable is
created dynamic, it will try to load its components at startup,
before the procedures of this module can be invoked, so in this case
all the components should be in standard locations.

* Menu:

* Usage and interface (libpaths)::
* Documentation on exports (libpaths)::
* Documentation on multifiles (libpaths)::


File: ciao.info,  Node: Usage and interface (libpaths),  Next: Documentation on exports (libpaths),  Prev: Customizing library paths and path aliases,  Up: Customizing library paths and path aliases

Usage and interface (`libpaths')
================================

   * *Library usage:*

     `:- use_module(library(libpaths)).'

   * *Exports:*
        - _Predicates:_

          `get_alias_path/0'.

        - _Multifiles:_

          `file_search_path/2', `library_directory/1'.


   * *Other modules used:*
        - _System library modules:_

          `system', `lists'.




File: ciao.info,  Node: Documentation on exports (libpaths),  Next: Documentation on multifiles (libpaths),  Prev: Usage and interface (libpaths),  Up: Customizing library paths and path aliases

Documentation on exports (`libpaths')
=====================================

 - PREDICATE: get_alias_path/0:
     `get_alias_path'

     Consult the environment variable 'CIAOALIASPATH' and add facts
     to predicates `library_directory/1' and `file_search_path/2' to
     define new library paths and path aliases. The format of
     'CIAOALIASPATH' is a sequence of paths or alias assignments
     separated by colons, an alias assignment is the name of the
     alias, an '=' and the path represented by that alias (no blanks
     allowed). For example, given
             CIAOALIASPATH=/home/bardo/ciao:contrib=/usr/local/lib/ciao
     the predicate will define /home/bardo/ciao as a library path and
     /usr/local/lib/ciao as the path represented by 'contrib'.





File: ciao.info,  Node: Documentation on multifiles (libpaths),  Prev: Documentation on exports (libpaths),  Up: Customizing library paths and path aliases

Documentation on multifiles (`libpaths')
========================================

 - PREDICATE: file_search_path/2:
     See *Note Basic file/stream handling::.

     The predicate is _multifile_.

     The predicate is of type _dynamic_.




 - PREDICATE: library_directory/1:
     See *Note Basic file/stream handling::.

     The predicate is _multifile_.

     The predicate is of type _dynamic_.





File: ciao.info,  Node: Using Ciao inside GNU emacs,  Next: *** PART II - The Ciao basic language (engine),  Prev: Customizing library paths and path aliases,  Up: Top

Using Ciao inside GNU emacs
***************************

   *Author(s):* Manuel Hermenegildo, Manuel C. Rodriguez, Daniel
Cabeza, <clip@clip.dia.fi.upm.es>, `http://www.clip.dia.fi.upm.es/',
The CLIP Group, School of Computer Science, Technical University of
Madrid.

   *Version:* 1.6#3 (2000/8/23, 11:27:29 CEST)

   *Version of last change:* 1.5#159 (2000/5/31, 10:52:49 CEST)

   The Ciao/Prolog emacs interface (or _mode_ in `emacs' terms)
provides a rich, integrated user interface to the Ciao _program
development environment_ components, including the `ciaosh'
interactive top level and the `ciaopp' preprocessor. While most
features of the Ciao development environment are available from the
command line of the preprocessor and the top-level shell, using Ciao
inside `emacs' is highly recommended. The facilities that this mode
provides include:

   * _Syntax highlighting_ and syntax coloring, _auto-indentation_,
     _auto-fill_, etc. of code. This includes the assertions used by
     the preprocessor and the documentation strings used by the Ciao
     auto-documenter, `lpdoc'.

   * Providing automatic access to on-line help for all predicates by
     accessing the Ciao system manuals in `info' format.

   * Starting and communicating with `ciaopp', the _Ciao
     preprocessor_, running in its own sub-shell. This allows easily
     performing certain kinds of _static checks_ (useful for finding
     errors in programs before running them), program analysis tasks,
     and _program transformations_ on source programs.

   * Starting and communicating with the _Ciao top-level_, running in
     its own sub-shell. This facilitates loading programs, checking
     the _syntax_ of programs (and of _assertions_ within programs),
     marking and unmarking modules for interactive debugging,
     _tracing the source code_ during debugging, making stand-alone
     executables, compiling modules to dynamically linkable Prolog
     objects, compiling modules to active objects, etc.

   * Syntax highlighting and coloring of the error and warning
     messages produced by the top level, preprocessor, or any other
     tool using the same message format (such as the `lpdoc'
     auto-documenter), and _locating automatically the points in the
     source files where such errors occur_.

   * Performing automatic _version control_ and keeping a _changelog_
     of individual files or whole applications. This is done by
     automatically including changelog entries in source files, which
     can then be processed by the `lpdoc' auto-documenter.


   This chapter explains how to use the Ciao/Prolog `emacs' interface
and how to set up your `emacs' environment for correct operation. The
Ciao `emacs' interface can also be used to work with other Prolog or
CLP systems.

* Menu:

* Conventions for writing Ciao programs under Emacs::
* Checking the installation::
* Functionality and associated key sequences (bindings)::
* Commands available in toplevel and preprocessor buffers::
* Using Ciao/Prolog mode capabilities in standard shells::
* Coexistence with other Prolog interfaces::
* Customization::
* Installation of the Ciao/Prolog emacs interface::
* Emacs version compatibility::
* Acknowledgments (ciao.el)::


File: ciao.info,  Node: Conventions for writing Ciao programs under Emacs,  Next: Checking the installation,  Prev: Using Ciao inside GNU emacs,  Up: Using Ciao inside GNU emacs

Conventions for writing Ciao programs under Emacs
=================================================

   This is particularly important for the source-level debugger and
the syntax coloring capabilities. This is due to the fact that it
would be unrealistic to write a complete Prolog parser in Emacs lisp.
These conventions are the following, in order of importance:

   * Clauses should begin on the first column (this is used to
     recognize the beginning of a clause).

   * C style comments should not be used in a clause, but can be used
     outside any clause.


   The following are suggestions which are not strictly necessary but
which can improve operation:

   * Body literals should be indented, and there should be not more
     than one literal per line. This allows more precision in the
     location of program points during source-level debugging, i.e.,
     when marking breakpoints and during line tracing.



File: ciao.info,  Node: Checking the installation,  Next: Functionality and associated key sequences (bindings),  Prev: Conventions for writing Ciao programs under Emacs,  Up: Using Ciao inside GNU emacs

Checking the installation
=========================

   It may be possible that a complete pre-installation of the
Ciao/Prolog `emacs' interface was already completed during Ciao
installation. To check this, open a file with a `.pl' ending. You
should see that `emacs' enters Ciao/Prolog mode: the mode is
identified in the status bar below the buffer and, if the emacs menu
bar is enabled, you should see the Ciao/Prolog menus. You should be
able from the menu-bar, for example, to go to the Ciao manuals in the
info or load the `.pl' file that you just opened into a ciao top
level.

   If things don't work properly, see the section *Note Installation
of the Ciao/Prolog emacs interface:: latter in this chapter.


File: ciao.info,  Node: Functionality and associated key sequences (bindings),  Next: Commands available in toplevel and preprocessor buffers,  Prev: Checking the installation,  Up: Using Ciao inside GNU emacs

Functionality and associated key sequences (bindings)
=====================================================

   The following is a summary of the capabilities of the Ciao/Prolog
emacs interface and the (default) _key sequences_ used to access
those capabilities. Most of these functions are accessible also from
the menu bar.

* Menu:

* Syntax coloring and syntax based editors::
* Getting on-line help::
* Loading and compiling programs::
* Locating errors and checking the syntax of assertions::
* Commands which help in typing in programs::
* Debugging programs::
* Preprocessing programs::
* Version control::
* Generating program documentation::
* Setting the top-level::
* Traditional Prolog Mode Commands::
* Other commands::
* Getting the Ciao/Prolog mode version::


File: ciao.info,  Node: Syntax coloring and syntax based editors,  Next: Getting on-line help,  Prev: Functionality and associated key sequences (bindings),  Up: Functionality and associated key sequences (bindings)

Syntax coloring and syntax based editors
----------------------------------------

   Syntax-based coloring is provided automatically when opening
Ciao/Prolog files. The mode should be set to Ciao/Prolog and the Ciao
mode menus should appear on the menu bar. Limited syntax-based
indentation is also provided:
<TAB>
     Indent current line as Ciao/Prolog code. With argument, indent
     any additional lines of the same clause rigidly along with this
     one.


File: ciao.info,  Node: Getting on-line help,  Next: Loading and compiling programs,  Prev: Syntax coloring and syntax based editors,  Up: Functionality and associated key sequences (bindings)

Getting on-line help
--------------------

   The following commands are useful for getting on-line help. This
is done by accessing the `info' version of the Ciao manuals or the
`emacs' built-in help strings. Note also that the `info' standard
`search' command (generally bound to <s>) can be used inside `info'
buffers to search for a given string.
<^C> <TAB>
     Find help for the symbol (e.g., predicate, directive,
     declaration, type, etc.) that is currently under the cursor.
     Opens a (hopefully) relevant part of the Ciao manuals in `info'
     mode. Requires that the Ciao manuals in `info' format be
     installed and accessible to `emacs' (i.e., they should appear
     somewhere in the info directory when typing `M-x info'). It also
     requires `word-help.el', which is provided with Ciao. Refer to
     the installation instructions if this is not the case.

<^C> </>
     Find a completion for the symbol (e.g., predicate, directive,
     declaration, type, etc.) that is currently under the cursor.
     Uses for completion the contents of the indices of the Ciao
     manuals. Same requirements as for finding help for the symbol.

<^C> <^M>
     Go to the part of the info directory containing the Ciao manuals.

<^H> <m>
     Show a short description of the Ciao/Prolog emacs mode,
     including all key bindings.


File: ciao.info,  Node: Loading and compiling programs,  Next: Locating errors and checking the syntax of assertions,  Prev: Getting on-line help,  Up: Functionality and associated key sequences (bindings)

Loading and compiling programs
------------------------------

   These commands allow _loading programs_, _creating executables_,
etc. by issuing the appropriate commands to a Ciao/Prolog top level
shell, running in its own buffer as a subprocess. See *Note The
interactive top-level shell:: for details. The following commands
implement the communication with the Ciao/Prolog top level:
<^C> <t>
     Ensure that an inferior Ciao/Prolog top-level process is
     running. Normally, it is not necessary to use this function
     since execution of any of the other functions related to the top
     level ensures that a top level is started (starting one if
     required). This function is useful when one would like to start
     a top level in order to type a command directly by hand into it.

<^C> <l>
     Load the current buffer (and any auxiliary files it may use)
     into the top level. The type of compilation performed (
     _compiling_ or _interpreting_) is selected automatically
     depending on whether the buffer has been marked for debugging or
     not - see below. In case you try to load a file while in the
     middle of the debugging process the debugger is first aborted
     and then the buffer is loaded. Also, if there is a defined
     query, the user is asked whether it should be called.

<^C> <L>
     Load the module designed as _main module_ (and any auxiliary
     files it may use) into the top level. If no main module is
     defined it will load the current buffer. The type of compilation
     performed ( _compiling_ or _interpreting_) is selected
     automatically depending on whether the buffer has been marked
     for debugging or not - see below. In case you try to load a file
     while in the middle of the debugging process the debugger is
     first aborted and then the buffer is loaded. Also, if there is a
     defined query, the user is asked whether is should be called.

<^C> <q>
     Set a default query. It is possible to set things up so that
     this query will be issued any time a program is (re)loaded. The
     functionality is available in the major mode (i.e., from a
     buffer containing a source file) and in the inferior mode (i.e.,
     from the buffer running the top-level shell. When called from
     the major mode it will ask in the minibuffer for the query and
     when calling from the inferior mode it will get the query on the
     current line.

<^C> <Q>
     Ask user if the predefined query should be issued.

<^C> <s>
     Set the current buffer as the principal module in a multiple
     module programming environment.

<^C> <x>
     Make an executable from the code in the current buffer. The
     buffer must contain a `main/0' or `main/1' predicate. Note that
     compiler options can be set to determine whether the libraries
     and auxiliary files used by the executable will be statically
     linked, dynamically linked, auto-loaded, etc.

<^C> <o>
     Make a Prolog object (.po) file from the code in the current
     buffer. This is very useful during debugging or program
     development, when only one or a few files of a large application
     are modified. If the application executable is dynamically
     linked, i.e., the component .po files are loaded dynamically
     during startup of the application, then this command can be used
     to recompile only the file or files which have changed, and the
     correct version will be loaded dynamically the next time the
     application is started. However, note that this only works if
     the inter-module interfaces have not changed. A safer, but
     possibly slower way is to generate the executable again, letting
     the Ciao compiler, which is inherently incremental, determine
     what needs to be recompiled.

<^C> <a>
     Make an active module executable from the code in the current
     buffer. An active module is a remote procedure call server (see
     the `activemod' library documentation for details).


File: ciao.info,  Node: Locating errors and checking the syntax of assertions,  Next: Commands which help in typing in programs,  Prev: Loading and compiling programs,  Up: Functionality and associated key sequences (bindings)

Locating errors and checking the syntax of assertions
-----------------------------------------------------

   These commands allow several syntactic checks of assertions, and
locating quickly the point in the source code corresponding to errors
flagged by the compiler or preprocessor:
<^C> <`>
     Go to the location in the source file containing the next error
     reported by the last Ciao/Prolog subprocess (preprocessor or
     toplevel) which was run.

<^C> <e>
     Remove the error mark in a buffer.

<^C> <E>
     Check the _syntax_ of the code and assertions in the current
     buffer, as well as imports and exports. Note that full
     (semantic) assertion checking must be done with the preprocessor.


File: ciao.info,  Node: Commands which help in typing in programs,  Next: Debugging programs,  Prev: Locating errors and checking the syntax of assertions,  Up: Functionality and associated key sequences (bindings)

Commands which help in typing in programs
-----------------------------------------

   The following commands are intended to help in the process of
writing programs:
<^C> <I> <S>
     Insert a (Unix) header at the top of the current buffer so that
     the ciao script interpreter will be called on this file if _run_
     from the command line. It also makes the file "executable"
     (e.g., '`chmod +x <file>'' in Unix). See *Note The script
     interpreter:: for details.


File: ciao.info,  Node: Debugging programs,  Next: Preprocessing programs,  Prev: Commands which help in typing in programs,  Up: Functionality and associated key sequences (bindings)

Debugging programs
------------------

   These commands allow marking modules for _debugging_ by issuing
the appropiate commands to a Ciao/Prolog top level shell, running in
its own buffer as a subprocess. There are two differents types of
debugging: traditional Prolog debugging (using the byrd-box model and
spy-points) and _source-level debugging_ (same as traditional
debugging plus source tracing and breakpoints).  In order to use
_breakpoints_, source debugging must be on. The following commands
implement comunication with the Ciao/Prolog top level:
<^C> <d>
     This is a shortcut which is particularly useful when debugging a
     single module or file. It corresponds to several lower-level
     actions. Those lower-level actions depend on how the module was
     selected for debugging. In case the module was not marked for
     source-level debugging, it marks the module corresponding to the
     current buffer for source-level debugging, reloads it to make
     sure that it is loaded in the correct way for debugging (same as
     C-c l), and sets the debugger in trace mode (i.e., issues the
     `trace.' command to the top-level shell). Conversely, if the
     module was already marked for source-level debugging then it
     will take the opposite actions, i.e., it unmarks the module for
     source-level debugging, reloads it, and sets the debugger to
     non-debug mode.

<^C> <m>
     Mark, or unmkark, the current buffer for debugging (traditional
     debugging or source debugging). Note that if the buffer has
     already been loaded while it was unmarked for debugging (and has
     therefore been loaded in "compile" mode) it has to be loaded
     again. The minibuffer shows how the module is loaded now and
     allows selecting another mode for it. There are three
     posibilities: N for no debug, S for source debug and D for
     traditional debug.

<^C> <M-m>
     Visits all Ciao/Prolog files which are currently open in a
     buffer allowing selecting for each of them whether to debug them
     or not and the type of debugging performed. When working on a
     multiple module program, it is possible to have many modules
     open at a time. In this case, you will navigate through all open
     Ciao/Prolog files and select the debug mode for each of them
     (same as doing C-c m for each).

<^C> <S> <b>
     Set a breakpoint on the current literal (goal). This can be done
     at any time (while debugging or not). The cursor must be _on the
     predicate symbol of the literal_. Breakpoints are only useful
     when using source-level debugging.

<^C> <S> <v>
     Remove a breakpoint from the current literal (goal). This can be
     done at any time (while debugging or not). The cursor must be
     _on the predicate symbol of the literal_.

<^C> <S> <n>
     Remove all breakpoints. This can be done at any time (while
     debugging or not).

<^C> <S> <l>
     Redisplay breakpoints in all Ciao buffers. This ensures that the
     marks in the source files and the Ciao/Prolog toplevel are
     synchronized.

<^C> <S> <r>
     Remove breakpoints color in all Ciao/Prolog files.

<^C> <S> <t>
     Set the debugger to the trace state. In this state, the program
     is executed step by step.

<^C> <S> <d>
     Set the debugger to the debug state. In this state, the program
     will only stop in breakpoints and spypoints. Breakpoints are
     specially supported in `emacs' and using source debug.

<^C> <r>
     Load the current region (between the cursor and a previous mark)
     into the top level for debugging. Since loading a region of a
     file is typically done for debugging and/or testing purposes,
     this command always loads the region in debugging mode
     (interpreted).

<^C> <p>
     Load the predicate around the cursor into the top level. Since
     loading a single predicate is typically done for debugging
     and/or testing purposes, this command always loads the predicate
     in debugging mode (interpreted).


File: ciao.info,  Node: Preprocessing programs,  Next: Version control,  Prev: Debugging programs,  Up: Functionality and associated key sequences (bindings)

Preprocessing programs
----------------------

   These commands allow _preprocessing programs_ with `ciaopp', the
_Ciao preprocessor_.

   `ciaopp' is the precompiler of the Ciao Prolog development
environment.  `ciaopp' can perform a number of program debugging,
analysis and source-to-source transformation tasks on (Ciao) Prolog
programs. These tasks include:

   * _Inference of properties_ of the predicates and literals of the
     progam, including _types_, _modes_ and other _variable
     instantiation_ properties, _non-failure_, _determinacy_, bounds
     on _computational cost_, bounds on _sizes of terms_ in the
     program, etc.

   * Certain kinds of _static debugging_, finding errors before
     running the program. This includes checking the ways in which
     programs call the system library predicates and also _checking
     the assertions_ present in the program or in other modules used
     by the program. Such assertions essentially represent partial
     _specifications_ of the program.

   * Several kinds of source to source _program transformations_ such
     as _program specialization_, _program parallelization_ (including
     _granularity control_), inclusion of _run-time tests_ for
     assertions which cannot be checked completely at compile-time,
     etc.


   The information generated by analysis, the assertions in the
system libraries, and the assertions optionally included in user
programs as specifications are all written in the same _assertion
language_, which is in turn also used by the Ciao system
documentation generator, `lpdoc'.

   `ciaopp' is distributed under the GNU general public license.

   See the preprocessor manual for details. The following commands
implement the communication with the Ciao preprocessor:

<^C> <M>
     Preprocess the buffer, selecting options. Instructs the
     preprocessor to load the current buffer and start an interactive
     dialog in which the different options available in the
     preprocessor can be set.

<^C> <P>
     Preprocess the buffer, using the previously selected options. If
     no options were set previously, then the preprocessor defaults
     are used.

<^C> <^V>
     Show last output file produced by Ciao preprocessor. The
     preprocessor works by producing a file which is a transformed
     and/or adorned (with assertions) version of the input file. This
     command is often used after running the preprocessor in order to
     visit the output file and see the results from running the
     preprocessor.

<^C> <V>
     Preprocess the buffer, using the previously selected (or
     default) options, waits for preprocessing to finish and displays
     the preprocessor output (leaving the cursor at the same point if
     already on a preprocessor output file). This allows running the
     preprocessor over and over and watching the output while
     modifying the source code.

<^C> <^R>
     Ensure that an inferior Ciao preprocessor process is running


File: ciao.info,  Node: Version control,  Next: Generating program documentation,  Prev: Preprocessing programs,  Up: Functionality and associated key sequences (bindings)

Version control
---------------

   The following commands can be used to carry out a simple form of
version control by keeping a log of changes on a file or a group of
related files. This log is kept in a format that is understood by
`lpdoc', the Ciao documenter [Her99]. As a result, if these version
comments are present, then `lpdoc' will be able to automatically
assign up to date version numbers to the manuals that it generates.
This way it is always possible to identify to which version of the
software a manual corresponds. Also, `lpdoc' can create automatically
sections describing the changes made since previous versions, which
are extracted from the comments in the changelog entries.

   The main effect of these commands is automatically associate the
following information to a set of changes performed in the file
and/or in a set of related files:

   * a _version number_ (such as, e.g., `1.2', where `1' is the major
     version number and `2' is the minor version number),

   * a patch number (such as, e.g., the `4' in `1.2#4'),

   * a time stamp (such as, e.g., `1998/12/14,17:20*28+MET'),

   * the author of the change, and

   * a comment explaining the change.

   The version numbering used can be local to a single file or common
to a number of related files. A simple version numbering policy is
implemented: when a relevant change is made, the user typically
inserts a changelog entry for it, using the appropriate command (or
selecting the corresponding option when prompted while saving a
file). This will cause the _patch number_ for the file (or for the
whole system that the file is part of) to be incremented
automatically and the corresponding machine-readable comment to be
inserted in the file. Major and minor version numbers can also be
changed, but this is always invoked by hand (see below).

   The changelog entry is written in the form of a `comment/2'
declaration. As mentioned before, the advantage of using this kind of
changelog entries is that these declarations can be processed by the
`lpdoc' automatic documenter (see the `lpdoc' reference manual
[Her99] or the `assertions' library documentation for more details on
these declarations).

   Whether the user is asked or not to introduce such changelog
entries, and how the patch and version numbers should be increased is
controlled by the presence in the file of a `comment/2' declaration
of the type:

   `:- comment(version_maintenance,<type>).'

(note that this requires including the `assertions' library in the
source file). These declarations themselves are also typically
introduced automatically when using this mode (see below).

   The version maintenance mode can also be set alternatively by
inserting a comment such as:

     %% Local Variables:
     %% mode: ciao
     %% update-version-comments: "off"
     %% End:

   The lines above instruct emacs to put the buffer visiting the file
in emacs Ciao/Prolog mode and to turn version maintenance off.
Setting the version maintenance mode in this way has the disadvantage
that `lpdoc', the auto-documenter, and other related tools will not
be aware of the type of version maintenance being performed (the
lines above are comments for Prolog). However, this can be useful in
fact for setting the _version maintenance mode for packages_ and
other files meant for inclusion in other files, since that way the
settings will not affect the file in which the package is included.

   The following commands implement the version control support:

<^X> <^S>
     This is the standard `emacs' command that saves a buffer by
     writing the contents into the associated `.pl' file. However, in
     Ciao/Prolog mode this command can be set to ask the user before
     saving whether to introduce a changelog entry documenting the
     changes performed.

     If the buffer does not already contain a comment specifying the
     type of version control to be performed, and before saving the
     buffer, the Ciao/Prolog mode prompts the user to choose among
     the following options:

    <q>
          Turn off prompting for the introduction of changelog
          entries for now.  `emacs' will not ask again while the
          buffer is loaded, but it will ask again next time you load
          the buffer.

    <n>
          Turn off version control for this file. A version control
          comment such as:

          `:- comment(version_maintenance,off).'

          is added to the buffer and the file is saved.  `emacs' will
          not perform any version control on this file until the line
          above is removed or modified (i.e., from now on C-x C-s
          simply saves the buffer).

    <y>
          Turn version control on for this file.

     If <y> is selected, then the system prompts again regarding how
     and where the version and patch number information is to be
     maintained. The following options are available:

    `on'
          All version control information will be contained within
          this file. When saving a buffer (C-x C-s) emacs will ask if
          a changelog entry should be added to the file before
          saving. If a comment is entered by the user, a new patch
          number is assigned to it and the comment is added to the
          file. This patch number will be the one that follows the
          most recent changelog entry already in the file. This is
          obviously useful when maintaining version numbers
          individually for each file.

    `<directory_name>'
          Global version control will be performed coherently on
          several files. When saving a buffer (C-x C-s) emacs will
          ask if a changelog entry should be added to the file before
          saving. If a comment is given, the global patch number
          (which will be kept in the file:
          `<directory_name>/GlobalPatch') is atomically incremented
          and the changelog entry is added to the current file,
          associated to that patch number. Also, a small entry is
          added to a file `<directory_name>/GlobalChangeLog' which
          points to the current file. This allows inspecting all
          changes sequentially by visiting all the files where the
          changes were made (see C-c C-n). This is obviously useful
          when maintaining a single thread of version and patch
          numbers for a set of files.

    `off'
          Turns off version control: C-x C-s then simply saves the
          file as usual.

     *Some useful tips:*

        * If a changelog entry is in fact introduced, the cursor is
          left at the point in the file where the comment was
          inserted and the mark is left at the original file point.
          This allows inspecting (and possibly modifying) the
          changelog entry, and then returning to the original point
          in the file by simply typing C-x C-x.

        * The first changelog entry is entered by default at the end
          of the buffer. Later, the changelog entries can be moved
          anywhere else in the file. New changelog entries are always
          inserted just above the first changelog entry which appears
          in the file.

        * The comments in changelog entries can be edited at any time.

        * If a changelog entry is moved to another file, and version
          numbers are shared by several files through a directory,
          the corresponding file pointer in the
          `<directory_name>/GlobalChangeLog' file needs to be changed
          also, for the entry to be locatable later using C-c C-n.


<^C> <^S>
     Same as C-x C-s except that it forces prompting for inclusion of
     a changelog entry even if the buffer is unmodified.

<^C> <n>
     Force a move to a new major/minor version number (the user will
     be prompted for the new numbers). Only applicable if using
     directory-based version maintenance. Note that otherwise it
     suffices with introducing a changelog entry in the file and
     changing its version number by hand.

<^C> <^N>
     When a unique version numbering is being maintained across
     several files, this command allows inspecting all changes
     sequentially by visiting all the files in which the changes were
     made:

        * If in a source file, find the next changelog entry in the
          source file, open in another window the corresponding
          `GlobalChangeLog' file, and position the cursor at the
          corresponding entry. This allows browsing the previous and
          following changes made, which may perhaps reside in other
          files in the system.

        * If in a `GlobalChangeLog' file, look for the next entry in
          the file, and open in another window the source file in
          which the corresponding comment resides, positioning the
          corresponding comment at the top of the screen. This allows
          going through a section of the `GlobalChangeLog' file
          checking all the corresponding comments in the different
          files in which they occur.



File: ciao.info,  Node: Generating program documentation,  Next: Setting the top-level,  Prev: Version control,  Up: Functionality and associated key sequences (bindings)

Generating program documentation
--------------------------------

   These commands provide some bindings and facilities for generating
the documentation corresponding to the current buffer. This is
specially useful while modifying the documentation for a file, in
order to check the output that will be produced.
<^C> <D> <B>
     Generate the documentation for the current buffer in the default
     format. This allows generating a simple document for the current
     buffer. Basically, it creates a `SETTINGS' file, sets `MAIN' in
     `SETTINGS' to the current buffer and then generates the
     documentation in a temporary directory. Note that for generating
     complex manuals the best approach is to set up a permanent
     documentation directory with the appropriate `SETTINGS' and
     `Makefile' files (see the LPdoc manual).

<^C> <D> <F>
     Change the default output format used by the LPdoc
     auto-documenter. It is set by default to `dvi' or to the
     environment variable `LPDOCFORMAT' if it is defined.

<^C> <D> <S>
     Visit, or create, the `SETTINGS' file (which controls all
     auto-documenter options).

<^C> <D> <G>
     Generate the documentation according to `SETTINGS' in the
     default format. This allows generating complex documents but it
     assumes that `SETTINGS' exists and that its options (main file,
     component files, paths, etc.) have been set properly.
     Documentation is generated in a temporary directory. Note
     however that for generating complex manuals the best approach is
     to set up a permanent documentation directory with the
     appropriate `SETTINGS' and `Makefile' files (see the LPdoc
     manual).

<^C> <D> <V>
     Start a viewer on the documentation for the current buffer in
     the default format.

<^C> <D> <W>
     Change the root working dir used by the LPdoc auto-documenter.
     It is set by default to a new dir under `/tmp' or to the
     environment variable `LPDOCWDIR' if it is defined.


File: ciao.info,  Node: Setting the top-level,  Next: Traditional Prolog Mode Commands,  Prev: Generating program documentation,  Up: Functionality and associated key sequences (bindings)

Setting the top-level, preprocessor, and documenter executables
---------------------------------------------------------------

   These commands allow _changing the executables used_ when starting
a Prolog top-level, the preprocessor, or the auto-documenter. They
also allow changing the arguments that these executables take, and
changing the path where the libraries reside. In the case of the
top-level and preprocessor, this should be done only by users which
understand the implications, but it is very useful if several
versions of Ciao/Prolog or the preprocessor are available in the
system. All these arguments can be changed through the _customize_
options in the help menu (see *Note Customization::).
<^C> <S> <C>
     Change the Ciao/Prolog executable used to run the Prolog-like
     top level. It is set by default to `ciao' or, to the environment
     variable `CIAO' if it is defined.

<^C> <S> <^C>
     Change the arguments passed to the Ciao/Prolog executable. They
     are set by default to none or, to the environment variable
     `CIAOARGS' if it is defined.

<^C> <S> <P>
     Change the executable used to run the Ciao Preprocessor
     toplevel. It is set by default to `ciaopp' or, to the
     environment variable `CIAOPP' if it is defined.

<^C> <S> <^P>
     Change the arguments passed to the Ciao preprocessor executable.
     They are set by default to none or to the environment variable
     `CIAOPPARGS' if it is defined.

<^C> <S> <L>
     Change the location of the Ciao/Prolog library paths (changes
     the environment variable `CIAOLIB').

<^C> <S> <D>
     Change the executable used to run the LPdoc auto-documenter. It
     is set by default to `lpdoc' or to the environment variable
     `LPDOC' if it is defined.

<^C> <S> <^D>
     Change the arguments passed to the LPdoc auto-documenter. They
     are set by default to none or to the environment variable
     `LPDOCARGS' if it is defined.

<^C> <S> <^L>
     Change the path in which the LPdoc library is installed. It is
     set by default to `/home/clip/lib' or to the environment
     variable `LPDOCLIB' if it is defined.


File: ciao.info,  Node: Traditional Prolog Mode Commands,  Next: Other commands,  Prev: Setting the top-level,  Up: Functionality and associated key sequences (bindings)

Traditional Prolog Mode Commands
--------------------------------

   These commands provide some bindings and facilities for loading
programs, which are present in emacs Prolog modes of other Prolog
systems (e.g., SICStus). This is useful mainly if the Ciao/Prolog
emacs mode is used with such Prolog systems. Note that the behavior
of these commands in Ciao is slightly different from that of SICStus
and their use ( `compile/1' and `consult/1') in the Ciao top-level
are not recommended.
<^C> <K>
     Compile the entire buffer.

<^C> <k>
     Compile a given region.

<^C> <^K>
     Compile the predicate around point.

<^C> <C>
     Consult the entire buffer.

<^C> <c>
     Consult a given region.

<^C> <^C>
     Consult the predicate around point.


File: ciao.info,  Node: Other commands,  Next: Getting the Ciao/Prolog mode version,  Prev: Traditional Prolog Mode Commands,  Up: Functionality and associated key sequences (bindings)

Other commands
--------------

   Some other commands which are active in the Ciao/Prolog mode:
<^C> <^L>
     Recenter the most recently used Ciao/Prolog inferior process
     buffer (top-level or preprocessor).


File: ciao.info,  Node: Getting the Ciao/Prolog mode version,  Prev: Other commands,  Up: Functionality and associated key sequences (bindings)

Getting the Ciao/Prolog mode version
------------------------------------

<^C> <v>
     Report the version of the emacs Ciao/Prolog mode.


File: ciao.info,  Node: Commands available in toplevel and preprocessor buffers,  Next: Using Ciao/Prolog mode capabilities in standard shells,  Prev: Functionality and associated key sequences (bindings),  Up: Using Ciao inside GNU emacs

Commands available in toplevel and preprocessor buffers
=======================================================

   The interactive top level and the preprocessor both are typically
run in an iteractive buffer, in which it is possible to communicate
with them in the same way as is they had been started from a standard
shell. In addition, the commands and key bindings available in
buffers containing source code are also available in these
interactive buffers, when applicable.


File: ciao.info,  Node: Using Ciao/Prolog mode capabilities in standard shells,  Next: Coexistence with other Prolog interfaces,  Prev: Commands available in toplevel and preprocessor buffers,  Up: Using Ciao inside GNU emacs

Using Ciao/Prolog mode capabilities in standard shells
======================================================

   The capabilities (commands, coloring, ...) which are active in the
Ciao/Prolog "inferior" mode (the mode of the buffers in which the top
level and the preprocessor run) can also be made available in any
standard command line shell which is being run within emacs. This can
be enabled by going to the buffer in which the shell is running and
typing "<M-x> `ciao-inferior-mode'". This is very useful for example
when running the stand-alone compiler, the `lpdoc' auto-documenter,
or even certain user applications (those that use the standard error
message library) in an emacs sub-shell. Turning the Ciao/Prolog
inferior mode on on that sub-shell will highlight and color the error
messages, and automatically find and visit the locations in the files
in which the errors are reported.


File: ciao.info,  Node: Coexistence with other Prolog interfaces,  Next: Customization,  Prev: Using Ciao/Prolog mode capabilities in standard shells,  Up: Using Ciao inside GNU emacs

Coexistence with other Prolog interfaces
========================================

   As mentioned previously, the Ciao/Prolog `emacs' interface can
also be used to work with other Prolog or CLP systems. Also, the
Ciao/Prolog `emacs' interface (_mode_) can coexist with other
Prolog-related `emacs' interfaces (_modes_) (such as, e.g., the
`SICStus' Prolog interface). Only one of the interfaces can be active
at a time for a given buffer (i.e., for each given file opened inside
`emacs'). In order the change a buffer to a given interface, move the
cursor to that buffer and type `M-x ...-mode' (e.g., for the
Ciao/Prolog mode, `M-x ciao-mode').

   If several Prolog-related `emacs' interfaces are loaded, then
typically the _last_ one to be loaded takes precedence, in the sense
that this will be the interface in which `emacs' will be set when
opening files which have a `.pl' ending (this depends a bit on how
things are set up in your `.emacs' file).


File: ciao.info,  Node: Customization,  Next: Installation of the Ciao/Prolog emacs interface,  Prev: Coexistence with other Prolog interfaces,  Up: Using Ciao inside GNU emacs

Customization
=============

   This section explains all variables used in the Ciao/Prolog emacs
mode which can be customized by users. Such customization can be
performed (in later versions of `emacs') from the `emacs' menus
(`Help -> Customize -> Top-level Customization Group'), or also by
adding a `setq' expression in the `.emacs' file. Such `setq'
expression should be similar to:

   `(setq <variable> <new_value>)'

The following sections list the different variables which can be
customized for `ciao', `ciaopp' and `lpdoc'.

* Menu:

* Ciao variables::
* CiaoPP variables::
* LPdoc variables::


File: ciao.info,  Node: Ciao variables,  Next: CiaoPP variables,  Prev: Customization,  Up: Customization

Ciao variables
--------------

`ciao-debug-breakpoint-color' (_face_)
     Color to use with breakpoints in source debugger.

`ciao-debug-call-color' (_face_)
     Color to use with the call port in source debugger.

`ciao-debug-exit-color' (_face_)
     Color to use with the exit port in source debugger.

`ciao-debug-expansion' (_face_)
     Color to use in source debugger when the predicate was not found.

`ciao-debug-fail-color' (_face_)
     Color to use with the fail port in source debugger.

`ciao-debug-redo-color' (_face_)
     Color to use with the redo port in source debugger.

`ciao-indent-width' (_integer_)
     Indentation for a new goal.

`ciao-main-buffer' (_string_)
     Name of main module in a multiple module program. It is very
     useful when reloading from an inferior module because reload is
     performed from the main module, thus also reloading all
     dependent modules.

`ciao-query' (_string_)
     Query to use in Ciao. Setting this is useful when using a long
     or complicated query because it saves from having to type it
     over and over again. It is possible to set that this query will
     be issued any time a program is (re)loaded.

`ciao-system' (_string_)
     Name of Ciao or Prolog executable which runs the classical
     Prolog-like top level.

`ciao-system-args' (_string_)
     *Arguments passed to Ciao/Prolog toplevel executable.

`ciao-toplevel-buffer-name' (_string_)
     Basic name of the buffer running the Ciao/Prolog toplevel
     inferior process.


File: ciao.info,  Node: CiaoPP variables,  Next: LPdoc variables,  Prev: Ciao variables,  Up: Customization

CiaoPP variables
----------------

`ciao-ciaopp-buffer-name' (_string_)
     Basic name of the buffer running the Ciao preprocessor inferior
     process.

`ciao-ciaopp-system' (_string_)
     Name of Ciao preprocessor executable.

`ciao-ciaopp-system-args' (_string_)
     Arguments passed to Ciao preprocessor executable.


File: ciao.info,  Node: LPdoc variables,  Prev: CiaoPP variables,  Up: Customization

LPdoc variables
---------------

`ciao-lpdoc-buffer-name' (_string_)
     Basic name of the buffer running the auto-documenter inferior
     process.

`ciao-lpdoc-docformat' (_symbol_)
     Name of default output format used by LPdoc.

`ciao-lpdoc-libpath' (_directory_)
     Path in which the LPdoc library is installed.

`ciao-lpdoc-system' (_string_)
     Name of LPdoc auto-documenter executable.

`ciao-lpdoc-system-args' (_string_)
     Arguments passed to LPdoc executable.

`ciao-lpdoc-wdir-root' (_directory_)
     Name of root working dir used by LPdoc.


File: ciao.info,  Node: Installation of the Ciao/Prolog emacs interface,  Next: Emacs version compatibility,  Prev: Customization,  Up: Using Ciao inside GNU emacs

Installation of the Ciao/Prolog emacs interface
===============================================

   If opening a file ending with `.pl' puts emacs in another mode
(such as `perl' mode, which is the -arguably incorrect- default
setting in some `emacs' distributions), then you can set things so
that the Ciao/Prolog mode is loaded by default in your system. This
can be done by including in your `.emacs' file a line such as:

   `(load <CIAOLIBDIR>/DOTemacs)'

This loads the above mentioned file from the Ciao library, which
contains the following lines (except that the paths are changed
during installation to appropriate values for your system):

     ;; Ciao /  / Prolog mode
     ;; (can be used for SICStus, and coexist with SICStus Prolog prolog.el)
     ;;
     (setq load-path (cons "<CIAOLIBDIR>" load-path))
     (autoload 'run-ciao-toplevel "ciao"
               "Start a Ciao /  / Prolog top-level sub-process." t)
     (autoload 'run-ciao-preprocessor "ciao"
               "Start a Ciao /  / Prolog preprocessor sub-process." t)
     (autoload 'ciao-mode "ciao"
               "Major mode for edit/run Ciao, Prolog,  t)
     (autoload 'ciao-inferior-mode "ciao"
               "Major mode for running Ciao, Prolog, lpdoc, etc." t)
     (setq auto-mode-alist (cons '("\\.pl$" . ciao-mode) auto-mode-alist))
     (setq auto-mode-alist (cons '("\\.pls$" . ciao-mode) auto-mode-alist))
     (setq auto-mode-alist (cons '("\\.lpdoc$" . ciao-mode) auto-mode-alist))
     (setq completion-ignored-extensions
           (append '(".dep" ".itf" ".po" ".asr" ".cpx")
                   completion-ignored-extensions))
     ;; ------------------------------------------------------------------------
     ;; In Un*x, the following (or similar) lines should be included in your
     ;; .cshrc or .profile to find the manuals (the Ciao installation leaves
     ;; in the Ciao library directory 'DOTcshrc' and 'DOTprofile' files with
     ;; the right paths which can be included directly in your startup scripts):
     ;;
     ;; setenv INFOPATH /usr/local/info:/usr/info:<LPDOCDIR>
     ;; ------------------------------------------------------------------------

   If you would like to configure things in a different way, you can
also copy the contents of this file to your `.emacs' file and make
the appropriate changes. For example, if you do not want `.pl' files
to be put automatically in Ciao/Prolog mode, then comment out (or
remove) the line:

   `(setq auto-mode-alist' ... `)'

You will then need to switch manually to Ciao/Prolog mode by typing
`M-x ciao-mode' after opening a Prolog file.

   If you are able to open the Ciao/Prolog menu but the Ciao manuals
are not found or the `ciao' command (the top-level) is not found when
loading `.pl' files, the probable cause is that you do not have the
Ciao paths in the `INFOPATH' and `MANPATH' _environment variables_
(whether these variables are set automatically or not for users
depends on how the Ciao system was installed). Under Un*x, you can
add these paths easily by including the line:

   `source <CIAOLIBDIR>/DOTcshrc'

in your `.login' or `.cshrc' files if you are using `csh' (or `tcsh',
etc.), or, alternatively, the line:

   `. <CIAOLIBDIR>/DOTprofile'

in your `.login' or `.profile' files if you are using `sh' (or
`bash', etc.). See the Ciao installation instructions (*Note
Installing Ciao from the source distribution:: or *Note Installing
Ciao from a Win32 binary distribution::) for details.


File: ciao.info,  Node: Emacs version compatibility,  Next: Acknowledgments (ciao.el),  Prev: Installation of the Ciao/Prolog emacs interface,  Up: Using Ciao inside GNU emacs

Emacs version compatibility
===========================

   This mode is currently being developed within `GNU emacs' version
20.4. It should also work with all other 20.XX and later 19.XX
versions.


File: ciao.info,  Node: Acknowledgments (ciao.el),  Prev: Emacs version compatibility,  Up: Using Ciao inside GNU emacs

Acknowledgments (ciao.el)
=========================

   This code is derived from the 1993 version of the emacs interface
for &-Prolog by M. Hermenegildo, itself derived from the original
`prolog.el' by _Masanobu Umeda_ with changes by _Johan Andersson_,
_Peter Olin_, _Mats Carlsson_, and _Johan Bevemyr_ of _SICS_, Sweden.
Other changes also by Daniel Cabeza and Manuel C. Rodriguez. See the
changelog for details.


File: ciao.info,  Node: *** PART II - The Ciao basic language (engine),  Next: The module system,  Prev: Using Ciao inside GNU emacs,  Up: Top

PART II - The Ciao basic language (engine)
******************************************

   This part documents the _Ciao basic builtins_. These predefined
predicates and declarations are available in every program, unless the
`pure' package is used (by using a `:- module(_,_,[pure]).'
declaration or `:- use_package(pure).'). These predicates are
contained in the `engine' directory within the `lib' library.  The
rest of the library predicates, including the packages that provide
most of the ISO-Prolog builtins, are documented in subsequent parts.


File: ciao.info,  Node: The module system,  Next: Directives for using code in other files,  Prev: *** PART II - The Ciao basic language (engine),  Up: Top

The module system
*****************

   *Author(s):* Daniel Cabeza and the CLIP Group.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   Modularity is a basic notion in a modern computer language.
Modules allow dividing programs in several parts, which have its own
independent name spaces. The module system in Ciao [CH00a], as in
many other Prolog implementations, is procedure based. This means
that predicate names are local to a module, but functor/atom names in
data are shared.

   The predicates visible in a module are the predicates defined in
that module, plus the predicates imported from other modules. Only
predicates exported by a module can be imported from other modules.
The default module of a given predicate name is the local one if the
predicate is defined locally, else the last module from which the
predicate is imported, having explicit imports priority (that is, a
predicate imported by an `use_module/2' declaration is always
preferred above a predicate imported by an `use_module/1'
declaration). To refer to a predicate from a module which is not the
default for that predicate the name has to be module qualified. A
module qualified predicate name has the form `Module':`Predicate' as
in the call `debugger:debug_module(M)'. Note that this does not allow
having access to predicates not imported, nor defining clauses of
other modules.

   All predicates defined in files with no module declaration belong
to a special module called `user', and all are implicitly exported.
This allows dividing programs in several files without being aware of
the module system at all. Note that this feature is only supported
for compatibility reasons, being its use discouraged. Many attractive
compilation features of Ciao cannot be performed in `user' modules.

   The case of multifile predicates (defined with the declaration
`multifile/1') is also special. Multifile predicates can be defined
by clauses distributed in several modules, and all modules which
define a predicate as multifile can use that predicate. The name
space of multifile predicates is independent, as if they belonged to
special module `multifile'.

   Every `user' or module file imports implicitly a number of modules
called builtin modules. They are imported before all other
importations of the module, allowing thus redefining any of their
predicates (with the exception of `true/0') by defining local
versions or importing them from other modules. Importing explicitly
from a builtin module, however, disables the implicit importation of
the rest (this feature is used by package `library(pure)' to define
pure prolog code).

* Menu:

* Usage and interface (modules)::
* Documentation on internals (modules)::


File: ciao.info,  Node: Usage and interface (modules),  Next: Documentation on internals (modules),  Prev: The module system,  Up: The module system

Usage and interface (`modules')
===============================

   * *Library usage:*

     Modules are an intrinsic feature of Ciao, so nothing special has
     to be done to use them.


File: ciao.info,  Node: Documentation on internals (modules),  Prev: Usage and interface (modules),  Up: The module system

Documentation on internals (`modules')
======================================

 - DECLARATION: module/3:
     *Usage:* :- `module(Name,Exports,Packages)'.
        - _Description:_ Declares a module of name `Name' which
          exports the predicates in `Exports', and uses the packages
          in `Packages'. `Name' must match with the name of the file
          where the module resides, without extension. For each
          source in `Packages', a package file is included, as if by
          an `include/1' declaration. If the source is specified with
          a path alias, this is the file included, if it is an atom,
          the library paths are searched. Package files provide
          functionalities by declaring imports from other modules,
          defining operators, new declarations, translations of code,
          etc.

          This directive must appear the first in the file.

          Also, if the compiler finds an unknown declaration as the
          first term in a file, the name of the declaration is
          regarded as a package library to be included, and the
          arguments of the declaration (if present) are interpreted
          like the arguments of `module/3'.

        - _The following properties hold at call time:_

          `Name' is a module name (an atom).
          (`modules:modulename/1')

          `Exports' is a list of `predname's.   (`basic_props:list/2')

          `Packages' is a list of `sourcename's.
          (`basic_props:list/2')



 - DECLARATION: module/2:
     *Usage:* :- `module(Name,Exports)'.
        - _Description:_ Same as directive `module/3', with an
          implicit package `iso', which enables to include ISO-Prolog
          compatible code (compatibility not 100% yet).

        - _The following properties hold at call time:_

          `Name' is a module name (an atom).
          (`modules:modulename/1')

          `Exports' is a list of `predname's.   (`basic_props:list/2')



 - DECLARATION: export/1:
     *Usage 1:* :- `export(Pred)'.
        - _Description:_ Adds `Pred' to the set of exported
          predicates.

        - _The following properties hold at call time:_

          `Pred' is a Name/Arity structure denoting a predicate name:
               predname(P/A) :-
                       atm(P),
                       int(A).

          (`basic_props:predname/1')

     *Usage 2:* :- `export(Exports)'.
        - _Description:_ Adds `Exports' to the set of exported
          predicates.

        - _The following properties hold at call time:_

          `Exports' is a list of `predname's.   (`basic_props:list/2')



 - DECLARATION: use_module/2:
     *Usage:* :- `use_module(Module,Imports)'.
        - _Description:_ Specifies that this code imports from the
          module defined in `Module' the predicates in `Imports'. The
          imported predicates must be exported by the other module.

        - _The following properties hold at call time:_

          `Module' is a source name.   (`streams_basic:sourcename/1')

          `Imports' is a list of `predname's.   (`basic_props:list/2')



 - DECLARATION: use_module/1:
     *Usage:* :- `use_module(Module)'.
        - _Description:_ Specifies that this code imports from the
          module defined in `Module' all the predicates exported by
          it. The previous version with the explicit import list is
          preferred to this as it minimizes the chances to have to
          recompile this code if the other module changes.

        - _The following properties hold at call time:_

          `Module' is a source name.   (`streams_basic:sourcename/1')



 - DECLARATION: import/2:
     *Usage:* :- `import(Module,Imports)'.
        - _Description:_ Declares that this code imports from the
          module with name `Module' the predicates in `Imports'.

          *Important note:* this declaration is intended to be used
          when the current module or the imported module is going to
          be dynamically loaded, and so the compiler does not include
          the code of the imported module in the current executable
          (if only because the compiler cannot know the location of
          the module file at the time of compilation). For the same
          reason the predicates imported are not checked to be
          exported by `Module'. Its use in other cases is strongly
          discouraged, as it disallows many compiler optimizations.

        - _The following properties hold at call time:_

          `Module' is a module name (an atom).
          (`modules:modulename/1')

          `Imports' is a list of `predname's.   (`basic_props:list/2')



 - DECLARATION: reexport/2:
     *Usage:* :- `reexport(Module,Preds)'.
        - _Description:_ Specifies that this code reexports from the
          module defined in `Module' the predicates in `Preds'. This
          implies that this module imports from the module defined in
          `Module' the predicates in `Preds', an also that this
          module exports the predicates in `Preds' .

        - _The following properties hold at call time:_

          `Module' is a source name.   (`streams_basic:sourcename/1')

          `Preds' is a list of `predname's.   (`basic_props:list/2')



 - DECLARATION: reexport/1:
     *Usage:* :- `reexport(Module)'.
        - _Description:_ Specifies that this code reexports from the
          module defined in `Module' all the predicates exported by
          it. This implies that this module imports from the module
          defined in `Module' all the predicates exported by it, an
          also that this module exports all such predicates .

        - _The following properties hold at call time:_

          `Module' is a source name.   (`streams_basic:sourcename/1')



 - DECLARATION: meta_predicate/1:
     *Usage:* :- `meta_predicate MetaSpecs'.
        - _Description:_ Specifies that the predicates in `MetaSpecs'
          have arguments which represent predicates and thus have to
          be module expanded. The directive is only mandatory for
          exported predicates (in modules). This directive is defined
          as a prefix operator in the compiler.

        - _The following properties hold at call time:_

          `MetaSpecs' is a sequence of `metaspec's.
          (`basic_props:sequence/2')



 - REGTYPE: modulename/1:
     A module name is an atom, not containing characters `:' or `$'.
     Also, `user' and `multifile' are reserved, as well as the module
     names of all builtin modules (because in an executable all
     modules must have distinct names).

     *Usage:* `modulename(M)'
        - _Description:_ `M' is a module name (an atom).



 - REGTYPE: metaspec/1:
     A meta-predicate specification for a predicate is the functor of
     that predicate applied to atoms which represent the kind of
     module expansion that should be done with the arguments.
     Possible contents are represented as:

    `goal'
          This argument will be a term denoting a goal (either a
          simple or complex one) which will be called. For
          commpatibility reasons it can be named as `:' as well.

    `clause'
          This argument will be a term denoting a clause.

    `fact'
          This argument should be instantiated to a term denoting a
          fact (head-only clause).

    `spec'
          This argument should be instantiated to a predicate name,
          as Functor/Arity.

    `pred(_N_)'
          This argument should be instantiated to a predicate
          construct to be called by means of a `call/_N_' predicate
          call (see `call/2').

    `addmodule'
          This is in fact is not a real meta-data specification. It
          specifies that in an argument added after this one will be
          passed the calling module, to allow handling more involved
          meta-data (e.g., lists of goals) by using conversion
          builtins.

    `?,+,-,_'
          These other values denote that this argument is not module
          expanded.

     *Usage:* `metaspec(M)'
        - _Description:_ `M' is a meta-predicate specification.




File: ciao.info,  Node: Directives for using code in other files,  Next: Control constructs/predicates,  Prev: The module system,  Up: Top

Directives for using code in other files
****************************************

   *Author(s):* Daniel Cabeza.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.3#107 (1999/11/18, 13:6:14 MET)

* Menu:

* Usage and interface (loading_code)::
* Documentation on internals (loading_code)::


File: ciao.info,  Node: Usage and interface (loading_code),  Next: Documentation on internals (loading_code),  Prev: Directives for using code in other files,  Up: Directives for using code in other files

Usage and interface (`loading_code')
====================================

   * *Library usage:*

     These directives are builtin in Ciao, so nothing special has to
     be done to use them.


File: ciao.info,  Node: Documentation on internals (loading_code),  Prev: Usage and interface (loading_code),  Up: Directives for using code in other files

Documentation on internals (`loading_code')
===========================================

 - DECLARATION: ensure_loaded/1:
     *Usage:* :- `ensure_loaded(File)'.  < * ISO * >
        - _Description:_ Specifies that the code present in `File'
          will be included in the executable being prepared, in the
          `user' module. The file `File' cannot have a module
          declaration. This directive is intended to be used by
          programs not divided in modules. Dividing programs into
          modules is however strongly encouraged, since most of the
          attractive features of Ciao (such as static debugging and
          global optimization) are only partially available for
          `user' modules.

        - _The following properties should hold at call time:_

          `File' is a source name.   (`streams_basic:sourcename/1')



 - DECLARATION: include/1:
     *Usage:* :- `include(File)'.  < * ISO * >
        - _Description:_ The contents of the file `File' are included
          in the current program text exactly as if they had been
          written in place of this directive.

        - _The following properties should hold at call time:_

          `File' is a source name.   (`streams_basic:sourcename/1')



 - DECLARATION: use_package/1:
     :- `use_package(Package)'.

     Specifies the use in this file of the packages defined in
     `Package'. See the description of the third argument of
     `module/3' for an explanation of package files.

     This directive must appear the first in the file, or just after a
     `module/3' declaration. A file with no module declaration, in
     the absence of this directive, uses an implicit package `iso',
     which enables to include ISO-Prolog compatible code
     (compatibility not 100% yet).

     *Usage 1:* :- `use_package(Package)'.
        - _The following properties should hold at call time:_

          `Package' is a source name.   (`streams_basic:sourcename/1')

     *Usage 2:* :- `use_package(Package)'.
        - _The following properties should hold at call time:_

          `Package' is a list of `sourcename's.
          (`basic_props:list/2')




File: ciao.info,  Node: Control constructs/predicates,  Next: Basic builtin directives,  Prev: Directives for using code in other files,  Up: Top

Control constructs/predicates
*****************************

   *Author(s):* Daniel Cabeza, Manuel Hermenegildo.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#66 (2000/3/16, 17:3:30 CET)

   This module contains the set of basic control predicates, except
the predicates dealing with exceptions, which are in *Note Exception
handling::.

* Menu:

* Usage and interface (basiccontrol)::
* Documentation on exports (basiccontrol)::
* Documentation on internals (basiccontrol)::


File: ciao.info,  Node: Usage and interface (basiccontrol),  Next: Documentation on exports (basiccontrol),  Prev: Control constructs/predicates,  Up: Control constructs/predicates

Usage and interface (`basiccontrol')
====================================

   * *Library usage:*

     These predicates/constructs are builtin in Ciao, so nothing
     special has to be done to use them. In fact, as they are
     hardwired in some parts of the system, most of them cannot be
     redefined.

   * *Exports:*
        - _Predicates:_

          `,/2', `;/2', `->/2', `!/0', `\+/1', `if/3', `true/0',
          `fail/0', `repeat/0', `call/1'.




File: ciao.info,  Node: Documentation on exports (basiccontrol),  Next: Documentation on internals (basiccontrol),  Prev: Usage and interface (basiccontrol),  Up: Control constructs/predicates

Documentation on exports (`basiccontrol')
=========================================

 - PREDICATE: ,/2:
     `P , Q'

     Conjunction (`P' _and_ `Q').

     *Usage 2:* < * ISO * >
        - _The following properties should hold at call time:_

          `P' is a term which represents a goal, i.e., an atom or a
          structure.   (`basic_props:callable/1')

          `Q' is a term which represents a goal, i.e., an atom or a
          structure.   (`basic_props:callable/1')



 - PREDICATE: ;/2:
     `P ; Q'

     Disjunction (`P' _or_ `Q').

     *Usage 2:* < * ISO * >
        - _The following properties should hold at call time:_

          `P' is a term which represents a goal, i.e., an atom or a
          structure.   (`basic_props:callable/1')

          `Q' is a term which represents a goal, i.e., an atom or a
          structure.   (`basic_props:callable/1')



 - PREDICATE: ->/2:
     `P -> Q'

     If `P' then `Q' else fail, using first solution of `P' only.
     Also, `('`P' `->' `Q' `;' `R'`)', if `P' then `Q' else `R',
     using first solution of `P' only. No cuts are allowed in `P'.

     *Usage 2:* < * ISO * >
        - _The following properties should hold at call time:_

          `P' is a term which represents a goal, i.e., an atom or a
          structure.   (`basic_props:callable/1')

          `Q' is a term which represents a goal, i.e., an atom or a
          structure.   (`basic_props:callable/1')



 - PREDICATE: !/0:
     *Usage 1:* < * ISO * >
        - _Description:_ Commit to any choices taken in the current
          predicate.

     *Usage 2:* < * ISO * >
        - _Description:_ Commit to any choices taken in the current
          predicate.



 - PREDICATE: \+/1:
     `\+ P'

     Goal `P' is not provable (negation by failure). Fails if `P' has
     a solution, and succeeds otherwise. No cuts are allowed in `P'.

     *Usage 2:* < * ISO * >
        - _The following properties should hold at call time:_

          `P' is a term which represents a goal, i.e., an atom or a
          structure.   (`basic_props:callable/1')



 - PREDICATE: if/3:
     `if(P,Q,R)'

     If `P' then `Q' else `R', exploring all solutions of `P'. No
     cuts are allowed in `P'.

     *Usage 2:*
        - _The following properties should hold at call time:_

          `P' is a term which represents a goal, i.e., an atom or a
          structure.   (`basic_props:callable/1')

          `Q' is a term which represents a goal, i.e., an atom or a
          structure.   (`basic_props:callable/1')

          `R' is a term which represents a goal, i.e., an atom or a
          structure.   (`basic_props:callable/1')



 - PREDICATE: true/0:
     *Usage 1:* < * ISO * >
        - _Description:_ Succeed (noop).

     *Usage 2:* < * ISO * >
        - _Description:_ Succeed (noop).



 - PREDICATE: fail/0:
     *Usage 1:* < * ISO * >
        - _Description:_ Fail, backtrack immediately.

     *Usage 2:* < * ISO * >
        - _Description:_ Fail, backtrack immediately.



 - PREDICATE: repeat/0:
     *Usage 1:* < * ISO * >
        - _Description:_ Generates an infinite sequence of
          backtracking choices.

     *Usage 2:* < * ISO * >
        - _Description:_ Generates an infinite sequence of
          backtracking choices.



 - PREDICATE: call/1:
     `call(G)'

     Executes goal `G', restricting the scope of the cuts to the
     execution of `G'. Equivalent to writing a variable `G' in a goal
     position.

     _Meta-predicate_ with arguments: `call(goal)'.

     *Usage 2:* < * ISO * >
        - _The following properties should hold at call time:_

          `G' is a term which represents a goal, i.e., an atom or a
          structure.   (`basic_props:callable/1')




File: ciao.info,  Node: Documentation on internals (basiccontrol),  Prev: Documentation on exports (basiccontrol),  Up: Control constructs/predicates

Documentation on internals (`basiccontrol')
===========================================

 - PREDICATE: |/2:
     An alias for disjunction (when appearing outside a list). The
     alias is performed when terms are read in.




 - PREDICATE: call/2:
     `call(Pred,Arg1)'

     There exists a set of builtin predicates of the form `call/N'
     with `N > 1' which execute predicate `Pred' given arguments
     `Arg1' ... `ArgX'. If `Pred' has already arguments `Arg1' is
     added to the start, the rest to the end. This predicate, when
     `Pred' is a variable, can be written using the special Ciao
     syntax `Pred(Arg1,...,ArgX)'.





File: ciao.info,  Node: Basic builtin directives,  Next: Basic data types and properties,  Prev: Control constructs/predicates,  Up: Top

Basic builtin directives
************************

   *Author(s):* Daniel Cabeza.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 0.9#11 (1999/3/18, 21:28:24 MET)

   This chapter documents the basic builtin directives in Ciao,
additional to the documented in other chapters. These directives are
natively interpreted by the Ciao compiler ( `ciaoc').

   Unlike in other Prolog systems, directives in Ciao are not goals
to be _executed_ by the compiler or top level. Instead, they are
_read_ and acted upon by these programs. The advantage of this is
that the effect of the directives is consistent for executables, code
loaded in the top level, code analyzed by the preprocessor, etc.

   As a result, by default only the builtin directives or
declarations defined in this manual can be used in user programs.
However, it is possible to define new declarations using the
`new_declaration/1' and `new_declaration/2' directives (or using
packages including them). Also, packages may define new directives
via code translations.

* Menu:

* Usage and interface (builtin_directives)::
* Documentation on internals (builtin_directives)::


File: ciao.info,  Node: Usage and interface (builtin_directives),  Next: Documentation on internals (builtin_directives),  Prev: Basic builtin directives,  Up: Basic builtin directives

Usage and interface (`builtin_directives')
==========================================

   * *Library usage:*

     These directives are builtin in Ciao, so nothing special has to
     be done to use them.


File: ciao.info,  Node: Documentation on internals (builtin_directives),  Prev: Usage and interface (builtin_directives),  Up: Basic builtin directives

Documentation on internals (`builtin_directives')
=================================================

 - DECLARATION: multifile/1:
     *Usage:* :- `multifile Predicates'.  < * ISO * >
        - _Description:_ Specifies that each predicate in
          `Predicates' may have clauses in more than one file. Each
          file that contains clauses for a multifile predicate must
          contain a directive multifile for the predicate. The
          directive should precede all clauses of the affected
          predicates. This directive is defined as a prefix operator
          in the compiler.

        - _The following properties should hold at call time:_

          `Predicates' is a sequence or list of `predname's.
          (`basic_props:sequence_or_list/2')



 - DECLARATION: discontiguous/1:
     *Usage:* :- `discontiguous Predicates'.  < * ISO * >
        - _Description:_ Specifies that each predicate in
          `Predicates' may be defined in this file by clauses which
          are not in consecutive order. Otherwise, a warning is
          signaled by the compiler when clauses of a predicate are
          not consecutive (this behavior is controllable by the
          prolog flag _discontiguous_warnings_). The directive should
          precede all clauses of the affected predicates. This
          directive is defined as a prefix operator in the compiler.

        - _The following properties should hold at call time:_

          `Predicates' is a sequence or list of `predname's.
          (`basic_props:sequence_or_list/2')



 - DECLARATION: impl_defined/1:
     *Usage:* :- `impl_defined(Predicates)'.
        - _Description:_ Specifies that each predicate in
          `Predicates' is _impl_icitly _defined_ in the current
          prolog source, either because it is a builtin predicate or
          because it is defined in a C file. Otherwise, a warning is
          signaled by the compiler when an exported predicate is not
          defined in the module or imported from other module.

        - _The following properties should hold at call time:_

          `Predicates' is a sequence or list of `predname's.
          (`basic_props:sequence_or_list/2')



 - DECLARATION: redefining/1:
     *Usage:* :- `redefining(Predicate)'.
        - _Description:_ Specifies that this module redefines
          predicate `Predicate', also imported from other module, or
          imports it from more than one module. This prevents the
          compiler giving warnings about redefinitions of that
          predicate. `Predicate' can be partially (or totally)
          uninstantiated, to allow disabling those warnings for
          several (or all) predicates at once.

        - _The following properties should hold at call time:_

          `Predicate' is _compatible_ with `predname'
          (`basic_props:compat/2')



 - DECLARATION: initialization/1:
     *Usage:* :- `initialization(Goal)'.  < * ISO * >
        - _Description:_ `Goal' will be executed at the start of the
          execution of any program containing the current code.

        - _The following properties should hold at call time:_

          `Goal' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')



 - DECLARATION: on_abort/1:
     *Usage:* :- `on_abort(Goal)'.
        - _Description:_ `Goal' will be executed after an abort of
          the execution of any program containing the current code.

        - _The following properties should hold at call time:_

          `Goal' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')




File: ciao.info,  Node: Basic data types and properties,  Next: Extra-logical properties for typing,  Prev: Basic builtin directives,  Up: Top

Basic data types and properties
*******************************

   *Author(s):* Daniel Cabeza, Manuel Hermenegildo.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.3#100 (1999/11/12, 17:14:25 MET)

   This library contains the set of basic properties used by the
builtin predicates, and which constitute the basic data types and
properties of the language. They can be used both as type testing
builtins within programs (by calling them explicitly) and as
properties in assertions.

* Menu:

* Usage and interface (basic_props)::
* Documentation on exports (basic_props)::


File: ciao.info,  Node: Usage and interface (basic_props),  Next: Documentation on exports (basic_props),  Prev: Basic data types and properties,  Up: Basic data types and properties

Usage and interface (`basic_props')
===================================

   * *Library usage:*

     These predicates are builtin in Ciao, so nothing special has to
     be done to use them.

   * *Exports:*
        - _Properties:_

          `member/2', `compat/2', `iso/1', `not_further_inst/2',
          `regtype/1'.

        - _Regular Types:_

          `term/1', `int/1', `nnegint/1', `flt/1', `num/1', `atm/1',
          `struct/1', `gnd/1', `constant/1', `callable/1',
          `operator_specifier/1', `list/1', `list/2', `sequence/2',
          `sequence_or_list/2', `character_code/1', `string/1',
          `predname/1', `atm_or_atm_list/1'.




File: ciao.info,  Node: Documentation on exports (basic_props),  Prev: Usage and interface (basic_props),  Up: Basic data types and properties

Documentation on exports (`basic_props')
========================================

 - REGTYPE: term/1:
     The most general type (includes all possible terms).

     *Usage 1:* `term(X)'
        - _Description:_ `X' is any term.

     *Usage 2:* `term(X)'
        - _Description:_ `X' is any term.



 - REGTYPE: int/1:
     The type of integers. The range of integers is `[-2^2147483616,
     2^2147483616)'. Thus for all practical purposes, the range of
     integers can be considered infinite.

     *Usage 1:* `int(T)'
        - _Description:_ `T' is an integer.

     *Usage 2:* `int(T)'
        - _Description:_ `T' is an integer.



 - REGTYPE: nnegint/1:
     The type of non-negative integers, i.e., natural numbers.

     *Usage 1:* `nnegint(T)'
        - _Description:_ `T' is a non-negative integer.

     *Usage 2:* `nnegint(T)'
        - _Description:_ `T' is a non-negative integer.



 - REGTYPE: flt/1:
     The type of floating-point numbers. The range of floats is the
     one provided by the C `double' type, typically `[4.9e-324,
     1.8e+308]' (plus or minus).

     *Usage 1:* `flt(T)'
        - _Description:_ `T' is a float.

     *Usage 2:* `flt(T)'
        - _Description:_ `T' is a float.



 - REGTYPE: num/1:
     The type of numbers, that is, integer or floating-point.

     *Usage 1:* `num(T)'
        - _Description:_ `T' is a number.

     *Usage 2:* `num(T)'
        - _Description:_ `T' is a number.



 - REGTYPE: atm/1:
     The type of atoms, or non-numeric constants. The size of atoms
     is unbound.

     *Usage 1:* `atm(T)'
        - _Description:_ `T' is an atom.

     *Usage 2:* `atm(T)'
        - _Description:_ `T' is an atom.



 - REGTYPE: struct/1:
     The type of compound terms, or terms with non-zeroary functors.
     By now there is a limit of 255 arguments.

     *Usage 1:* `struct(T)'
        - _Description:_ `T' is a compound term.

     *Usage 2:* `struct(T)'
        - _Description:_ `T' is a compound term.



 - REGTYPE: gnd/1:
     The type of all terms without variables.

     *Usage 1:* `gnd(T)'
        - _Description:_ `T' is ground.

     *Usage 2:* `gnd(T)'
        - _Description:_ `T' is ground.



 - REGTYPE: constant/1:
     *Usage 1:* `constant(T)'
        - _Description:_ `T' is an atomic term (an atom or a number).

     *Usage 2:* `constant(T)'
        - _Description:_ `T' is an atomic term (an atom or a number).



 - REGTYPE: callable/1:
     *Usage 1:* `callable(T)'
        - _Description:_ `T' is a term which represents a goal, i.e.,
          an atom or a structure.

     *Usage 2:* `callable(T)'
        - _Description:_ `T' is a term which represents a goal, i.e.,
          an atom or a structure.



 - REGTYPE: operator_specifier/1:
     The type and associativity of an operator is described by the
     following mnemonic atoms:

    `xfx'
          Infix, non-associative: it is a requirement that both of
          the two subexpressions which are the arguments of the
          operator must be of _lower_ precedence than the operator
          itself.

    `xfy'
          Infix, right-associative: only the first (left-hand)
          subexpression must be of lower precedence; the right-hand
          subexpression can be of the _same_ precedence as the main
          operator.

    `yfx'
          Infix, left-associative: same as above, but the other way
          around.

    `fx'
          Prefix, non-associative: the subexpression must be of
          _lower_ precedence than the operator.

    `fy'
          Prefix, associative: the subexpression can be of the _same_
          precedence as the operator.

    `xf'
          Postfix, non-associative: the subexpression must be of
          _lower_ precedence than the operator.

    `yf'
          Postfix, associative: the subexpression can be of the
          _same_ precedence as the operator.

     *Usage 1:* `operator_specifier(X)'
        - _Description:_ `X' specifies the type and associativity of
          an operator.

     *Usage 2:* `operator_specifier(X)'
        - _Description:_ `X' specifies the type and associativity of
          an operator.



 - REGTYPE: list/1:
     A list is formed with successive applications of the functor
     `'.'/2', and its end is the atom `[]'. Defined as
          list([]).
          list([_1|L]) :-
                  list(L).
          list([]).
          list([_1|L]) :-
                  list(L).

     *Usage 1:* `list(L)'
        - _Description:_ `L' is a list.

     *Usage 2:* `list(L)'
        - _Description:_ `L' is a list.



 - REGTYPE: list/2:
     `list(L,T)'

     `L' is a list, and for all its elements, `T' holds.

     _Meta-predicate_ with arguments: `list(?,pred(1))'.

     *Usage 1:* `list(L,T)'
        - _Description:_ `L' is a list of `T's.

     *Usage 2:* `list(L,T)'
        - _Description:_ `L' is a list of `T's.



 - PROPERTY: member/2:
     *Usage 1:* `member(X,L)'
        - _Description:_ `X' is an element of `L'.

     *Usage 2:* `member(X,L)'
        - _Description:_ `X' is an element of `L'.



 - REGTYPE: sequence/2:
     A sequence is formed with zero, one or more occurrences of the
     operator `','/2'. For example, `a, b, c' is a sequence of three
     atoms, `a' is a sequence of one atom.

     _Meta-predicate_ with arguments: `sequence(?,pred(1))'.

     *Usage 1:* `sequence(S,T)'
        - _Description:_ `S' is a sequence of `T's.

     *Usage 2:* `sequence(S,T)'
        - _Description:_ `S' is a sequence of `T's.



 - REGTYPE: sequence_or_list/2:
     _Meta-predicate_ with arguments: `sequence_or_list(?,pred(1))'.

     *Usage 1:* `sequence_or_list(S,T)'
        - _Description:_ `S' is a sequence or list of `T's.

     *Usage 2:* `sequence_or_list(S,T)'
        - _Description:_ `S' is a sequence or list of `T's.



 - REGTYPE: character_code/1:
     *Usage 1:* `character_code(T)'
        - _Description:_ `T' is an integer which is a character code.

        - _The following properties hold upon exit:_

          `T' is an integer.   (`basic_props:int/1')

     *Usage 2:* `character_code(T)'
        - _Description:_ `T' is an integer which is a character code.

        - _The following properties hold upon exit:_

          `T' is an integer.   (`basic_props:int/1')



 - REGTYPE: string/1:
     A string is a list of character codes. The usual syntax for
     strings `"string"' is allowed, which is equivalent to
     `[0's,0't,0'r,0'i,0'n,0'g]' or `[115,116,114,105,110,103]'.
     There is also a special Ciao syntax when the list is not
     complete: `"st"||R' is equivalent to `[0's,0't|R]'.

     *Usage 1:* `string(T)'
        - _Description:_ `T' is a string (a list of character codes).

        - _The following properties hold upon exit:_

          `T' is a list of `character_code's.   (`basic_props:list/2')

     *Usage 2:* `string(T)'
        - _Description:_ `T' is a string (a list of character codes).

        - _The following properties hold upon exit:_

          `T' is a list of `character_code's.   (`basic_props:list/2')



 - REGTYPE: predname/1:
     *Usage 1:* `predname(P)'
        - _Description:_ `P' is a Name/Arity structure denoting a
          predicate name:
               predname(P/A) :-
                       atm(P),
                       int(A).
               predname(P/A) :-
                       atm(P),
                       int(A).


     *Usage 2:* `predname(P)'
        - _Description:_ `P' is a Name/Arity structure denoting a
          predicate name:
               predname(P/A) :-
                       atm(P),
                       int(A).
               predname(P/A) :-
                       atm(P),
                       int(A).




 - REGTYPE: atm_or_atm_list/1:
     *Usage 1:* `atm_or_atm_list(T)'
        - _Description:_ `T' is an atom or a list of atoms.

     *Usage 2:* `atm_or_atm_list(T)'
        - _Description:_ `T' is an atom or a list of atoms.



 - PROPERTY: compat/2:
     This property captures the notion of type or property
     compatibility. The instantiation or constraint state of the term
     is compatible with the given property, in the sense that
     assuming that imposing that property on the term does not render
     the store inconsistent. For example, terms `X' (i.e., a free
     variable), `[Y|Z]', and `[Y,Z]' are all compatible with the
     regular type `list/1', whereas the terms `f(a)' and `[1|2]' are
     not.

     _Meta-predicate_ with arguments: `compat(?,pred(1))'.

     *Usage 1:* `compat(Term,Prop)'
        - _Description:_ `Term' is _compatible_ with `Prop'

     *Usage 2:* `compat(Term,Prop)'
        - _Description:_ `Term' is _compatible_ with `Prop'



 - PROPERTY: iso/1:
     *Usage 1:* `iso(G)'
        - _Description:_ _Complies with the ISO-Prolog standard._

     *Usage 2:* `iso(G)'
        - _Description:_ _Complies with the ISO-Prolog standard._



 - PROPERTY: not_further_inst/2:
     *Usage 1:* `not_further_inst(G,V)'
        - _Description:_ `V' is not further instantiated.

     *Usage 2:* `not_further_inst(G,V)'
        - _Description:_ `V' is not further instantiated.



 - PROPERTY: regtype/1:
     *Usage 1:* `regtype(G)'
        - _Description:_ Defines a regular type.

     *Usage 2:* `regtype(G)'
        - _Description:_ Defines a regular type.




File: ciao.info,  Node: Extra-logical properties for typing,  Next: Basic term manipulation,  Prev: Basic data types and properties,  Up: Top

Extra-logical properties for typing
***********************************

   *Author(s):* Daniel Cabeza, Manuel Hermenegildo.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 0.7#8 (1998/9/23, 19:21:44 MEST)

   This library contains traditional Prolog predicates for testing
types. They depend on the state of instantiation of their arguments,
thus being of extra-logical nature.

* Menu:

* Usage and interface (term_typing)::
* Documentation on exports (term_typing)::


File: ciao.info,  Node: Usage and interface (term_typing),  Next: Documentation on exports (term_typing),  Prev: Extra-logical properties for typing,  Up: Extra-logical properties for typing

Usage and interface (`term_typing')
===================================

   * *Library usage:*

     These predicates are builtin in Ciao, so nothing special has to
     be done to use them.

   * *Exports:*
        - _Properties:_

          `var/1', `nonvar/1', `atom/1', `integer/1', `float/1',
          `number/1', `atomic/1', `ground/1', `type/2'.




File: ciao.info,  Node: Documentation on exports (term_typing),  Prev: Usage and interface (term_typing),  Up: Extra-logical properties for typing

Documentation on exports (`term_typing')
========================================

 - PROPERTY: var/1:
     *Usage 1:* `var(X)'
        - _Description:_ `X' is a free variable.

        - _The following properties hold globally:_

          `X' is not further instantiated.
          (`basic_props:not_further_inst/2')

     *Usage 2:* `var(X)'
        - _Description:_ `X' is a free variable.

        - _The following properties hold globally:_

          `X' is not further instantiated.
          (`basic_props:not_further_inst/2')



 - PROPERTY: nonvar/1:
     *Usage 1:* `nonvar(X)'
        - _Description:_ `X' is currently a term which is not a free
          variable.

        - _The following properties hold globally:_

          `X' is not further instantiated.
          (`basic_props:not_further_inst/2')

     *Usage 2:* `nonvar(X)'
        - _Description:_ `X' is currently a term which is not a free
          variable.

        - _The following properties hold globally:_

          `X' is not further instantiated.
          (`basic_props:not_further_inst/2')



 - PROPERTY: atom/1:
     *Usage 1:* `atom(X)'
        - _Description:_ `X' is currently instantiated to an atom.

        - _The following properties hold globally:_

          `X' is not further instantiated.
          (`basic_props:not_further_inst/2')

     *Usage 2:* `atom(X)'
        - _Description:_ `X' is currently instantiated to an atom.

        - _The following properties hold globally:_

          `X' is not further instantiated.
          (`basic_props:not_further_inst/2')



 - PROPERTY: integer/1:
     *Usage 1:* `integer(X)'
        - _Description:_ `X' is currently instantiated to an integer.

        - _The following properties hold globally:_

          `X' is not further instantiated.
          (`basic_props:not_further_inst/2')

     *Usage 2:* `integer(X)'
        - _Description:_ `X' is currently instantiated to an integer.

        - _The following properties hold globally:_

          `X' is not further instantiated.
          (`basic_props:not_further_inst/2')



 - PROPERTY: float/1:
     *Usage 1:* `float(X)'
        - _Description:_ `X' is currently instantiated to a float.

        - _The following properties hold globally:_

          `X' is not further instantiated.
          (`basic_props:not_further_inst/2')

     *Usage 2:* `float(X)'
        - _Description:_ `X' is currently instantiated to a float.

        - _The following properties hold globally:_

          `X' is not further instantiated.
          (`basic_props:not_further_inst/2')



 - PROPERTY: number/1:
     *Usage 1:* `number(X)'
        - _Description:_ `X' is currently instantiated to a number.

        - _The following properties hold globally:_

          `X' is not further instantiated.
          (`basic_props:not_further_inst/2')

     *Usage 2:* `number(X)'
        - _Description:_ `X' is currently instantiated to a number.

        - _The following properties hold globally:_

          `X' is not further instantiated.
          (`basic_props:not_further_inst/2')



 - PROPERTY: atomic/1:
     *Usage 1:* `atomic(X)'
        - _Description:_ `X' is currently instantiated to an atom or
          a number.

        - _The following properties hold globally:_

          `X' is not further instantiated.
          (`basic_props:not_further_inst/2')

     *Usage 2:* `atomic(X)'
        - _Description:_ `X' is currently instantiated to an atom or
          a number.

        - _The following properties hold globally:_

          `X' is not further instantiated.
          (`basic_props:not_further_inst/2')



 - PROPERTY: ground/1:
     *Usage 1:* `ground(X)'
        - _Description:_ `X' is currently ground (it contains no
          variables).

        - _The following properties hold globally:_

          `X' is not further instantiated.
          (`basic_props:not_further_inst/2')

     *Usage 2:* `ground(X)'
        - _Description:_ `X' is currently ground (it contains no
          variables).

        - _The following properties hold globally:_

          `X' is not further instantiated.
          (`basic_props:not_further_inst/2')



 - PROPERTY: type/2:
     *Usage 1:* `type(X,Y)'
        - _Description:_ `X' is internally of type `Y' (`var',
          `attv', `float', `integer', `structure', `atom' or `list').

        - _The following properties hold upon exit:_

          `Y' is an atom.   (`basic_props:atm/1')

     *Usage 2:* `type(X,Y)'
        - _Description:_ `X' is internally of type `Y' (`var',
          `attv', `float', `integer', `structure', `atom' or `list').

        - _The following properties hold upon exit:_

          `Y' is an atom.   (`basic_props:atm/1')




File: ciao.info,  Node: Basic term manipulation,  Next: Comparing terms,  Prev: Extra-logical properties for typing,  Up: Top

Basic term manipulation
***********************

   *Author(s):* Daniel Cabeza, Manuel Hermenegildo.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

* Menu:

* Usage and interface (term_basic)::
* Documentation on exports (term_basic)::


File: ciao.info,  Node: Usage and interface (term_basic),  Next: Documentation on exports (term_basic),  Prev: Basic term manipulation,  Up: Basic term manipulation

Usage and interface (`term_basic')
==================================

   * *Library usage:*

     These predicates are builtin in Ciao, so nothing special has to
     be done to use them.

   * *Exports:*
        - _Predicates:_

          `arg/3', `functor/3', `=../2', `copy_term/2', `C/3'.

        - _Properties:_

          `=/2'.




File: ciao.info,  Node: Documentation on exports (term_basic),  Prev: Usage and interface (term_basic),  Up: Basic term manipulation

Documentation on exports (`term_basic')
=======================================

 - PROPERTY: =/2:
     *Usage 1:* `X = Y' < * ISO * >
        - _Description:_ `X' and `Y' unify.

     *Usage 2:* `X = Y' < * ISO * >
        - _Description:_ `X' and `Y' unify.



 - PREDICATE: arg/3:
     *Usage 1:* `arg(+ArgNo,+Term,?Arg)' < * ISO * >
        - _Description:_ Argument `ArgNo' of the term `Term' is `Arg'.

        - _The following properties should hold at call time:_

          `ArgNo' is currently instantiated to an integer.
          (`term_typing:integer/1')

     *Usage 2:* `arg(ArgNo,Term,Arg)' < * ISO * >
        - _Description:_ Argument `ArgNo' of the term `Term' is `Arg'.

        - _The following properties should hold at call time:_

          `ArgNo' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')

          `Term' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')

          `ArgNo' is currently instantiated to an integer.
          (`term_typing:integer/1')



 - PREDICATE: functor/3:
     *Usage 1:* `functor(?Term,?Name,?Arity)' < * ISO * >
        - _Description:_ The principal functor of the term `Term' has
          name `Name' and arity `Arity'.

     *Usage 2:* `functor(Term,Name,Arity)' < * ISO * >
        - _Description:_ The principal functor of the term `Term' has
          name `Name' and arity `Arity'.



 - PREDICATE: =../2:
     *Usage 1:* `?Term =.. ?List' < * ISO * >
        - _Description:_ The functor and arguments of the term `Term'
          comprise the list `List'.

     *Usage 2:* `Term =.. List' < * ISO * >
        - _Description:_ The functor and arguments of the term `Term'
          comprise the list `List'.



 - PREDICATE: copy_term/2:
     *Usage 1:* `copy_term(Term,Copy)' < * ISO * >
        - _Description:_ `Copy' is a renaming of `Term', such that
          brand new variables have been substituted for all variables
          in `Term'. If any of the variables of `Term' have
          attributes, the copied variables will have copies of the
          attributes as well. It behaves as if defined by:

               :- data 'copy of'/1.
               
               copy_term(X, Y) :-
                       asserta_fact('copy of'(X)),
                       retract_fact('copy of'(Y)).


     *Usage 2:* `copy_term(Term,Copy)' < * ISO * >
        - _Description:_ `Copy' is a renaming of `Term', such that
          brand new variables have been substituted for all variables
          in `Term'. If any of the variables of `Term' have
          attributes, the copied variables will have copies of the
          attributes as well. It behaves as if defined by:

               :- data 'copy of'/1.
               
               copy_term(X, Y) :-
                       asserta_fact('copy of'(X)),
                       retract_fact('copy of'(Y)).




 - PREDICATE: C/3:
     *Usage 1:* `C(?S1,?Terminal,?S2)'
        - _Description:_ `S1' is connected by the terminal `Terminal'
          to `S2'. Internally used in _DCG grammar rules_. Defined as
          if by the single clause: `'C'([X|S], X, S).'

     *Usage 2:* `C(S1,Terminal,S2)'
        - _Description:_ `S1' is connected by the terminal `Terminal'
          to `S2'. Internally used in _DCG grammar rules_. Defined as
          if by the single clause: `'C'([X|S], X, S).'




File: ciao.info,  Node: Comparing terms,  Next: Basic predicates handling names of constants,  Prev: Basic term manipulation,  Up: Top

Comparing terms
***************

   *Author(s):* Daniel Cabeza, Manuel Hermenegildo.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   These built-in predicates are extra-logical. They treat
uninstantiated variables as objects with values which may be
compared, and they never instantiate those variables. They should
_not_ be used when what you really want is arithmetic comparison or
unification.

   The predicates make reference to a _standard total ordering_ of
terms, which is as follows:

   * Variables, by age (roughly, oldest first - the order is _not_
     related to the names of variables).

   * Floats, in numeric order (e.g. -1.0 is put before 1.0).

   * Integers, in numeric order (e.g. -1 is put before 1).

   * Atoms, in alphabetical (i.e. character code) order.

   * Compound terms, ordered first by arity, then by the name of the
     principal functor, then by the arguments in left-to-right order.
     Recall that lists are equivalent to compound terms with
     principal functor `'.'/2'.


   For example, here is a list of terms in standard order:

     [ X, -1.0, -9, 1, bar, foo, [1], X = Y, foo(0,2), bar(1,1,1) ]

* Menu:

* Usage and interface (term_compare)::
* Documentation on exports (term_compare)::


File: ciao.info,  Node: Usage and interface (term_compare),  Next: Documentation on exports (term_compare),  Prev: Comparing terms,  Up: Comparing terms

Usage and interface (`term_compare')
====================================

   * *Library usage:*

     These predicates are builtin in Ciao, so nothing special has to
     be done to use them.

   * *Exports:*
        - _Predicates:_

          `compare/3'.

        - _Properties:_

          `==/2', `\==/2', `@</2', `@=</2', `@>/2', `@>=/2'.




File: ciao.info,  Node: Documentation on exports (term_compare),  Prev: Usage and interface (term_compare),  Up: Comparing terms

Documentation on exports (`term_compare')
=========================================

 - PROPERTY: ==/2:
     *Usage 1:* `Term1 == Term2'
        - _Description:_ The terms `Term1' and `Term2' are strictly
          identical.

        - _The following properties should hold globally:_

          `Term1' is not further instantiated.
          (`basic_props:not_further_inst/2')

          `Term2' is not further instantiated.
          (`basic_props:not_further_inst/2')

     *Usage 2:* `Term1 == Term2'
        - _Description:_ The terms `Term1' and `Term2' are strictly
          identical.

        - _The following properties should hold globally:_

          `Term1' is not further instantiated.
          (`basic_props:not_further_inst/2')

          `Term2' is not further instantiated.
          (`basic_props:not_further_inst/2')



 - PROPERTY: \==/2:
     *Usage 1:* `Term1 \== Term2'
        - _Description:_ The terms `Term1' and `Term2' are not
          strictly identical.

        - _The following properties should hold globally:_

          `Term1' is not further instantiated.
          (`basic_props:not_further_inst/2')

          `Term2' is not further instantiated.
          (`basic_props:not_further_inst/2')

     *Usage 2:* `Term1 \== Term2'
        - _Description:_ The terms `Term1' and `Term2' are not
          strictly identical.

        - _The following properties should hold globally:_

          `Term1' is not further instantiated.
          (`basic_props:not_further_inst/2')

          `Term2' is not further instantiated.
          (`basic_props:not_further_inst/2')



 - PROPERTY: @</2:
     *Usage 1:* `@<(Term1,Term2)'
        - _Description:_ The term `Term1' precedes the term `Term2'
          in the standard order.

        - _The following properties should hold globally:_

          `Term1' is not further instantiated.
          (`basic_props:not_further_inst/2')

          `Term2' is not further instantiated.
          (`basic_props:not_further_inst/2')

     *Usage 2:* `@<(Term1,Term2)'
        - _Description:_ The term `Term1' precedes the term `Term2'
          in the standard order.

        - _The following properties should hold globally:_

          `Term1' is not further instantiated.
          (`basic_props:not_further_inst/2')

          `Term2' is not further instantiated.
          (`basic_props:not_further_inst/2')



 - PROPERTY: @=</2:
     *Usage 1:* `@=<(Term1,Term2)'
        - _Description:_ The term `Term1' precedes or is identical to
          the term `Term2' in the standard order.

        - _The following properties should hold globally:_

          `Term1' is not further instantiated.
          (`basic_props:not_further_inst/2')

          `Term2' is not further instantiated.
          (`basic_props:not_further_inst/2')

     *Usage 2:* `@=<(Term1,Term2)'
        - _Description:_ The term `Term1' precedes or is identical to
          the term `Term2' in the standard order.

        - _The following properties should hold globally:_

          `Term1' is not further instantiated.
          (`basic_props:not_further_inst/2')

          `Term2' is not further instantiated.
          (`basic_props:not_further_inst/2')



 - PROPERTY: @>/2:
     *Usage 1:* `@>(Term1,Term2)'
        - _Description:_ The term `Term1' follows the term `Term2' in
          the standard order.

        - _The following properties should hold globally:_

          `Term1' is not further instantiated.
          (`basic_props:not_further_inst/2')

          `Term2' is not further instantiated.
          (`basic_props:not_further_inst/2')

     *Usage 2:* `@>(Term1,Term2)'
        - _Description:_ The term `Term1' follows the term `Term2' in
          the standard order.

        - _The following properties should hold globally:_

          `Term1' is not further instantiated.
          (`basic_props:not_further_inst/2')

          `Term2' is not further instantiated.
          (`basic_props:not_further_inst/2')



 - PROPERTY: @>=/2:
     *Usage 1:* `@>=(Term1,Term2)'
        - _Description:_ The term `Term1' follows or is identical to
          the term `Term2' in the standard order.

        - _The following properties should hold globally:_

          `Term1' is not further instantiated.
          (`basic_props:not_further_inst/2')

          `Term2' is not further instantiated.
          (`basic_props:not_further_inst/2')

     *Usage 2:* `@>=(Term1,Term2)'
        - _Description:_ The term `Term1' follows or is identical to
          the term `Term2' in the standard order.

        - _The following properties should hold globally:_

          `Term1' is not further instantiated.
          (`basic_props:not_further_inst/2')

          `Term2' is not further instantiated.
          (`basic_props:not_further_inst/2')



 - PREDICATE: compare/3:
     `compare(Op,Term1,Term2)'

     `Op' is the result of comparing the terms `Term1' and `Term2'.

     *Usage 1:* `compare(?atm,@term,@term)'
        - _The following properties should hold upon exit:_

          `?atm' is an element of `[=,>,<]'.
          (`basic_props:member/2')

          `@term' is any term.   (`basic_props:term/1')

          `@term' is any term.   (`basic_props:term/1')

     *Usage 2:*
        - _Call and exit should be _compatible_ with:_

          `Op' is an atom.   (`basic_props:atm/1')

        - _The following properties should hold at call time:_

          `Term1' is any term.   (`basic_props:term/1')

          `Term2' is any term.   (`basic_props:term/1')

        - _The following properties should hold upon exit:_

          `Op' is an atom.   (`basic_props:atm/1')

          `Term1' is any term.   (`basic_props:term/1')

          `Term2' is any term.   (`basic_props:term/1')

          `Op' is an element of `[=,>,<]'.   (`basic_props:member/2')

          `Term1' is any term.   (`basic_props:term/1')

          `Term2' is any term.   (`basic_props:term/1')

        - _The following properties should hold globally:_

          `Term1' is not further instantiated.
          (`basic_props:not_further_inst/2')

          `Term2' is not further instantiated.
          (`basic_props:not_further_inst/2')




File: ciao.info,  Node: Basic predicates handling names of constants,  Next: Arithmetic,  Prev: Comparing terms,  Up: Top

Basic predicates handling names of constants
********************************************

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   The Ciao system provides builtin predicates which allow dealing
with names of constants (atoms or numbers). As an atom name must be
of less than 512 characters, to handle sequences of more characters,
strings (character code lists) must be used.

* Menu:

* Usage and interface (atomic_basic)::
* Documentation on exports (atomic_basic)::


File: ciao.info,  Node: Usage and interface (atomic_basic),  Next: Documentation on exports (atomic_basic),  Prev: Basic predicates handling names of constants,  Up: Basic predicates handling names of constants

Usage and interface (`atomic_basic')
====================================

   * *Library usage:*

     These predicates are builtin in Ciao, so nothing special has to
     be done to use them.

   * *Exports:*
        - _Predicates:_

          `name/2', `atom_codes/2', `number_codes/2',
          `number_codes/3', `atom_length/2', `atom_concat/3',
          `sub_atom/4'.




File: ciao.info,  Node: Documentation on exports (atomic_basic),  Prev: Usage and interface (atomic_basic),  Up: Basic predicates handling names of constants

Documentation on exports (`atomic_basic')
=========================================

 - PREDICATE: name/2:
     `name(Const,String)'

     `String' is the list of the ASCII codes of the characters
     comprising the name of `Const'. Note that if `Const' is an atom
     whose name can be interpreted as a number (e.g. '96'), the
     predicate is not reversible, as that atom will not be
     constructed when `Const' is uninstantiated. Thus it is
     recommended that new programs use the ISO-compliant predicates
     `atom_codes/2' or `number_codes/2', as these predicates do not
     have this inconsistency.

     *Usage 2:* `name(-constant,+string)'
        - _Description:_ If `String' can be interpreted as a number,
          `Const' is unified with that number, otherwise with the
          atom whose name is `String'.

     *Usage 3:*
        - _Calls should, and exit will be compatible with:_

          `String' is a string (a list of character codes).
          (`basic_props:string/1')

        - _The following properties should hold at call time:_

          `Const' is an atomic term (an atom or a number).
          (`basic_props:constant/1')

        - _The following properties hold upon exit:_

          `String' is a string (a list of character codes).
          (`basic_props:string/1')

     *Usage 4:*
        - _Description:_ If `String' can be interpreted as a number,
          `Const' is unified with that number, otherwise with the
          atom whose name is `String'.

        - _The following properties should hold at call time:_

          `Const' is a free variable.   (`term_typing:var/1')

          `String' is a string (a list of character codes).
          (`basic_props:string/1')

        - _The following properties hold upon exit:_

          `Const' is an atomic term (an atom or a number).
          (`basic_props:constant/1')



 - PREDICATE: atom_codes/2:
     `atom_codes(Atom,String)'

     `String' is the list of the ASCII codes of the characters
     comprising the name of `Atom'.

     *Usage 3:* < * ISO * >
        - _Calls should, and exit will be compatible with:_

          `String' is a string (a list of character codes).
          (`basic_props:string/1')

        - _The following properties should hold at call time:_

          `Atom' is an atom.   (`basic_props:atm/1')

        - _The following properties hold upon exit:_

          `String' is a string (a list of character codes).
          (`basic_props:string/1')

     *Usage 4:* < * ISO * >
        - _The following properties should hold at call time:_

          `Atom' is a free variable.   (`term_typing:var/1')

          `String' is a string (a list of character codes).
          (`basic_props:string/1')

        - _The following properties hold upon exit:_

          `Atom' is an atom.   (`basic_props:atm/1')



 - PREDICATE: number_codes/2:
     `number_codes(Number,String)'

     `String' is the list of the ASCII codes of the characters
     comprising a representation of `Number'.

     *Usage 3:* < * ISO * >
        - _Calls should, and exit will be compatible with:_

          `String' is a string (a list of character codes).
          (`basic_props:string/1')

        - _The following properties should hold at call time:_

          `Number' is a number.   (`basic_props:num/1')

        - _The following properties hold upon exit:_

          `String' is a string (a list of character codes).
          (`basic_props:string/1')

     *Usage 4:* < * ISO * >
        - _The following properties should hold at call time:_

          `Number' is a free variable.   (`term_typing:var/1')

          `String' is a string (a list of character codes).
          (`basic_props:string/1')

        - _The following properties hold upon exit:_

          `Number' is a number.   (`basic_props:num/1')



 - PREDICATE: number_codes/3:
     `number_codes(Number,String,Base)'

     `String' is the list of the ASCII codes of the characters
     comprising a representation of `Number' in base `Base'.

     *Usage 3:*
        - _Calls should, and exit will be compatible with:_

          `String' is a string (a list of character codes).
          (`basic_props:string/1')

        - _The following properties should hold at call time:_

          `Number' is a number.   (`basic_props:num/1')

          `Base' is an integer.   (`basic_props:int/1')

        - _The following properties hold upon exit:_

          `String' is a string (a list of character codes).
          (`basic_props:string/1')

     *Usage 4:*
        - _The following properties should hold at call time:_

          `Number' is a free variable.   (`term_typing:var/1')

          `String' is a string (a list of character codes).
          (`basic_props:string/1')

          `Base' is an integer.   (`basic_props:int/1')

        - _The following properties hold upon exit:_

          `Number' is a number.   (`basic_props:num/1')



 - PREDICATE: atom_length/2:
     `atom_length(Atom,Length)'

     `Length' is the number of characters forming the name of `Atom'.

     *Usage 2:* < * ISO * >
        - _Calls should, and exit will be compatible with:_

          `Length' is an integer.   (`basic_props:int/1')

        - _The following properties should hold at call time:_

          `Atom' is an atom.   (`basic_props:atm/1')

        - _The following properties hold upon exit:_

          `Length' is an integer.   (`basic_props:int/1')



 - PREDICATE: atom_concat/3:
     `atom_concat(Atom_1,Atom_2,Atom_12)'

     `Atom_12' is the result of concatenating `Atom_1' followed by
     `Atom_2'.

     *Usage 1:* `atom_concat(+atom,+atom,?atom)' < * ISO * >
        - _Description:_ Concatenate two atoms.

     *Usage 2:* `atom_concat(-atom,-atom,+atom)' < * ISO * >
        - _Description:_ Non-deterministically split an atom.

     *Usage 3:* `atom_concat(-atom,+atom,+atom)' < * ISO * >
        - _Description:_ Take out of an atom a certain suffix (or
          fail if it cannot be done).

     *Usage 4:* `atom_concat(+atom,-atom,+atom)' < * ISO * >
        - _Description:_ Take out of an atom a certain prefix (or
          fail if it cannot be done).

     *Usage 5:* < * ISO * >
        - _Description:_ Concatenate two atoms.

        - _Calls should, and exit will be compatible with:_

          `Atom_12' is currently instantiated to an atom.
          (`term_typing:atom/1')

        - _The following properties should hold at call time:_

          `Atom_1' is currently instantiated to an atom.
          (`term_typing:atom/1')

          `Atom_2' is currently instantiated to an atom.
          (`term_typing:atom/1')

        - _The following properties hold upon exit:_

          `Atom_12' is currently instantiated to an atom.
          (`term_typing:atom/1')

     *Usage 6:* < * ISO * >
        - _Description:_ Non-deterministically split an atom.

        - _The following properties should hold at call time:_

          `Atom_1' is a free variable.   (`term_typing:var/1')

          `Atom_2' is a free variable.   (`term_typing:var/1')

          `Atom_12' is currently instantiated to an atom.
          (`term_typing:atom/1')

        - _The following properties hold upon exit:_

          `Atom_1' is currently instantiated to an atom.
          (`term_typing:atom/1')

          `Atom_2' is currently instantiated to an atom.
          (`term_typing:atom/1')

     *Usage 7:* < * ISO * >
        - _Description:_ Take out of an atom a certain suffix (or
          fail if it cannot be done).

        - _The following properties should hold at call time:_

          `Atom_1' is a free variable.   (`term_typing:var/1')

          `Atom_2' is currently instantiated to an atom.
          (`term_typing:atom/1')

          `Atom_12' is currently instantiated to an atom.
          (`term_typing:atom/1')

        - _The following properties hold upon exit:_

          `Atom_1' is currently instantiated to an atom.
          (`term_typing:atom/1')

     *Usage 8:* < * ISO * >
        - _Description:_ Take out of an atom a certain prefix (or
          fail if it cannot be done).

        - _The following properties should hold at call time:_

          `Atom_1' is currently instantiated to an atom.
          (`term_typing:atom/1')

          `Atom_2' is a free variable.   (`term_typing:var/1')

          `Atom_12' is currently instantiated to an atom.
          (`term_typing:atom/1')

        - _The following properties hold upon exit:_

          `Atom_2' is currently instantiated to an atom.
          (`term_typing:atom/1')



 - PREDICATE: sub_atom/4:
     `sub_atom(Atom,Before,Length,Sub_atom)'

     `Sub_atom' is formed with `Length' consecutive characters of
     `Atom' after the `Before' character. For example, the goal
     `sub_atom(summer,1,4,umme)' succeeds.

     *Usage 2:*
        - _Calls should, and exit will be compatible with:_

          `Sub_atom' is an atom.   (`basic_props:atm/1')

        - _The following properties should hold at call time:_

          `Atom' is an atom.   (`basic_props:atm/1')

          `Before' is currently instantiated to an integer.
          (`term_typing:integer/1')

          `Length' is currently instantiated to an integer.
          (`term_typing:integer/1')

        - _The following properties hold upon exit:_

          `Sub_atom' is an atom.   (`basic_props:atm/1')




File: ciao.info,  Node: Arithmetic,  Next: Basic file/stream handling,  Prev: Basic predicates handling names of constants,  Up: Top

Arithmetic
**********

   *Author(s):* Daniel Cabeza, Manuel Hermenegildo.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 0.9#18 (1999/3/23, 21:6:13 MET)

   Arithmetic is performed by built-in predicates which take as
arguments arithmetic expressions (see `arithexpression/1') and
evaluate them. Terms representing arithmetic expressions can be
created dynamically, but at the time of evaluation, each variable in
an arithmetic expression must be bound to a non-variable expression
(the term must be ground). For example, given the code in the first
line a possible shell interaction follows:
     evaluate(Expression, Answer) :- Answer is Expression.
     
     ?- _X=24*9, evaluate(_X+6, Ans).
     
     Ans = 222 ?
     
     yes

* Menu:

* Usage and interface (arithmetic)::
* Documentation on exports (arithmetic)::


File: ciao.info,  Node: Usage and interface (arithmetic),  Next: Documentation on exports (arithmetic),  Prev: Arithmetic,  Up: Arithmetic

Usage and interface (`arithmetic')
==================================

   * *Library usage:*

     These predicates are builtin in Ciao, so nothing special has to
     be done to use them.

   * *Exports:*
        - _Predicates:_

          `is/2', `</2', `=</2', `>/2', `>=/2', `=:=/2', `=\=/2'.

        - _Regular Types:_

          `arithexpression/1'.




File: ciao.info,  Node: Documentation on exports (arithmetic),  Prev: Usage and interface (arithmetic),  Up: Arithmetic

Documentation on exports (`arithmetic')
=======================================

 - PREDICATE: is/2:
     `Val is Exp'

     The arithmetic expression `Exp' is evaluated and the result is
     unified with `Val'

     *Usage 2:* < * ISO * >
        - _Calls should, and exit will be compatible with:_

          `Val' is any term.   (`basic_props:term/1')

        - _The following properties should hold at call time:_

          `Exp' is an arithmetic expression.
          (`arithmetic:arithexpression/1')

        - _The following properties hold upon exit:_

          `Val' is any term.   (`basic_props:term/1')



 - PREDICATE: </2:
     `Exp1 < Exp2'

     The numeric value of `Exp1' is less than the numeric value of
     `Exp2' when both are evaluated as arithmetic expressions.

     *Usage 2:* < * ISO * >
        - _The following properties should hold at call time:_

          `Exp1' is an arithmetic expression.
          (`arithmetic:arithexpression/1')

          `Exp2' is an arithmetic expression.
          (`arithmetic:arithexpression/1')



 - PREDICATE: =</2:
     `Exp1 =< Exp2'

     The numeric value of `Exp1' is less than or equal to the numeric
     value of `Exp2' when both are evaluated as arithmetic
     expressions.

     *Usage 2:* < * ISO * >
        - _The following properties should hold at call time:_

          `Exp1' is an arithmetic expression.
          (`arithmetic:arithexpression/1')

          `Exp2' is an arithmetic expression.
          (`arithmetic:arithexpression/1')



 - PREDICATE: >/2:
     `Exp1 > Exp2'

     The numeric value of `Exp1' is greater than the numeric value of
     `Exp2' when both are evaluated as arithmetic expressions.

     *Usage 2:* < * ISO * >
        - _The following properties should hold at call time:_

          `Exp1' is an arithmetic expression.
          (`arithmetic:arithexpression/1')

          `Exp2' is an arithmetic expression.
          (`arithmetic:arithexpression/1')



 - PREDICATE: >=/2:
     `Exp1 >= Exp2'

     The numeric value of `Exp1' is greater than or equal to the
     numeric value of `Exp2' when both are evaluated as arithmetic
     expressions.

     *Usage 2:* < * ISO * >
        - _The following properties should hold at call time:_

          `Exp1' is an arithmetic expression.
          (`arithmetic:arithexpression/1')

          `Exp2' is an arithmetic expression.
          (`arithmetic:arithexpression/1')



 - PREDICATE: =:=/2:
     `Exp1 =:= Exp2'

     The numeric values of `Exp1' and `Exp2' are equal when both are
     evaluated as arithmetic expressions.

     *Usage 2:* < * ISO * >
        - _The following properties should hold at call time:_

          `Exp1' is an arithmetic expression.
          (`arithmetic:arithexpression/1')

          `Exp2' is an arithmetic expression.
          (`arithmetic:arithexpression/1')



 - PREDICATE: =\=/2:
     `Exp1 =\= Exp2'

     The numeric values of `Exp1' and `Exp2' are not equal when both
     are evaluated as arithmetic expressions.

     *Usage 2:* < * ISO * >
        - _The following properties should hold at call time:_

          `Exp1' is an arithmetic expression.
          (`arithmetic:arithexpression/1')

          `Exp2' is an arithmetic expression.
          (`arithmetic:arithexpression/1')



 - REGTYPE: arithexpression/1:
     An arithmetic expression is a term built from numbers and
     evaluable functors that represent arithmetic functions. An
     arithmetic expression evaluates to a number, which may be an
     integer ( `int/1') or a float ( `flt/1'). The evaluable functors
     allowed in an arithmetic expression are listed below, together
     with an indication of the functions they represent. All
     evaluable functors defined in ISO-Prolog are implemented, as
     well as some other useful or traditional. Unless stated
     otherwise, an expression evaluates to a float if any of its
     arguments is a float, otherwise to an integer.

        * `- /1': sign reversal.  < * ISO * >

        * `+ /1': identity.

        * `-- /1': decrement by one.

        * `++ /1': increment by one.

        * `+ /2': addition.  < * ISO * >

        * `- /2': subtraction.  < * ISO * >

        * `* /2': multiplication.  < * ISO * >

        * `// /2': integer division. Float arguments are truncated to
          integers, result always integer.  < * ISO * >

        * `/ /2': division. Result always float.  < * ISO * >

        * `rem/2': integer remainder. The result is always an
          integer, its sign is the sign of the first argument.  < *
          ISO * >

        * `mod/2': modulo. The result is always a positive integer.
          < * ISO * >

        * `abs/1': absolute value.  < * ISO * >

        * `sign/1': sign of.  < * ISO * >

        * `float_integer_part/1': float integer part. Result always
          float.  < * ISO * >

        * `float_fractional_part/1': float fractional part. Result
          always float.  < * ISO * >

        * `truncate/1': The result is the integer equal to the
          integer part of the argument.  < * ISO * >

        * `integer/1': same as `truncate/1'.

        * `float/1': conversion to float.  < * ISO * >

        * `floor/1': largest integer not greater than.  < * ISO * >

        * `round/1': integer nearest to.  < * ISO * >

        * `ceiling/1': smallest integer not smaller than.  < * ISO * >

        * `** /2': exponentiation. Result always float.  < * ISO * >

        * `>> /2': integer bitwise right shift.  < * ISO * >

        * `<< /2': integer bitwise left shift.  < * ISO * >

        * `/\ /2': integer bitwise and.  < * ISO * >

        * `\/ /2': integer bitwise or.  < * ISO * >

        * `\ /1': integer bitwise complement.  < * ISO * >

        * `# /2': integer bitwise exclusive or (xor).

        * `exp/1': exponential (_e_ to the power of). Result always
          float.  < * ISO * >

        * `log/1': natural logarithm (base _e_). Result always float.
          < * ISO * >

        * `sqrt/1': square root. Result always float.  < * ISO * >

        * `sin/1': sine. Result always float.  < * ISO * >

        * `cos/1': cosine. Result always float.  < * ISO * >

        * `atan/1': arc tangent. Result always float.  < * ISO * >

        * `gcd/2': Greatest common divisor. Arguments must evaluate
          to integers, result always integer.


     In addition to these functors, a list of just a number evaluates
     to this number. Since a quoted string is just a list of
     integers, this allows a quoted character to be used in place of
     its ASCII code; e.g. `"A"' behaves within arithmetic expressions
     as the integer 65. Note that this is not ISO-compliant, and that
     can be achieved by using the ISO notation `0'A'.

     Arithmetic expressions, as described above, are just data
     structures. If you want one evaluated you must pass it as an
     argument to one of the arithmetic predicates defined in this
     library.

     *Usage 1:* `arithexpression(E)'
        - _Description:_ `E' is an arithmetic expression.

     *Usage 2:* `arithexpression(E)'
        - _Description:_ `E' is an arithmetic expression.




File: ciao.info,  Node: Basic file/stream handling,  Next: Basic input/output,  Prev: Arithmetic,  Up: Top

Basic file/stream handling
**************************

   *Author(s):* Daniel Cabeza, Mats Carlsson.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   This module provides basic predicates for handling files and
streams, in order to make input/output on them.

* Menu:

* Usage and interface (streams_basic)::
* Documentation on exports (streams_basic)::
* Documentation on multifiles (streams_basic)::


File: ciao.info,  Node: Usage and interface (streams_basic),  Next: Documentation on exports (streams_basic),  Prev: Basic file/stream handling,  Up: Basic file/stream handling

Usage and interface (`streams_basic')
=====================================

   * *Library usage:*

     These predicates are builtin in Ciao, so nothing special has to
     be done to use them.

   * *Exports:*
        - _Predicates:_

          `open/3', `close/1', `set_input/1', `current_input/1',
          `set_output/1', `current_output/1', `character_count/2',
          `line_count/2', `line_position/2', `flush_output/1',
          `flush_output/0', `clearerr/1', `current_stream/3',
          `stream_code/2', `absolute_file_name/2',
          `absolute_file_name/7'.

        - _Regular Types:_

          `sourcename/1', `stream/1', `io_mode/1'.

        - _Multifiles:_

          `file_search_path/2', `library_directory/1'.




File: ciao.info,  Node: Documentation on exports (streams_basic),  Next: Documentation on multifiles (streams_basic),  Prev: Usage and interface (streams_basic),  Up: Basic file/stream handling

Documentation on exports (`streams_basic')
==========================================

 - PREDICATE: open/3:
     `open(File,Mode,Stream)'

     Open `File' with mode `Mode' and return in `Stream' the stream
     associated with the file. No extension is implicit in `File'.

     *Usage 1:* `open(+sourcename,+io_mode,?stream)' < * ISO * >
        - _Description:_ Normal use.

     *Usage 2:* `open(+int,+io_mode,?stream)'
        - _Description:_ In the special case that `File' is an
          integer, it is assumed to be a file descriptor passed to
          Prolog from a foreign function call. The file descriptor is
          connected to a Prolog stream (invoking the UNIX function
          `fdopen') which is unified with `Stream'.

     *Usage 3:* < * ISO * >
        - _Description:_ Normal use.

        - _Calls should, and exit will be compatible with:_

          `Stream' is an open stream.   (`streams_basic:stream/1')

        - _The following properties should hold at call time:_

          `File' is a source name.   (`streams_basic:sourcename/1')

          `Mode' is an opening mode ('read', 'write' or 'append').
          (`streams_basic:io_mode/1')

        - _The following properties hold upon exit:_

          `Stream' is an open stream.   (`streams_basic:stream/1')

     *Usage 4:*
        - _Description:_ In the special case that `File' is an
          integer, it is assumed to be a file descriptor passed to
          Prolog from a foreign function call. The file descriptor is
          connected to a Prolog stream (invoking the UNIX function
          `fdopen') which is unified with `Stream'.

        - _Calls should, and exit will be compatible with:_

          `Stream' is an open stream.   (`streams_basic:stream/1')

        - _The following properties should hold at call time:_

          `File' is an integer.   (`basic_props:int/1')

          `Mode' is an opening mode ('read', 'write' or 'append').
          (`streams_basic:io_mode/1')

        - _The following properties hold upon exit:_

          `Stream' is an open stream.   (`streams_basic:stream/1')



 - PREDICATE: close/1:
     `close(Stream)'

     Close the stream `Stream'.

     *Usage 2:* < * ISO * >
        - _The following properties should hold at call time:_

          `Stream' is an open stream.   (`streams_basic:stream/1')



 - PREDICATE: set_input/1:
     `set_input(Stream)'

     Set the current input stream to `Stream'. A notion of _current
     input stream_ is maintained by the system, so that input
     predicates with no explicit stream operate on the current input
     stream. Initially it is set to `user_input'.

     *Usage 2:* < * ISO * >
        - _The following properties should hold at call time:_

          `Stream' is an open stream.   (`streams_basic:stream/1')



 - PREDICATE: current_input/1:
     `current_input(Stream)'

     Unify `Stream' with the current input stream.

     *Usage 2:* < * ISO * >
        - _Calls should, and exit will be compatible with:_

          `Stream' is an open stream.   (`streams_basic:stream/1')

        - _The following properties hold upon exit:_

          `Stream' is an open stream.   (`streams_basic:stream/1')



 - PREDICATE: set_output/1:
     `set_output(Stream)'

     Set the current output stream to `Stream'. A notion of _current
     output stream_ is maintained by the system, so that output
     predicates with no explicit stream operate on the current output
     stream. Initially it is set to `user_output'.

     *Usage 2:* < * ISO * >
        - _The following properties should hold at call time:_

          `Stream' is an open stream.   (`streams_basic:stream/1')



 - PREDICATE: current_output/1:
     `current_output(Stream)'

     Unify `Stream' with the current output stream.

     *Usage 2:* < * ISO * >
        - _Calls should, and exit will be compatible with:_

          `Stream' is an open stream.   (`streams_basic:stream/1')

        - _The following properties hold upon exit:_

          `Stream' is an open stream.   (`streams_basic:stream/1')



 - PREDICATE: character_count/2:
     `character_count(Stream,Count)'

     `Count' characters have been read from or written to `Stream'.

     *Usage 2:*
        - _Calls should, and exit will be compatible with:_

          `Count' is an integer.   (`basic_props:int/1')

        - _The following properties should hold at call time:_

          `Stream' is an open stream.   (`streams_basic:stream/1')

        - _The following properties hold upon exit:_

          `Count' is an integer.   (`basic_props:int/1')



 - PREDICATE: line_count/2:
     `line_count(Stream,Count)'

     `Count' lines have been read from or written to `Stream'.

     *Usage 2:*
        - _Calls should, and exit will be compatible with:_

          `Count' is an integer.   (`basic_props:int/1')

        - _The following properties should hold at call time:_

          `Stream' is an open stream.   (`streams_basic:stream/1')

        - _The following properties hold upon exit:_

          `Count' is an integer.   (`basic_props:int/1')



 - PREDICATE: line_position/2:
     `line_position(Stream,Count)'

     `Count' characters have been read from or written to the current
     line of `Stream'.

     *Usage 2:*
        - _Calls should, and exit will be compatible with:_

          `Count' is an integer.   (`basic_props:int/1')

        - _The following properties should hold at call time:_

          `Stream' is an open stream.   (`streams_basic:stream/1')

        - _The following properties hold upon exit:_

          `Count' is an integer.   (`basic_props:int/1')



 - PREDICATE: flush_output/1:
     `flush_output(Stream)'

     Flush any buffered data to output stream `Stream'.

     *Usage 2:* < * ISO * >
        - _The following properties should hold at call time:_

          `Stream' is an open stream.   (`streams_basic:stream/1')



 - PREDICATE: flush_output/0:
     `flush_output'

     Behaves like `current_output(S), flush_output(S)'




 - PREDICATE: clearerr/1:
     `clearerr(Stream)'

     Clear the end-of-file and error indicators for input stream
     `Stream'.

     *Usage 2:*
        - _The following properties should hold at call time:_

          `Stream' is an open stream.   (`streams_basic:stream/1')



 - PREDICATE: current_stream/3:
     `current_stream(Filename,Mode,Stream)'

     `Stream' is a stream which was opened in mode `Mode' and which
     is connected to the absolute file name `Filename' (an atom) or
     to the file descriptor `Filename' (an integer). This predicate
     can be used for enumerating all currently open streams through
     backtracking.

     *Usage 3:*
        - _Calls should, and exit will be compatible with:_

          `Filename' is an atom.   (`basic_props:atm/1')

          `Mode' is an opening mode ('read', 'write' or 'append').
          (`streams_basic:io_mode/1')

          `Stream' is an open stream.   (`streams_basic:stream/1')

        - _The following properties hold upon exit:_

          `Filename' is an atom.   (`basic_props:atm/1')

          `Mode' is an opening mode ('read', 'write' or 'append').
          (`streams_basic:io_mode/1')

          `Stream' is an open stream.   (`streams_basic:stream/1')

     *Usage 4:*
        - _Calls should, and exit will be compatible with:_

          `Filename' is an integer.   (`basic_props:int/1')

          `Mode' is an opening mode ('read', 'write' or 'append').
          (`streams_basic:io_mode/1')

          `Stream' is an open stream.   (`streams_basic:stream/1')

        - _The following properties hold upon exit:_

          `Filename' is an integer.   (`basic_props:int/1')

          `Mode' is an opening mode ('read', 'write' or 'append').
          (`streams_basic:io_mode/1')

          `Stream' is an open stream.   (`streams_basic:stream/1')



 - PREDICATE: stream_code/2:
     `stream_code(Stream,StreamCode)'

     `StreamCode' is the file descriptor (an integer) corresponding
     to the Prolog stream `Stream'.

     *Usage 3:*
        - _Calls should, and exit will be compatible with:_

          `StreamCode' is an integer.   (`basic_props:int/1')

        - _The following properties should hold at call time:_

          `Stream' is an open stream.   (`streams_basic:stream/1')

        - _The following properties hold upon exit:_

          `StreamCode' is an integer.   (`basic_props:int/1')

     *Usage 4:*
        - _The following properties should hold at call time:_

          `Stream' is a free variable.   (`term_typing:var/1')

          `StreamCode' is an integer.   (`basic_props:int/1')

        - _The following properties hold upon exit:_

          `Stream' is an open stream.   (`streams_basic:stream/1')



 - PREDICATE: absolute_file_name/2:
     `absolute_file_name(RelFileSpec,AbsFileSpec)'

     If `RelFileSpec' is an absolute pathname then do an absolute
     lookup. If `RelFileSpec' is a relative pathname then prefix the
     name with the name of the current directory and do an absolute
     lookup. If `RelFileSpec' is a path alias, perform the lookup
     following the path alias rules (see `sourcename/1'). In all
     cases: if a matching file with suffix `.pl' exists, then
     `AbsFileSpec' will be unified with this file. Failure to open a
     file normally causes an exception. The behaviour can be
     controlled by the `fileerrors' prolog flag.

     *Usage 1:* `absolute_file_name(+RelFileSpec,-AbsFileSpec)'
        - _Description:_ `AbsFileSpec' is the absolute name (with
          full path) of `RelFileSpec'.

        - _Calls should, and exit will be compatible with:_

          `+RelFileSpec' is a source name.
          (`streams_basic:sourcename/1')

          `-AbsFileSpec' is an atom.   (`basic_props:atm/1')

     *Usage 2:* `absolute_file_name(RelFileSpec,AbsFileSpec)'
        - _Description:_ `AbsFileSpec' is the absolute name (with
          full path) of `RelFileSpec'.

        - _Calls should, and exit will be compatible with:_

          `RelFileSpec' is a source name.
          (`streams_basic:sourcename/1')

          `AbsFileSpec' is an atom.   (`basic_props:atm/1')

        - _The following properties should hold at call time:_

          `RelFileSpec' is currently a term which is not a free
          variable.   (`term_typing:nonvar/1')

          `AbsFileSpec' is a free variable.   (`term_typing:var/1')



 - PREDICATE: absolute_file_name/7:
     `absolute_file_name(Spec,Opt,Suffix,CurrDir,AbsFile,AbsBase,AbsDir)'

     `AbsFile' is the absolute name (with full path) of `Spec', which
     has an optional first suffix `Opt' and an optional second suffix
     `Suffix', when the current directory is `CurrDir'. `AbsBase' is
     the same as `AbsFile', but without the second suffix, and
     `AbsDir' is the absolute path of the directory where `AbsFile'
     is. The Ciao compiler invokes this predicate with `Opt'=`'_opt''
     and `Suffix'=`'.pl'' when searching source files.

     *Usage 2:*
        - _The following properties should hold at call time:_

          `Spec' is a source name.   (`streams_basic:sourcename/1')

          `Opt' is an atom.   (`basic_props:atm/1')

          `Suffix' is an atom.   (`basic_props:atm/1')

          `CurrDir' is an atom.   (`basic_props:atm/1')

          `AbsFile' is a free variable.   (`term_typing:var/1')

          `AbsBase' is a free variable.   (`term_typing:var/1')

          `AbsDir' is a free variable.   (`term_typing:var/1')

        - _The following properties hold upon exit:_

          `AbsFile' is an atom.   (`basic_props:atm/1')

          `AbsBase' is an atom.   (`basic_props:atm/1')

          `AbsDir' is an atom.   (`basic_props:atm/1')



 - REGTYPE: sourcename/1:
     A source name is a flexible way of referring to a concrete file.
     A source name is either a relative or absolute filename given as:

        * an atom, or

        * a unary functor (which represents a _path alias_, see
          below) applied to a _relative_ path, the latter being given
          as an atom.


     In all cases certain filename extensions (e.g., `.pl') can be
     implicit. In the first form above, file names can be relative to
     the current directory. Also, file names beginning with `~' or
     `$' are treated specially. For example,

    `'~/ciao/sample.pl''
          is equivalent to `'/home/staff/herme/ciao/sample.pl'', if
          `/home/staff/herme' is the user's home directory. (This is
          also equivalent to `'$HOME/ciao/sample.pl'' as explained
          below.)

    `'~bardo/prolog/sample.pl''
          is equivalent to `'/home/bardo/prolog/sample.pl'', if
          `/home/bardo' is bardo's home directory.

    `'$UTIL/sample.pl''
          is equivalent to `'/usr/local/src/utilities/sample.pl'', if
          `/usr/local/src/utilities' is the value of the environment
          variable `UTIL'.

     The second form allows using path aliases. Such aliases allow
     refering to files not with absolute file system paths but with
     paths which are relative to predefined (or user-defined)
     abstract names. For example, given the path alias `myutils'
     which has been defined to refer to path
     `'/home/bardo/utilities'', if that directory contains the file
     `stuff.pl' then the term `myutils(stuff)' in a `use_module/1'
     declaration would refer to the file
     `'/home/bardo/utilities/stuff.pl'' (the `.pl' extension is
     implicit in the `use_module/1' declaration). As a special case,
     if that directory contains a subdirectory named `stuff' which in
     turn contains the file `stuff.pl', the same term would refer to
     the file `'/home/bardo/utilities/stuff/stuff.pl''. If a path
     alias is related to several paths, all paths are scanned in
     sequence until a match is found. For information on predefined
     path aliases or how to define new path aliases, see
     `file_search_path/2'.

     *Usage 1:* `sourcename(F)'
        - _Description:_ `F' is a source name.

     *Usage 2:* `sourcename(F)'
        - _Description:_ `F' is a source name.



 - REGTYPE: stream/1:
     Streams correspond to the file pointers used at the operating
     system level, and usually represent opened files. There are four
     special streams which correspond with the operating system
     standard streams:
    `user_input'
          The standard input stream, i.e. the terminal, usually.

    `user_output'
          The standard output stream, i.e. the terminal, usually.

    `user_error'
          The standard error stream.

    `user'
          The standard input or output stream, depending on context.

     *Usage 1:* `stream(S)'
        - _Description:_ `S' is an open stream.

     *Usage 2:* `stream(S)'
        - _Description:_ `S' is an open stream.



 - REGTYPE: io_mode/1:
     Can have the following values:
    `read'
          Open the file for input.

    `write'
          Open the file for output. The file is created if it does
          not already exist, the file will otherwise be truncated.

    `append'
          Open the file for output. The file is created if it does
          not already exist, the file will otherwise be appended to.

     *Usage 1:* `io_mode(M)'
        - _Description:_ `M' is an opening mode ('read', 'write' or
          'append').

     *Usage 2:* `io_mode(M)'
        - _Description:_ `M' is an opening mode ('read', 'write' or
          'append').




File: ciao.info,  Node: Documentation on multifiles (streams_basic),  Prev: Documentation on exports (streams_basic),  Up: Basic file/stream handling

Documentation on multifiles (`streams_basic')
=============================================

 - PREDICATE: file_search_path/2:
     `file_search_path(Alias,Path)'

     The path alias `Alias' is linked to path `Path'. Both arguments
     must be atoms. New facts (or clauses) of this predicate can be
     asserted to define new path aliases. Predefined path aliases in
     Ciao are:

    `library'
          Initially points to all Ciao library paths. See
          `library_directory/1'.

    `engine'
          The path of the Ciao engine builtins.

    `.'
          The current path (`'.'').

     The predicate is _multifile_.

     The predicate is of type _dynamic_.




 - PREDICATE: library_directory/1:
     `library_directory(Path)'

     `Path' is a library path (a path represented by the path alias
     `library'). Predefined library paths in Ciao are
     `'$CIAOLIB/lib'', `'$CIAOLIB/library'', and
     `'$CIAOLIB/contrib'', given that `$CIAOLIB' is the path of the
     root ciao library directory. More library paths can be defined
     by asserting new facts (or clauses) of this predicate.

     The predicate is _multifile_.

     The predicate is of type _dynamic_.





File: ciao.info,  Node: Basic input/output,  Next: Exception handling,  Prev: Basic file/stream handling,  Up: Top

Basic input/output
******************

   *Author(s):* Daniel Cabeza, Mats Carlsson.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   This module provides predicates for character input/output and for
canonical term output. From the ISO-Prolog predicates for character
input/output, only the `_code' versions are provided, the rest are
given by `library(iso_byte_char)', using these. Most predicates are
provided in two versions: one that specifies the input or output
stream as the first argument and a second which omits this argument
and uses the current input or output stream.

* Menu:

* Usage and interface (io_basic)::
* Documentation on exports (io_basic)::


File: ciao.info,  Node: Usage and interface (io_basic),  Next: Documentation on exports (io_basic),  Prev: Basic input/output,  Up: Basic input/output

Usage and interface (`io_basic')
================================

   * *Library usage:*

     These predicates are builtin in Ciao, so nothing special has to
     be done to use them.

   * *Exports:*
        - _Predicates:_

          `get_code/2', `get_code/1', `get1_code/2', `get1_code/1',
          `peek_code/2', `peek_code/1', `skip_code/2', `skip_code/1',
          `put_code/2', `put_code/1', `nl/1', `nl/0', `tab/2',
          `tab/1', `code_class/2', `getct/2', `getct1/2', `display/2',
          `display/1', `displayq/2', `displayq/1'.




File: ciao.info,  Node: Documentation on exports (io_basic),  Prev: Usage and interface (io_basic),  Up: Basic input/output

Documentation on exports (`io_basic')
=====================================

 - PREDICATE: get_code/2:
     `get_code(Stream,Code)'

     Reads from `Stream' the next character and unifies `Code' with
     its character code. At end of stream, unifies `Code' with the
     integer -1.

     *Usage 2:* < * ISO * >
        - _Calls should, and exit will be compatible with:_

          `Code' is an integer.   (`basic_props:int/1')

        - _The following properties should hold at call time:_

          `Stream' is an open stream.   (`streams_basic:stream/1')

        - _The following properties hold upon exit:_

          `Code' is an integer.   (`basic_props:int/1')



 - PREDICATE: get_code/1:
     `get_code(Code)'

     Behaves like `current_input(S), get_code(S,Code)'.

     *Usage 2:* < * ISO * >
        - _Calls should, and exit will be compatible with:_

          `Code' is an integer.   (`basic_props:int/1')

        - _The following properties hold upon exit:_

          `Code' is an integer.   (`basic_props:int/1')



 - PREDICATE: get1_code/2:
     `get1_code(Stream,Code)'

     Reads from `Stream' the next non-layout character (see
     `code_class/2') and unifies `Code' with its character code. At
     end of stream, unifies `Code' with the integer -1.

     *Usage 2:*
        - _Calls should, and exit will be compatible with:_

          `Code' is an integer.   (`basic_props:int/1')

        - _The following properties should hold at call time:_

          `Stream' is an open stream.   (`streams_basic:stream/1')

        - _The following properties hold upon exit:_

          `Code' is an integer.   (`basic_props:int/1')



 - PREDICATE: get1_code/1:
     `get1_code(Code)'

     Behaves like `current_input(S), get1_code(S,Code)'.

     *Usage 2:*
        - _Calls should, and exit will be compatible with:_

          `Code' is an integer.   (`basic_props:int/1')

        - _The following properties hold upon exit:_

          `Code' is an integer.   (`basic_props:int/1')



 - PREDICATE: peek_code/2:
     `peek_code(Stream,Code)'

     Unifies `Code' with the character code of the next character of
     `Stream', leaving the stream position unaltered. At end of
     stream, unifies `Code' with the integer -1.

     *Usage 2:* < * ISO * >
        - _Calls should, and exit will be compatible with:_

          `Code' is an integer.   (`basic_props:int/1')

        - _The following properties should hold at call time:_

          `Stream' is an open stream.   (`streams_basic:stream/1')

        - _The following properties hold upon exit:_

          `Code' is an integer.   (`basic_props:int/1')



 - PREDICATE: peek_code/1:
     `peek_code(Code)'

     Behaves like `current_input(S), peek_code(S,Code)'.

     *Usage 2:* < * ISO * >
        - _Calls should, and exit will be compatible with:_

          `Code' is an integer.   (`basic_props:int/1')

        - _The following properties hold upon exit:_

          `Code' is an integer.   (`basic_props:int/1')



 - PREDICATE: skip_code/2:
     `skip_code(Stream,Code)'

     Skips just past the next character code `Code' from `Stream'.

     *Usage 2:*
        - _The following properties should hold at call time:_

          `Stream' is an open stream.   (`streams_basic:stream/1')

          `Code' is an integer.   (`basic_props:int/1')



 - PREDICATE: skip_code/1:
     `skip_code(Code)'

     Behaves like `current_input(S), skip_code(S,Code)'.

     *Usage 2:*
        - _The following properties should hold at call time:_

          `Code' is an integer.   (`basic_props:int/1')



 - PREDICATE: put_code/2:
     `put_code(Stream,Code)'

     Outputs to `Stream' the character corresponding to character
     code `Code'.

     *Usage 2:* < * ISO * >
        - _The following properties should hold at call time:_

          `Stream' is an open stream.   (`streams_basic:stream/1')

          `Code' is an integer.   (`basic_props:int/1')



 - PREDICATE: put_code/1:
     `put_code(Code)'

     Behaves like `current_output(S), put_code(S,Code)'.

     *Usage 2:* < * ISO * >
        - _The following properties should hold at call time:_

          `Code' is an integer.   (`basic_props:int/1')



 - PREDICATE: nl/1:
     `nl(Stream)'

     Outputs a newline character to `Stream'. Equivalent to
     `put_code(Stream, 0'\n)'.

     *Usage 2:* < * ISO * >
        - _The following properties should hold at call time:_

          `Stream' is an open stream.   (`streams_basic:stream/1')



 - PREDICATE: nl/0:
     `nl'

     Behaves like `current_output(S), nl(S)'.




 - PREDICATE: tab/2:
     `tab(Stream,Num)'

     Outputs `Num' spaces to `Stream'.

     *Usage 2:*
        - _The following properties should hold at call time:_

          `Stream' is an open stream.   (`streams_basic:stream/1')

          `Num' is an integer.   (`basic_props:int/1')



 - PREDICATE: tab/1:
     `tab(Num)'

     Behaves like `current_output(S), tab(S,Num)'.

     *Usage 2:*
        - _The following properties should hold at call time:_

          `Num' is an integer.   (`basic_props:int/1')



 - PREDICATE: code_class/2:
     `code_class(Code,Class)'

     Unifies `Class' with an integer corresponding to the lexical
     class of the character whose code is `Code', with the following
     correspondence:
              0 - layout (includes space, newline, tab)
              1 - small letter
              2 - capital letter (including '_')
              3 - digit
              4 - graphic (includes #$&*+-./:<=>?@^\`~ )
              5 - punctuation (includes !;"'%(),[]{|} )
     Note that in ISO-Prolog the back quote ``' is a punctuation
     character, whereas in Ciao it is a graphic character. Thus, if
     compatibility with ISO-Prolog is desired, the programmer should
     not use this character in unquoted names.

     *Usage 2:*
        - _Calls should, and exit will be compatible with:_

          `Class' is an integer.   (`basic_props:int/1')

        - _The following properties should hold at call time:_

          `Code' is an integer.   (`basic_props:int/1')

        - _The following properties hold upon exit:_

          `Class' is an integer.   (`basic_props:int/1')



 - PREDICATE: getct/2:
     `getct(Code,Type)'

     Reads from the current input stream the next character, unifying
     `Code' with its character code, and `Type' with its lexical
     class. At end of stream, unifies both `Code' and `Type' with the
     integer -1. Equivalent to
             get(Code), (Code = -1 -> Type = -1 ; code_class(Code,Type))

     *Usage 2:*
        - _Calls should, and exit will be compatible with:_

          `Code' is an integer.   (`basic_props:int/1')

          `Type' is an integer.   (`basic_props:int/1')

        - _The following properties hold upon exit:_

          `Code' is an integer.   (`basic_props:int/1')

          `Type' is an integer.   (`basic_props:int/1')



 - PREDICATE: getct1/2:
     `getct1(Code,Type)'

     Reads from the current input stream the next non-layout
     character, unifying `Code' with its character code, and `Type'
     with its lexical class (which will be nonzero). At end of
     stream, unifies both `Code' and `Type' with the integer -1.
     Equivalent to
             get1(Code), (Code = -1 -> Type = -1 ; code_class(Code,Type))

     *Usage 2:*
        - _Calls should, and exit will be compatible with:_

          `Code' is an integer.   (`basic_props:int/1')

          `Type' is an integer.   (`basic_props:int/1')

        - _The following properties hold upon exit:_

          `Code' is an integer.   (`basic_props:int/1')

          `Type' is an integer.   (`basic_props:int/1')



 - PREDICATE: display/2:
     `display(Stream,Term)'

     Displays `Term' onto `Stream'. Lists are output using list
     notation, the other compound terms are output in functional
     notation. Similar to `write_term(Stream, Term,
     [ignore_ops(ops)])', except that curly bracketed notation is not
     used with `{}/1', and the `write_strings' flag is not honored.

     *Usage 2:*
        - _The following properties should hold at call time:_

          `Stream' is an open stream.   (`streams_basic:stream/1')

          `Term' is any term.   (`basic_props:term/1')

        - _The following properties hold upon exit:_

          `Term' is any term.   (`basic_props:term/1')

        - _The following properties hold globally:_

          `Term' is not further instantiated.
          (`basic_props:not_further_inst/2')



 - PREDICATE: display/1:
     `display(Term)'

     Behaves like `current_output(S), display(S,Term)'.

     *Usage 2:*
        - _The following properties should hold at call time:_

          `Term' is any term.   (`basic_props:term/1')

        - _The following properties hold upon exit:_

          `Term' is any term.   (`basic_props:term/1')

        - _The following properties hold globally:_

          `Term' is not further instantiated.
          (`basic_props:not_further_inst/2')



 - PREDICATE: displayq/2:
     `displayq(Stream,Term)'

     Similar to `display(Stream, Term)', but atoms and functors that
     can't be read back by `read_term/3' are quoted. Thus, similar to
     `write_term(Stream, Term, [quoted(true), ignore_ops(ops)])',
     with the same exceptions as `display/2'.

     *Usage 2:*
        - _The following properties should hold at call time:_

          `Stream' is an open stream.   (`streams_basic:stream/1')

          `Term' is any term.   (`basic_props:term/1')

        - _The following properties hold upon exit:_

          `Term' is any term.   (`basic_props:term/1')

        - _The following properties hold globally:_

          `Term' is not further instantiated.
          (`basic_props:not_further_inst/2')



 - PREDICATE: displayq/1:
     `displayq(Term)'

     Behaves like `current_output(S), displayq(S,Term)'.

     *Usage 2:*
        - _The following properties should hold at call time:_

          `Term' is any term.   (`basic_props:term/1')

        - _The following properties hold upon exit:_

          `Term' is any term.   (`basic_props:term/1')

        - _The following properties hold globally:_

          `Term' is not further instantiated.
          (`basic_props:not_further_inst/2')




File: ciao.info,  Node: Exception handling,  Next: Changing system behaviour and various flags,  Prev: Basic input/output,  Up: Top

Exception handling
******************

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   This module includes predicates related to exceptions, which alter
the normal flow of Prolog.

* Menu:

* Usage and interface (exceptions)::
* Documentation on exports (exceptions)::


File: ciao.info,  Node: Usage and interface (exceptions),  Next: Documentation on exports (exceptions),  Prev: Exception handling,  Up: Exception handling

Usage and interface (`exceptions')
==================================

   * *Library usage:*

     These predicates are builtin in Ciao, so nothing special has to
     be done to use them.

   * *Exports:*
        - _Predicates:_

          `catch/3', `intercept/3', `throw/1', `halt/0', `halt/1'.




File: ciao.info,  Node: Documentation on exports (exceptions),  Prev: Usage and interface (exceptions),  Up: Exception handling

Documentation on exports (`exceptions')
=======================================

 - PREDICATE: catch/3:
     `catch(Goal,Error,Handler)'

     Executes `Goal'. If an exception is raised during its execution,
     `Error' is unified with the exception, and if the unification
     succeeds, the entire execution derived from `Goal' is aborted,
     and `Handler' is executed. The execution resumes with the
     continuation of the catch/3 call. For example, given the code
          p(X) :- throw(error), display('---').
          p(X) :- display(X).
     the execution of "`catch(p(0), E, display(E)), display(.),
     fail.'" results in the output "`error.'".

     _Meta-predicate_ with arguments: `catch(goal,?,goal)'.

     *Usage 2:* < * ISO * >
        - _Calls should, and exit will be compatible with:_

          `Error' is any term.   (`basic_props:term/1')

        - _The following properties should hold at call time:_

          `Goal' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')

          `Handler' is a term which represents a goal, i.e., an atom
          or a structure.   (`basic_props:callable/1')

        - _The following properties hold upon exit:_

          `Error' is any term.   (`basic_props:term/1')



 - PREDICATE: intercept/3:
     `intercept(Goal,Error,Handler)'

     Executes `Goal'. If an exception is raised during its execution,
     `Error' is unified with the exception, and if the unification
     succeeds, `Handler' is executed and then the execution resumes
     after the predicate which produced the exception. Note the
     difference with builtin `catch/3', given the same code defined
     there, the execution of "`intercept(p(0), E, display(E)),
     display(.), fail.'" results in the output "`error---.0.'".

     _Meta-predicate_ with arguments: `intercept(goal,?,goal)'.

     *Usage 2:*
        - _Calls should, and exit will be compatible with:_

          `Error' is any term.   (`basic_props:term/1')

        - _The following properties should hold at call time:_

          `Goal' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')

          `Handler' is a term which represents a goal, i.e., an atom
          or a structure.   (`basic_props:callable/1')

        - _The following properties hold upon exit:_

          `Error' is any term.   (`basic_props:term/1')



 - PREDICATE: throw/1:
     `throw(Ball)'

     Raises an error, throwing the exception `Ball', to be caught by
     an ancestor `catch/3' or `intercept/3'. The closest matching
     ancestor is chosen. Exceptions are also thrown by other builtins
     in case of error.

     *Usage 1:* < * ISO * >
        - _Calls should, and exit will be compatible with:_

          `Ball' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')

     *Usage 2:* < * ISO * >
        - _Calls should, and exit will be compatible with:_

          `Ball' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')



 - PREDICATE: halt/0:
     `halt'

     Halt the system, exiting to the invoking shell.




 - PREDICATE: halt/1:
     `halt(Code)'

     Halt the system, exiting to the invoking shell, returning exit
     code `Code'.

     *Usage 2:* < * ISO * >
        - _The following properties should hold at call time:_

          `Code' is an integer.   (`basic_props:int/1')



 - PREDICATE: abort/0:
     `abort'

     Abort the current execution.





File: ciao.info,  Node: Changing system behaviour and various flags,  Next: Fast/concurrent update of facts,  Prev: Exception handling,  Up: Top

Changing system behaviour and various flags
*******************************************

   *Author(s):* Daniel Cabeza, Mats Carlsson.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   Flags define some parameters of the system and control the
behavior of system or library predicates. Each flag has a name and an
associated predefined value, and except some system flags which are
fixed in general their associated value is changeable. Predefined
flags in the system are:

`argv'
     Its value is a list of atoms representing the program arguments
     supplied when the current executable was invoked. This is the
     value to which is instantiated the argument of the `main/1'
     predicate at executable startup. Unchangeable.

`bounded'
     It is `false', to denote that the range of integers can be
     considered infinite (but see `int/1'). Unchangeable. < * ISO * >

`fileerrors'
     If `on', predicates handling files give errors (throw
     exceptions) when a file is inexistent or an operation is not
     allowed. If `off', fail in that conditions. Initially `on'.

`gc'
     Controls whether garbage collection is done. May be `on'
     (default) or `off'.

`gc_margin'
     An integer `Margin'. If less than `Margin' kilobytes are
     reclaimed in a garbage collection then the size of the garbage
     collected area should be increased. Also, no garbage collection
     is attempted unless the garbage collected area has at least
     `Margin' kilobytes. Initially 500.

`gc_trace'
     Governs garbage collection trace messages. An element off
     `[on,off,terse,verbose]'. Initially `off'.

`integer_rounding_function'
     It is `toward_zero', so that `-1 =:= -3//2' succeeds.
     Unchangeable. < * ISO * >

`max_arity'
     It is 255, so that no compound term (or predicate) can have more
     than this number of arguments. Unchangeable. < * ISO * >

`quiet'
     Controls which messages issued using `io_aux' are actually
     written. As the system uses that library to report its messages,
     this flag controls the _verbosity_ of the system. Possible
     states of the flag are:

    `on'
          No messages are reported.

    `error'
          Only error messages are reported.

    `warning'
          Only error and warning messages are reported.

    `off'
          All messages are reported, except debug messages. This is
          the default state.

    `debug'
          All messages, including debug messages, are reported. This
          is only intended for the system implementators.

`unknown'
     Controls action on calls to undefined predicates. The possible
     states of the flag are:

    `error'
          An error is thrown with the error term
          `existence_error(procedure, F/A)'.

    `fail'
          The call simply fails.

    `warning'
          A warning is written and the call fails.

     The state is initially `error'. < * ISO * >

* Menu:

* Usage and interface (prolog_flags)::
* Documentation on exports (prolog_flags)::
* Documentation on multifiles (prolog_flags)::


File: ciao.info,  Node: Usage and interface (prolog_flags),  Next: Documentation on exports (prolog_flags),  Prev: Changing system behaviour and various flags,  Up: Changing system behaviour and various flags

Usage and interface (`prolog_flags')
====================================

   * *Library usage:*

     These predicates are builtin in Ciao, so nothing special has to
     be done to use them.

   * *Exports:*
        - _Predicates:_

          `set_prolog_flag/2', `current_prolog_flag/2',
          `prolog_flag/3', `push_prolog_flag/2', `pop_prolog_flag/1',
          `prompt/2', `gc/0', `nogc/0', `fileerrors/0',
          `nofileerrors/0'.

        - _Multifiles:_

          `define_flag/3'.




File: ciao.info,  Node: Documentation on exports (prolog_flags),  Next: Documentation on multifiles (prolog_flags),  Prev: Usage and interface (prolog_flags),  Up: Changing system behaviour and various flags

Documentation on exports (`prolog_flags')
=========================================

 - PREDICATE: set_prolog_flag/2:
     `set_prolog_flag(FlagName,Value)'

     Set existing flag `FlagName' to `Value'.

     *Usage 2:* < * ISO * >
        - _The following properties should hold at call time:_

          `FlagName' is an atom.   (`basic_props:atm/1')

          `Value' is any term.   (`basic_props:term/1')



 - PREDICATE: current_prolog_flag/2:
     `current_prolog_flag(FlagName,Value)'

     `FlagName' is an existing flag and `Value' is the value
     currently associated with it.

     *Usage 2:* < * ISO * >
        - _Calls should, and exit will be compatible with:_

          `FlagName' is an atom.   (`basic_props:atm/1')

          `Value' is any term.   (`basic_props:term/1')

        - _The following properties hold upon exit:_

          `FlagName' is an atom.   (`basic_props:atm/1')

          `Value' is any term.   (`basic_props:term/1')



 - PREDICATE: prolog_flag/3:
     `prolog_flag(FlagName,OldValue,NewValue)'

     `FlagName' is an existing flag, unify `OldValue' with the value
     associated with it, and set it to new value `NewValue'.

     *Usage 2:* `prolog_flag(?FlagName,-OldValue,-NewValue)'
        - _Description:_ Same as `current_prolog_flag(`FlagName',
          `OldValue')'

        - _The following properties should hold at call time:_

          `FlagName' is an atom.   (`basic_props:atm/1')

          The terms `OldValue' and `NewValue' are strictly identical.
          (`term_compare:== /2')

     *Usage 3:*
        - _Calls should, and exit will be compatible with:_

          `FlagName' is an atom.   (`basic_props:atm/1')

          `OldValue' is any term.   (`basic_props:term/1')

        - _The following properties should hold at call time:_

          `NewValue' is any term.   (`basic_props:term/1')

        - _The following properties hold upon exit:_

          `FlagName' is an atom.   (`basic_props:atm/1')

          `OldValue' is any term.   (`basic_props:term/1')

     *Usage 4:* `prolog_flag(FlagName,OldValue,NewValue)'
        - _Description:_ Same as `current_prolog_flag(`FlagName',
          `OldValue')'

        - _The following properties should hold at call time:_

          `OldValue' is a free variable.   (`term_typing:var/1')

          `NewValue' is a free variable.   (`term_typing:var/1')

          `FlagName' is an atom.   (`basic_props:atm/1')

          The terms `OldValue' and `NewValue' are strictly identical.
          (`term_compare:== /2')



 - PREDICATE: push_prolog_flag/2:
     `push_prolog_flag(Flag,NewValue)'

     Same as `set_prolog_flag/2', but storing current value of `Flag'
     to restore it with `pop_prolog_flag/1'.

     *Usage 2:*
        - _The following properties should hold at call time:_

          `Flag' is an atom.   (`basic_props:atm/1')

          `NewValue' is any term.   (`basic_props:term/1')



 - PREDICATE: pop_prolog_flag/1:
     `pop_prolog_flag(Flag)'

     Restore the value of `Flag' previous to the last non-canceled
     `push_prolog_flag/2' on it.

     *Usage 2:*
        - _The following properties should hold at call time:_

          `Flag' is an atom.   (`basic_props:atm/1')



 - PREDICATE: prompt/2:
     `prompt(Old,New)'

     Unify `Old' with the current prompt for reading, change it to
     `New'.

     *Usage 2:* `prompt(Old,New)'
        - _Description:_ Unify `Old' with the current prompt for
          reading without changing it.

        - _The following properties should hold at call time:_

          `Old' is a free variable.   (`term_typing:var/1')

          `New' is a free variable.   (`term_typing:var/1')

          The terms `Old' and `New' are strictly identical.
          (`term_compare:== /2')

        - _The following properties hold upon exit:_

          `Old' is an atom.   (`basic_props:atm/1')

          `New' is an atom.   (`basic_props:atm/1')

     *Usage 3:*
        - _Calls should, and exit will be compatible with:_

          `Old' is an atom.   (`basic_props:atm/1')

        - _The following properties should hold at call time:_

          `New' is an atom.   (`basic_props:atm/1')

        - _The following properties hold upon exit:_

          `Old' is an atom.   (`basic_props:atm/1')

     *Usage 4:* `prompt(Old,New)'
        - _Description:_ Unify `Old' with the current prompt for
          reading without changing it.

        - _The following properties should hold at call time:_

          `Old' is a free variable.   (`term_typing:var/1')

          `New' is a free variable.   (`term_typing:var/1')

          The terms `Old' and `New' are strictly identical.
          (`term_compare:== /2')

        - _The following properties hold upon exit:_

          `Old' is an atom.   (`basic_props:atm/1')

          `New' is an atom.   (`basic_props:atm/1')



 - PREDICATE: gc/0:
     *Usage 1:*
        - _Description:_ Enable garbage collection. Equivalent to
          `set_prolog_flag(gc, on)'

     *Usage 2:*
        - _Description:_ Enable garbage collection. Equivalent to
          `set_prolog_flag(gc, on)'



 - PREDICATE: nogc/0:
     *Usage 1:*
        - _Description:_ Disable garbage collection. Equivalent to
          `set_prolog_flag(gc, off)'

     *Usage 2:*
        - _Description:_ Disable garbage collection. Equivalent to
          `set_prolog_flag(gc, off)'



 - PREDICATE: fileerrors/0:
     *Usage 1:*
        - _Description:_ Enable reporting of file errors. Equivalent
          to `set_prolog_flag(fileerrors, on)'

     *Usage 2:*
        - _Description:_ Enable reporting of file errors. Equivalent
          to `set_prolog_flag(fileerrors, on)'



 - PREDICATE: nofileerrors/0:
     *Usage 1:*
        - _Description:_ Disable reporting of file errors. Equivalent
          to `set_prolog_flag(fileerrors, off)'

     *Usage 2:*
        - _Description:_ Disable reporting of file errors. Equivalent
          to `set_prolog_flag(fileerrors, off)'




File: ciao.info,  Node: Documentation on multifiles (prolog_flags),  Prev: Documentation on exports (prolog_flags),  Up: Changing system behaviour and various flags

Documentation on multifiles (`prolog_flags')
============================================

 - PREDICATE: define_flag/3:
     `define_flag(Flag,Values,Default)'

     New flags can be defined by writing facts of this predicate.
     `Flag' is the name of the new flag, `Values' defines the posible
     values for the flag (see below) and `Default' defines the
     predefined value associated with the flag (which should be
     compatible with `Values').

     The predicate is _multifile_.

     *Usage 1:* `define_flag(-atm,Values,-atm)'
        - _Description:_ Posible values for the flag are atoms.

          Example:
               :- multifile define_flag/3.
               define_flag(tmpdir, atom, '/tmp').

        - _Call and exit should be _compatible_ with:_

          The terms `Values' and `atom' are strictly identical.
          (`term_compare:== /2')

     *Usage 2:* `define_flag(-atm,Values,-int)'
        - _Description:_ Posible values for the flag are integers.

          Example:
               :- multifile define_flag/3.
               define_flag(max_connections, integer, 10).

        - _Call and exit should be _compatible_ with:_

          The terms `Values' and `integer' are strictly identical.
          (`term_compare:== /2')

     *Usage 3:* `define_flag(Flag,Values,Default)'
        - _Description:_ Posible values for the flag are the elements
          of `Values'.

          Example:
               :- multifile define_flag/3.
               define_flag(debug, [on,debug,trace,off], off).

        - _Call and exit should be _compatible_ with:_

          `Flag' is an atom.   (`basic_props:atm/1')

          `Values' is a list.   (`basic_props:list/1')

        - _The following properties should hold upon exit:_

          `Default' is an element of `Values'.
          (`basic_props:member/2')




File: ciao.info,  Node: Fast/concurrent update of facts,  Next: Extending the syntax,  Prev: Changing system behaviour and various flags,  Up: Top

Fast/concurrent update of facts
*******************************

   *Author(s):* Daniel Cabeza, Manuel Carro.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   Prolog implementations traditionally implement the concept of
dynamic predicates: predicates which can be inspected or modified at
run-time, adding or deleting individual clauses. The powerfulness of
this feature brings also a great disadvantage: as new clause bodies
can be arbitrarily added to the program, new unknown predicate calls
can arise, thus preventing any global analysis or optimization of the
code. But it is the case that most of the time what the programmer
wants is simply to store data, with the purpose of sharing it between
search branches, predicates, or even execution threads. In Ciao the
concept of data predicate serves this purpose: a data predicate is a
predicate composed exclusively by facts, which can be inspected, and
dynamically added or deleted, at run-time. Using data predicates
instead of normal dynamic predicates brings benefits in terms of
speed, but above all turns the code automatically analyzable.  There
is also a special kind of data predicates, called concurrent
predicates, which can be used to communicate/synchronize among
different execution threads (see *Note Low-level
concurrency/multithreading primitives::).

* Menu:

* Usage and interface (data_facts)::
* Documentation on exports (data_facts)::
* Documentation on internals (data_facts)::


File: ciao.info,  Node: Usage and interface (data_facts),  Next: Documentation on exports (data_facts),  Prev: Fast/concurrent update of facts,  Up: Fast/concurrent update of facts

Usage and interface (`data_facts')
==================================

   * *Library usage:*

     These predicates are builtin in Ciao, so nothing special has to
     be done to use them.

   * *Exports:*
        - _Predicates:_

          `asserta_fact/1', `asserta_fact/2', `assertz_fact/1',
          `assertz_fact/2', `current_fact/1', `current_fact/2',
          `retract_fact/1', `retractall_fact/1', `current_fact_nb/1',
          `retract_fact_nb/1', `close_predicate/1',
          `open_predicate/1', `set_fact/1', `erase/1'.




File: ciao.info,  Node: Documentation on exports (data_facts),  Next: Documentation on internals (data_facts),  Prev: Usage and interface (data_facts),  Up: Fast/concurrent update of facts

Documentation on exports (`data_facts')
=======================================

 - PREDICATE: asserta_fact/1:
     `asserta_fact(Fact)'

     `Fact' is added to the corresponding data predicate. The fact
     becomes the first clause of the predicate concerned.

     _Meta-predicate_ with arguments: `asserta_fact(fact)'.




 - PREDICATE: asserta_fact/2:
     `asserta_fact(Fact,Ref)'

     Same as `asserta_fact/1', instantiating `Ref' to a unique
     identifier of the asserted fact.

     _Meta-predicate_ with arguments: `asserta_fact(fact,?)'.




 - PREDICATE: assertz_fact/1:
     `assertz_fact(Fact)'

     `Fact' is added to the corresponding data predicate. The fact
     becomes the last clause of the predicate concerned.

     _Meta-predicate_ with arguments: `assertz_fact(fact)'.




 - PREDICATE: assertz_fact/2:
     `assertz_fact(Fact,Ref)'

     Same as `assertz_fact/1', instantiating `Ref' to a unique
     identifier of the asserted fact.

     _Meta-predicate_ with arguments: `assertz_fact(fact,?)'.




 - PREDICATE: current_fact/1:
     `current_fact(Fact)'

     Gives on backtracking all the facts defined as data or
     concurrent which unify with `Fact'. It is faster than calling
     the predicate explicitly, which do invoke the meta-interpreter.
     If the `Fact' has been defined as concurrent and has not been
     closed, `current_fact/1' will wait (instead of failing) for more
     clauses to appear after the last clause of `Fact' is returned.

     _Meta-predicate_ with arguments: `current_fact(fact)'.




 - PREDICATE: current_fact/2:
     `current_fact(Fact,Ref)'

     `Fact' is a fact of a data predicate and `Ref' is its reference
     identifying it uniquely.

     _Meta-predicate_ with arguments: `current_fact(fact,?)'.

     *Usage 1:* `current_fact(+callable,-reference)'
        - _Description:_ Gives on backtracking all the facts defined
          as data which unify with `Fact', instantiating `Ref' to a
          unique identifier for each fact.

     *Usage 2:* `current_fact(?callable,+reference)'
        - _Description:_ Given `Ref', unifies `Fact' with the fact
          identified by it.



 - PREDICATE: retract_fact/1:
     `retract_fact(Fact)'

     Unifies `Fact' with the first matching fact of a data predicate,
     and then erases it. On backtracking successively unifies with
     and erases new matching facts. If `Fact' is declared as
     concurrent and is non- closed, `retract_fact/1' will wait for
     more clauses or for the closing of the predicate after the last
     matching clause has been removed.

     _Meta-predicate_ with arguments: `retract_fact(fact)'.




 - PREDICATE: retractall_fact/1:
     `retractall_fact(Fact)'

     Erase all the facts of a data predicate unifying with `Fact'.
     Even if all facts are removed, the predicate continues to exist.

     _Meta-predicate_ with arguments: `retractall_fact(fact)'.




 - PREDICATE: current_fact_nb/1:
     `current_fact_nb(Fact)'

     Behaves as `current_fact/1' but a fact is never waited on even
     if it is concurrent and non-closed.

     _Meta-predicate_ with arguments: `current_fact_nb(fact)'.




 - PREDICATE: retract_fact_nb/1:
     `retract_fact_nb(Fact)'

     Behaves as `retract_fact/1', but never waits on a fact, even if
     it has been declared as concurrent and is non- closed.

     _Meta-predicate_ with arguments: `retract_fact_nb(fact)'.




 - PREDICATE: close_predicate/1:
     `close_predicate(Pred)'

     Changes the behavior of the predicate `Pred' if it has been
     declared as a concurrent predicate: calls to this predicate will
     fail (instead of wait) if no more clauses of `Pred' are
     available.

     _Meta-predicate_ with arguments: `close_predicate(fact)'.




 - PREDICATE: open_predicate/1:
     `open_predicate(Pred)'

     Reverts the behavior of concurrent predicate `Pred' to waiting
     instead of failing if no more clauses of `Pred' are available.

     _Meta-predicate_ with arguments: `open_predicate(fact)'.




 - PREDICATE: set_fact/1:
     `set_fact(Fact)'

     Sets `Fact' as the unique fact of the corresponding data
     predicate.

     _Meta-predicate_ with arguments: `set_fact(fact)'.




 - PREDICATE: erase/1:
     `erase(Ref)'

     Deletes the clause referenced by `Ref'.





File: ciao.info,  Node: Documentation on internals (data_facts),  Prev: Documentation on exports (data_facts),  Up: Fast/concurrent update of facts

Documentation on internals (`data_facts')
=========================================

 - REGTYPE: reference/1:
     *Usage:* `reference(R)'
        - _Description:_ `R' is a reference of a dynamic or data
          clause.




File: ciao.info,  Node: Extending the syntax,  Next: Message printing primitives,  Prev: Fast/concurrent update of facts,  Up: Top

Extending the syntax
********************

   *Author(s):* Daniel Cabeza.

   This chapter documents the builtin directives in Ciao for
extending the syntax of source files. Note that the ISO-Prolog
directive `char_conversion/2' is not implemented, since Ciao does not
(yet) have a character conversion table.

* Menu:

* Usage and interface (syntax_extensions)::
* Documentation on internals (syntax_extensions)::


File: ciao.info,  Node: Usage and interface (syntax_extensions),  Next: Documentation on internals (syntax_extensions),  Prev: Extending the syntax,  Up: Extending the syntax

Usage and interface (`syntax_extensions')
=========================================

   * *Library usage:*

     These directives are builtin in Ciao, so nothing special has to
     be done to use them.


File: ciao.info,  Node: Documentation on internals (syntax_extensions),  Prev: Usage and interface (syntax_extensions),  Up: Extending the syntax

Documentation on internals (`syntax_extensions')
================================================

 - DECLARATION: op/3:
     *Usage:* :- `op(Priority,Op_spec,Operator)'.  < * ISO * >
        - _Description:_ Updates the operator table for reading the
          terms in the rest of the current text, in the same way as
          the builtin `op/3' does. Its scope is local to the current
          text. Usually included in package files.

        - _The following properties hold at call time:_

          `Priority' is an integer.   (`basic_props:int/1')

          `Op_spec' specifies the type and associativity of an
          operator.   (`basic_props:operator_specifier/1')

          `Operator' is an atom or a list of atoms.
          (`basic_props:atm_or_atm_list/1')



 - DECLARATION: new_declaration/1:
     *Usage:* :- `new_declaration(Predicate)'.
        - _Description:_ Declares `Predicate' to be a valid
          declaration in the rest of the current text. Such
          declarations are simply ignored by the compiler or top
          level, but can be used by other code processing programs
          such as an automatic documentator. Also, they can easily
          translated into standard code (a set of facts and/or rules)
          by defining a suitable expansion (e.g., by
          `add_sentence_trans/1', etc.). This is tipically done in
          package files.

          Equivalent to `new_declaration(Predicate, off)'.

        - _The following properties hold at call time:_

          `Predicate' is a Name/Arity structure denoting a predicate
          name:
               predname(P/A) :-
                       atm(P),
                       int(A).

          (`basic_props:predname/1')



 - DECLARATION: new_declaration/2:
     *Usage:* :- `new_declaration(Predicate,In_Itf)'.
        - _Description:_ Declares `Predicate' to be a valid
          declaration in the rest of the current text. Such
          declarations will be included in the interface file for
          this file if `In_Itf' is 'on', not if it is 'off'.
          Including such declarations in interface files makes them
          visible while processing other modules which make use of
          this one.

        - _The following properties hold at call time:_

          `Predicate' is a Name/Arity structure denoting a predicate
          name:
               predname(P/A) :-
                       atm(P),
                       int(A).

          (`basic_props:predname/1')

          `In_Itf' is 'on' or 'off'  (`syntax_extensions:switch/1')



 - DECLARATION: load_compilation_module/1:
     *Usage:* :- `load_compilation_module(File)'.
        - _Description:_ Loads code defined in `File' into the
          compiler, usually including predicates which define
          translations of terms, for use with the declarations
          `add_sentence_trans/1' and similar ones. Normally included
          in package files.

        - _The following properties hold at call time:_

          `File' is a source name.   (`streams_basic:sourcename/1')



 - DECLARATION: add_sentence_trans/1:
     *Usage:* :- `add_sentence_trans(Predicate)'.
        - _Description:_ Starts a translation, defined by
          `Predicate', of the terms read by the compiler in the rest
          of the current text. For each subsequent term read by the
          compiler, the translation predicate is called to obtain a
          new term which will be used by the compiler as if it where
          the term present in the file. A list may be returned also,
          to translate a single term into several terms. `Predicate'
          must be exported by a module previously loaded with a
          `load_compilation_module/1' declaration. Normally included
          in package files.

        - _The following properties hold at call time:_

          `Predicate' is a translation predicate spec (has arity 2 or
          3).   (`syntax_extensions:translation_predname/1')



 - DECLARATION: add_term_trans/1:
     *Usage:* :- `add_term_trans(P)'.
        - _Description:_ Starts a translation, defined by
          `Predicate', of the terms and sub-terms read by the
          compiler in the rest of the current text. This translation
          is performed after all translations defined by
          `add_sentence_trans/1' are done. For each subsequent term
          read by the compiler, and recursively any subterm included,
          the translation predicate is called to possibly obtain a
          new term to replace the old one. Care must be taken of not
          introducing an endless loop of translations. `Predicate'
          must be exported by a module previously loaded with a
          `load_compilation_module/1' declaration. Normally included
          in package files.

        - _The following properties hold at call time:_

          `P' is a translation predicate spec (has arity 2 or 3).
          (`syntax_extensions:translation_predname/1')



 - DECLARATION: add_goal_trans/1:
     *Usage:* :- `add_goal_trans(Predicate)'.
        - _Description:_ Declares a translation, defined by
          `Predicate', of the goals present in the clauses of the
          current text. This translation is performed after all
          translations defined by `add_sentence_trans/1' and
          `add_term_trans/1' are done. For each clause read by the
          compiler, the translation predicate is called with each
          goal present in the clause to possibly obtain other goal to
          substitute the original one, and the translation is
          subsequently applied to the resulting goal. Care must be
          taken of not introducing an endless loop of translations.
          `Predicate' must be exported by a module previously loaded
          with a `load_compilation_module/1' declaration. Bear in
          mind that this type of translation noticeably slows down
          compilation. Normally included in package files.

        - _The following properties hold at call time:_

          `Predicate' is a translation predicate spec (has arity 2 or
          3).   (`syntax_extensions:translation_predname/1')



 - DECLARATION: add_clause_trans/1:
     *Usage:* :- `add_clause_trans(Predicate)'.
        - _Description:_ Declares a translation, defined by
          `Predicate', of the clauses of the current text. The
          translation is performed before `add_goal_trans/1'
          translations but after `add_sentence_trans/1' and
          `add_term_trans/1' translations. The usefulness of this
          translation is that information of the interface of related
          modules is available when it is performed. For each clause
          read by the compiler, the translation predicate is called
          with the first argument instantiated to a structure
          `clause(Head,Body)', and the predicate must return in the
          second argument a similar structure, without changing the
          functor in `Head'. Before executing the translation
          predicate with actual clauses it is called with an input of
          `clause(0,0)' (output is discarded).

        - _The following properties hold at call time:_

          `Predicate' is a translation predicate spec (has arity 2 or
          3).   (`syntax_extensions:translation_predname/1')



 - REGTYPE: translation_predname/1:
     A translation predicate is a predicate of arity 2 or 3 used to
     make compile-time translations. The compiler invokes a
     translation predicate instantiating its first argument with the
     item to be translated, and if the predicate is of arity 3 its
     third argument with the name of the module where the translation
     is done. If the call is successful, the second argument is used
     as if that item were in the place of the original, else the
     original item is used.

     *Usage:* `translation_predname(P)'
        - _Description:_ `P' is a translation predicate spec (has
          arity 2 or 3).




File: ciao.info,  Node: Message printing primitives,  Next: Attributed variables,  Prev: Extending the syntax,  Up: Top

Message printing primitives
***************************

   *Author(s):* Daniel Cabeza.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   This module provides predicates for printing in a unified way
informational messages, and also for printing some terms in a
specific way.

* Menu:

* Usage and interface (io_aux)::
* Documentation on exports (io_aux)::
* Known bugs and planned improvements (io_aux)::


File: ciao.info,  Node: Usage and interface (io_aux),  Next: Documentation on exports (io_aux),  Prev: Message printing primitives,  Up: Message printing primitives

Usage and interface (`io_aux')
==============================

   * *Library usage:*

     These predicates are builtin in Ciao, so nothing special has to
     be done to use them.

   * *Exports:*
        - _Predicates:_

          `message/2', `message_lns/4', `display_string/1'.




File: ciao.info,  Node: Documentation on exports (io_aux),  Next: Known bugs and planned improvements (io_aux),  Prev: Usage and interface (io_aux),  Up: Message printing primitives

Documentation on exports (`io_aux')
===================================

 - PREDICATE: message/2:
     `message(Type,Message)'

     Output to standard error `Message', which is of type `Type'. The
     `quiet' _prolog flag_ (see *Note Changing system behaviour and
     various flags::) controls which messages are actually output,
     depending on its type. Also, for `error', `warning' and `note'
     messages, a prefix is output which denotes the severity of the
     message. `Message' is an item or a list of items from this list:
    `$$(String)'
          `String' is a string, which is output with
          `display_string/1'.

    `''(Term)'
          `Term' is output quoted. If the module `write' is loaded,
          the term is output with `writeq/1', else with `displayq/1'.

    `~~(Term)'
          `Term' is output unquoted. If the module `write' is loaded,
          the term is output with `write/1', else with `display/1'.

    `[](Term)'
          `Term' is recursively output as a message, can be an item
          or a list of items from this list.

    `Term'
          Any other term is output with `display/1'.

     *Usage 1:* `message(Type,Message)'
        - _The following properties should hold at call time:_

          `Type' is an atom.   (`basic_props:atm/1')

          `Type' is an element of
          `[error,warning,note,message,debug]'.
          (`basic_props:member/2')

     *Usage 2:* `message(Type,Message)'
        - _The following properties should hold at call time:_

          `Type' is an atom.   (`basic_props:atm/1')

          `Type' is an element of
          `[error,warning,note,message,debug]'.
          (`basic_props:member/2')



 - PREDICATE: message_lns/4:
     `message_lns(Type,L0,L1,Message)'

     Output to standard error `Message', which is of type `Type', and
     occurs between lines `L0' and `L1'. This is the same as
     `message/2', but printing the lines where the message occurs in
     a unified way (this is useful because automatic tools such as
     the emacs mode know how to parse them).

     *Usage 1:* `message_lns(Type,L0,L1,Message)'
        - _The following properties should hold at call time:_

          `Type' is an atom.   (`basic_props:atm/1')

          `Type' is an element of
          `[error,warning,note,message,debug]'.
          (`basic_props:member/2')

     *Usage 2:* `message_lns(Type,L0,L1,Message)'
        - _The following properties should hold at call time:_

          `Type' is an atom.   (`basic_props:atm/1')

          `Type' is an element of
          `[error,warning,note,message,debug]'.
          (`basic_props:member/2')



 - PREDICATE: error/1:
     Defined as
          error(Message) :-
                  message(error,Message).
     .




 - PREDICATE: warning/1:
     Defined as
          warning(Message) :-
                  message(warning,Message).
     .




 - PREDICATE: note/1:
     Defined as
          note(Message) :-
                  message(note,Message).
     .




 - PREDICATE: message/1:
     Defined as
          message(Message) :-
                  message(message,Message).
     .




 - PREDICATE: debug/1:
     Defined as
          debug(Message) :-
                  message(debug,Message).
     .




 - PREDICATE: inform_user/1:
     `inform_user(Message)'

     Similar to `message/1', but `Message' is output with
     `display_list/1'. This predicate is obsolete, and may disappear
     in future versions.




 - PREDICATE: display_string/1:
     `display_string(String)'

     Output `String' as the sequence of characters it represents.

     *Usage 1:* `display_string(String)'
        - _The following properties should hold at call time:_

          `String' is a string (a list of character codes).
          (`basic_props:string/1')

     *Usage 2:* `display_string(String)'
        - _The following properties should hold at call time:_

          `String' is a string (a list of character codes).
          (`basic_props:string/1')



 - PREDICATE: display_list/1:
     `display_list(List)'

     Outputs `List'. If `List' is a list, do `display/1' on each of
     its elements, else do `display/1' on `List'.




 - PREDICATE: display_term/1:
     `display_term(Term)'

     Output `Term' in a way that a `read/1' will be able to read it
     back, even if operators change.





File: ciao.info,  Node: Known bugs and planned improvements (io_aux),  Prev: Documentation on exports (io_aux),  Up: Message printing primitives

Known bugs and planned improvements (`io_aux')
==============================================

   *  `message/2' assumes that a module with name 'write' is
     library(write).


File: ciao.info,  Node: Attributed variables,  Next: Gathering some basic internal info,  Prev: Message printing primitives,  Up: Top

Attributed variables
********************

   *Author(s):* Christian Holzbaur, Daniel Cabeza, Manuel Carro.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#157 (2000/5/30, 13:4:47 CEST)

   These predicates are builtin in Ciao, so nothing special has to be
done to use them.

* Menu:

* Usage and interface (attributes)::
* Documentation on exports (attributes)::
* Documentation on multifiles (attributes)::


File: ciao.info,  Node: Usage and interface (attributes),  Next: Documentation on exports (attributes),  Prev: Attributed variables,  Up: Attributed variables

Usage and interface (`attributes')
==================================

   * *Library usage:*

     Note that `combine_attributes/2' and `verify_attribute/2' are
     not called with the attributed variables involved, but with the
     corresponding attributes instead. The reasons are:

        * There are simple applications which only refer to the
          attributes.

        * If the application wants to refer to the attributed
          variables themselves, they can be made part the attribute
          term. The implementation of `freeze/2' utilizes this
          technique. Note that this does not lead to cyclic
          structures, as the connection between an attributed
          variable and its attribute is invisible to the pure parts
          of the Prolog implementation.

        * If attributed variables were passed as arguments, the user
          code would have to refer to the attributes through an extra
          call to `get_attribute/2'.

        * As the/one attribute is the first argument to each of the
          two predicates, indexing applies. Note that attributed
          variables themselves look like variables to the indexing
          mechanism.


     However, future improvements may change or extend the interface
     to attributed variables in order to provide a richer and more
     expressive interface.

     For customized output of attributed variables, please refer to
     the documentation of the predicate `portray_attribute/2'.

   * *Exports:*
        - _Predicates:_

          `attach_attribute/2', `get_attribute/2',
          `update_attribute/2', `detach_attribute/1'.

        - _Multifiles:_

          `verify_attribute/2', `combine_attributes/2'.




File: ciao.info,  Node: Documentation on exports (attributes),  Next: Documentation on multifiles (attributes),  Prev: Usage and interface (attributes),  Up: Attributed variables

Documentation on exports (`attributes')
=======================================

 - PREDICATE: attach_attribute/2:
     *Usage 1:* `attach_attribute(Var,Attr)'
        - _Description:_ Attach attribute `Attr' to `Var'.

        - _The following properties should hold at call time:_

          `Var' is a free variable.   (`term_typing:var/1')

          `Attr' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')

     *Usage 2:* `attach_attribute(Var,Attr)'
        - _Description:_ Attach attribute `Attr' to `Var'.

        - _The following properties should hold at call time:_

          `Var' is a free variable.   (`term_typing:var/1')

          `Attr' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')



 - PREDICATE: get_attribute/2:
     *Usage 1:* `get_attribute(Var,Attr)'
        - _Description:_ Unify `Attr' with the attribute of `Var', or
          fail if `Var' has no attribute.

        - _The following properties should hold at call time:_

          `Var' is a free variable.   (`term_typing:var/1')

        - _The following properties should hold upon exit:_

          `Attr' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')

     *Usage 2:* `get_attribute(Var,Attr)'
        - _Description:_ Unify `Attr' with the attribute of `Var', or
          fail if `Var' has no attribute.

        - _The following properties should hold at call time:_

          `Var' is a free variable.   (`term_typing:var/1')

        - _The following properties should hold upon exit:_

          `Attr' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')



 - PREDICATE: update_attribute/2:
     *Usage 1:* `update_attribute(Var,Attr)'
        - _Description:_ Change the attribute of attributed variable
          `Var' to `Attr'.

        - _The following properties should hold at call time:_

          `Var' is a free variable.   (`term_typing:var/1')

          `Attr' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')

     *Usage 2:* `update_attribute(Var,Attr)'
        - _Description:_ Change the attribute of attributed variable
          `Var' to `Attr'.

        - _The following properties should hold at call time:_

          `Var' is a free variable.   (`term_typing:var/1')

          `Attr' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')



 - PREDICATE: detach_attribute/1:
     *Usage 1:* `detach_attribute(Var)'
        - _Description:_ Take out the attribute from the attributed
          variable `Var'.

        - _The following properties should hold at call time:_

          `Var' is a free variable.   (`term_typing:var/1')

     *Usage 2:* `detach_attribute(Var)'
        - _Description:_ Take out the attribute from the attributed
          variable `Var'.

        - _The following properties should hold at call time:_

          `Var' is a free variable.   (`term_typing:var/1')




File: ciao.info,  Node: Documentation on multifiles (attributes),  Prev: Documentation on exports (attributes),  Up: Attributed variables

Documentation on multifiles (`attributes')
==========================================

 - PREDICATE: verify_attribute/2:
     The predicate is _multifile_.

     *Usage:* `verify_attribute(Attr,Term)'
        - _Description:_ _A user defined predicate._ This predicate
          is called when an attributed variable with attribute `Attr'
          is about to be unified with the non-variable term `Term'.
          The user should define this predicate (as multifile) in the
          modules implementing special unification.

        - _The following properties should hold at call time:_

          `Attr' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')

          `Term' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')



 - PREDICATE: combine_attributes/2:
     The predicate is _multifile_.

     *Usage:* `combine_attributes(Var1,Var2)'
        - _Description:_ _A user defined predicate._ This predicate
          is called when two attributed variables with attributes
          `Var1' and `Var2' are about to be unified. The user should
          define this predicate (as multifile) in the modules
          implementing special unification.

        - _The following properties should hold at call time:_

          `Var1' is a free variable.   (`term_typing:var/1')

          `Var2' is a free variable.   (`term_typing:var/1')




File: ciao.info,  Node: Gathering some basic internal info,  Next: *** PART III - ISO-Prolog library (iso),  Prev: Attributed variables,  Up: Top

Gathering some basic internal info
**********************************

   *Author(s):* Daniel Cabeza, Manuel Carro.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.3#13 (1999/7/2, 18:49:49 MEST)

   This module provides predicates which return basic internal info.

* Menu:

* Usage and interface (system_info)::
* Documentation on exports (system_info)::
* Documentation on internals (system_info)::


File: ciao.info,  Node: Usage and interface (system_info),  Next: Documentation on exports (system_info),  Prev: Gathering some basic internal info,  Up: Gathering some basic internal info

Usage and interface (`system_info')
===================================

   * *Library usage:*

     These predicates are builtin in Ciao, so nothing special has to
     be done to use them.

   * *Exports:*
        - _Predicates:_

          `get_arch/1', `get_os/1', `this_module/1',
          `current_module/1', `ciaolibdir/1'.




File: ciao.info,  Node: Documentation on exports (system_info),  Next: Documentation on internals (system_info),  Prev: Usage and interface (system_info),  Up: Gathering some basic internal info

Documentation on exports (`system_info')
========================================

 - PREDICATE: get_arch/1:
     This predicate will describe the computer architecture wich is
     currently executing the predicate.

     Computer architectures are identified by a simple atom. This
     atom is implementation-defined, and may suffer any change from
     one Ciao Prolog version to another.

     For example,Ciao Prolog running on an Intel-based machine will
     retrieve:
          ?- get_arch(I).
          
          I = i86 ? ;
          
          no
          ?-

     *Usage 1:* `get_arch(?ArchDescriptor)'
        - _Description:_ Unifies `ArchDescriptor' with a simple atom
          which describes the computer architecture currently
          executing the predicate.

        - _Calls should, and exit will be compatible with:_

          `?ArchDescriptor' is an atom.   (`basic_props:atm/1')

     *Usage 2:* `get_arch(ArchDescriptor)'
        - _Description:_ Unifies `ArchDescriptor' with a simple atom
          which describes the computer architecture currently
          executing the predicate.

        - _Calls should, and exit will be compatible with:_

          `ArchDescriptor' is an atom.   (`basic_props:atm/1')



 - PREDICATE: get_os/1:
     This predicate will describe the Operating System which is
     running on the machine currently executing the Prolog program.

     Operating Systems are identified by a simple atom. This atom is
     implementation-defined, and may suffer any change from one Ciao
     Prolog version to another.

     For example,Ciao Prolog running on Linux will retrieve:
          ?- get_os(I).
          
          I = 'LINUX' ? ;
          
          no
          ?-

     *Usage 1:* `get_os(?OsDescriptor)'
        - _Description:_ Unifies `OsDescriptor' with a simple atom
          which describes the running Operating System when predicate
          was called.

        - _Calls should, and exit will be compatible with:_

          `?OsDescriptor' is an atom.   (`basic_props:atm/1')

     *Usage 2:* `get_os(OsDescriptor)'
        - _Description:_ Unifies `OsDescriptor' with a simple atom
          which describes the running Operating System when predicate
          was called.

        - _Calls should, and exit will be compatible with:_

          `OsDescriptor' is an atom.   (`basic_props:atm/1')



 - PREDICATE: this_module/1:
     _Meta-predicate_ with arguments: `this_module(addmodule)'.

     *Usage 1:* `this_module(Module)'
        - _Description:_ `Module' is the internal module identifier
          for current module.

        - _Call and exit should be _compatible_ with:_

          `Module' is an internal module identifier
          (`system_info:internal_module_id/1')

     *Usage 2:* `this_module(Module)'
        - _Description:_ `Module' is the internal module identifier
          for current module.

        - _Call and exit should be _compatible_ with:_

          `Module' is an internal module identifier
          (`system_info:internal_module_id/1')



 - PREDICATE: current_module/1:
     This predicate will successively unify its argument with all
     module names currently loaded. Module names will be simple atoms.

     When called using a free variable as argument, it will retrieve
     on backtracking all modules currently loaded. This is usefull
     when called from the Ciao `toplevel'.

     When called using a module name as argument it will check
     whether the given module is loaded or not. This is usefull when
     called from user programs.

     *Usage 1:* `current_module(Module)'
        - _Description:_ Retrieves (on backtracking) all currently
          loaded modules into your application.

        - _Call and exit should be _compatible_ with:_

          `Module' is an internal module identifier
          (`system_info:internal_module_id/1')

     *Usage 2:* `current_module(Module)'
        - _Description:_ Retrieves (on backtracking) all currently
          loaded modules into your application.

        - _Call and exit should be _compatible_ with:_

          `Module' is an internal module identifier
          (`system_info:internal_module_id/1')



 - PREDICATE: ciaolibdir/1:
     *Usage 1:* `ciaolibdir(CiaoPath)'
        - _Description:_ `CiaoPath' is the path to the root of the
          Ciao libraries. Inside this directory, there are the
          directories 'lib', 'library' and 'contrib', which contain
          library modules.

        - _Call and exit should be _compatible_ with:_

          `CiaoPath' is an atom.   (`basic_props:atm/1')

     *Usage 2:* `ciaolibdir(CiaoPath)'
        - _Description:_ `CiaoPath' is the path to the root of the
          Ciao libraries. Inside this directory, there are the
          directories 'lib', 'library' and 'contrib', which contain
          library modules.

        - _Call and exit should be _compatible_ with:_

          `CiaoPath' is an atom.   (`basic_props:atm/1')




File: ciao.info,  Node: Documentation on internals (system_info),  Prev: Documentation on exports (system_info),  Up: Gathering some basic internal info

Documentation on internals (`system_info')
==========================================

 - PROPERTY: internal_module_id/1:
     For a user file it is a term user/1 with an argument different
     for each user file, for other modules is just the name of the
     module (as an atom).

     *Usage:* `internal_module_id(M)'
        - _Description:_ `M' is an internal module identifier




File: ciao.info,  Node: *** PART III - ISO-Prolog library (iso),  Next: ISO-Prolog package,  Prev: Gathering some basic internal info,  Up: Top

PART III - ISO-Prolog library (iso)
***********************************

   This part documents the _iso_ package which provides to Ciao
programs (most of) the ISO-Prolog functionality , including the
_ISO-Prolog builtins_ not covered by the basic library. All these
predicates are loaded by default in user files and in modules which
use standard module declarations such as:

   `:- module(_modulename_,_exports_).'

   which are equivalent to:

   `:- module(_modulename_,_exports_,[iso]).'

   or

   `:- module(_modulename_,_exports_).'

   `:- use_package([iso]).'

   If you do not want these ISO builtins loaded for a given file (in
order to make the executable smaller) you can ask for this explicitly
using:

   `:- module(_modulename_,_exports_,[]).'

   or

   `:- module(_modulename_,_exports_).'

   `:- use_package([]).'

   See the description of the declarations for declaring modules and
using other modules, and the documentation of the `iso' library for
details.


File: ciao.info,  Node: ISO-Prolog package,  Next: All solutions predicates,  Prev: *** PART III - ISO-Prolog library (iso),  Up: Top

ISO-Prolog package
******************

   This library package allows the use of the ISO-Prolog predicates
in Ciao programs. It is included by default in modules starting with a
`module/2' declaration or user files without a starting
`use_package/1' declaration.

* Menu:

* Usage and interface (iso)::


File: ciao.info,  Node: Usage and interface (iso),  Prev: ISO-Prolog package,  Up: ISO-Prolog package

Usage and interface (`iso')
===========================

   * *Library usage:*

     `:- use_package(iso).'

     or

     `:- module(...,...,[iso]).'

   * *Other modules used:*
        - _System library modules:_

          `aggregates', `dynamic', `iso_misc', `iso_byte_char',
          `iso_incomplete', `operators', `read', `write'.




File: ciao.info,  Node: All solutions predicates,  Next: Dynamic predicates,  Prev: ISO-Prolog package,  Up: Top

All solutions predicates
************************

   *Author(s):* First version by Richard A. O'Keefe and David H.D.
Warren. Changes by Mats Carlsson, Daniel Cabeza, and Manuel
Hermenegildo.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#115 (2000/4/12, 12:17:22 CEST)

   This module implements the standard solution aggregation
predicates.

   When there are many solutions to a problem, and when all those
solutions are required to be collected together, this can be achieved
by repeatedly backtracking and gradually building up a list of the
solutions. The following built-in predicates are provided to automate
this process.

* Menu:

* Usage and interface (aggregates)::
* Documentation on exports (aggregates)::


File: ciao.info,  Node: Usage and interface (aggregates),  Next: Documentation on exports (aggregates),  Prev: All solutions predicates,  Up: All solutions predicates

Usage and interface (`aggregates')
==================================

   * *Library usage:*

     `:- use_module(library(aggregates)).'

   * *Exports:*
        - _Predicates:_

          `setof/3', `bagof/3', `findall/3', `findall/4',
          `findnsols/4', `findnsols/5', `^/2'.


   * *Other modules used:*
        - _System library modules:_

          `sort', `lists'.




File: ciao.info,  Node: Documentation on exports (aggregates),  Prev: Usage and interface (aggregates),  Up: All solutions predicates

Documentation on exports (`aggregates')
=======================================

 - PREDICATE: setof/3:
     `setof(Template,Generator,Set)'

     Finds the `Set' of instances of the `Template' satisfying
     `Generator'. The set is in ascending order (see *Note Comparing
     terms:: for a definition of this order) without duplicates, and
     is non-empty. If there are no solutions, `setof' fails. `setof'
     may succeed in more than one way, binding free variables in
     `Generator' to different values. This can be avoided by using
     existential quantifiers on the free variables in front of
     `Generator', using `^/2'. For example, given the clauses:
          father(bill, tom).
          father(bill, ann).
          father(bill, john).
          father(harry, july).
          father(harry, daniel).

     The following query produces two alternative solutions via
     backtracking:
          ?- setof(X,father(F,X),Sons).
          
          F = bill,
          Sons = [ann,john,tom] ? ;
          
          F = harry,
          Sons = [daniel,july] ? ;
          
          no
          ?-

     _Meta-predicate_ with arguments: `setof(?,goal,?)'.




 - PREDICATE: bagof/3:
     `bagof(Template,Generator,Bag)'

     Finds all the instances of the `Template' produced by the
     `Generator', and returns them in the `Bag' in the order in which
     they were found. If the `Generator' contains free variables
     which are not bound in the `Template', it assumes that this is
     like any other Prolog question and that you want bindings for
     those variables. This can be avoided by using existential
     quantifiers on the free variables in front of the `Generator',
     using `^/2'.

     _Meta-predicate_ with arguments: `bagof(?,goal,?)'.




 - PREDICATE: findall/3:
     `findall(Template,Generator,List)'

     A special case of bagof, where all free variables in the
     `Generator' are taken to be existentially quantified. Faster
     than the other aggregation predicates.

     _Meta-predicate_ with arguments: `findall(?,goal,?)'.




 - PREDICATE: findall/4:
     _Meta-predicate_ with arguments: `findall(?,goal,?,?)'.

     *Usage:* `findall(Template,Generator,List,Tail)'
        - _Description:_ As `findall/3', but returning in `Tail' the
          tail of `List'.



 - PREDICATE: findnsols/4:
     `findnsols(N,Template,Generator,List)'

     As `findall/3', but generating at most `N' solutions of
     `Generator'. Thus, the length of `List' will not be greater than
     `N'. If `N'=<0, returns directly an empty list. This predicate
     is especially useful if `Generator' may have an infinite number
     of solutions.

     _Meta-predicate_ with arguments: `findnsols(?,?,goal,?)'.




 - PREDICATE: findnsols/5:
     `findnsols(N,Template,Generator,List,Tail)'

     As `findnsols/4', but returning in `Tail' the tail of `List'.

     _Meta-predicate_ with arguments: `findnsols(?,?,goal,?,?)'.




 - PREDICATE: ^/2:
     *Usage:* `X ^ P'
        - _Description:_ Existential quantification: `X' is
          existentially quantified in `P'. E.g., in `A^p(A,B)', `A'
          is existentially quantified. Used only within aggregation
          predicates. In all other contexts, simply, execute the
          procedure call `P'.




File: ciao.info,  Node: Dynamic predicates,  Next: Term input,  Prev: All solutions predicates,  Up: Top

Dynamic predicates
******************

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#146 (2000/5/19, 21:1:42 CEST)

   This module implements the assert/retract family of predicates to
manipulate dynamic predicates.

   The predicates defined in this module allow modification of the
program as it is actually running. Clauses can be added to the
program (_asserted_) or removed from the program (_retracted_). For
these predicates, the argument which corresponds to the clause head
must be instantiated to an atom or a compound term. The argument
corresponding to the clause must be instantiated either to a term
`Head :- Body' or, if the body part is empty, to `Head'. An empty
body part is represented as `true'. Note that using this library is
very detrimental to global analysis, and that for most uses the
predicates listed in *Note Fast/concurrent update of facts:: suffice.

* Menu:

* Usage and interface (dynamic)::
* Documentation on exports (dynamic)::
* Documentation on multifiles (dynamic)::


File: ciao.info,  Node: Usage and interface (dynamic),  Next: Documentation on exports (dynamic),  Prev: Dynamic predicates,  Up: Dynamic predicates

Usage and interface (`dynamic')
===============================

   * *Library usage:*

     `:- use_module(library(dynamic)).'

   * *Exports:*
        - _Predicates:_

          `asserta/1', `asserta/2', `assertz/1', `assertz/2',
          `assert/1', `assert/2', `retract/1', `retractall/1',
          `abolish/1', `clause/2', `clause/3', `current_predicate/1',
          `current_predicate/2', `data/1', `wellformed_body/3'.

        - _Multifiles:_

          `do_on_abolish/1'.




File: ciao.info,  Node: Documentation on exports (dynamic),  Next: Documentation on multifiles (dynamic),  Prev: Usage and interface (dynamic),  Up: Dynamic predicates

Documentation on exports (`dynamic')
====================================

 - PREDICATE: asserta/1:
     _Meta-predicate_ with arguments: `asserta(clause)'.

     *Usage:* `asserta(+Clause)' < * ISO * >
        - _Description:_ The current instance of `Clause' is
          interpreted as a clause and is added to the current
          program. The predicate concerned must be dynamic. The new
          clause becomes the _first_ clause for the predicate
          concerned. Any uninstantiated variables in `Clause' will be
          replaced by new private variables.



 - PREDICATE: asserta/2:
     _Meta-predicate_ with arguments: `asserta(clause,?)'.

     *Usage:* `asserta(+Clause,-Ref)'
        - _Description:_ Like `asserta/1'. `Ref' is a unique
          identifier of the asserted clause.



 - PREDICATE: assertz/1:
     _Meta-predicate_ with arguments: `assertz(clause)'.

     *Usage:* `assertz(+Clause)' < * ISO * >
        - _Description:_ Like `asserta/1', except that the new clause
          becomes the _last_ clause for the predicate concerned.



 - PREDICATE: assertz/2:
     _Meta-predicate_ with arguments: `assertz(clause,?)'.

     *Usage:* `assertz(+Clause,-Ref)'
        - _Description:_ Like `assertz/1'. `Ref' is a unique
          identifier of the asserted clause.



 - PREDICATE: assert/1:
     _Meta-predicate_ with arguments: `assert(clause)'.

     *Usage:* `assert(+Clause)'
        - _Description:_ Identical to `assertz/1'. Included for
          compatibility.



 - PREDICATE: assert/2:
     _Meta-predicate_ with arguments: `assert(clause,?)'.

     *Usage:* `assert(+Clause,-Ref)'
        - _Description:_ Identical to `assertz/2'. Included for
          compatibility.



 - PREDICATE: retract/1:
     _Meta-predicate_ with arguments: `retract(clause)'.

     *Usage:* `retract(+Clause)' < * ISO * >
        - _Description:_ The first clause in the program that matches
          `Clause' is erased. The predicate concerned must be dynamic.

          The predicate `retract/1' may be used in a non-determinate
          fashion, i.e., it will successively retract clauses
          matching the argument through backtracking. If reactivated
          by backtracking, invocations of the predicate whose clauses
          are being retracted will proceed unaffected by the
          retracts. This is also true for invocations of `clause' for
          the same predicate. The space occupied by a retracted
          clause will be recovered when instances of the clause are
          no longer in use.



 - PREDICATE: retractall/1:
     _Meta-predicate_ with arguments: `retractall(fact)'.

     *Usage:* `retractall(+Head)'
        - _Description:_ Erase all clauses whose head matches `Head',
          where `Head' must be instantiated to an atom or a compound
          term. The predicate concerned must be dynamic. The
          predicate definition is retained.



 - PREDICATE: abolish/1:
     _Meta-predicate_ with arguments: `abolish(spec)'.

     *Usage:* `abolish(+Spec)' < * ISO * >
        - _Description:_ Erase all clauses of the predicate specified
          by the predicate spec `Spec'. The predicate definition
          itself is also erased (the predicate is deemed undefined
          after execution of the abolish). The predicates concerned
          must all be user defined.



 - PREDICATE: clause/2:
     _Meta-predicate_ with arguments: `clause(fact,?)'.

     *Usage:* `clause(+Head,?Body)' < * ISO * >
        - _Description:_ The clause '`Head' `:-' `Body'' exists in
          the current program. The predicate concerned must be
          dynamic.



 - PREDICATE: clause/3:
     `clause(Head,Body,Ref)'

     Like `clause(Head,Body)', plus the clause is uniquely identified
     by `Ref'.

     _Meta-predicate_ with arguments: `clause(fact,?,?)'.

     *Usage 1:* `clause(+Head,?Body,?Ref)'
        - _Description:_ `Head' must be instantiated to an atom or a
          compound term.

     *Usage 2:* `clause(?Head,?Body,+Ref)'
        - _Description:_ `Ref' must be instantiated to a valid
          identifier.



 - PREDICATE: current_predicate/1:
     *Usage:* `current_predicate(?Spec)' < * ISO * >
        - _Description:_ A predicate in the current module is named
          `Spec'.



 - PREDICATE: current_predicate/2:
     *Usage:* `current_predicate(?Spec,+Module)'
        - _Description:_ A predicate in `Module' is named `Spec'.



 - PREDICATE: dynamic/1:
     No further documentation available for this predicate.




 - PREDICATE: data/1:
     No further documentation available for this predicate.




 - PREDICATE: wellformed_body/3:
     `wellformed_body(BodyIn,Env,BodyOut)'

     `BodyIn' is a well-formed clause body. `BodyOut' is its
     counterpart with no single-variable meta-goals (i.e., with
     `call(X)' for `X'). `Env' denotes if global cuts are admissible
     in `BodyIn' (`+' if they are, `-' if they are not).





File: ciao.info,  Node: Documentation on multifiles (dynamic),  Prev: Documentation on exports (dynamic),  Up: Dynamic predicates

Documentation on multifiles (`dynamic')
=======================================

 - PREDICATE: do_on_abolish/1:
     `do_on_abolish(Head)'

     A hook predicate which will be called when the definition of the
     predicate of `Head' is abolished.

     The predicate is _multifile_.





File: ciao.info,  Node: Term input,  Next: Term output,  Prev: Dynamic predicates,  Up: Top

Term input
**********

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#100 (2000/3/30, 18:1:28 CEST)

* Menu:

* Usage and interface (read)::
* Documentation on exports (read)::


File: ciao.info,  Node: Usage and interface (read),  Next: Documentation on exports (read),  Prev: Term input,  Up: Term input

Usage and interface (`read')
============================

   * *Library usage:*

     `:- use_module(library(read)).'

   * *Exports:*
        - _Predicates:_

          `read/1', `read/2', `read_term/2', `read_term/3',
          `read_top_level/3', `second_prompt/2'.


   * *Other modules used:*
        - _System library modules:_

          `tokenize', `operators', `lists'.




File: ciao.info,  Node: Documentation on exports (read),  Prev: Usage and interface (read),  Up: Term input

Documentation on exports (`read')
=================================

 - PREDICATE: read/1:
     `read(Term)'

     Like `read(Stream,Term)' with `Stream' associated to the current
     input stream.




 - PREDICATE: read/2:
     *Usage:* `read(+Stream,?Term)' < * ISO * >
        - _Description:_ The next term, delimited by a full-stop
          (i.e., a `.' followed by either a space or a control
          character), is read from `Stream' and is unified with
          `Term'. The syntax of the term must agree with current
          operator declarations. If the end of `Stream' has been
          reached, `Term' is unified with the term `end_of_file'.
          Further calls to `read/2' for the same stream will then
          cause an error, unless the stream is connected to the
          terminal (in which case a prompt is opened on the terminal).



 - PREDICATE: read_term/2:



 - PREDICATE: read_term/3:



 - PREDICATE: read_top_level/3:
     No further documentation available for this predicate.




 - PREDICATE: second_prompt/2:
     No further documentation available for this predicate.





File: ciao.info,  Node: Term output,  Next: Defining operators,  Prev: Term input,  Up: Top

Term output
***********

   *Author(s):* Adapted from shared code written by Richard A.
O'Keefe. Changes by Mats Carlsson, Daniel Cabeza, and Manuel
Hermenegildo..

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#158 (2000/5/30, 13:8:10 CEST)

   This library provides different predicates for term output,
additional to the kernel predicates `display/1'- `display/2' and
`displayq/1'-`displayq/2'. All the predicates defined in ISO-Prolog
are included, plus other traditionally provided by Prolog
Implementations. Output predicates are provided in two versions: one
that uses the current output stream and other in which the stream is
specified explicitly, as an additional first argument.

* Menu:

* Usage and interface (write)::
* Documentation on exports (write)::
* Documentation on multifiles (write)::


File: ciao.info,  Node: Usage and interface (write),  Next: Documentation on exports (write),  Prev: Term output,  Up: Term output

Usage and interface (`write')
=============================

   * *Library usage:*

     `:- use_module(library(write)).'

   * *Exports:*
        - _Predicates:_

          `write_term/3', `write_term/2', `write/2', `write/1',
          `writeq/2', `writeq/1', `write_canonical/2',
          `write_canonical/1', `print/2', `print/1', `write_list1/1',
          `portray_clause/2', `portray_clause/1', `numbervars/3',
          `prettyvars/1', `printable_char/1'.

        - _Properties:_

          `write_option/1'.

        - _Multifiles:_

          `define_flag/3', `portray_attribute/2', `portray/1'.


   * *Other modules used:*
        - _System library modules:_

          `operators', `sort'.




File: ciao.info,  Node: Documentation on exports (write),  Next: Documentation on multifiles (write),  Prev: Usage and interface (write),  Up: Term output

Documentation on exports (`write')
==================================

 - PREDICATE: write_term/3:
     *Usage:* `write_term(@Stream,?Term,+OptList)' < * ISO * >
        - _Description:_ Outputs the term `Term' to the stream
          `Stream', with the list of write-options `OptList'. See
          `write_option/1' type for default options.

        - _The following properties should hold upon exit:_

          `@Stream' is an open stream.   (`streams_basic:stream/1')

          `?Term' is any term.   (`basic_props:term/1')

          `+OptList' is a list of `write_option's.
          (`basic_props:list/2')



 - PREDICATE: write_term/2:
     *Usage:* `write_term(?Term,+OptList)' < * ISO * >
        - _Description:_ Behaves like `current_output(S),
          write_term(S,Term,OptList)'.

        - _The following properties should hold upon exit:_

          `?Term' is any term.   (`basic_props:term/1')

          `+OptList' is a list of `write_option's.
          (`basic_props:list/2')



 - PROPERTY: write_option/1:
     `Opt' is a valid write option which affects the predicate
     `write_term/3' and similar ones. Possible write_options are:
        * *quoted(*_bool_*):* If _bool_ is `true', atoms and functors
          that can't be read back by `read_term/3' are quoted, if it
          is `false', each atom and functor is written as its name.
          Default value is `false'.

        * *ignore_ops(*_flag_*):* If _flag_ is `true', each compound
          term is output in functional notation, if it is `ops',
          curly bracketed notation and list notation is enabled when
          outputing compound terms, if it is `false', also operator
          notation is enabled when outputing compound terms. Default
          value is `false'.

        * *numbervars(*_bool_*):* If _bool_ is `true', a term of the
          form `'$VAR'(N)' where `N' is an integer, is output as a
          variable name consisting of a capital letter possibly
          followed by an integer, a term of the form `'$VAR'(Atom)'
          where `Atom' is an atom, as this atom (without quotes), and
          a term of the form `'$VAR'(String)' where `String' is a
          character string, as the atom corresponding to this
          character string. See predicates `numbervars/3' and
          `prettyvars/1'. If _bool_ is `false' this cases are not
          treated in any special way. Default value is `false'.

        * *portrayed(*_bool_*):* If _bool_ is `true', then call
          multifile predicates `portray/1' and `portray_attribute/1',
          to provide the user handlers for pretty printing some
          terms. `portray_attribute/1' is called whenever an
          attributed variable is to be printed, `portray/1' is called
          whenever a non-variable term is to be printed. If either
          call succeeds, then it is assumed that the term has been
          output, else it is printed as usual. If _bool_ is `false',
          these predicates are not called. Default value is `false'.
          This option is set by the toplevel when writting the final
          values of variables, and by the debugging package when
          writting the goals in the tracing messages. Thus you can
          vary the forms of these messages if you wish.

        * *max_depth(*_depth_*):* _depth_ is a positive integer or
          cero. If it is positive, it denotes the depth limit on
          printing compound terms. If it is cero, there is no limit.
          Default value is `0' (no limit).

        * *priority(*_prio_*):* _prio_ is an integer between 1 and
          1200. If the term to be printed has higher priority than
          _prio_, it will be printed parenthesized. Default value is
          1200 (no term parenthesized).

     .

     *Usage:* `write_option(Opt)'
        - _Description:_ `Opt' is a valid write option.



 - PREDICATE: write/2:
     *Usage:* `write(@Stream,?Term)' < * ISO * >
        - _Description:_ Behaves like `write_term(Stream, Term,
          [numbervars(true)])'.

        - _The following properties should hold upon exit:_

          `@Stream' is an open stream.   (`streams_basic:stream/1')

          `?Term' is any term.   (`basic_props:term/1')



 - PREDICATE: write/1:
     *Usage:* `write(?Term)' < * ISO * >
        - _Description:_ Behaves like `current_output(S),
          write(S,Term)'.

        - _The following properties should hold upon exit:_

          `?Term' is any term.   (`basic_props:term/1')



 - PREDICATE: writeq/2:
     *Usage:* `writeq(@Stream,?Term)' < * ISO * >
        - _Description:_ Behaves like `write_term(Stream, Term,
          [quoted(true), numbervars(true)])'.

        - _The following properties should hold upon exit:_

          `@Stream' is an open stream.   (`streams_basic:stream/1')

          `?Term' is any term.   (`basic_props:term/1')



 - PREDICATE: writeq/1:
     *Usage:* `writeq(?Term)' < * ISO * >
        - _Description:_ Behaves like `current_output(S),
          writeq(S,Term)'.

        - _The following properties should hold upon exit:_

          `?Term' is any term.   (`basic_props:term/1')



 - PREDICATE: write_canonical/2:
     *Usage:* `write_canonical(@Stream,?Term)' < * ISO * >
        - _Description:_ Behaves like `write_term(Stream, Term,
          [quoted(true), ignore_ops(true)])'. The output of this
          predicate can always be parsed by `read_term/2' even if the
          term contains special characters or if operator
          declarations have changed.

        - _The following properties should hold upon exit:_

          `@Stream' is an open stream.   (`streams_basic:stream/1')

          `?Term' is any term.   (`basic_props:term/1')



 - PREDICATE: write_canonical/1:
     *Usage:* `write_canonical(?Term)' < * ISO * >
        - _Description:_ Behaves like `current_output(S),
          write_canonical(S,Term)'.

        - _The following properties should hold upon exit:_

          `?Term' is any term.   (`basic_props:term/1')



 - PREDICATE: print/2:
     *Usage:* `print(@Stream,?Term)'
        - _Description:_ Behaves like `write_term(Stream, Term,
          [numbervars(true), portrayed(true)])'.

        - _The following properties should hold upon exit:_

          `@Stream' is an open stream.   (`streams_basic:stream/1')

          `?Term' is any term.   (`basic_props:term/1')



 - PREDICATE: print/1:
     *Usage:* `print(?Term)'
        - _Description:_ Behaves like `current_output(S),
          print(S,Term)'.

        - _The following properties should hold upon exit:_

          `?Term' is any term.   (`basic_props:term/1')



 - PREDICATE: write_list1/1:
     *Usage:*
        - _Description:_ Writes a list to current output one element
          in each line.

        - _Call and exit should be _compatible_ with:_

          `Arg1' is a list.   (`basic_props:list/1')



 - PREDICATE: portray_clause/2:
     *Usage:* `portray_clause(@Stream,?Clause)'
        - _Description:_ Outputs the clause `Clause' onto `Stream',
          pretty printing its variables and using indentation,
          including a period at the end. This predicate is used by
          `listing/0'.

        - _The following properties should hold upon exit:_

          `@Stream' is an open stream.   (`streams_basic:stream/1')

          `?Clause' is any term.   (`basic_props:term/1')



 - PREDICATE: portray_clause/1:
     *Usage:* `portray_clause(?Clause)'
        - _Description:_ Behaves like `current_output(S),
          portray_clause(S,Term)'.

        - _The following properties should hold upon exit:_

          `?Clause' is any term.   (`basic_props:term/1')



 - PREDICATE: numbervars/3:
     *Usage:* `numbervars(?Term,+N,?M)'
        - _Description:_ Unifies each of the variables in term `Term'
          with a term of the form `'$VAR'(I)' where `I' is an integer
          from `N' onwards. `M' is unified with the last integer used
          plus 1. If the resulting term is output with a write option
          `numbervars(true)', in the place of the variables in the
          original term will be printed a variable name consisting of
          a capital letter possibly followed by an integer. When `N'
          is 0 you will get the variable names A, B, ..., Z, A1, B1,
          etc.

        - _The following properties should hold upon exit:_

          `?Term' is any term.   (`basic_props:term/1')

          `+N' is currently instantiated to an integer.
          (`term_typing:integer/1')

          `?M' is currently instantiated to an integer.
          (`term_typing:integer/1')



 - PREDICATE: prettyvars/1:
     *Usage:* `prettyvars(?Term)'
        - _Description:_ Similar to `numbervars(Term,0,_)', except
          that singleton variables in `Term' are unified with
          `'$VAR'('_')', so that when the resulting term is output
          with a write option `numbervars(true)', in the place of
          singleton variables `_' is written. This predicate is used
          by `portray_clause/2'.

        - _The following properties should hold upon exit:_

          `?Term' is any term.   (`basic_props:term/1')



 - PREDICATE: printable_char/1:
     No further documentation available for this predicate.





File: ciao.info,  Node: Documentation on multifiles (write),  Prev: Documentation on exports (write),  Up: Term output

Documentation on multifiles (`write')
=====================================

 - PREDICATE: define_flag/3:
     Defines flags as follows:
          define_flag(write_strings,[on,off],off).
     (See *Note Changing system behaviour and various flags::).

     If flag is `on', lists which may be written as strings are.

     The predicate is _multifile_.




 - PREDICATE: portray_attribute/2:
     The predicate is _multifile_.

     *Usage:* `portray_attribute(Attr,Var)'
        - _Description:_ _A user defined predicate._ When an
          attributed variable `Var' is about to be printed, this
          predicate receives the variable and its attribute `Attr'.
          The predicate should either print something based on `Attr'
          or `Var', or do nothing and fail. In the latter case, the
          default printer ( `write/1') will print the attributed
          variable like an unbound variable, e.g. `_673'.

        - _The following properties should hold at call time:_

          `Attr' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')

          `Var' is a free variable.   (`term_typing:var/1')



 - PREDICATE: portray/1:
     The predicate is _multifile_.

     *Usage:* `portray(?Term)'
        - _Description:_ _A user defined predicate._ This should
          either print the `Term' and succeed, or do nothing and
          fail. In the latter case, the default printer (`write/1')
          will print the `Term'.




File: ciao.info,  Node: Defining operators,  Next: iso_byte_char (library),  Prev: Term output,  Up: Top

Defining operators
******************

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 0.9#7 (1999/3/17, 17:29:23 MET)

   Operators allow writting terms in a more clear way than the
standard functional notation. Standard operators in Ciao are defined
by this predicate (but note that the compiler itself defines more
operators at compile time):
     standard_ops :-
             op(1200,xfx,[:-]),
             op(1200,fx,[:-,?-]),
             op(1100,xfy,[;]),
             op(1050,xfy,[->]),
             op(1000,xfy,[',']),
             op(950,xfy,[
             op(950,xf,[
             op(900,fy,[\+]),
             op(700,xfx,[=,\=,==,\==,@<,@>,@=<,@>=,=..,is,=:=,=\=,<,=<,>,>=]),
             op(550,xfx,[:]),
             op(500,yfx,[+,-,/\,\/,#]),
             op(500,fy,[++,--]),
             op(400,yfx,[*,/,//,rem,mod,<<,>>]),
             op(200,fy,[+,-,\]),
             op(200,xfx,[**]),
             op(200,xfy,[^]),
             op(200,xfy,[`]),
             op(25,fy,[^]).

* Menu:

* Usage and interface (operators)::
* Documentation on exports (operators)::


File: ciao.info,  Node: Usage and interface (operators),  Next: Documentation on exports (operators),  Prev: Defining operators,  Up: Defining operators

Usage and interface (`operators')
=================================

   * *Library usage:*

     `:- use_module(library(operators)).'

   * *Exports:*
        - _Predicates:_

          `op/3', `current_op/3', `current_prefixop/3',
          `current_infixop/4', `current_postfixop/3'.




File: ciao.info,  Node: Documentation on exports (operators),  Prev: Usage and interface (operators),  Up: Defining operators

Documentation on exports (`operators')
======================================

 - PREDICATE: op/3:
     `op(Precedence,Type,Name)'

     Declares the atom `Name' to be an operator of the stated `Type'
     and `Precedence' (0 =< `Precedence' =< 1200). `Name' may also be
     a list of atoms in which case all of them are declared to be
     operators. If `Precedence' is 0 then the operator properties of
     `Name' (if any) are cancelled. Note that, unlike in ISO-Prolog,
     it is allowed to define two operators with the same name, one
     infix and the other postfix.




 - PREDICATE: current_op/3:
     `current_op(Precedence,Type,Op)'

     The atom `Op' is currently an operator of type `Type' and
     precedence `Precedence'. Neither `Op' nor the other arguments
     need be instantiated at the time of the call; i.e., this
     predicate can be used to generate as well as to test.




 - PREDICATE: current_prefixop/3:
     No further documentation available for this predicate.




 - PREDICATE: current_infixop/4:
     No further documentation available for this predicate.




 - PREDICATE: current_postfixop/3:
     No further documentation available for this predicate.





File: ciao.info,  Node: iso_byte_char (library),  Next: iso_misc (library),  Prev: Defining operators,  Up: Top

iso_byte_char (library)
***********************

* Menu:

* Usage and interface (iso_byte_char)::
* Documentation on exports (iso_byte_char)::


File: ciao.info,  Node: Usage and interface (iso_byte_char),  Next: Documentation on exports (iso_byte_char),  Prev: iso_byte_char (library),  Up: iso_byte_char (library)

Usage and interface (`iso_byte_char')
=====================================

   * *Library usage:*

     `:- use_module(library(iso_byte_char)).'

   * *Exports:*
        - _Predicates:_

          `char_code/2', `atom_chars/2', `number_chars/2',
          `get_byte/1', `get_byte/2', `peek_byte/1', `peek_byte/2',
          `put_byte/1', `put_byte/2', `get_char/1', `get_char/2',
          `peek_char/1', `peek_char/2', `put_char/1', `put_char/2'.




File: ciao.info,  Node: Documentation on exports (iso_byte_char),  Prev: Usage and interface (iso_byte_char),  Up: iso_byte_char (library)

Documentation on exports (`iso_byte_char')
==========================================

 - PREDICATE: char_code/2:
     No further documentation available for this predicate.




 - PREDICATE: atom_chars/2:
     No further documentation available for this predicate.




 - PREDICATE: number_chars/2:
     No further documentation available for this predicate.




 - PREDICATE: get_byte/1:
     No further documentation available for this predicate.




 - PREDICATE: get_byte/2:
     No further documentation available for this predicate.




 - PREDICATE: peek_byte/1:
     No further documentation available for this predicate.




 - PREDICATE: peek_byte/2:
     No further documentation available for this predicate.




 - PREDICATE: put_byte/1:
     No further documentation available for this predicate.




 - PREDICATE: put_byte/2:
     No further documentation available for this predicate.




 - PREDICATE: get_char/1:
     No further documentation available for this predicate.




 - PREDICATE: get_char/2:
     No further documentation available for this predicate.




 - PREDICATE: peek_char/1:
     No further documentation available for this predicate.




 - PREDICATE: peek_char/2:
     No further documentation available for this predicate.




 - PREDICATE: put_char/1:
     No further documentation available for this predicate.




 - PREDICATE: put_char/2:
     No further documentation available for this predicate.





File: ciao.info,  Node: iso_misc (library),  Next: iso_incomplete (library),  Prev: iso_byte_char (library),  Up: Top

iso_misc (library)
******************

   *Version:* 0.4#5 (1998/2/24)

* Menu:

* Usage and interface (iso_misc)::
* Documentation on exports (iso_misc)::


File: ciao.info,  Node: Usage and interface (iso_misc),  Next: Documentation on exports (iso_misc),  Prev: iso_misc (library),  Up: iso_misc (library)

Usage and interface (`iso_misc')
================================

   * *Library usage:*

     `:- use_module(library(iso_misc)).'

   * *Exports:*
        - _Predicates:_

          `\=/2', `once/1', `compound/1', `sub_atom/5',
          `unify_with_occurs_check/2'.


   * *Other modules used:*
        - _System library modules:_

          `between'.




File: ciao.info,  Node: Documentation on exports (iso_misc),  Prev: Usage and interface (iso_misc),  Up: iso_misc (library)

Documentation on exports (`iso_misc')
=====================================

 - PREDICATE: \=/2:
     No further documentation available for this predicate.




 - PREDICATE: once/1:
     No further documentation available for this predicate.

     _Meta-predicate_ with arguments: `once(goal)'.




 - PREDICATE: compound/1:
     No further documentation available for this predicate.




 - PREDICATE: sub_atom/5:
     No further documentation available for this predicate.




 - PREDICATE: unify_with_occurs_check/2:
     No further documentation available for this predicate.





File: ciao.info,  Node: iso_incomplete (library),  Next: *** PART IV - Classic Prolog library (classic),  Prev: iso_misc (library),  Up: Top

iso_incomplete (library)
************************

* Menu:

* Usage and interface (iso_incomplete)::
* Documentation on exports (iso_incomplete)::


File: ciao.info,  Node: Usage and interface (iso_incomplete),  Next: Documentation on exports (iso_incomplete),  Prev: iso_incomplete (library),  Up: iso_incomplete (library)

Usage and interface (`iso_incomplete')
======================================

   * *Library usage:*

     `:- use_module(library(iso_incomplete)).'

   * *Exports:*
        - _Predicates:_

          `open/4', `close/2', `stream_property/2'.




File: ciao.info,  Node: Documentation on exports (iso_incomplete),  Prev: Usage and interface (iso_incomplete),  Up: iso_incomplete (library)

Documentation on exports (`iso_incomplete')
===========================================

 - PREDICATE: open/4:
     No further documentation available for this predicate.




 - PREDICATE: close/2:
     No further documentation available for this predicate.




 - PREDICATE: stream_property/2:
     No further documentation available for this predicate.





File: ciao.info,  Node: *** PART IV - Classic Prolog library (classic),  Next: Classic Prolog package,  Prev: iso_incomplete (library),  Up: Top

PART IV - Classic Prolog library (classic)
******************************************

   This part documents some Ciao libraries which provide additional
predicates and functionalities that, despite not being in the ISO
standard, are present in many popular Prolog systems. This includes
definite clause grammars (DCGs), "Quintus-style" internal database,
list processing predicates, dictionaries, string processing, DEC-10
Prolog-style input/output, formatted output, dynamic loading of
modules, activation of operators at run-time, etc.


File: ciao.info,  Node: Classic Prolog package,  Next: Definite clause grammars,  Prev: *** PART IV - Classic Prolog library (classic),  Up: Top

Classic Prolog package
**********************

   This library package allows the use of certain Prolog features
which have become sort of 'classical' from many Prolog
implementations. These include definite clause grammars and some
classical predicates like `append/3'. The libraries listed below
define these predicates, and the following chapters describe them.

* Menu:

* Usage and interface (classic)::


File: ciao.info,  Node: Usage and interface (classic),  Prev: Classic Prolog package,  Up: Classic Prolog package

Usage and interface (`classic')
===============================

   * *Library usage:*

     `:- use_package(classic).'

     or

     `:- module(...,...,[classic]).'

   * *New operators defined:*

     `-->/2' [1200,xfx].

   * *Other modules used:*
        - _System library modules:_

          `operators', `old_database', `lists', `sort', `dict',
          `strings', `dec10_io', `format', `ttyout', `dynmods'.




File: ciao.info,  Node: Definite clause grammars,  Next: Definite clause grammars (expansion),  Prev: Classic Prolog package,  Up: Top

Definite clause grammars
************************

   This library package allows the use of DCGs (Definite Clause
Grammars) [Col78,PW80] in a Ciao module/program.

   Definite clause grammars are an extension of the well-known
context-free grammars. Prolog's grammar rules provide a convenient
notation for expressing definite clause grammars. A DCG rule in
Prolog takes the general form

     `head' --> `body'.

meaning "a possible form for `head' is `body'". Both `body' and
`head' are sequences of one or more items linked by the standard
Prolog conjunction operator "`,'".

   Definite clause grammars extend context-free grammars in the
following ways:

  1. A non-terminal symbol may be any Prolog term (other than a
     variable or number).

  2. A terminal symbol may be any Prolog term. To distinguish
     terminals from non-terminals, a sequence of one or more terminal
     symbols is written within a grammar rule as a Prolog list. An
     empty sequence is written as the empty list `[]'. If the
     terminal symbols are ASCII character codes, such lists can be
     written (as elsewhere) as strings. An empty sequence is written
     as the empty list, `[]' or `""'.

  3. Extra conditions, in the form of Prolog procedure calls, may be
     included in the right-hand side of a grammar rule. Such
     procedure calls are written enclosed in `{}' brackets.

  4. The left-hand side of a grammar rule consists of a non-terminal,
     optionally followed by a sequence of terminals (again written as
     a Prolog list).

  5. Alternatives may be stated explicitly in the right-hand side of
     a grammar rule, using the disjunction operator `;' or `|' as in
     Prolog.

  6. The cut symbol may be included in the right-hand side of a
     grammar rule, as in a Prolog clause. The cut symbol does not
     need to be enclosed in `{}' brackets.

   As an example, here is a simple grammar which parses an arithmetic
expression (made up of digits and operators) and computes its value.

     expr(Z) --> term(X), "+", expr(Y), {Z is X + Y}.
     expr(Z) --> term(X), "-", expr(Y), {Z is X - Y}.
     expr(X) --> term(X).
     
     term(Z) --> number(X), "*", term(Y), {Z is X * Y}.
     term(Z) --> number(X), "/", term(Y), {Z is X / Y}.
     term(Z) --> number(Z).
     
     number(C) --> "+", number(C).
     number(C) --> "-", number(X), {C is -X}.
     number(X) --> [C], {0'0=<C, C=<0'9, X is C - 0'0}.

   In the last rule, `C' is the ASCII code of some digit.

   The query

     | ?- expr(Z, "-2+3*5+1", []).

will compute `Z'=14. The two extra arguments are explained below.

   Now, in fact, grammar rules are merely a convenient "syntactic
sugar" for ordinary Prolog clauses. Each grammar rule takes an input
string, analyses some initial portion, and produces the remaining
portion (possibly enlarged) as output for further analysis. The
arguments required for the input and output strings are not written
explicitly in a grammar rule, but the syntax implicitly defines them.
We now show how to translate grammar rules into ordinary clauses by
making explicit the extra arguments.

   A rule such as

     p(X) --> q(X).

translates into

     p(X, S0, S) :- q(X, S0, S).

   If there is more than one non-terminal on the right-hand side, as
in

     p(X, Y) -->
             q(X),
             r(X, Y),
             s(Y).

then corresponding input and output arguments are identified, as in

     p(X, Y, S0, S) :-
             q(X, S0, S1),
             r(X, Y, S1, S2),
             r(Y, S2, S).

   Terminals are translated using the built-in predicate `'C'/3'
(this predicate is not normally useful in itself; it has been given
the name `'C'' simply to avoid using up a more useful name). Then,
for instance

     p(X) --> [go,to], q(X), [stop].

is translated by

     p(X, S0, S) :-
             'C'(S0, go, S1),
             'C'(S1, to, S2),
             q(X, S2, S3),
             'C'(S3, stop, S).

   Extra conditions expressed as explicit procedure calls naturally
translate as themselves, e.g.

     p(X) --> [X], {integer(X), X>0}, q(X).

translates to

     p(X, S0, S) :-
             'C'(S0, X, S1),
             integer(X),
             X>0,
             q(X, S1, S).

   Similarly, a cut is translated literally.

   Terminals on the left-hand side of a rule translate into an
explicit list in the output argument of the main non-terminal, e.g.

     is(N), [not] --> [aint].

becomes

     is(N, S0, [not|S]) :- 'C'(S0, aint, S).

   Disjunction has a fairly obvious translation, e.g.

     args(X, Y) -->
             (   dir(X), [to], indir(Y)
             ;   indir(Y), dir(X)
             ).

translates to

     args(X, Y, S0, S) :-
             (   dir(X, S0, S1),
                 'C'(S1, to, S2),
                 indir(Y, S2, S)
             ;   indir(Y, S0, S1),
                 dir(X, S1, S)
             ).

* Menu:

* Usage and interface (dcg)::


File: ciao.info,  Node: Usage and interface (dcg),  Prev: Definite clause grammars,  Up: Definite clause grammars

Usage and interface (`dcg')
===========================

   * *Library usage:*

     `:- use_package(dcg).'

     or

     `:- module(...,...,[dcg]).'


File: ciao.info,  Node: Definite clause grammars (expansion),  Next: List processing,  Prev: Definite clause grammars,  Up: Top

Definite clause grammars (expansion)
************************************

   *Version:* 0.4#5 (1998/2/24)

* Menu:

* Usage and interface (dcg_expansion)::
* Documentation on exports (dcg_expansion)::


File: ciao.info,  Node: Usage and interface (dcg_expansion),  Next: Documentation on exports (dcg_expansion),  Prev: Definite clause grammars (expansion),  Up: Definite clause grammars (expansion)

Usage and interface (`dcg_expansion')
=====================================

   * *Library usage:*

     `:- use_module(library(dcg_expansion)).'

   * *Exports:*
        - _Predicates:_

          `phrase/2', `phrase/3', `dcg_translation/2'.


   * *Other modules used:*
        - _System library modules:_

          `terms', `assertions/doc_props'.




File: ciao.info,  Node: Documentation on exports (dcg_expansion),  Prev: Usage and interface (dcg_expansion),  Up: Definite clause grammars (expansion)

Documentation on exports (`dcg_expansion')
==========================================

 - PREDICATE: phrase/2:
     `phrase(Phrase,List)'

     Like `phrase(Phrase,List,[])'.

     _Meta-predicate_ with arguments: `phrase(goal,?)'.




 - PREDICATE: phrase/3:
     _Meta-predicate_ with arguments: `phrase(goal,?,?)'.

     *Usage:* `phrase(+Phrase,?List,?Remainder)'
        - _Description:_ The list `List' is a phrase of type `Phrase'
          (according to the current grammar rules), where `Phrase' is
          either a non-terminal or more generally a grammar rule
          body. `Remainder' is what remains of the list after a
          phrase has been found.

        - _The following properties should hold globally:_

          Documentation is still incomplete:
          `phrase(+Phrase,?List,?Remainder)' may not conform the
          functionality documented.   (`doc_props:doc_incomplete/1')



 - PREDICATE: dcg_translation/2:
     Performs the code expansion of source clauses that use DCGs.





File: ciao.info,  Node: List processing,  Next: Sorting lists,  Prev: Definite clause grammars (expansion),  Up: Top

List processing
***************

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#41 (2000/2/4, 13:34:24 CET)

   This module provides a set of predicates for list processing.

* Menu:

* Usage and interface (lists)::
* Documentation on exports (lists)::


File: ciao.info,  Node: Usage and interface (lists),  Next: Documentation on exports (lists),  Prev: List processing,  Up: List processing

Usage and interface (`lists')
=============================

   * *Library usage:*

     `:- use_module(library(lists)).'

   * *Exports:*
        - _Predicates:_

          `nonsingle/1', `append/3', `reverse/2', `reverse/3',
          `delete/3', `select/3', `length/2', `nth/3', `add_after/4',
          `add_before/4', `dlist/3', `list_concat/2', `list_insert/2',
          `insert_last/3', `contains_ro/2', `contains1/2',
          `nocontainsx/2', `last/2', `list_lookup/3', `list_lookup/4',
          `intset_insert/3', `intset_delete/3', `intset_in/2',
          `intset_sequence/3', `intersection/3', `union/3',
          `difference/3', `equal_lists/2', `list_to_list_of_lists/2',
          `powerset/2'.

        - _Properties:_

          `list1/2', `sublist/2', `subordlist/2'.




File: ciao.info,  Node: Documentation on exports (lists),  Prev: Usage and interface (lists),  Up: List processing

Documentation on exports (`lists')
==================================

 - PREDICATE: nonsingle/1:
     *Usage:* `nonsingle(X)'
        - _Description:_ `X' is not a singleton.



 - PREDICATE: append/3:
     *Usage:* `append(Xs,Ys,Zs)'
        - _Description:_ `Zs' is `Ys' appended to `Xs'.



 - PREDICATE: reverse/2:
     *Usage:* `reverse(Xs,Ys)'
        - _Description:_ Reverses the order of elements in `Xs'.

        - _The following properties should hold at call time:_

          `Xs' is a list.   (`basic_props:list/1')

          `Ys' is a free variable.   (`term_typing:var/1')

        - _The following properties should hold upon exit:_

          `Xs' is a list.   (`basic_props:list/1')

          `Ys' is a list.   (`basic_props:list/1')



 - PREDICATE: reverse/3:
     No further documentation available for this predicate.




 - PREDICATE: delete/3:
     *Usage:* `delete(L1,E,L2)'
        - _Description:_ `L2' is `L1' without the ocurrences of `E'.



 - PREDICATE: select/3:
     *Usage:* `select(X,Xs,Ys)'
        - _Description:_ `Xs' and `Ys' have the same elements except
          for one occurrence of `X'.



 - PREDICATE: length/2:
     *Usage 1:* `length(L,N)'
        - _Description:_ Computes the length of `L'.

        - _The following properties should hold at call time:_

          `L' is a list.   (`basic_props:list/1')

          `N' is a free variable.   (`term_typing:var/1')

        - _The following properties should hold upon exit:_

          `L' is a list.   (`basic_props:list/1')

          `N' is currently instantiated to an integer.
          (`term_typing:integer/1')

     *Usage 2:* `length(L,N)'
        - _Description:_ Outputs `L' of length `N'.

        - _The following properties should hold at call time:_

          `L' is a free variable.   (`term_typing:var/1')

          `N' is currently instantiated to an integer.
          (`term_typing:integer/1')

        - _The following properties should hold upon exit:_

          `L' is a list.   (`basic_props:list/1')

          `N' is currently instantiated to an integer.
          (`term_typing:integer/1')

     *Usage 3:* `length(L,N)'
        - _Description:_ Checks that `L' is of length `N'.

        - _The following properties should hold at call time:_

          `L' is a list.   (`basic_props:list/1')

          `N' is currently instantiated to an integer.
          (`term_typing:integer/1')

        - _The following properties should hold upon exit:_

          `L' is a list.   (`basic_props:list/1')

          `N' is currently instantiated to an integer.
          (`term_typing:integer/1')



 - PREDICATE: nth/3:
     `nth(N,List,Elem)'

     `N' is the position in `List' of `Elem'. `N' counts from one.

     *Usage 1:* `nth(+int,?list,?term)'
        - _Description:_ Unifies `Elem' and the `N'th element of
          `List'.

     *Usage 2:* `nth(-int,?list,?term)'
        - _Description:_ Finds the positions where `Elem' is in
          `List'. Positions are found in ascending order.



 - PREDICATE: add_after/4:
     *Usage:* `add_after(+L0,+E0,+E,-L)'
        - _Description:_ Adds element `E' after element `E0' (or at
          end) to list `L0' returning in `L' the new list (uses term
          comparison).



 - PREDICATE: add_before/4:
     No further documentation available for this predicate.




 - PROPERTY: list1/2:
     _Meta-predicate_ with arguments: `list1(?,pred(1))'.

     *Usage:* `list1(X,Y)'
        - _Description:_ `X' is a list of `Y's of at least one
          element.



 - PREDICATE: dlist/3:
     *Usage:* `dlist(List,DList,Tail)'
        - _Description:_ `List' is the result of removing `Tail' from
          the end of `DList' (makes a difference list from a list).



 - PREDICATE: list_concat/2:
     *Usage:* `list_concat(LL,L)'
        - _Description:_ `L' is the concatenation of all the lists in
          `LL'.

        - _Call and exit should be _compatible_ with:_

          `LL' is a list of `list's.   (`basic_props:list/2')

          `L' is a list.   (`basic_props:list/1')



 - PREDICATE: list_insert/2:
     *Usage:* `list_insert(-List,+Term)'
        - _Description:_ Adds `Term' to the end of `List' if there is
          no element in `List' identical to `Term'.



 - PREDICATE: insert_last/3:
     *Usage:* `insert_last(+L0,+E,-L)'
        - _Description:_ Adds element `E' at end of list `L0'
          returning `L'.



 - PREDICATE: contains_ro/2:
     *Usage:*
        - _Description:_ Impure membership (does not instantiate a
          variable in its first argument.



 - PREDICATE: contains1/2:
     No further documentation available for this predicate.




 - PREDICATE: nocontainsx/2:
     *Usage:* `nocontainsx(L,X)'
        - _Description:_ `X' is not identical to any element of `L'.



 - PREDICATE: last/2:
     *Usage:* `last(L,X)'
        - _Description:_ X is the last element of L.



 - PREDICATE: list_lookup/3:
     No further documentation available for this predicate.




 - PREDICATE: list_lookup/4:
     *Usage:* `list_lookup(List,Functor,Key,Value)'
        - _Description:_ Look up `Functor'(`Key',`Value') pair in
          variable ended key-value pair list `L' or else add it at
          the end.



 - PREDICATE: intset_insert/3:
     No further documentation available for this predicate.




 - PREDICATE: intset_delete/3:
     No further documentation available for this predicate.




 - PREDICATE: intset_in/2:
     No further documentation available for this predicate.




 - PREDICATE: intset_sequence/3:
     No further documentation available for this predicate.




 - PREDICATE: intersection/3:
     *Usage:* `intersection(+List1,+List2,-List)'
        - _Description:_ `List' has the elements which are both in
          `List1' and `List2'.



 - PREDICATE: union/3:
     *Usage:* `union(+List1,+List2,-List)'
        - _Description:_ `List' has the elements which are in `List1'
          followed by the elements which are in `List2' but not in
          `List1'.



 - PREDICATE: difference/3:
     *Usage:* `difference(+List1,+List2,-List)'
        - _Description:_ `List' has the elements which are in `List1'
          but not in `List2'.



 - PROPERTY: sublist/2:
     *Usage:* `sublist(List1,List2)'
        - _Description:_ `List2' contains all the elements of `List1'.

        - _If the following properties should hold at call time:_

          `List2' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')



 - PROPERTY: subordlist/2:
     *Usage:* `subordlist(List1,List2)'
        - _Description:_ `List2' contains all the elements of `List1'
          in the same order.

        - _If the following properties should hold at call time:_

          `List2' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')



 - PREDICATE: equal_lists/2:
     *Usage:* `equal_lists(+List1,+List2)'
        - _Description:_ `List1' has all the elements of `List2', and
          vice versa.



 - PREDICATE: list_to_list_of_lists/2:
     *Usage:* `list_to_list_of_lists(+List,-LList)'
        - _Description:_ `LList' is the list of one element lists
          with elements of `List'.



 - PREDICATE: powerset/2:
     *Usage:* `powerset(+List,-LList)'
        - _Description:_ `LList' is the powerset of `List', i.e., the
          list of all lists which have elements of `List'. If `List'
          is ordered, `LList' and all its elements are ordered.




File: ciao.info,  Node: Sorting lists,  Next: Dictionaries,  Prev: List processing,  Up: Top

Sorting lists
*************

   *Author(s):* Richard A. O'Keefe. All changes by UPM CLIP Group..

   *Version:* 0.4#5 (1998/2/24)

* Menu:

* Usage and interface (sort)::
* Documentation on exports (sort)::
* Documentation on internals (sort)::


File: ciao.info,  Node: Usage and interface (sort),  Next: Documentation on exports (sort),  Prev: Sorting lists,  Up: Sorting lists

Usage and interface (`sort')
============================

   * *Library usage:*

     `:- use_module(library(sort)).'

   * *Exports:*
        - _Predicates:_

          `sort/2', `keysort/2'.




File: ciao.info,  Node: Documentation on exports (sort),  Next: Documentation on internals (sort),  Prev: Usage and interface (sort),  Up: Sorting lists

Documentation on exports (`sort')
=================================

 - PREDICATE: sort/2:
     `sort(List1,List2)'

     The elements of `List1' are sorted into the standard order (see
     *Note Comparing terms::) and any identical elements are merged,
     yielding `List2'. The time and space complexity of this
     operation is at worst `O(N lg N)' where `N' is the length of
     `List1'.

     *Usage:* `sort(+list,?list)'
        - _Description:_ `List2' is the sorted list corresponding to
          `List1'.



 - PREDICATE: keysort/2:
     `keysort(List1,List2)'

     `List1' is sorted into order according to the value of the
     _keys_ of its elements, yielding the list `List2'. No merging
     takes place. This predicate is _stable_, i.e., if an element `A'
     occurs before another element `B' _with the same key_ in the
     input, then `A' will occur before `B' also in the output. The
     time and space complexity of this operation is at worst `O(N lg
     N)' where `N' is the length of `List1'.

     *Usage:* `keysort(+keylist,?keylist)'
        - _Description:_ `List2' is the (key-)sorted list
          corresponding to `List1'.




File: ciao.info,  Node: Documentation on internals (sort),  Prev: Documentation on exports (sort),  Up: Sorting lists

Documentation on internals (`sort')
===================================

 - REGTYPE: keypair/1:
     *Usage:* `keypair(P)'
        - _Description:_ `P' is a pair of the form "`K-_'", where `K'
          is considered the _key_.




File: ciao.info,  Node: Dictionaries,  Next: String processing,  Prev: Sorting lists,  Up: Top

Dictionaries
************

   *Version:* 0.4#5 (1998/2/24)

   This module provides predicates for implementing dictionaries.
Such dictionaries are currently implemented as ordered binary trees.

* Menu:

* Usage and interface (dict)::
* Documentation on exports (dict)::


File: ciao.info,  Node: Usage and interface (dict),  Next: Documentation on exports (dict),  Prev: Dictionaries,  Up: Dictionaries

Usage and interface (`dict')
============================

   * *Library usage:*

     `:- use_module(library(dict)).'

   * *Exports:*
        - _Predicates:_

          `dic_node/2', `dic_lookup/3', `dic_lookup/4', `dic_get/3',
          `dic_replace/4'.




File: ciao.info,  Node: Documentation on exports (dict),  Prev: Usage and interface (dict),  Up: Dictionaries

Documentation on exports (`dict')
=================================

 - PREDICATE: dic_node/2:
     No further documentation available for this predicate.




 - PREDICATE: dic_lookup/3:
     No further documentation available for this predicate.




 - PREDICATE: dic_lookup/4:
     No further documentation available for this predicate.




 - PREDICATE: dic_get/3:
     No further documentation available for this predicate.




 - PREDICATE: dic_replace/4:
     No further documentation available for this predicate.





File: ciao.info,  Node: String processing,  Next: Formatted output,  Prev: Dictionaries,  Up: Top

String processing
*****************

   *Author(s):* Daniel Cabeza.

   *Version:* 0.4#5 (1998/2/24)

   This module provides predicates for doing input/output with
strings (character code lists) and for including in grammars defining
strings.

* Menu:

* Usage and interface (strings)::
* Documentation on exports (strings)::
* Documentation on internals (strings)::


File: ciao.info,  Node: Usage and interface (strings),  Next: Documentation on exports (strings),  Prev: String processing,  Up: String processing

Usage and interface (`strings')
===============================

   * *Library usage:*

     `:- use_module(library(strings)).'

   * *Exports:*
        - _Predicates:_

          `get_line/2', `get_line/1', `write_string/2',
          `write_string/1', `whitespace/2', `whitespace0/2',
          `string/3'.




File: ciao.info,  Node: Documentation on exports (strings),  Next: Documentation on internals (strings),  Prev: Usage and interface (strings),  Up: String processing

Documentation on exports (`strings')
====================================

 - PREDICATE: get_line/2:
     `get_line(Stream,Line)'

     Reads from `Stream' a line of text and unifies `Line' with it.
     The end of the line can have UNIX [10] or MS-DOS [13 10]
     termination, which is not included in `Line'. At EOF, the term
     end_of_file is returned.




 - PREDICATE: get_line/1:
     `get_line(Line)'

     Behaves like `current_input(S), get_line(S,Line)'.




 - PREDICATE: write_string/2:
     `write_string(Stream,String)'

     Writes `String' onto `Stream'.




 - PREDICATE: write_string/1:
     `write_string(String)'

     Behaves like `current_input(S), write_string(S, String)'.




 - PREDICATE: whitespace/2:
     `whitespace(String,Rest)'

     In a grammar rule, as `whitespace/0', represents whitespace (a
     positive number of space (32), tab (9), newline (10) or return
     (13) characters). Thus, `Rest' is a proper suffix of `String'
     with one or more whitespace characters removed. An example of
     use would be:
             attrs([]) --> ""
             attrs([N|Ns]) -->
                 whitespace,
                 attr(N),
                 attrs(Ns).




 - PREDICATE: whitespace0/2:
     `whitespace0(String,Rest)'

     In a grammar rule, as `whitespace0/0', represents possible
     whitespace (any number of space (32), tab (9), newline (10) or
     return (13) characters). Thus, `Rest' is `String' or a proper
     suffix of `String' with one or more whitespace characters
     removed. An example of use would be:

             assignment(N,V) -->
                 variable_name(N), whitespace0, "=", whitespace0, value(V).




 - PREDICATE: string/3:
     `string(String,Head,Tail)'

     In a grammar rule, as `string/1', represents literally `String'.
     An example of use would be:

          double(A) -->
                  string(A),
                  string(A).





File: ciao.info,  Node: Documentation on internals (strings),  Prev: Documentation on exports (strings),  Up: String processing

Documentation on internals (`strings')
======================================

 - PROPERTY: line/1:
     A property, defined as follows:
               line(L) :-
                       string(L).
               line(end_of_file).





File: ciao.info,  Node: Formatted output,  Next: DEC-10 Prolog file IO,  Prev: String processing,  Up: Top

Formatted output
****************

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.3#27 (1999/7/9, 20:25:50 MEST)

   The `format' family of predicates is due to Quintus Prolog. They
act as a Prolog interface to the C `stdio' function `printf()',
allowing formatted output.

   Output is formatted according to an output pattern which can have
either a format control sequence or any other character, which will
appear verbatim in the output. Control sequences act as place-holders
for the actual terms that will be output. Thus
             ?- format("Hello ~q!",world).

will print `Hello world!'.

   If there is only one item to print it may be supplied alone. If
there are more they have to be given as a list. If there are none
then an empty list should be supplied. There has to be as many items
as control characters.

   The character `~' introduces a control sequence. To print a `~'
verbatim just repeat it:
             ?- format("Hello ~~world!", []).

will result in `Hello ~world!'.

   A format may be spread over several lines. The control sequence
`\c' followed by a <LFD> will translate to the empty string:
             ?- format("Hello \c
             world!", []).

will result in `Hello world!'.

* Menu:

* Usage and interface (format)::
* Documentation on exports (format)::


File: ciao.info,  Node: Usage and interface (format),  Next: Documentation on exports (format),  Prev: Formatted output,  Up: Formatted output

Usage and interface (`format')
==============================

   * *Library usage:*

     `:- use_module(library(format)).'

   * *Exports:*
        - _Predicates:_

          `format/2', `format/3'.

        - _Regular Types:_

          `format_control/1'.


   * *Other modules used:*
        - _System library modules:_

          `write', `assertions/doc_props'.




File: ciao.info,  Node: Documentation on exports (format),  Prev: Usage and interface (format),  Up: Formatted output

Documentation on exports (`format')
===================================

 - PREDICATE: format/2:
     *Usage:* `format(Format,Arguments)'
        - _Description:_ Print `Arguments' onto current output stream
          according to format `Format'.

        - _Call and exit should be _compatible_ with:_

          `Format' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')



 - PREDICATE: format/3:
     *Usage:* `format(+Stream,Format,Arguments)'
        - _Description:_ Print `Arguments' onto `Stream' according to
          format `Format'.

        - _Call and exit should be _compatible_ with:_

          `Format' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')



 - REGTYPE: format_control/1:
     The general format of a control sequence is `~`N'`C''. The
     character `C' determines the type of the control sequence. `N'
     is an optional numeric argument. An alternative form of `N' is
     `*'. `*' implies that the next argument in `Arguments' should be
     used as a numeric argument in the control sequence. Example:

          ?- format("Hello~4cworld!", [0'x]).

     and

          ?- format("Hello~*cworld!", [4,0'x]).

     both produce

          Helloxxxxworld!

     The following control sequences are available.

        * ~a The argument is an atom. The atom is printed without
          quoting.

        * ~`N'c (Print character.) The argument is a number that will
          be interpreted as an ASCII code. `N' defaults to one and is
          interpreted as the number of times to print the character.

        * ~`N'e

        * ~`N'E

        * ~`N'f

        * ~`N'g

        * ~`N'G (Print float). The argument is a float. The float and
          `N' will be passed to the C `printf()' function as

               printf("%.`N'e", `Arg')
               printf("%.`N'E", `Arg')
               printf("%.`N'f", `Arg')
               printf("%.`N'g", `Arg')
               printf("%.`N'G", `Arg')

          If `N' is not supplied the action defaults to

               printf("%e", `Arg')
               printf("%E", `Arg')
               printf("%f", `Arg')
               printf("%g", `Arg')
               printf("%G", `Arg')

        * ~`N'd (Print decimal.) The argument is an integer. `N' is
          interpreted as the number of digits after the decimal
          point. If `N' is 0 or missing, no decimal point will be
          printed. Example:

               ?- format("Hello ~1d world!", [42]).
               ?- format("Hello ~d world!", [42]).

          will print as

               Hello 4.2 world!
               Hello 42 world!

          respectively.

        * ~`N'D (Print decimal.) The argument is an integer.
          Identical to `~`N'd' except that `,' will separate groups
          of three digits to the left of the decimal point. Example:

               ?- format("Hello ~1D world!", [12345]).

          will print as

               Hello 1,234.5 world!

        * ~`N'r (Print radix.) The argument is an integer. `N' is
          interpreted as a radix. `N' should be >= 2 and <= 36. If
          `N' is missing the radix defaults to 8. The letters `a-z'
          will denote digits larger than 9. Example:

               ?- format("Hello ~2r world!", [15]).
               ?- format("Hello ~16r world!", [15]).

          will print as

               Hello 1111 world!
               Hello f world!

          respectively.

        * ~`N'R (Print radix.) The argument is an integer. Identical
          to `~`N'r' except that the letters `A-Z' will denote digits
          larger than 9. Example:

               ?- format("Hello ~16R world!", [15]).

          will print as

               Hello F world!

        * ~`N's (Print string.) The argument is a list of ASCII
          codes. Exactly `N' characters will be printed. `N' defaults
          to the length of the string. Example:

               ?- format("Hello ~4s ~4s!", ["new","world"]).
               ?- format("Hello ~s world!", ["new"]).

          will print as

               Hello new  worl!
               Hello new world!

          respectively.

        * ~i (Ignore argument.) The argument may be of any type. The
          argument will be ignored. Example:

               ?- format("Hello ~i~s world!", ["old","new"]).

          will print as

               Hello new world!

        * ~k (Print canonical.) The argument may be of any type. The
          argument will be passed to `write_canonical/2' (*Note Term
          output::). Example:

               ?- format("Hello ~k world!", [[a,b,c]]).

          will print as

               Hello .(a,.(b,.(c,[]))) world!

        * ~p (print.) The argument may be of any type. The argument
          will be passed to `print/2' (*Note Term output::). Example:

          suposing the user has defined the predicate

               portray([X|Y]) :- print(cons(X,Y)).

          then

               ?- format("Hello ~p world!", [[a,b,c]]).

          will print as

               Hello cons(a,cons(b,cons(c,[]))) world!

        * ~q (Print quoted.) The argument may be of any type. The
          argument will be passed to `writeq/2' (*Note Term
          output::). Example:

               ?- format("Hello ~q world!", [['A','B']]).

          will print as

               Hello ['A','B'] world!

        * ~w (write.) The argument may be of any type. The argument
          will be passed to `write/2' (*Note Term output::). Example:

               ?- format("Hello ~w world!", [['A','B']]).

          will print as

               Hello [A,B] world!

        * ~`N'n (Print newline.) Print `N' newlines. `N' defaults to
          1. Example:

               ?- format("Hello ~n world!", []).

          will print as

               Hello
                world!

        * ~N (Fresh line.) Print a newline, if not already at the
          beginning of a line.

     The following control sequences are also available for
     compatibility, but do not perform any useful functions.

        * ~`N'| (Set tab.) Set a tab stop at position `N', where `N'
          defaults to the current position, and advance the current
          position there.

        * ~`N'+ (Advance tab.) Set a tab stop at `N' positions past
          the current position, where `N' defaults to 8, and advance
          the current position there.

        * ~`N't (Set fill character.) Set the fill character to be
          used in the next position movement to `N', where `N'
          defaults to <SPC>.

     *Usage:* `format_control(C)'
        - _Description:_ `C' is an atom or string describing how the
          arguments should be formatted. If it is an atom it will be
          converted into a string with `name/2'.

        - _The following properties should hold globally:_

          Documentation is still incomplete: `format_control(C)' may
          not conform the functionality documented.
          (`doc_props:doc_incomplete/1')




File: ciao.info,  Node: DEC-10 Prolog file IO,  Next: ttyout (library),  Prev: Formatted output,  Up: Top

DEC-10 Prolog file IO
*********************

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 0.4#5 (1998/2/24)

   This module implements the support for DEC-10 Prolog style file
I/O.

* Menu:

* Usage and interface (dec10_io)::
* Documentation on exports (dec10_io)::


File: ciao.info,  Node: Usage and interface (dec10_io),  Next: Documentation on exports (dec10_io),  Prev: DEC-10 Prolog file IO,  Up: DEC-10 Prolog file IO

Usage and interface (`dec10_io')
================================

   * *Library usage:*

     `:- use_module(library(dec10_io)).'

   * *Exports:*
        - _Predicates:_

          `see/1', `seeing/1', `seen/0', `tell/1', `telling/1',
          `told/0', `close_file/1'.


   * *Other modules used:*
        - _System library modules:_

          `streams'.




File: ciao.info,  Node: Documentation on exports (dec10_io),  Prev: Usage and interface (dec10_io),  Up: DEC-10 Prolog file IO

Documentation on exports (`dec10_io')
=====================================

 - PREDICATE: see/1:
     No further documentation available for this predicate.




 - PREDICATE: seeing/1:
     No further documentation available for this predicate.




 - PREDICATE: seen/0:
     No further documentation available for this predicate.




 - PREDICATE: tell/1:
     No further documentation available for this predicate.




 - PREDICATE: telling/1:
     No further documentation available for this predicate.




 - PREDICATE: told/0:
     No further documentation available for this predicate.




 - PREDICATE: close_file/1:
     No further documentation available for this predicate.





File: ciao.info,  Node: ttyout (library),  Next: dynmods (library),  Prev: DEC-10 Prolog file IO,  Up: Top

ttyout (library)
****************

   *Version:* 0.4#5 (1998/2/24)

* Menu:

* Usage and interface (ttyout)::
* Documentation on exports (ttyout)::


File: ciao.info,  Node: Usage and interface (ttyout),  Next: Documentation on exports (ttyout),  Prev: ttyout (library),  Up: ttyout (library)

Usage and interface (`ttyout')
==============================

   * *Library usage:*

     `:- use_module(library(ttyout)).'

   * *Exports:*
        - _Predicates:_

          `ttyget/1', `ttyget1/1', `ttynl/0', `ttyput/1', `ttyskip/1',
          `ttytab/1', `ttyflush/0', `ttydisplay/1', `ttydisplayq/1',
          `ttyskipeol/0', `ttydisplay_string/1'.




File: ciao.info,  Node: Documentation on exports (ttyout),  Prev: Usage and interface (ttyout),  Up: ttyout (library)

Documentation on exports (`ttyout')
===================================

 - PREDICATE: ttyget/1:
     No further documentation available for this predicate.




 - PREDICATE: ttyget1/1:
     No further documentation available for this predicate.




 - PREDICATE: ttynl/0:
     No further documentation available for this predicate.




 - PREDICATE: ttyput/1:
     No further documentation available for this predicate.




 - PREDICATE: ttyskip/1:
     No further documentation available for this predicate.




 - PREDICATE: ttytab/1:
     No further documentation available for this predicate.




 - PREDICATE: ttyflush/0:
     No further documentation available for this predicate.




 - PREDICATE: ttydisplay/1:
     No further documentation available for this predicate.




 - PREDICATE: ttydisplayq/1:
     No further documentation available for this predicate.




 - PREDICATE: ttyskipeol/0:
     No further documentation available for this predicate.




 - PREDICATE: ttydisplay_string/1:
     No further documentation available for this predicate.





File: ciao.info,  Node: dynmods (library),  Next: Quintus-like internal database,  Prev: ttyout (library),  Up: Top

dynmods (library)
*****************

* Menu:

* Usage and interface (dynmods)::
* Documentation on exports (dynmods)::


File: ciao.info,  Node: Usage and interface (dynmods),  Next: Documentation on exports (dynmods),  Prev: dynmods (library),  Up: dynmods (library)

Usage and interface (`dynmods')
===============================

   * *Library usage:*

     `:- use_module(library(dynmods)).'

   * *Exports:*
        - _Predicates:_

          `use_module/1'.


   * *Other modules used:*
        - _System library modules:_

          `aggregates', `dynamic', `iso_misc', `iso_byte_char',
          `iso_incomplete', `operators', `read', `write',
          `compiler/compiler'.




File: ciao.info,  Node: Documentation on exports (dynmods),  Prev: Usage and interface (dynmods),  Up: dynmods (library)

Documentation on exports (`dynmods')
====================================

 - PREDICATE: use_module/1:
     No further documentation available for this predicate.

     _Meta-predicate_ with arguments: `use_module(addmodule)'.





File: ciao.info,  Node: Quintus-like internal database,  Next: runtime_ops (library),  Prev: dynmods (library),  Up: Top

Quintus-like internal database
******************************

   *Version:* 0.4#5 (1998/2/24)

   The predicates described in this section were introduced in early
implementations of Prolog to provide efficient means of performing
operations on large quantities of data. The introduction of indexed
dynamic predicates have rendered these predicates obsolete, and the
sole purpose of providing them is to support existing code. There is
no reason whatsoever to use them in new code.

   These predicates store arbitrary terms in the database without
interfering with the clauses which make up the program. The terms
which are stored in this way can subsequently be retrieved via the
key on which they were stored. Many terms may be stored on the same
key, and they can be individually accessed by pattern matching.
Alternatively, access can be achieved via a special identifier which
uniquely identifies each recorded term and which is returned when the
term is stored.

* Menu:

* Usage and interface (old_database)::
* Documentation on exports (old_database)::


File: ciao.info,  Node: Usage and interface (old_database),  Next: Documentation on exports (old_database),  Prev: Quintus-like internal database,  Up: Quintus-like internal database

Usage and interface (`old_database')
====================================

   * *Library usage:*

     `:- use_module(library(old_database)).'

   * *Exports:*
        - _Predicates:_

          `recorda/3', `recordz/3', `recorded/3', `current_key/2'.




File: ciao.info,  Node: Documentation on exports (old_database),  Prev: Usage and interface (old_database),  Up: Quintus-like internal database

Documentation on exports (`old_database')
=========================================

 - PREDICATE: recorda/3:
     `recorda(+Key,?Term,-Ref)'

     The term `Term' is recorded in the internal database as the
     first item for the key `Key', where `Ref' is its
     implementation-defined identifier. The key must be given, and
     only its principal functor is significant. Any uninstantiated
     variables in the `Term' will be replaced by new private
     variables, along with copies of any subgoals blocked on these
     variables.




 - PREDICATE: recordz/3:
     `recordz(+Key,?Term,-Ref)'

     Like `recorda/3', except that the new term becomes the _last_
     item for the key `Key'.




 - PREDICATE: recorded/3:
     `recorded(?Key,?Term,?Ref)'

     The internal database is searched for terms recorded under the
     key `Key'. These terms are successively unified with `Term' in
     the order they occur in the database. At the same time, `Ref' is
     unified with the implementation-defined identifier uniquely
     identifying the recorded item. If the key is instantiated to a
     compound term, only its principal functor is significant. If the
     key is uninstantiated, all terms in the database are
     successively unified with `Term' in the order they occur.




 - PREDICATE: current_key/2:
     `current_key(?KeyName,?KeyTerm)'

     `KeyTerm' is the most general form of the key for a currently
     recorded term, and `KeyName' is the name of that key. This
     predicate can be used to enumerate in undefined order all keys
     for currently recorded terms through backtracking.





File: ciao.info,  Node: runtime_ops (library),  Next: *** PART V - Annotated Prolog library (assertions),  Prev: Quintus-like internal database,  Up: Top

runtime_ops (library)
*********************

* Menu:

* Usage and interface (runtime_ops)::


File: ciao.info,  Node: Usage and interface (runtime_ops),  Prev: runtime_ops (library),  Up: runtime_ops (library)

Usage and interface (`runtime_ops')
===================================

   * *Library usage:*

     `:- use_package(runtime_ops).'

     or

     `:- module(...,...,[runtime_ops]).'

   * *Other modules used:*
        - _System library modules:_

          `operators', `aggregates', `dynamic', `iso_misc',
          `iso_byte_char', `iso_incomplete', `read', `write'.




File: ciao.info,  Node: *** PART V - Annotated Prolog library (assertions),  Next: The Ciao assertion package,  Prev: runtime_ops (library),  Up: Top

PART V - Annotated Prolog library (assertions)
**********************************************

   Ciao allows _annotating_ the program code with _assertions_. Such
assertions include type and instantiation mode declarations, but also
more general properties as well as comments in the style of the
_literate programming_. These assertions document predicates (and
modules and whole applications) and can be used by the Ciao
preprocessor/compiler while debugging and optimizing the program or
library, and by the Ciao documenter to build the program or library
reference manual.


File: ciao.info,  Node: The Ciao assertion package,  Next: Types and properties related to assertions,  Prev: *** PART V - Annotated Prolog library (assertions),  Up: Top

The Ciao assertion package
**************************

   *Author(s):* Manuel Hermenegildo, Francisco Bueno, German Puebla.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#8 (1999/12/9, 21:1:11 MET)

   The `assertions' package adds a number of new declaration
definitions and new operator definitions which allow including
program assertions in user programs. Such assertions can be used to
describe predicates, properties, modules, applications, etc. These
descriptions can be formal specifications (such as preconditions and
post-conditions) or machine-readable textual comments.

   This module is part of the `assertions' library. It defines the
basic code-related assertions, i.e., those intended to be used mainly
by compilation-related tools, such as the static analyzer or the
run-time test generator.

   Giving specifications for predicates and other program elements is
the main functionality documented here. The exact syntax of comments
is described in the autodocumenter ( `lpdoc' [Knu84,Her99]) manual,
although some support for adding machine-readable comments in
assertions is also mentioned here.

   There are two kinds of assertions: predicate assertions and
program point assertions. All predicate assertions are currently
placed as directives in the source code, i.e., preceded by "`:-'".
Program point assertions are placed as goals in clause bodies.

* Menu:

* More info::
* Some attention points::
* Usage and interface (assertions)::
* Documentation on new declarations (assertions)::
* Documentation on exports (assertions)::


File: ciao.info,  Node: More info,  Next: Some attention points,  Prev: The Ciao assertion package,  Up: The Ciao assertion package

More info
=========

   The facilities provided by the library are documented in the
description of its component modules. This documentation is intended
to provide information only at a "reference manual" level. For a more
tutorial introduction to the subject and some more examples please
see the document "An Assertion Language for Debugging of Constraint
Logic Programs (Technical Report CLIP2/97.1)". The assertion language
implemented in this library is modeled after this design document,
although, due to implementation issues, it may differ in some
details. The purpose of this manual is to document precisely what the
implementation of the library supports at any given point in time.


File: ciao.info,  Node: Some attention points,  Next: Usage and interface (assertions),  Prev: More info,  Up: The Ciao assertion package

Some attention points
=====================

   * *Formatting commands within text strings:* many of the
     predicates defined in these modules include arguments intended
     for providing textual information. This includes titles,
     descriptions, comments, etc. The type of this argument is a
     character string. In order for the automatic generation of
     documentation to work correctly, this character string should
     adhere to certain conventions. See the description of the
     `docstring/1' type/grammar for details.

   * *Referring to variables:* In order for the automatic
     documentation system to work correctly, variable names (for
     example, when referring to arguments in the head patterns of
     _pred_ declarations) must be surrounded by an `@var' command.
     For example, `@var{VariableName}' should be used for referring
     to the variable "VariableName", which will appear then formatted
     as follows: `VariableName'. See the description of the
     `docstring/1' type/grammar for details.



File: ciao.info,  Node: Usage and interface (assertions),  Next: Documentation on new declarations (assertions),  Prev: Some attention points,  Up: The Ciao assertion package

Usage and interface (`assertions')
==================================

   * *Library usage:*

     The recommended procedure in order to make use of assertions in
     user programs is to include the `assertions' syntax library,
     using one of the following declarations, as appropriate:

             :- module(...,...,[assertions]).
             :- include(library(assertions)).
             :- use_package([assertions]).

   * *Exports:*
        - _Predicates:_

          `check/1', `trust/1', `true/1', `false/1'.


   * *New operators defined:*

     `=>/2' [975,xfx], `::/2' [978,xfx], `decl/1' [1150,fx], `decl/2'
     [1150,xfx], `pred/1' [1150,fx], `pred/2' [1150,xfx], `prop/1'
     [1150,fx], `prop/2' [1150,xfx], `modedef/1' [1150,fx], `calls/1'
     [1150,fx], `calls/2' [1150,xfx], `success/1' [1150,fx],
     `success/2' [1150,xfx], `comp/1' [1150,fx], `comp/2' [1150,xfx],
     `entry/1' [1150,fx].

   * *New declarations defined:*

     `pred/1', `pred/2', `calls/1', `calls/2', `success/1',
     `success/2', `comp/1', `comp/2', `prop/1', `prop/2', `entry/1',
     `modedef/1', `decl/1', `decl/2', `comment/2'.

   * *Other modules used:*
        - _System library modules:_

          `assertions/assertions_props'.




File: ciao.info,  Node: Documentation on new declarations (assertions),  Next: Documentation on exports (assertions),  Prev: Usage and interface (assertions),  Up: The Ciao assertion package

Documentation on new declarations (`assertions')
================================================

 - DECLARATION: pred/1:
     This assertion provides information on a predicate. The body of
     the assertion (its only argument) contains properties or
     comments in the formats defined by `assrt_body/1'.

     More than one of these assertions may appear per predicate, in
     which case each one represents a possible " mode" of use (
     usage) of the predicate. The exact scope of the usage is defined
     by the properties given for calls in the body of each assertion
     (which should thus distinguish the different usages intended).
     All of them together cover all possible modes of usage.

     For example, the following assertions describe (all the and the
     only) modes of usage of predicate `length/2' (see `lists'):
          :- pred length(L,N) : list * var => list * integer
          	# "Computes the length of `L'.".
          :- pred length(L,N) : var * integer => list * integer
          	# "Outputs `L' of length `N'.".
          :- pred length(L,N) : list * integer => list * integer
          	# "Checks that `L' is of length `N'.".

     *Usage:* :- `pred(AssertionBody)'.
        - _The following properties should hold at call time:_

          `AssertionBody' is an assertion body.
          (`assertions_props:assrt_body/1')



 - DECLARATION: pred/2:
     This assertion is similar to a `pred/1' assertion but it is
     explicitely qualified. Non-qualified `pred/1' assertions are
     assumed the qualifier `check'.

     *Usage:* :- `pred(AssertionStatus,AssertionBody)'.
        - _The following properties should hold at call time:_

          `AssertionStatus' is an acceptable status for an assertion.
          (`assertions_props:assrt_status/1')

          `AssertionBody' is an assertion body.
          (`assertions_props:assrt_body/1')



 - DECLARATION: calls/1:
     This assertion is similar to a `pred/1' assertion but it only
     provides information about the calls to a predicate. If one or
     several calls assertions are given they are understood to
     describe all possible calls to the predicate.

     For example, the following assertion describes all possible
     calls to predicate `is/2' (see `arithmetic'):
          :- calls is(term,arithexpression).

     *Usage:* :- `calls(AssertionBody)'.
        - _The following properties should hold at call time:_

          `AssertionBody' is a call assertion body.
          (`assertions_props:c_assrt_body/1')



 - DECLARATION: calls/2:
     This assertion is similar to a `calls/1' assertion but it is
     explicitely qualified. Non-qualified `calls/1' assertions are
     assumed the qualifier `check'.

     *Usage:* :- `calls(AssertionStatus,AssertionBody)'.
        - _The following properties should hold at call time:_

          `AssertionStatus' is an acceptable status for an assertion.
          (`assertions_props:assrt_status/1')

          `AssertionBody' is a call assertion body.
          (`assertions_props:c_assrt_body/1')



 - DECLARATION: success/1:
     This assertion is similar to a `pred/1' assertion but it only
     provides information about the answers to a predicate. The
     described answers might be conditioned to a particular way of
     calling the predicate.

     For example, the following assertion specifies the answers of
     the `length/2' predicate _if_ it is called as in the first mode
     of usage above (note that the previous pred assertion already
     conveys such information, however it also compelled the
     predicate calls, while the success assertion does not):
          :- success length(L,N) : list * var => list * integer.

     *Usage:* :- `success(AssertionBody)'.
        - _The following properties should hold at call time:_

          `AssertionBody' is a predicate assertion body.
          (`assertions_props:s_assrt_body/1')



 - DECLARATION: success/2:
     This assertion is similar to a `success/1' assertion but it is
     explicitely qualified. Non-qualified `success/1' assertions are
     assumed the qualifier `check'.

     *Usage:* :- `success(AssertionStatus,AssertionBody)'.
        - _The following properties should hold at call time:_

          `AssertionStatus' is an acceptable status for an assertion.
          (`assertions_props:assrt_status/1')

          `AssertionBody' is a predicate assertion body.
          (`assertions_props:s_assrt_body/1')



 - DECLARATION: comp/1:
     This assertion is similar to a `pred/1' assertion but it only
     provides information about the global execution properties of a
     predicate (note that such kind of information is also conveyed
     by pred assertions). The described properties might be
     conditioned to a particular way of calling the predicate.

     For example, the following assertion specifies that the
     computation of `append/3' (see `lists') will not fail _if_ it is
     called as described (but does not compel the predicate to be
     called that way):
          :- comp append(Xs,Ys,Zs) : var * var * var + not_fail.

     *Usage:* :- `comp(AssertionBody)'.
        - _The following properties should hold at call time:_

          `AssertionBody' is a comp assertion body.
          (`assertions_props:g_assrt_body/1')



 - DECLARATION: comp/2:
     This assertion is similar to a `comp/1' assertion but it is
     explicitely qualified. Non-qualified `comp/1' assertions are
     assumed the qualifier `check'.

     *Usage:* :- `comp(AssertionStatus,AssertionBody)'.
        - _The following properties should hold at call time:_

          `AssertionStatus' is an acceptable status for an assertion.
          (`assertions_props:assrt_status/1')

          `AssertionBody' is a comp assertion body.
          (`assertions_props:g_assrt_body/1')



 - DECLARATION: prop/1:
     This assertion is similar to a `pred/1' assertion but it flags
     that the predicate being documented is also a " property."

     Properties are standard predicates, but which are _guaranteed to
     terminate for any possible instantiation state of their
     argument(s)_, do not perform side-effects which may interfere
     with the program behaviour, and do not further instantiate their
     arguments or add new constraints.

     Provided the above holds, properties can thus be safely used as
     run-time checks. The program transformation used in `ciaopp' for
     run-time checking guarantees the third requirement. It also
     performs some basic checks on properties which in most cases are
     enough for the second requirement. However, it is the user's
     responsibility to guarantee termination of the properties
     defined. (See also *Note Declaring regular types:: for some
     considerations applicable to writing properties.)

     The set of properties is thus a strict subset of the set of
     predicates. Note that properties can be used to describe
     characteristics of arguments in assertions and they can also be
     executed (called) as any other predicates.

     *Usage:* :- `prop(AssertionBody)'.
        - _The following properties should hold at call time:_

          `AssertionBody' is an assertion body.
          (`assertions_props:assrt_body/1')



 - DECLARATION: prop/2:
     This assertion is similar to a `prop/1' assertion but it is
     explicitely qualified. Non-qualified `prop/1' assertions are
     assumed the qualifier `check'.

     *Usage:* :- `prop(AssertionStatus,AssertionBody)'.
        - _The following properties should hold at call time:_

          `AssertionStatus' is an acceptable status for an assertion.
          (`assertions_props:assrt_status/1')

          `AssertionBody' is an assertion body.
          (`assertions_props:assrt_body/1')



 - DECLARATION: entry/1:
     This assertion provides information about the _external_ calls
     to a predicate. It is identical syntactically to a `calls/1'
     assertion. However, they describe only external calls, i.e.,
     calls to the exported predicates of a module from outside the
     module, or calls to the predicates in a non-modular file from
     other files (or the user).

     These assertions are _trusted_ by the compiler. As a result, if
     their descriptions are erroneous they can introduce bugs in
     programs. Thus, `entry/1' assertions should be written with care.

     An important use of these assertions is in providing information
     to the compiler which it may not be able to infer from the
     program. The main use is in providing information on the ways in
     which exported predicates of a module will be called from
     outside the module. This will greatly improve the precision of
     the analyzer, which otherwise has to assume that the arguments
     that exported predicates receive are any arbitrary term.

     *Usage:* :- `entry(AssertionBody)'.
        - _The following properties should hold at call time:_

          `AssertionBody' is a call assertion body.
          (`assertions_props:c_assrt_body/1')



 - DECLARATION: modedef/1:
     This assertion is used to define modes. A mode defines in a
     compact way a set of call and success properties. Once defined,
     modes can be applied to predicate arguments in assertions. The
     meaning of this application is that the call and success
     properties defined by the mode hold for the argument to which
     the mode is applied. Thus, a mode is conceptually a "property
     macro".

     The syntax of mode definitions is similar to that of pred
     declarations. For example, the following set of assertions:

          :- modedef +A : nonvar(A) # "`A' is bound upon predicate entry.".
          
          :- pred p(+A,B) : integer(A) =>  ground(B).

     is equivalent to:

          :- pred p(A,B) : (nonvar(A),integer(A)) =>  ground(B)
             # "`A' is bound upon predicate entry.".

     *Usage:* :- `modedef(AssertionBody)'.
        - _The following properties should hold at call time:_

          `AssertionBody' is an assertion body.
          (`assertions_props:assrt_body/1')



 - DECLARATION: decl/1:
     This assertion is similar to a `pred/1' assertion but it is used
     for declarations instead than for predicates.

     *Usage:* :- `decl(AssertionBody)'.
        - _The following properties should hold at call time:_

          `AssertionBody' is an assertion body.
          (`assertions_props:assrt_body/1')



 - DECLARATION: decl/2:
     This assertion is similar to a `decl/1' assertion but it is
     explicitely qualified. Non-qualified `decl/1' assertions are
     assumed the qualifier `check'.

     *Usage:* :- `decl(AssertionStatus,AssertionBody)'.
        - _The following properties should hold at call time:_

          `AssertionStatus' is an acceptable status for an assertion.
          (`assertions_props:assrt_status/1')

          `AssertionBody' is an assertion body.
          (`assertions_props:assrt_body/1')



 - DECLARATION: comment/2:
     *Usage:* :- `comment(Pred,Comment)'.
        - _Description:_ This assertion gives a text `Comment' for a
          given predicate `Pred'.

        - _The following properties should hold at call time:_

          `Pred' is a head pattern.
          (`assertions_props:head_pattern/1')

          `Comment' is a text comment with admissible documentation
          commands. The usual formatting commands that are applicable
          in comment strings are defined by `stringcommand/1'. See the
          `lpdoc' manual for documentation on comments.
          (`assertions_props:docstring/1')




File: ciao.info,  Node: Documentation on exports (assertions),  Prev: Documentation on new declarations (assertions),  Up: The Ciao assertion package

Documentation on exports (`assertions')
=======================================

 - PREDICATE: check/1:
     *Usage:* `check(PropertyConjunction)'
        - _Description:_ This assertion provides information on a
          clause program point (position in the body of a clause).
          Calls to a `check/1' assertion can appear in the body of a
          clause in any place where a literal can normally appear.
          The property defined by `PropertyConjunction' should hold
          in all the run-time stores corresponding to that program
          point. See also *Note Run-time checking of assertions::.

        - _The following properties should hold at call time:_

          `PropertyConjunction' is either a term or a _conjunction_
          of terms. The main functor and arity of each of those terms
          corresponds to the definition of a property. The first
          argument of each such term is a variable which appears as a
          head argument.   (`assertions_props:property_conjunction/1')



 - PREDICATE: trust/1:
     *Usage:* `trust(PropertyConjunction)'
        - _Description:_ This assertion also provides information on
          a clause program point. It is identical syntactically to a
          `check/1' assertion. However, the properties stated are not
          taken as something to be checked but are instead _trusted_
          by the compiler. While the compiler may in some cases
          detect an inconsistency between a `trust/1' assertion and
          the program, in all other cases the information given in
          the assertion will be taken to be true. As a result, if
          these assertions are erroneous they can introduce bugs in
          programs. Thus, `trust/1' assertions should be written with
          care.

          An important use of these assertions is in providing
          information to the compiler which it may not be able to
          infer from the program (either because the information is
          not present or because the analyzer being used is not
          precise enough). In particular, providing information on
          external predicates which may not be accessible at the time
          of compiling the module can greatly improve the precision
          of the analyzer. This can be easily done with trust
          assertion.

        - _The following properties should hold at call time:_

          `PropertyConjunction' is either a term or a _conjunction_
          of terms. The main functor and arity of each of those terms
          corresponds to the definition of a property. The first
          argument of each such term is a variable which appears as a
          head argument.   (`assertions_props:property_conjunction/1')



 - PREDICATE: true/1:
     *Usage:* `true(PropertyConjunction)'
        - _Description:_ This assertion is identical syntactically to
          a `check/1' assertion. However, the properties stated have
          been proved to hold by the analyzer. Thus, these assertions
          often represent the analyzer output.

        - _The following properties should hold at call time:_

          `PropertyConjunction' is either a term or a _conjunction_
          of terms. The main functor and arity of each of those terms
          corresponds to the definition of a property. The first
          argument of each such term is a variable which appears as a
          head argument.   (`assertions_props:property_conjunction/1')



 - PREDICATE: false/1:
     *Usage:* `false(PropertyConjunction)'
        - _Description:_ This assertion is identical syntactically to
          a `check/1' assertion. However, the properties stated have
          been proved not to hold by the analyzer. Thus, these
          assertions often represent the analyzer output.

        - _The following properties should hold at call time:_

          `PropertyConjunction' is either a term or a _conjunction_
          of terms. The main functor and arity of each of those terms
          corresponds to the definition of a property. The first
          argument of each such term is a variable which appears as a
          head argument.   (`assertions_props:property_conjunction/1')




File: ciao.info,  Node: Types and properties related to assertions,  Next: Declaring regular types,  Prev: The Ciao assertion package,  Up: Top

Types and properties related to assertions
******************************************

   *Author(s):* Manuel Hermenegildo.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#25 (1999/12/29, 12:46:8 CET)

   This module is part of the `assertions' library. It defines types
and properties related to assertions.

* Menu:

* Usage and interface (assertions_props)::
* Documentation on exports (assertions_props)::


File: ciao.info,  Node: Usage and interface (assertions_props),  Next: Documentation on exports (assertions_props),  Prev: Types and properties related to assertions,  Up: Types and properties related to assertions

Usage and interface (`assertions_props')
========================================

   * *Library usage:*

     `:- use_module(library(assertions_props)).'

   * *Exports:*
        - _Properties:_

          `head_pattern/1', `nabody/1', `docstring/1'.

        - _Regular Types:_

          `assrt_body/1', `complex_arg_property/1',
          `property_conjunction/1', `property_starterm/1',
          `complex_goal_property/1', `dictionary/1', `c_assrt_body/1',
          `s_assrt_body/1', `g_assrt_body/1', `assrt_status/1',
          `assrt_type/1', `predfunctor/1', `propfunctor/1'.


   * *Other modules used:*
        - _System library modules:_

          `dcg_expansion'.




File: ciao.info,  Node: Documentation on exports (assertions_props),  Prev: Usage and interface (assertions_props),  Up: Types and properties related to assertions

Documentation on exports (`assertions_props')
=============================================

 - REGTYPE: assrt_body/1:
     This predicate defines the different types of syntax admissible
     in the bodies of `pred/1', `decl/1', etc. assertions. Such a
     body is of the form:

                Pr [:: DP] [: CP] [=> AP] [+ GP] [# CO]

     where (fields between [...] are optional):

        * `Pr' is a head pattern ( `head_pattern/1') which describes
          the predicate or property and possibly gives some implicit
          call/answer information.

        * `DP' is a (possibly empty) complex argument property (
          `complex_arg_property/1') which expresses properties which
          are compatible with the predicate, i.e., instantiations
          made by the predicate are _compatible_ with the properties
          in the sense that applying the property at any point to
          would not make it fail.

        * `CP' is a (possibly empty) complex argument property (
          `complex_arg_property/1') which applies to the _calls_ to
          the predicate.

        * `AP' is a (possibly empty) complex argument property (
          `complex_arg_property/1') which applies to the _answers_ to
          the predicate (if the predicate succeeds). These only apply
          if the (possibly empty) properties given for calls in the
          assertion hold.

        * `GP' is a (possibly empty) complex goal property (
          `complex_goal_property/1') which applies to the _whole
          execution_ of a call to the predicate. These only apply if
          the (possibly empty) properties given for calls in the
          assertion hold.

        * `CO' is a comment string ( `docstring/1'). This comment
          only applies if the (possibly empty) properties given for
          calls in the assertion hold. The usual formatting commands
          that are applicable in comment strings can be used (see
          `stringcommand/1').

          See the `lpdoc' manual for documentation on assertion
          comments.


     *Usage:* `assrt_body(X)'
        - _Description:_ `X' is an assertion body.



 - PROPERTY: head_pattern/1:
     A head pattern can be a predicate name (functor/arity) (
     `predname/1') or a term. Thus, both `p/3' and `p(A,B,C)' are
     valid head patterns. In the case in which the head pattern is a
     term, each argument of such a term can be:

        * A variable. This is useful in order to be able to refer to
          the corresponding argument positions by name within
          properties and in comments. Thus,
          `p(Input,Parameter,Output)' is a valid head pattern.

        * A ground term. In this case this term determines a property
          of the corresponding argument. The actual property referred
          to is that given by the term but with one more argument
          added at the beginning, which is a new variable which, in a
          rewriting of the head pattern, appears at the argument
          position occupied by the term. Unless otherwise stated (see
          below), the property built this way is understood to hold
          for both calls and answers. For example, the head pattern
          `p(Input,list(integer),Output)' is valid and equivalent for
          example to having the head pattern `p(Input,A,Output)' and
          stating that the property `list(A,integer)' holds for the
          calls and successes of the predicate.

        * Finally, it can also be a variable or a ground term, as
          above, but preceded by a " mode." This mode determines in a
          compact way certain call or answer properties. For example,
          the head pattern `p(Input,+list(integer),Output)' is valid,
          as long as `+/1' is declared as a mode.

          Acceptable modes are documented in `library(modes)'. User
          defined modes are documented in `modedef/1'.


     *Usage:* `head_pattern(Pr)'
        - _Description:_ `Pr' is a head pattern.



 - REGTYPE: complex_arg_property/1:
     `complex_arg_property(Props)'

     `Props' is a (possibly empty) complex argument property. Such
     properties can appear in two formats, which are defined by
     `property_conjunction/1' and `property_starterm/1' respectively.
     The two formats can be mixed provided they are not in the same
     field of an assertion. I.e., the following is a valid assertion:

     `:- pred foo(X,Y) : nonvar * var => (ground(X),ground(Y)).'

     *Usage:* `complex_arg_property(Props)'
        - _Description:_ `Props' is a (possibly empty) complex
          argument property



 - REGTYPE: property_conjunction/1:
     This type defines the first, unabridged format in which
     properties can be expressed in the bodies of assertions. It is
     essentially a conjunction of properties which refer to
     variables. The following is an example of a complex property in
     this format:

        * `(integer(X),list(Y,integer))': `X' has the property
          `integer/1' and `Y' has the property `list/2', with second
          argument `integer'.


     *Usage:* `property_conjunction(Props)'
        - _Description:_ `Props' is either a term or a _conjunction_
          of terms. The main functor and arity of each of those terms
          corresponds to the definition of a property. The first
          argument of each such term is a variable which appears as a
          head argument.



 - REGTYPE: property_starterm/1:
     This type defines a second, compact format in which properties
     can be expressed in the bodies of assertions. A
     `property_starterm/1' is a term whose main functor is `*/2' and,
     when it appears in an assertion, the number of terms joined by
     `*/2' is exactly the arity of the predicate it refers to. A
     similar series of properties as in `property_conjunction/1'
     appears, but the arity of each property is one less: the
     argument position to which they refer (first argument) is left
     out and determined by the position of the property in the
     `property_starterm/1'. The idea is that each element of the
     `*/2' term corresponds to a head argument position. Several
     properties can be assigned to each argument position by grouping
     them in curly brackets. The following is an example of a complex
     property in this format:

        * ` integer * list(integer)': the first argument of the
          procedure (or function, or ...) has the property
          `integer/1' and the second one has the property `list/2',
          with second argument `integer'.

        * ` {integer,var} * list(integer)': the first argument of the
          procedure (or function, or ...) has the properties
          `integer/1' and `var/1' and the second one has the property
          `list/2', with second argument `integer'.


     *Usage:* `property_starterm(Props)'
        - _Description:_ `Props' is either a term or several terms
          separated by `*/2'. The main functor of each of those terms
          corresponds to that of the definition of a property, and
          the arity should be one less than in the definition of such
          property. All arguments of each such term are ground.



 - REGTYPE: complex_goal_property/1:
     `complex_goal_property(Props)'

     `Props' is a (possibly empty) complex goal property. Such
     properties can be either a term or a _conjunction_ of terms. The
     main functor and arity of each of those terms corresponds to the
     definition of a property. Such properties apply to all
     executions of all goals of the predicate which comply with the
     assertion in which the `Props' appear.

     The arguments of the terms in `Props' are implicitely augmented
     with a first argument which corresponds to a goal of the
     predicate of the assertion in which the `Props' appear. For
     example, the assertion
               :- comp var(A) + not_further_inst(A).
     has property `not_further_inst/1' as goal property, and
     establishes that in all executions of `var(A)' it should hold
     that `not_further_inst(var(A),A)'.

     *Usage:* `complex_goal_property(Props)'
        - _Description:_ `Props' is either a term or a _conjunction_
          of terms. The main functor and arity of each of those terms
          corresponds to the definition of a property. A first
          implicit argument in such terms identifies goals to which
          the properties apply.



 - PROPERTY: nabody/1:
     *Usage:* `nabody(ABody)'
        - _Description:_ `ABody' is a normalized assertion body.



 - REGTYPE: dictionary/1:
     *Usage:* `dictionary(D)'
        - _Description:_ `D' is a dictionary of variable names.



 - REGTYPE: c_assrt_body/1:
     This predicate defines the different types of syntax admissible
     in the bodies of `call/1', `entry/1', etc. assertions. The
     following are admissible:

                Pr : CP [# CO]

     where (fields between [...] are optional):

        * `CP' is a (possibly empty) complex argument property (
          `complex_arg_property/1') which applies to the _calls_ to
          the predicate.

        * `CO' is a comment string ( `docstring/1'). This comment
          only applies if the (possibly empty) properties given for
          calls in the assertion hold. The usual formatting commands
          that are applicable in comment strings can be used (see
          `stringcommand/1').


     The format of the different parts of the assertion body are
     given by `n_assrt_body/5' and its auxiliary types.

     *Usage:* `c_assrt_body(X)'
        - _Description:_ `X' is a call assertion body.



 - REGTYPE: s_assrt_body/1:
     This predicate defines the different types of syntax admissible
     in the bodies of `pred/1', `func/1', etc. assertions. The
     following are admissible:

                Pr : CP => AP # CO
                Pr : CP => AP
                Pr => AP # CO
                Pr => AP

     where:

        * `Pr' is a head pattern ( `head_pattern/1') which describes
          the predicate or property and possibly gives some implicit
          call/answer information.

        * `CP' is a (possibly empty) complex argument property (
          `complex_arg_property/1') which applies to the _calls_ to
          the predicate.

        * `AP' is a (possibly empty) complex argument property (
          `complex_arg_property/1') which applies to the _answers_ to
          the predicate (if the predicate succeeds). These only apply
          if the (possibly empty) properties given for calls in the
          assertion hold.

        * `CO' is a comment string ( `docstring/1'). This comment
          only applies if the (possibly empty) properties given for
          calls in the assertion hold. The usual formatting commands
          that are applicable in comment strings can be used (see
          `stringcommand/1').


     The format of the different parts of the assertion body are
     given by `n_assrt_body/5' and its auxiliary types.

     *Usage:* `s_assrt_body(X)'
        - _Description:_ `X' is a predicate assertion body.



 - REGTYPE: g_assrt_body/1:
     This predicate defines the different types of syntax admissible
     in the bodies of `comp/1' assertions. The following are
     admissible:

                Pr : CP + GP # CO
                Pr : CP + GP
                Pr + GP # CO
                Pr + GP

     where:

        * `Pr' is a head pattern ( `head_pattern/1') which describes
          the predicate or property and possibly gives some implicit
          call/answer information.

        * `CP' is a (possibly empty) complex argument property (
          `complex_arg_property/1') which applies to the _calls_ to
          the predicate.

        * `GP' contains (possibly empty) complex goal property (
          `complex_goal_property/1') which applies to the _whole
          execution_ of a call to the predicate. These only apply if
          the (possibly empty) properties given for calls in the
          assertion hold.

        * `CO' is a comment string ( `docstring/1'). This comment
          only applies if the (possibly empty) properties given for
          calls in the assertion hold. The usual formatting commands
          that are applicable in comment strings can be used (see
          `stringcommand/1').


     The format of the different parts of the assertion body are
     given by `n_assrt_body/5' and its auxiliary types.

     *Usage:* `g_assrt_body(X)'
        - _Description:_ `X' is a comp assertion body.



 - REGTYPE: assrt_status/1:
     The types of assertion status. They have the same meaning as the
     program-point assertions, and are as follows:
          assrt_status(true).
          assrt_status(false).
          assrt_status(check).
          assrt_status(checked).
          assrt_status(trust).

     *Usage:* `assrt_status(X)'
        - _Description:_ `X' is an acceptable status for an assertion.



 - REGTYPE: assrt_type/1:
     The admissible kinds of assertions:
          assrt_type(pred).
          assrt_type(prop).
          assrt_type(decl).
          assrt_type(func).
          assrt_type(calls).
          assrt_type(success).
          assrt_type(comp).
          assrt_type(entry).
          assrt_type(modedef).

     *Usage:* `assrt_type(X)'
        - _Description:_ `X' is an admissible kind of assertion.



 - REGTYPE: predfunctor/1:
     *Usage:* `predfunctor(X)'
        - _Description:_ `X' is a type of assertion which defines a
          predicate.



 - REGTYPE: propfunctor/1:
     *Usage:* `propfunctor(X)'
        - _Description:_ `X' is a type of assertion which defines a
          _property_.



 - PROPERTY: docstring/1:
     *Usage:* `docstring(String)'
        - _Description:_ `String' is a text comment with admissible
          documentation commands. The usual formatting commands that
          are applicable in comment strings are defined by
          `stringcommand/1'. See the `lpdoc' manual for documentation
          on comments.




File: ciao.info,  Node: Declaring regular types,  Next: Properties which are native to analyzers,  Prev: Types and properties related to assertions,  Up: Top

Declaring regular types
***********************

   *Author(s):* Manuel Hermenegildo, Pedro Lopez, Francisco Bueno.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#9 (1999/12/9, 21:57:42 MET)

   This library package adds some new declaration definitions and new
operator definitions to user programs. These new declarations and
operators provide some very simple syntactic sugar to support regular
type definitions in source code. Regular types are just properties
which have the additional characteristic of being regular types (
`basic_props:regtype/1').

   For example, this library package allows writing:
        :- regtype tree(X) # "`X' is a tree.".
   instead of the more combersome:
        :- prop tree(X) + regtype # "`X' is a tree.".

   Regular types can be used as properties to describe predicates and
play an essential role in program debugging (see the Ciao Prolog
preprocessor (`ciaopp') manual).

   In this chapter we explain some general considerations worth
taking into account when writing properties in general, not just
regular types. The exact syntax of regular types is also described.

* Menu:

* Defining properties::
* Usage and interface (regtypes)::
* Documentation on new declarations (regtypes)::


File: ciao.info,  Node: Defining properties,  Next: Usage and interface (regtypes),  Prev: Declaring regular types,  Up: Declaring regular types

Defining properties
===================

   Given the classes of assertions in the Ciao assertion language,
there are two fundamental classes of properties. Properties used in
assertions which refer to execution states (i.e., `calls/1',
`success/1', and the like) are called _properties of execution
states_. Properties used in assertions related to computations (i.e.,
`comp/1') are called _properties of computations_. Different
considerations apply when writing a property of the former or of the
later kind.

   Consider a definition of the predicate `string_concat/3' which
concatenates two character strings (represented as lists of ASCII
codes):
     string_concat([],L,L).
     string_concat([X|Xs],L,[X|NL]):- string_concat(Xs,L,NL).

   Assume that we would like to state in an assertion that each
argument "is a list of integers." However, we must decide which one
of the following two possibilities we mean exactly: "the argument is
_instantiated_ to a list of integers" (let us call this property
`instantiated_to_intlist/1'), or "if any part of the argument is
instantiated, this instantiation must be compatible with the argument
being a list of integers" (we will call this property
`compatible_with_intlist/1'). For example,
`instantiated_to_intlist/1' should be true for the terms `[]' and
`[1,2]', but should not for `X', `[a,2]', and `[X,2]'. In turn,
`compatible_with_intlist/1' should be true for `[]', `X', `[1,2]',
and `[X,2]', but should not be for `[X|1]', `[a,2]', and `1'. We
refer to properties such as `instantiated_to_intlist/1' above as
_instantiation properties_ and to those such as
`compatible_with_intlist/1' as _compatibility properties_
(corresponding to the traditional notions of "instantiation types"
and "compatibility types").

   It turns out that both of these notions are quite useful in
practice. In the example above, we probably would like to use
`compatible_with_intlist/1' to state that on success of
`string_concat/3' all three argument must be compatible with lists of
integers in an assertion like:

     :- success string_concat(A,B,C) => ( compatible_with_intlist(A),
                                          compatible_with_intlist(B),
                                          compatible_with_intlist(C) ).

   With this assertion, no error will be flagged for a call to
`string_concat/3' such as `string_concat([20],L,R)', which on success
produces the resulting atom `string_concat([20],L,[20|L])', but a
call `string_concat([],a,R)' would indeed flag an error.

   On the other hand, and assuming that we are running on a Prolog
system, we would probably like to use `instantiated_to_intlist/1' for
`sumlist/2' as follows:

     :- calls sumlist(L,N) : instantiated_to_intlist(L).
     
     sumlist([],0).
     sumlist([X|R],S) :- sumlist(R,PS), S is PS+X.

to describe the type of calls for which the program has been
designed, i.e., those in which the first argument of `sumlist/2' is
indeed a list of integers.

   The property `instantiated_to_intlist/1' might be written as in
the following (Prolog) definition:

     :- prop instantiated_to_intlist/1.
     
     instantiated_to_intlist(X) :-
            nonvar(X), instantiated_to_intlist_aux(X).
     
     instantiated_to_intlist_aux([]).
     instantiated_to_intlist_aux([X|T]) :-
            integer(X), instantiated_to_intlist(T).

   (Recall that the Prolog builtin `integer/1' itself implements an
instantiation check, failing if called with a variable as the
argument.)

   The property `compatible_with_intlist/1' might in turn be written
as follows (also in Prolog):

     :- prop compatible_with_intlist/1.
     
     compatible_with_intlist(X) :- var(X).
     compatible_with_intlist(X) :-
            nonvar(X), compatible_with_intlist_aux(X).
     
     compatible_with_intlist_aux([]).
     compatible_with_intlist_aux([X|T]) :-
            int_compat(X), compatible_with_intlist(T).
     
     int_compat(X) :- var(X).
     int_compat(X) :- nonvar(X), integer(X).

   Note that these predicates meet the criteria for being properties
and thus the `prop/1' declaration is correct.

   Ensuring that a property meets the criteria for "not affecting the
computation" can sometimes make its coding somewhat tedious. In some
ways, one would like to be able to write simply:

     intlist([]).
     intlist([X|R]) :- int(X), intlist(R).

(Incidentally, note that the above definition, provided that it suits
the requirements for being a property and that `int/1' is a regular
type, meets the criteria for being a regular type. Thus, it could be
declared `:- regtype intlist/1'.)

   But note that (independently of the definition of `int/1') the
definition above is not the correct instantiation check, since it
would succeed for a call such as `intlist(X)'. In fact, it is not
strictly correct as a compatibility property either, because, while
it would fail or succeed as expected, it would perform instantiations
(e.g., if called with `intlist(X)' it would bind `X' to `[]'). In
practice, it is convenient to provide some run-time support to aid in
this task.

   The run-time support of the Ciao system (see *Note Run-time
checking of assertions::) ensures that the execution of properties is
performed in such a way that properties written as above can be used
directly as instantiation checks. Thus, writing:

     :- calls sumlist(L,N) : intlist(L).

has the desired effect. Also, the same properties can often be used
as compatibility checks by writing them in the assertions as
`compat(Property)' (`basic_props:compat/1'). Thus, writing:

     :- success string_concat(A,B,C) => ( compat(intlist(A)),
                                          compat(intlist(B)),
                                          compat(intlist(C)) ).

also has the desired effect.

   As a general rule, the properties that can be used directly for
checking for compatibility should be _downwards closed_, i.e., once
they hold they will keep on holding in every state accessible in
forwards execution. There are certain predicates which are inherently
_instantiation_ checks and should not be used as _compatibility_
properties nor appear in the definition of a property that is to be
used with `compat'. Examples of such predicates (for Prolog) are
`==', `ground', `nonvar', `integer', `atom', `>', etc. as they
require a certain instantiation degree of their arguments in order to
succeed.

   In contrast with properties of execution states, _properties of
computations_ refer to the entire execution of the call(s) that the
assertion relates to. One such property is, for example, `not_fail/1'
(note that although it has been used as in `:- comp append(Xs,Ys,Zs)
+ not_fail', it is in fact read as `not_fail(append(Xs,Ys,Zs))'; see
`assertions_props:complex_goal_property/1'). For this property, which
should be interpreted as "execution of the predicate either succeeds
at least once or loops," we can use the following predicate
`not_fail/1' for run-time checking:

     not_fail(Goal):-
           if( call(Goal),
               true,            %% then
               warning(Goal) ). %% else

where the `warning/1' (library) predicate simply prints a warning
message.

   In this simple case, implementation of the predicate is not very
difficult using the (non-standard) `if/3' builtin predicate present
in many Prolog systems.

   However, it is not so easy to code predicates which check other
properties of the computation and we may in general need to program a
meta-interpreter for this purpose.


File: ciao.info,  Node: Usage and interface (regtypes),  Next: Documentation on new declarations (regtypes),  Prev: Defining properties,  Up: Declaring regular types

Usage and interface (`regtypes')
================================

   * *Library usage:*

     `:- use_package(regtypes).'

     or

     `:- module(...,...,[regtypes]).'

   * *New operators defined:*

     `regtype/1' [1150,fx], `regtype/2' [1150,xfx].

   * *New declarations defined:*

     `regtype/1', `regtype/2'.

   * *Other modules used:*
        - _System library modules:_

          `assertions/assertions_props'.




File: ciao.info,  Node: Documentation on new declarations (regtypes),  Prev: Usage and interface (regtypes),  Up: Declaring regular types

Documentation on new declarations (`regtypes')
==============================================

 - DECLARATION: regtype/1:
     This assertion is similar to a pred assertion but it flags that
     the predicate being documented is also a " regular type." This
     allows for example checking whether it is in the class of types
     supported by the type checking and inference modules. Currently,
     types are properties whose definitions are _regular programs_.

     A regular program is defined by a set of clauses, each of the
     form:
          p(x, v_1, ..., v_n)  :- body_1, ..., body_k.
     where:
       1. `x' is a term whose variables (which are called _term
          variables_) are unique, i.e., it is not allowed to
          introduce equality constraints between the variables of `x'.

          For example, `p(f(X, Y)) :- ...' is valid, but `p(f(X, X))
          :- ...' is not.

       2. in all clauses defining `p/n+1' the terms `x' do not unify
          except maybe for one single clause in which `x' is a
          variable.

       3. `n' >= 0 and `p/n' is a _parametric type functor_ (whereas
          the predicate defined by the clauses is `p/n'+1).

       4. `v_1', ..., `v_n' are unique variables, which are called
          _parametric variables_.

       5. Each `body_i' is of the form:

            1. `regtype(z, t)' where `z' is one of the _term
               variables_ and `t' is a _regular type expression_;

            2. `q(y, t_1, ..., t_m)' where `m' >= 0, `q/m' is a
               _parametric type functor_, not in the set of functors
               `=/2', `^/2', `./3' `regtype/2'.

               `t_1, ..., t_m' are _regular type expressions_, and
               `y' is a _term variable_.

       6. Each term variable occurs at most once in the clause's body
          (and should be as the first argument of a literal).
          A _regular type expression_ is either a parametric variable
     or a parametric type functor applied to some of the parametric
     variables.

     A parametric type functor is a regular type, defined by a
     regular program, or a basic type. Basic types are defined in the
     CIAO `engine(basic_props)' manual.

     The set of types is thus a well defined subset of the set of
     properties. Note that types can be used to describe
     characteristics of arguments in assertions and they can also be
     executed (called) as any other predicates.

     *Usage:* :- `regtype(AssertionBody)'.
        - _The following properties should hold at call time:_

          `AssertionBody' is an assertion body.
          (`assertions_props:assrt_body/1')



 - DECLARATION: regtype/2:
     This assertion is similar to a `regtype/1' assertion but it is
     explicitely qualified. Non-qualified `regtype/1' assertions are
     assumed the qualifier `check'. Note that checking regular type
     definitions should be done with the `ciaopp' preprocessor.

     *Usage:* :- `regtype(AssertionStatus,AssertionBody)'.
        - _The following properties should hold at call time:_

          `AssertionStatus' is an acceptable status for an assertion.
          (`assertions_props:assrt_status/1')

          `AssertionBody' is an assertion body.
          (`assertions_props:assrt_body/1')




File: ciao.info,  Node: Properties which are native to analyzers,  Next: Meta-properties,  Prev: Declaring regular types,  Up: Top

Properties which are native to analyzers
****************************************

   *Author(s):* Francisco Bueno, Manuel Hermenegildo, Pedro Lopez.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#1 (1999/11/29, 17:12:34 MET)

   This library contains a set of properties which are natively
understood by the different program analyzers of `ciaopp'. They are
used by `ciaopp' on output and they can also be used as properties in
assertions.

* Menu:

* Usage and interface (native_props)::
* Documentation on exports (native_props)::


File: ciao.info,  Node: Usage and interface (native_props),  Next: Documentation on exports (native_props),  Prev: Properties which are native to analyzers,  Up: Properties which are native to analyzers

Usage and interface (`native_props')
====================================

   * *Library usage:*

     `:- use_module(library('assertions/native_props'))'

     or also as a package `:- use_package(nativeprops)'.

     Note the different names of the library and the package.

   * *Exports:*
        - _Properties:_

          `linear/1', `mshare/1', `fails/1', `not_fails/1',
          `possibly_fails/1', `covered/1', `not_covered/1',
          `is_det/1', `possibly_nondet/1', `mut_exclusive/1',
          `not_mut_exclusive/1', `size_lb/2', `size_ub/2',
          `steps_lb/2', `steps_ub/2', `sideff_pure/1',
          `sideff_soft/1', `sideff_hard/1'.


   * *Other modules used:*
        - _System library modules:_

          `andprolog/andprolog', `metaterms', `sort', `lists'.




File: ciao.info,  Node: Documentation on exports (native_props),  Prev: Usage and interface (native_props),  Up: Properties which are native to analyzers

Documentation on exports (`native_props')
=========================================

 - PROPERTY: linear/1:
     `linear(X)'

     `X' is bound to a term which is linear, i.e., if it contains any
     variables, such variables appear only once in the term. For
     example, `[1,2,3]' and `f(A,B)' are linear terms, while `f(A,A)'
     is not.

     *Usage:* `linear(X)'
        - _Description:_ `X' is instantiated to a linear term.



 - PROPERTY: mshare/1:
     `mshare(X)'

     `X' contains all _sharing sets_ [JL88,MH89] which specify the
     possible variable occurrences in the terms to which the
     variables involved in the clause may be bound. Sharing sets are
     a compact way of representing groundness of variables and
     dependencies between variables. This representation is however
     generally difficult to read for humans. For this reason, this
     information is often translated to `ground/1', `indep/1' and
     `indep/2' properties, which are easier to read.

     *Usage:* `mshare(X)'
        - _Description:_ The sharing pattern is ``X''.



 - PROPERTY: fails/1:
     `fails(X)'

     Calls of the form `X' fail.

     *Usage:* `fails(X)'
        - _Description:_ Calls of the form `X' fail.



 - PROPERTY: not_fails/1:
     `not_fails(X)'

     Calls of the form `X' produce at least one solution, or not
     terminate [DLGH97].

     *Usage:* `not_fails(X)'
        - _Description:_ All the calls of the form `X' do not fail.



 - PROPERTY: possibly_fails/1:
     `possibly_fails(X)'

     Non-failure is not ensured for any call of the form `X'
     [DLGH97]. In other words, nothing can be ensured about
     non-failure nor termination of such calls.

     *Usage:* `possibly_fails(X)'
        - _Description:_ Non-failure is not ensured for calls of the
          form `X'.



 - PROPERTY: covered/1:
     `covered(X)'

     For any call of the form `X' there is at least one clause whose
     test succeeds (i.e. all the calls of the form `X' are covered.)
     [DLGH97].

     *Usage:* `covered(X)'
        - _Description:_ All the calls of the form `X' are covered.



 - PROPERTY: not_covered/1:
     `not_covered(X)'

     There is some call of the form `X' for which there is not any
     clause whose test succeeds [DLGH97].

     *Usage:* `not_covered(X)'
        - _Description:_ Not all of the calls of the form `X' are
          covered.



 - PROPERTY: is_det/1:
     `is_det(X)'

     All calls of the form `X' are deterministic, i.e. produce at
     most one solution, or not terminate.

     *Usage:* `is_det(X)'
        - _Description:_ All calls of the form `X' are deterministic.



 - PROPERTY: possibly_nondet/1:
     `possibly_nondet(X)'

     Non-determinism is not ensured for all calls of the form `X'. In
     other words, nothing can be ensured about determinacy nor
     termination of such calls.

     *Usage:* `possibly_nondet(X)'
        - _Description:_ Non-determinism is not ensured for calls of
          the form `X'.



 - PROPERTY: mut_exclusive/1:
     `mut_exclusive(X)'

     For any call of the form `X' at most one clause succeeds, i.e.
     clauses are pairwise exclusive.

     *Usage:* `mut_exclusive(X)'
        - _Description:_ For any call of the form `X' at most one
          clause succeeds.



 - PROPERTY: not_mut_exclusive/1:
     `not_mut_exclusive(X)'

     Not for all calls of the form `X' at most one clause succeeds.
     I.e. clauses are not disjoint for some call.

     *Usage:* `not_mut_exclusive(X)'
        - _Description:_ Not for all calls of the form `X' at most
          one clause succeeds.



 - PROPERTY: size_lb/2:
     `size_lb(X,Y)'

     The minimum size of the terms to which the argument `Y' is bound
     to is given by the expression `Y'. Various measures can be used
     to determine the size of an argument, e.g., list-length,
     term-size, term-depth, integer-value, etc. [DL93].

     *Usage:* `size_lb(X,Y)'
        - _Description:_ `Y' is a lower bound on the size of argument
          `X'.



 - PROPERTY: size_ub/2:
     `size_ub(X,Y)'

     The maximum size of the terms to which the argument `Y' is bound
     to is given by the expression `Y'. Various measures can be used
     to determine the size of an argument, e.g., list-length,
     term-size, term-depth, integer-value, etc. [DL93].

     *Usage:* `size_ub(X,Y)'
        - _Description:_ `Y' is a upper bound on the size of argument
          `X'.



 - PROPERTY: steps_lb/2:
     `steps_lb(X,Y)'

     The minimum computation time (in resolution steps) spent by any
     call of the form `X' is given by the expression `Y'
     [DLGHL97,LGHD96]

     *Usage:* `steps_lb(X,Y)'
        - _Description:_ `Y' is a lower bound on the cost of any call
          of the form `X'.



 - PROPERTY: steps_ub/2:
     `steps_ub(X,Y)'

     The maximum computation time (in resolution steps) spent by any
     call of the form `X' is given by the expression `Y' [DL93,LGHD96]

     *Usage:* `steps_ub(X,Y)'
        - _Description:_ `Y' is a upper bound on the cost of any call
          of the form `X'.



 - PROPERTY: sideff_pure/1:
     *Usage:* `sideff_pure(X)'
        - _Description:_ `X' is pure, i.e., has no side-effects.



 - PROPERTY: sideff_soft/1:
     *Usage:* `sideff_soft(X)'
        - _Description:_ `X' has _soft side-effects_, i.e., those not
          affecting program execution (e.g., input/output).



 - PROPERTY: sideff_hard/1:
     *Usage:* `sideff_hard(X)'
        - _Description:_ `X' has _hard side-effects_, i.e., those
          that might affect program execution (e.g., assert/retract).



 - PROPERTY: indep/1:
     *Usage:* `indep(X)'
        - _Description:_ The variables in pairs in ``X'' are pairwise
          independent.



 - PROPERTY: indep/2:
     *Usage:* `indep(X,Y)'
        - _Description:_ `X' and `Y' do not have variables in common.




File: ciao.info,  Node: Meta-properties,  Next: ISO-Prolog modes,  Prev: Properties which are native to analyzers,  Up: Top

Meta-properties
***************

   *Author(s):* Francisco Bueno.

   This library allows the use of some meta-constructs which provide
for specifying properties of terms which are unknown at the time of
the specification, or expressed with a shorthand for the property
definition, i.e., without really defining it.

   An example of such use is an assertion which specifies that any
property holding upon call will also hold upon exit:
              :- pred p(X) : Prop(X) => Prop(X).

   Another example is using shorthands for properties when
documenting:
              :- pred p(X) : regtype(X,(^(list;list);list)).

   (See below for an explanation of such a regular type.)

* Menu:

* Usage and interface (meta_props)::
* Documentation on exports (meta_props)::
* Documentation on multifiles (meta_props)::
* Documentation on internals (meta_props)::
* Known bugs and planned improvements (meta_props)::


File: ciao.info,  Node: Usage and interface (meta_props),  Next: Documentation on exports (meta_props),  Prev: Meta-properties,  Up: Meta-properties

Usage and interface (`meta_props')
==================================

   * *Library usage:*

     `:- use_module(library('assertions/meta_props'))'

     or also as a package `:- use_package(metaprops)'.

     Note the different names of the library and the package.

   * *Exports:*
        - _Properties:_

          `call/2', `prop/2', `regtype/2'.

        - _Multifiles:_

          `callme/2'.




File: ciao.info,  Node: Documentation on exports (meta_props),  Next: Documentation on multifiles (meta_props),  Prev: Usage and interface (meta_props),  Up: Meta-properties

Documentation on exports (`meta_props')
=======================================

 - PROPERTY: call/2:
     `call(P,A)'

     `A' has property `P' (provided that `P' is a property).
     Equivalent to `P(A)'.

     *Usage:* `call(P,A)'
        - _Description:_ `A' has property `P'.

        - _If the following properties hold at call time:_

          `P' is a term which represents a goal, i.e., an atom or a
          structure.   (`basic_props:callable/1')



 - PROPERTY: prop/2:
     *Usage:* `prop(A,P)'
        - _Description:_ `A' has property `P'.

        - _If the following properties hold at call time:_

          `P' has property `^ (callable;prop_abs)'.
          (`meta_props:prop/2')



 - PROPERTY: regtype/2:
     *Usage:* `regtype(A,T)'
        - _Description:_ `A' is of type `T'.

        - _If the following properties hold at call time:_

          `T' has property `^ (regtype;prop_abs)'.
          (`meta_props:prop/2')




File: ciao.info,  Node: Documentation on multifiles (meta_props),  Next: Documentation on internals (meta_props),  Prev: Documentation on exports (meta_props),  Up: Meta-properties

Documentation on multifiles (`meta_props')
==========================================

 - PREDICATE: callme/2:
     (User defined.) A hook predicate you have to define as
     `callme(P,X):- P(X), !.' in the program that uses this library.
     This is done automatically if the package is used instead of the
     library module (but then you _should not_ define `callme/2' in
     your program).

     The predicate is _multifile_.





File: ciao.info,  Node: Documentation on internals (meta_props),  Next: Known bugs and planned improvements (meta_props),  Prev: Documentation on multifiles (meta_props),  Up: Meta-properties

Documentation on internals (`meta_props')
=========================================

 - PROPERTY: prop_abs/1:
     `prop_abs(Prop)'

     `Prop' is a _property abstraction_, i.e., a _parametric
     property_, or a term formed of property abstractions, where the
     functors used in the term are escaped by `^'.

     One particular case of property abstractions are _parametric
     regular type abstractions_, i.e., a parametric type functor or a
     `^'-escaped term formed of regular type abstractions.

     Such abstractions are a short-hand for a corresponding regular
     type (correspondingly, property). For example, the following
     abstraction:
                   ^(list;list);list
     denotes terms of the form `(X;Y)' where `list(X)' and `list(Y)'
     hold and also terms `T' such that `list(T)' holds. It is
     equivalent to the regular type:
                   abstract_type((X;Y)):- list(X), list(Y).
                   abstract_type(T):- list(T).

     *Usage:* `prop_abs(Prop)'
        - _Description:_ `Prop' is a property abstraction.




File: ciao.info,  Node: Known bugs and planned improvements (meta_props),  Prev: Documentation on internals (meta_props),  Up: Meta-properties

Known bugs and planned improvements (`meta_props')
==================================================

   * Using a hook predicate is not very elegant. Need something else.

   * The cut in the hook prevents backtracking (enough for most uses
     of properties but not quite ok).


File: ciao.info,  Node: ISO-Prolog modes,  Next: Classical Prolog modes,  Prev: Meta-properties,  Up: Top

ISO-Prolog modes
****************

   *Author(s):* Daniel Cabeza, Manuel Hermenegildo.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.3#112 (1999/11/23, 1:8:50 MET)

   This file defines the " modes" used in the documentation of the
ISO-Prolog standard. See also *Note Classical Prolog modes:: for an
alternative set of modes.

* Menu:

* Usage and interface (isomodes)::
* Documentation on new modes (isomodes)::


File: ciao.info,  Node: Usage and interface (isomodes),  Next: Documentation on new modes (isomodes),  Prev: ISO-Prolog modes,  Up: ISO-Prolog modes

Usage and interface (`isomodes')
================================

   * *Library usage:*

     `:- use_package([assertions,isomodes]).'

   * *New operators defined:*

     `?/1' [200,fy], `@/1' [200,fy].

   * *New modes defined:*

     `+/1', `@/1', `-/1', `?/1', `*/1', `+/2', `@/2', `-/2', `?/2',
     `*/2'.

   * *Other modules used:*
        - _System library modules:_

          `assertions/meta_props'.




File: ciao.info,  Node: Documentation on new modes (isomodes),  Prev: Usage and interface (isomodes),  Up: ISO-Prolog modes

Documentation on new modes (`isomodes')
=======================================

 - MODE: +/1:
     *Usage:* `+ A'
        - _The following properties are added at call time:_

          `A' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')



 - MODE: @/1:
     *Usage:* `@ A'
        - _The following properties are added globally:_

          `A' is not further instantiated.
          (`basic_props:not_further_inst/2')



 - MODE: -/1:
     *Usage:* `- A'
        - _The following properties are added at call time:_

          `A' is a free variable.   (`term_typing:var/1')



 - MODE: ?/1:
     Unspecified argument.




 - MODE: */1:
     Unspecified argument.




 - MODE: +/2:
     *Usage:* `A + X'
        - _The following properties are added at call time:_

          `A' has property `X'.   (`meta_props:call/2')



 - MODE: @/2:
     *Usage:* `@(A,X)'
        - _The following properties are added at call time:_

          `A' has property `X'.   (`meta_props:call/2')

        - _The following properties are added upon exit:_

          `A' has property `X'.   (`meta_props:call/2')

        - _The following properties are added globally:_

          `A' is not further instantiated.
          (`basic_props:not_further_inst/2')



 - MODE: -/2:
     *Usage:* `A - X'
        - _The following properties are added at call time:_

          `A' is a free variable.   (`term_typing:var/1')

        - _The following properties are added upon exit:_

          `A' has property `X'.   (`meta_props:call/2')



 - MODE: ?/2:
     *Usage:* `?(A,X)'
        - _Call and exit are _compatible_ with:_

          `A' has property `X'.   (`meta_props:call/2')

        - _The following properties are added upon exit:_

          `A' has property `X'.   (`meta_props:call/2')



 - MODE: */2:
     *Usage:* `A * X'
        - _Call and exit are _compatible_ with:_

          `A' has property `X'.   (`meta_props:call/2')




File: ciao.info,  Node: Classical Prolog modes,  Next: Run-time checking of assertions,  Prev: ISO-Prolog modes,  Up: Top

Classical Prolog modes
**********************

   *Author(s):* Manuel Hermenegildo.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 0.8#43 (1999/3/6, 18:39:38 CET)

   This file defines a number of very simple " modes" which are
frequently useful in programs. These correspond to the modes used in
classical Prolog texts with some simple addtions. Note that some of
these modes use the same symbol as one of the ISO-modes (see *Note
ISO-Prolog modes::) but with subtly different meaning.

* Menu:

* Usage and interface (basicmodes)::
* Documentation on new modes (basicmodes)::


File: ciao.info,  Node: Usage and interface (basicmodes),  Next: Documentation on new modes (basicmodes),  Prev: Classical Prolog modes,  Up: Classical Prolog modes

Usage and interface (`basicmodes')
==================================

   * *Library usage:*

     :- use_package([assertions,basicmodes]).

   * *New operators defined:*

     `?/1' [500,fx], `@/1' [500,fx].

   * *New modes defined:*

     `+/1', `-/1', `?/1', `@/1', `in/1', `out/1', `go/1', `+/2',
     `-/2', `?/2', `@/2', `in/2', `out/2', `go/2'.

   * *Other modules used:*
        - _System library modules:_

          `assertions/meta_props'.




File: ciao.info,  Node: Documentation on new modes (basicmodes),  Prev: Usage and interface (basicmodes),  Up: Classical Prolog modes

Documentation on new modes (`basicmodes')
=========================================

 - MODE: +/1:
     Input value in argument.

     *Usage:* `+ A'
        - _The following properties are added at call time:_

          `A' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')



 - MODE: -/1:
     No input value in argument.

     *Usage:* `- A'
        - _The following properties are added at call time:_

          `A' is a free variable.   (`term_typing:var/1')



 - MODE: ?/1:
     Unspecified argument.




 - MODE: @/1:
     No output value in argument.

     *Usage:* `@ A'
        - _The following properties are added globally:_

          `A' is not further instantiated.
          (`basic_props:not_further_inst/2')



 - MODE: in/1:
     Input argument.

     *Usage:* `in(A)'
        - _The following properties are added at call time:_

          `A' is currently ground (it contains no variables).
          (`term_typing:ground/1')

        - _The following properties are added upon exit:_

          `A' is currently ground (it contains no variables).
          (`term_typing:ground/1')



 - MODE: out/1:
     Output argument.

     *Usage:* `out(A)'
        - _The following properties are added at call time:_

          `A' is a free variable.   (`term_typing:var/1')

        - _The following properties are added upon exit:_

          `A' is currently ground (it contains no variables).
          (`term_typing:ground/1')



 - MODE: go/1:
     Ground output (input/output argument).

     *Usage:* `go(A)'
        - _The following properties are added upon exit:_

          `A' is currently ground (it contains no variables).
          (`term_typing:ground/1')



 - MODE: +/2:
     *Usage:* `A + X'
        - _Call and exit are _compatible_ with:_

          `A' has property `X'.   (`meta_props:call/2')

        - _The following properties are added at call time:_

          `A' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')



 - MODE: -/2:
     *Usage:* `A - X'
        - _Call and exit are _compatible_ with:_

          `A' has property `X'.   (`meta_props:call/2')

        - _The following properties are added at call time:_

          `A' is a free variable.   (`term_typing:var/1')



 - MODE: ?/2:
     *Usage:* `?(A,X)'
        - _Call and exit are _compatible_ with:_

          `A' has property `X'.   (`meta_props:call/2')



 - MODE: @/2:
     *Usage:* `@(A,X)'
        - _Call and exit are _compatible_ with:_

          `A' has property `X'.   (`meta_props:call/2')

        - _The following properties are added globally:_

          `A' is not further instantiated.
          (`basic_props:not_further_inst/2')



 - MODE: in/2:
     *Usage:* `in(A,X)'
        - _Call and exit are _compatible_ with:_

          `A' has property `X'.   (`meta_props:call/2')

        - _The following properties are added at call time:_

          `A' is currently ground (it contains no variables).
          (`term_typing:ground/1')

        - _The following properties are added upon exit:_

          `A' is currently ground (it contains no variables).
          (`term_typing:ground/1')



 - MODE: out/2:
     *Usage:* `out(A,X)'
        - _Call and exit are _compatible_ with:_

          `A' has property `X'.   (`meta_props:call/2')

        - _The following properties are added at call time:_

          `A' is a free variable.   (`term_typing:var/1')

        - _The following properties are added upon exit:_

          `A' is currently ground (it contains no variables).
          (`term_typing:ground/1')



 - MODE: go/2:
     *Usage:* `go(A,X)'
        - _Call and exit are _compatible_ with:_

          `A' has property `X'.   (`meta_props:call/2')

        - _The following properties are added upon exit:_

          `A' is currently ground (it contains no variables).
          (`term_typing:ground/1')




File: ciao.info,  Node: Run-time checking of assertions,  Next: *** PART VI - Ciao Prolog library miscellanea,  Prev: Classical Prolog modes,  Up: Top

Run-time checking of assertions
*******************************

   *Author(s):* German Puebla.

   This library package allows the use of run-time checks for the
assertions introduced in a program.

   The recommended way of performing _run-time checks_ of predicate
assertions in a program is via the Ciao preprocessor (see `ciaopp'
manual), which performs the required program transformation. However,
this package can also be used to perform checking of program-point
assertions.

* Menu:

* Usage and interface (rtchecks)::
* Documentation on multifiles (rtchecks)::
* Known bugs and planned improvements (rtchecks)::


File: ciao.info,  Node: Usage and interface (rtchecks),  Next: Documentation on multifiles (rtchecks),  Prev: Run-time checking of assertions,  Up: Run-time checking of assertions

Usage and interface (`rtchecks')
================================

   * *Library usage:*

     `:- use_package(rtchecks).'

     or

     `:- module(...,...,[rtchecks]).'

   * *Other modules used:*
        - _System library modules:_

          `assertions/meta_props', `rtchecks/rtchecks_sys'.




File: ciao.info,  Node: Documentation on multifiles (rtchecks),  Next: Known bugs and planned improvements (rtchecks),  Prev: Usage and interface (rtchecks),  Up: Run-time checking of assertions

Documentation on multifiles (`rtchecks')
========================================

 - PREDICATE: callme/2:
     No further documentation available for this predicate.

     The predicate is _multifile_.




 - PREDICATE: callme/1:
     No further documentation available for this predicate.

     The predicate is _multifile_.




 - PREDICATE: proves/2:
     No further documentation available for this predicate.

     The predicate is _multifile_.




 - PREDICATE: disproves/2:
     No further documentation available for this predicate.

     The predicate is _multifile_.





File: ciao.info,  Node: Known bugs and planned improvements (rtchecks),  Prev: Documentation on multifiles (rtchecks),  Up: Run-time checking of assertions

Known bugs and planned improvements (`rtchecks')
================================================

   * All the code in this package is included in the user program
     when it is used, ant there is a lot of it! A module should be
     used instead.

   * `check/1' uses lists instead of "proper" properties.


File: ciao.info,  Node: *** PART VI - Ciao Prolog library miscellanea,  Next: Structured stream handling,  Prev: Run-time checking of assertions,  Up: Top

PART VI - Ciao Prolog library miscellanea
*****************************************

   This part documents several Ciao libraries which provide different
useful additional functionalities. Such functionalities include
performing operating system calls, gathering statistics from the
Prolog engine, file and file name manipulation, error and exception
handling, fast reading and writing of terms ( marshalling and
unmarshalling), file locking, program reporting messages,
pretty-printing programs and assertions, a browser of the system
libraries, additional expansion utilities, concurrent aggregates,
graph visualization, etc.


File: ciao.info,  Node: Structured stream handling,  Next: Operating system utilities,  Prev: *** PART VI - Ciao Prolog library miscellanea,  Up: Top

Structured stream handling
**************************

   *Version:* 0.5#15 (1998/6/9, 16:30:53 MET DST)

* Menu:

* Usage and interface (streams)::
* Documentation on exports (streams)::


File: ciao.info,  Node: Usage and interface (streams),  Next: Documentation on exports (streams),  Prev: Structured stream handling,  Up: Structured stream handling

Usage and interface (`streams')
===============================

   * *Library usage:*

     `:- use_module(library(streams)).'

   * *Exports:*
        - _Predicates:_

          `open_null_stream/1', `open_input/2', `close_input/1',
          `open_output/2', `close_output/1'.




File: ciao.info,  Node: Documentation on exports (streams),  Prev: Usage and interface (streams),  Up: Structured stream handling

Documentation on exports (`streams')
====================================

 - PREDICATE: open_null_stream/1:
     No further documentation available for this predicate.




 - PREDICATE: open_input/2:
     No further documentation available for this predicate.




 - PREDICATE: close_input/1:
     No further documentation available for this predicate.




 - PREDICATE: open_output/2:
     No further documentation available for this predicate.




 - PREDICATE: close_output/1:
     No further documentation available for this predicate.





File: ciao.info,  Node: Operating system utilities,  Next: Prolog system internal predicates,  Prev: Structured stream handling,  Up: Top

Operating system utilities
**************************

   *Author(s):* Daniel Cabeza, Manuel Carro.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.3#50 (1999/9/8, 22:35:15 MEST)

   This module contains predicates for invoking services which are
typically provided by the operating system. Note that the predicates
which take names of files or directories as arguments in this module
expect atoms, not path aliases. I.e., generally these predicates will
not call `absolute_file_name/2' on names of files or directories
taken as arguments.

* Menu:

* Usage and interface (system)::
* Documentation on exports (system)::


File: ciao.info,  Node: Usage and interface (system),  Next: Documentation on exports (system),  Prev: Operating system utilities,  Up: Operating system utilities

Usage and interface (`system')
==============================

   * *Library usage:*

     `:- use_module(library(system)).'

   * *Exports:*
        - _Predicates:_

          `pause/1', `time/1', `datime/1', `datime/9', `getenvstr/2',
          `extract_paths/2', `get_pid/1', `current_host/1',
          `current_executable/1', `umask/2', `working_directory/2',
          `cd/1', `shell/0', `shell/1', `shell/2', `system/1',
          `system/2', `popen/3', `exec/4', `exec/3',
          `directory_files/2', `mktemp/2', `file_exists/1',
          `file_exists/2', `file_property/2', `file_properties/6',
          `modif_time/2', `modif_time0/2', `fmode/2', `chmod/2',
          `chmod/3', `delete_file/1'.

        - _Regular Types:_

          `datime_struct/1', `popen_mode/1'.




File: ciao.info,  Node: Documentation on exports (system),  Prev: Usage and interface (system),  Up: Operating system utilities

Documentation on exports (`system')
===================================

 - PREDICATE: pause/1:
     `pause(Seconds)'

     Make this thread sleep for some `Seconds'.




 - PREDICATE: time/1:
     `time(Time)'

     `Time' is unified with the number of seconds elapsed since
     January, 1, 1970 (UTC).




 - PREDICATE: datime/1:
     `datime(Datime)'

     `Datime' is unified with a term of the form
     `datime(Year,Month,Day,Hour,Minute,Second)' which contains the
     current date and time.




 - PREDICATE: datime/9:
     `datime(Time,Year,Month,Day,Hour,Min,Sec,WeekDay,YearDay)'

     `Time' is as in `time/1'. `WeekDay' is the number of days since
     Sunday, in the range 0 to 6. `YearDay' is the number of days
     since January 1, in the range 0 to 365.

     *Usage 1:* `datime(+int,?int,?int,?int,?int,?int,?int,?int,?int)'
        - _Description:_ If `Time' is given, the rest of the
          arguments are unified with the date and time to which the
          `Time' argument refers.

     *Usage 2:* `datime(-int,?int,?int,?int,?int,?int,?int,?int,?int)'
        - _Description:_ Bound `Time' to current time and the rest of
          the arguments refer to current time.



 - REGTYPE: datime_struct/1:
     A regular type, defined as follows:
               datime_struct(datime(Year,Month,Day,Hour,Min,Sec)) :-
                       int(Year),
                       int(Month),
                       int(Day),
                       int(Hour),
                       int(Min),
                       int(Sec).




 - PREDICATE: getenvstr/2:
     `getenvstr(Name,Value)'

     The environment variable `Name' has `Value'. Fails if variable
     `Name' is not defined.




 - PREDICATE: extract_paths/2:
     `extract_paths(String,Paths)'

     Interpret `String' as the value of a UNIX environment variable
     holding a list of paths and return in `Paths' the list of the
     paths. Paths in `String' are separated by colons, and an empty
     path is considered a shorthand for '.' (current path). The most
     typical environment variable with this format is PATH. For
     example, this is a typical use:
          ?- set_prolog_flag(write_strings, on).
          
          yes
          ?- getenvstr('PATH', PATH), extract_paths(PATH, Paths).
          
          PATH = ":/home/bardo/bin:/home/clip/bin:/opt/bin/:/bin",
          Paths = [".","/home/bardo/bin","/home/clip/bin","/opt/bin/","/bin"] ?
          
          yes
          ?-




 - PREDICATE: get_pid/1:
     `get_pid(Pid)'

     Unifies `Pid' with the process identificator of the current
     process or thread.




 - PREDICATE: current_host/1:
     `current_host(Hostname)'

     `Hostname' is unified with the fully qualified name of the host.




 - PREDICATE: current_executable/1:
     `current_executable(Path)'

     Unifies `Path' with the path to the current executable.




 - PREDICATE: umask/2:
     `umask(OldMask,NewMask)'

     The process file creation mask was `OldMask', and it is changed
     to `NewMask'.

     *Usage 2:* `umask(OldMask,NewMask)'
        - _Description:_ Gets the process file creation mask without
          changing it.

        - _The following properties should hold at call time:_

          `OldMask' is a free variable.   (`term_typing:var/1')

          `NewMask' is a free variable.   (`term_typing:var/1')

          The terms `OldMask' and `NewMask' are strictly identical.
          (`term_compare:== /2')

        - _The following properties hold upon exit:_

          `OldMask' is an integer.   (`basic_props:int/1')

          `NewMask' is an integer.   (`basic_props:int/1')



 - PREDICATE: working_directory/2:
     `working_directory(OldDir,NewDir)'

     Unifies current working directory with `OldDir', and then
     changes the working directory to `NewDir'. Calling
     `working_directory(Dir,Dir)' simply unifies `Dir' with the
     current working directory without changing anything else.

     *Usage 2:* `working_directory(OldDir,NewDir)'
        - _Description:_ Gets current working directory.

        - _The following properties should hold at call time:_

          `OldDir' is a free variable.   (`term_typing:var/1')

          `NewDir' is a free variable.   (`term_typing:var/1')

          The terms `OldDir' and `NewDir' are strictly identical.
          (`term_compare:== /2')

        - _The following properties hold upon exit:_

          `OldDir' is an atom.   (`basic_props:atm/1')

          `NewDir' is an atom.   (`basic_props:atm/1')



 - PREDICATE: cd/1:
     `cd(Path)'

     Changes working directory to `Path'.




 - PREDICATE: shell/0:
     *Usage:*
        - _Description:_ Execs the shell specified by the environment
          variable `SHELL'. When the shell process terminates,
          control is returned to Prolog.



 - PREDICATE: shell/1:
     `shell(Command)'

     `Command' is executed in the shell specified by the environment
     variable `SHELL'. It succeeds if the exit code is zero and fails
     otherwise.




 - PREDICATE: shell/2:
     `shell(Command,ReturnCode)'

     Executes `Command' in the shell specified by the environment
     variable `SHELL' and stores the exit code in `ReturnCode'.




 - PREDICATE: system/1:
     `system(Command)'

     Executes `Command' using the shell `/bin/sh'.




 - PREDICATE: system/2:
     `system(Command,ReturnCode)'

     Executes `Command' in the `/bin/sh' shell and stores the exit
     code in `ReturnCode'.




 - PREDICATE: popen/3:
     `popen(Command,Mode,Stream)'

     Open a pipe to process `Command' in a new shell with a given
     `Mode' and return a communication `Stream' (as in UNIX
     `popen(3)'). If `Mode' is `read' the output from the process is
     sent to `Stream'. If `Mode' is `write', `Stream' is sent as
     input to the process. `Stream' may be read from or written into
     using the ordinary stream I/O predicates. `Stream' must be
     closed explicitly using `close/1', i.e., it is not closed
     automatically when the process dies.




 - REGTYPE: popen_mode/1:
     *Usage:* `popen_mode(M)'
        - _Description:_ `M' is 'read' or 'write'.



 - PREDICATE: exec/4:
     `exec(Command,StdIn,StdOut,StdErr)'

     Starts the process `Command' and returns the standart I/O
     streams of the process in `StdIn', `StdOut', and `StdErr'.




 - PREDICATE: exec/3:
     `exec(Command,StdIn,StdOut)'

     Starts the process `Command' and returns the standart I/O
     streams of the process in `StdIn' and `StdOut'. `Standard error'
     is connected to whichever the parent process had it connected to.




 - PREDICATE: directory_files/2:
     `directory_files(Directory,FileList)'

     `FileList' is the unordered list of entries (files, directories,
     etc.) in `Directory'.




 - PREDICATE: mktemp/2:
     `mktemp(Template,Filename)'

     Returns a unique `Filename' based on `Template': `Template' must
     be a valid file name with six trailing X, which are substituted
     to create a new file name.




 - PREDICATE: file_exists/1:
     `file_exists(File)'

     Succeeds if `File' (a file or directory) exists (and is
     accessible).




 - PREDICATE: file_exists/2:
     `file_exists(File,Mode)'

     `File' (a file or directory) exists and it is accessible with
     `Mode', as in the Unix call `access(2)'. Typically, `Mode' is 4
     for read permission, 2 for write permission and 1 for execute
     permission.




 - PREDICATE: file_property/2:
     `file_property(File,Property)'

     `File' has the property `Property'. The possible properties are:

    type(`Type')
          `Type' is one of `regular', `directory', `symlink', `fifo',
          `socket' or `unknown'.

    linkto(`Linkto')
          If `File' is a symbolic link, `Linkto' is the file pointed
          to by the link (and the other properties come from that
          file, not from the link itself).

    mod_time(`ModTime')
          `ModTime' is the time of last modification (seconds since
          January, 1, 1970).

    mode(`Protection')
          `Protection' is the protection mode.

    size(`Size')
          `Size' is the size.

     If `Property' is uninstantiated, the predicate will enumerate
     the properties on backtracking.




 - PREDICATE: file_properties/6:
     `file_properties(Path,Type,Linkto,Time,Protection,Size)'

     The file `Path' has the following properties:

        * File type `Type' (one of `regular', `directory', `symlink',
          `fifo', `socket' or `unknown').

        * If `Path' is a symbolic link, `Linkto' is the file pointed
          to. All other properties come from the file pointed, not
          the link. `Linkto' is " if `Path' is not a symbolic link.

        * Time of last modification `Time' (seconds since January, 1,
          1970).

        * Protection mode `Protection'.

        * Size in bytes `Size'.





 - PREDICATE: modif_time/2:
     `modif_time(File,Time)'

     The file `File' was last modified at `Time', which is in seconds
     since January, 1, 1970. Fails if `File' does not exist.




 - PREDICATE: modif_time0/2:
     `modif_time0(File,Time)'

     If `File' exists, `Time' is its latest modification time, as in
     `modif_time/2'. Otherwise, if `File' does not exist, `Time' is
     zero.




 - PREDICATE: fmode/2:
     `fmode(File,Mode)'

     The file `File' has protection mode `Mode'.




 - PREDICATE: chmod/2:
     `chmod(File,NewMode)'

     Change the protection mode of file `File' to `NewMode'.




 - PREDICATE: chmod/3:
     `chmod(File,OldMode,NewMode)'

     The file `File' has protection mode `OldMode' and it is changed
     to `NewMode'.

     *Usage 2:* `chmod(File,OldMode,NewMode)'
        - _Description:_ Equivalent to fmode(`File',`OldMode')

        - _The following properties should hold at call time:_

          `File' is an atom.   (`basic_props:atm/1')

          `OldMode' is a free variable.   (`term_typing:var/1')

          `NewMode' is a free variable.   (`term_typing:var/1')

          The terms `OldMode' and `NewMode' are strictly identical.
          (`term_compare:== /2')

        - _The following properties hold upon exit:_

          `File' is an atom.   (`basic_props:atm/1')

          `OldMode' is an atom.   (`basic_props:atm/1')

          `NewMode' is an atom.   (`basic_props:atm/1')



 - PREDICATE: delete_file/1:
     `delete_file(File)'

     Delete the file `File'.





File: ciao.info,  Node: Prolog system internal predicates,  Next: Atom to Term Conversion,  Prev: Operating system utilities,  Up: Top

Prolog system internal predicates
*********************************

   *Author(s):* Manuel Carro, Daniel Cabeza, Mats Carlsson.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#153 (2000/5/29, 10:24:35 CEST)

   This module implements some miscellaneous predicates which provide
access to some internal statistics, special properties of the
predicates, etc.

* Menu:

* Usage and interface (prolog_sys)::
* Documentation on exports (prolog_sys)::
* Documentation on internals (prolog_sys)::
* Known bugs and planned improvements (prolog_sys)::


File: ciao.info,  Node: Usage and interface (prolog_sys),  Next: Documentation on exports (prolog_sys),  Prev: Prolog system internal predicates,  Up: Prolog system internal predicates

Usage and interface (`prolog_sys')
==================================

   * *Library usage:*

     `:- use_module(library(prolog_sys)).'

   * *Exports:*
        - _Predicates:_

          `statistics/0', `statistics/2', `predicate_property/2',
          `current_atom/1', `current_predicate/2',
          `garbage_collect/0', `new_atom/1'.




File: ciao.info,  Node: Documentation on exports (prolog_sys),  Next: Documentation on internals (prolog_sys),  Prev: Usage and interface (prolog_sys),  Up: Prolog system internal predicates

Documentation on exports (`prolog_sys')
=======================================

 - PREDICATE: statistics/0:
     *Usage:*
        - _Description:_ Prints statistics about the system.



 - PREDICATE: statistics/2:
     *Usage 1:* `statistics(Time_option,Time_result)'
        - _Description:_ Gather information about time (either
          process time or wall time) since last consult or since
          start of program. Results are returned in milliseconds.

        - _The following properties should hold at call time:_

          Options to get information about execution time.
          `Time_option' must be one of `runtime', `walltime'.
          (`prolog_sys:time_option/1')

          `Time_result' is any term.   (`basic_props:term/1')

        - _The following properties hold upon exit:_

          Options to get information about execution time.
          `Time_option' must be one of `runtime', `walltime'.
          (`prolog_sys:time_option/1')

          `Time_result' is a two-element list of integers. The first
          integer is the time since the start of the execution; the
          second integer is the time since the previous consult to
          time.   (`prolog_sys:time_result/1')

     *Usage 2:* `statistics(Memory_option,Memory_result)'
        - _Description:_ Gather information about memory consumption.

        - _The following properties should hold at call time:_

          Options to get information about memory usage.
          (`prolog_sys:memory_option/1')

          `Memory_result' is any term.   (`basic_props:term/1')

        - _The following properties hold upon exit:_

          Options to get information about memory usage.
          (`prolog_sys:memory_option/1')

          Result is a two-element list of integers. The first element
          is the space taken up by the option selected, measured in
          bytes; the second integer is zero for program space (which
          grows as necessary), and the amount of free space otherwise.
          (`prolog_sys:memory_result/1')

     *Usage 3:* `statistics(Garbage_collection_option,Gc_result)'
        - _Description:_ Gather information about garbage collection.

        - _The following properties should hold at call time:_

          Options to get information about garbage collection.
          (`prolog_sys:garbage_collection_option/1')

          `Gc_result' is any term.   (`basic_props:term/1')

        - _The following properties hold upon exit:_

          Options to get information about garbage collection.
          (`prolog_sys:garbage_collection_option/1')

          `Gc_result' is a tree-element list of integers, related to
          garbage collection and memory management. When
          `stack_shifts' is selected, the first one is the number of
          shifts (reallocations) of the local stack; the second is
          the number of shifts of the trail, and the third is the
          time spent in these shifts. When `garbage_collection' is
          selected, the numbers are, respectively, the number of
          garbage collections performed, the number of bytes freed,
          and the time spent in garbage collection.
          (`prolog_sys:gc_result/1')

     *Usage 4:* `statistics(Symbol_option,Symbol_result)'
        - _Description:_ Gather information about number of symbols
          and predicates.

        - _The following properties should hold at call time:_

          Option to get information about the number of symbols in
          the program.   (`prolog_sys:symbol_option/1')

          `Symbol_result' is any term.   (`basic_props:term/1')

        - _The following properties hold upon exit:_

          Option to get information about the number of symbols in
          the program.   (`prolog_sys:symbol_option/1')

          `Symbol_result' is a two-element list of integers. The
          first one is the number of atom, functor, and predicate
          names in the symbol table. The second is the number of
          predicates known to be defined (although maybe without
          clauses).   (`prolog_sys:symbol_result/1')

     *Usage 5:* `statistics(Option,?term)'
        - _Description:_ If `Option' is unbound, it is bound to the
          values on the other cases.



 - PREDICATE: predicate_property/2:
     *Usage:* `predicate_property(Head,Property)'
        - _Description:_ The predicate with clause `Head' is
          `Property'.

        - _The following properties should hold at call time:_

          `Head' is any term.   (`basic_props:term/1')

          `Property' is any term.   (`basic_props:term/1')

        - _The following properties hold upon exit:_

          `Head' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')

          `Property' is an atom.   (`basic_props:atm/1')



 - PREDICATE: current_atom/1:
     *Usage:* `current_atom(Atom)'
        - _Description:_ Enumerates on backtracking all the existing
          atoms in the system.

        - _The following properties should hold at call time:_

          `Atom' is a free variable.   (`term_typing:var/1')

        - _The following properties hold upon exit:_

          `Atom' is an atom.   (`basic_props:atm/1')



 - PREDICATE: current_predicate/2:
     *Usage:* `current_predicate(?PredSpec,?Module)'
        - _Description:_ PredSpec exists in Module.



 - PREDICATE: garbage_collect/0:
     *Usage:*
        - _Description:_ Forces garbage collection when called.



 - PREDICATE: new_atom/1:
     *Usage:* `new_atom(Atom)'
        - _Description:_ Returns, on success, a new atom, not
          existing before in the system. The entry argument must be a
          variable. The idea behind this atom generation is to
          provide a fast source of identifiers for new objects,
          concurrent predicates, etc. on the fly.

        - _The following properties should hold at call time:_

          `Atom' is a free variable.   (`term_typing:var/1')

        - _The following properties hold upon exit:_

          `Atom' is an atom.   (`basic_props:atm/1')




File: ciao.info,  Node: Documentation on internals (prolog_sys),  Next: Known bugs and planned improvements (prolog_sys),  Prev: Documentation on exports (prolog_sys),  Up: Prolog system internal predicates

Documentation on internals (`prolog_sys')
=========================================

 - REGTYPE: time_option/1:
     *Usage:* `time_option(M)'
        - _Description:_ Options to get information about execution
          time. `M' must be one of `runtime', `walltime'.



 - REGTYPE: memory_option/1:
     *Usage:* `memory_option(M)'
        - _Description:_ Options to get information about memory
          usage.



 - REGTYPE: garbage_collection_option/1:
     *Usage:* `garbage_collection_option(M)'
        - _Description:_ Options to get information about garbage
          collection.



 - REGTYPE: symbol_option/1:
     *Usage:* `symbol_option(M)'
        - _Description:_ Option to get information about the number
          of symbols in the program.



 - REGTYPE: time_result/1:
     *Usage:* `time_result(Result)'
        - _Description:_ `Result' is a two-element list of integers.
          The first integer is the time since the start of the
          execution; the second integer is the time since the
          previous consult to time.



 - REGTYPE: memory_result/1:
     *Usage:* `memory_result(Result)'
        - _Description:_ Result is a two-element list of integers.
          The first element is the space taken up by the option
          selected, measured in bytes; the second integer is zero for
          program space (which grows as necessary), and the amount of
          free space otherwise.



 - REGTYPE: gc_result/1:
     *Usage:* `gc_result(Result)'
        - _Description:_ `Result' is a tree-element list of integers,
          related to garbage collection and memory management. When
          `stack_shifts' is selected, the first one is the number of
          shifts (reallocations) of the local stack; the second is
          the number of shifts of the trail, and the third is the
          time spent in these shifts. When `garbage_collection' is
          selected, the numbers are, respectively, the number of
          garbage collections performed, the number of bytes freed,
          and the time spent in garbage collection.



 - REGTYPE: symbol_result/1:
     *Usage:* `symbol_result(Result)'
        - _Description:_ `Result' is a two-element list of integers.
          The first one is the number of atom, functor, and predicate
          names in the symbol table. The second is the number of
          predicates known to be defined (although maybe without
          clauses).




File: ciao.info,  Node: Known bugs and planned improvements (prolog_sys),  Prev: Documentation on internals (prolog_sys),  Up: Prolog system internal predicates

Known bugs and planned improvements (`prolog_sys')
==================================================

   * The space used by the process is not measured here: process
     data, code, and stack also take up memory. The memory reported
     for atoms is not what is actually used, but the space used up by
     the hash table (which is enlarged as needed).


File: ciao.info,  Node: Atom to Term Conversion,  Next: ctrlcclean (library),  Prev: Prolog system internal predicates,  Up: Top

Atom to Term Conversion
***********************

   *Author(s):* Francisco Bueno, Daniel Cabeza.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 0.9#78 (1999/5/3, 19:19:27 MEST)

* Menu:

* Usage and interface (atom2term)::
* Documentation on exports (atom2term)::


File: ciao.info,  Node: Usage and interface (atom2term),  Next: Documentation on exports (atom2term),  Prev: Atom to Term Conversion,  Up: Atom to Term Conversion

Usage and interface (`atom2term')
=================================

   * *Library usage:*

     `:- use_module(library(atom2term)).'

   * *Exports:*
        - _Predicates:_

          `atom2term/2', `string2term/2', `parse_term/3'.




File: ciao.info,  Node: Documentation on exports (atom2term),  Prev: Usage and interface (atom2term),  Up: Atom to Term Conversion

Documentation on exports (`atom2term')
======================================

 - PREDICATE: atom2term/2:
     *Usage:* `atom2term(+Atom,-Term)'
        - _Description:_ Convert an atom into a term. `Atom' is an
          atom, but must have term syntax. `Term' is a term resulting
          from parsing `Atom' char by char. Note: this is just a
          simple version written for parsing daVinci's messages.
          There should be a call to the standard reader to do this!



 - PREDICATE: string2term/2:
     *Usage:* `string2term(+String,-Term)'
        - _Description:_ Same as `atom2term/2' but first argument is
          a string (containing a term).



 - PREDICATE: parse_term/3:




File: ciao.info,  Node: ctrlcclean (library),  Next: errhandle (library),  Prev: Atom to Term Conversion,  Up: Top

ctrlcclean (library)
********************

   *Version:* 0.4#5 (1998/2/24)

* Menu:

* Usage and interface (ctrlcclean)::
* Documentation on exports (ctrlcclean)::


File: ciao.info,  Node: Usage and interface (ctrlcclean),  Next: Documentation on exports (ctrlcclean),  Prev: ctrlcclean (library),  Up: ctrlcclean (library)

Usage and interface (`ctrlcclean')
==================================

   * *Library usage:*

     `:- use_module(library(ctrlcclean)).'

   * *Exports:*
        - _Predicates:_

          `ctrlc_clean/1', `delete_on_ctrlc/2', `ctrlcclean/0'.


   * *Other modules used:*
        - _System library modules:_

          `system'.




File: ciao.info,  Node: Documentation on exports (ctrlcclean),  Prev: Usage and interface (ctrlcclean),  Up: ctrlcclean (library)

Documentation on exports (`ctrlcclean')
=======================================

 - PREDICATE: ctrlc_clean/1:
     No further documentation available for this predicate.

     _Meta-predicate_ with arguments: `ctrlc_clean(goal)'.




 - PREDICATE: delete_on_ctrlc/2:
     No further documentation available for this predicate.




 - PREDICATE: ctrlcclean/0:
     No further documentation available for this predicate.





File: ciao.info,  Node: errhandle (library),  Next: Fast Reading and Writing of Terms,  Prev: ctrlcclean (library),  Up: Top

errhandle (library)
*******************

   *Version:* 0.4#5 (1998/2/24)

* Menu:

* Usage and interface (errhandle)::
* Documentation on exports (errhandle)::


File: ciao.info,  Node: Usage and interface (errhandle),  Next: Documentation on exports (errhandle),  Prev: errhandle (library),  Up: errhandle (library)

Usage and interface (`errhandle')
=================================

   * *Library usage:*

     `:- use_module(library(errhandle)).'

   * *Exports:*
        - _Predicates:_

          `error_protect/1', `handle_error/2'.




File: ciao.info,  Node: Documentation on exports (errhandle),  Prev: Usage and interface (errhandle),  Up: errhandle (library)

Documentation on exports (`errhandle')
======================================

 - PREDICATE: error_protect/1:
     No further documentation available for this predicate.

     _Meta-predicate_ with arguments: `error_protect(goal)'.




 - PREDICATE: handle_error/2:
     No further documentation available for this predicate.





File: ciao.info,  Node: Fast Reading and Writing of Terms,  Next: File name manipulation,  Prev: errhandle (library),  Up: Top

Fast Reading and Writing of Terms
*********************************

   *Author(s):* Daniel Cabeza, Oscar Portela Arjona.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#81 (2000/3/23, 16:37:17 CET)

   This library provides predicates to support reading / writing of
terms on a format designed to be handled on read faster than standart
representation.

* Menu:

* Usage and interface (fastrw)::
* Documentation on exports (fastrw)::


File: ciao.info,  Node: Usage and interface (fastrw),  Next: Documentation on exports (fastrw),  Prev: Fast Reading and Writing of Terms,  Up: Fast Reading and Writing of Terms

Usage and interface (`fastrw')
==============================

   * *Library usage:*

     `:- use_module(library(fastrw)).'

   * *Exports:*
        - _Predicates:_

          `fast_read/1', `fast_write/1', `fast_write_to_string/3'.


   * *Other modules used:*
        - _System library modules:_

          `dict'.




File: ciao.info,  Node: Documentation on exports (fastrw),  Prev: Usage and interface (fastrw),  Up: Fast Reading and Writing of Terms

Documentation on exports (`fastrw')
===================================

 - PREDICATE: fast_read/1:
     `fast_read(Term)'

     The next term is read from current standart input and is unified
     with `Term'. The syntax of the term must agree with fast_read /
     fast_write format. If the end of the input has been reached,
     `Term' is unified with the term 'end_of_file'. Further calls to
     `fast_read/1' will then cause an error.




 - PREDICATE: fast_write/1:
     `fast_write(Term)'

     Output `Term' in a way that `fast_read/1' will be able to read
     it back.




 - PREDICATE: fast_write_to_string/3:
     No further documentation available for this predicate.





File: ciao.info,  Node: File name manipulation,  Next: file_utils (library),  Prev: Fast Reading and Writing of Terms,  Up: Top

File name manipulation
**********************

   *Author(s):* Daniel Cabeza, Angel Fernandez Pineda.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.3#51 (1999/9/9, 16:28:44 MEST)

   This library provides some small utilities to handle file name
syntax.

* Menu:

* Usage and interface (filenames)::
* Documentation on exports (filenames)::


File: ciao.info,  Node: Usage and interface (filenames),  Next: Documentation on exports (filenames),  Prev: File name manipulation,  Up: File name manipulation

Usage and interface (`filenames')
=================================

   * *Library usage:*

     `:- use_module(library(filenames)).'

   * *Exports:*
        - _Predicates:_

          `no_path_file_name/2', `file_name_extension/3',
          `basename/2', `extension/2'.


   * *Other modules used:*
        - _System library modules:_

          `lists'.




File: ciao.info,  Node: Documentation on exports (filenames),  Prev: Usage and interface (filenames),  Up: File name manipulation

Documentation on exports (`filenames')
======================================

 - PREDICATE: no_path_file_name/2:
     This predicate will extract the last item (usually the file
     name) from a given path.

     The first argument must be instantiated to a string or atom.
     Whenever the first argument is an atom, the second argument will
     be an atom. Whenever the first argument is a string, the second
     argument will be a string.

     This predicate will fail under any of the following conditions:
        * First argument is not an atom, nor a string.

        * Second argument is not the last given path item (given path
          is the first argument).

     Those are the most usual usages of no_path_file_name/2:
          ?- no_path_file_name_("/home/nexusV/somefile.txt",K).
          
          K = "somefile.txt" ?
          
          yes
          ?- no_path_file_name('/home/nexusV/somefile.txt',K).
          
          K = 'somefile.txt' ?
          
          yes
          ?-

     *Usage:* `no_path_file_name(Path,FileName)'
        - _Description:_ `FileName' is the file corresponding to the
          given `Path'.

        - _Call and exit should be _compatible_ with:_

          `Path' is an atom or a string  (`filenames:atom_or_str/1')

          `FileName' is an atom or a string
          (`filenames:atom_or_str/1')



 - PREDICATE: file_name_extension/3:
     This predicate may be used in two ways:
        * To create a file name from its components: name and
          extension. For instance:

               ?- file_name_extension(File,mywork,'.txt').
               
               File = 'mywork.txt' ?
               
               yes
               ?-

        * To split a file name into its name and extension. For
          Instance:
               ?- file_name_extension('mywork.txt',A,B).
               
               A = mywork,
               B = '.txt' ?
               
               yes
               ?-

     Any other usage of file_name_extension/3 will cause the
     predicate to fail. Notice that valid arguments are accepted both
     as atoms or strings.

     *Usage:* `file_name_extension(FileName,BaseName,Extension)'
        - _Description:_ Splits a `FileName' into its `BaseName' and
          `Extension'.

        - _Call and exit should be _compatible_ with:_

          `FileName' is an atom or a string
          (`filenames:atom_or_str/1')

          `BaseName' is an atom or a string
          (`filenames:atom_or_str/1')

          `Extension' is an atom or a string
          (`filenames:atom_or_str/1')



 - PREDICATE: basename/2:
     `basename(FileName,BaseName)'

     `BaseName' is `FileName' without extension. Equivalent to
     `file_name_extension(FileName,BaseName,_)'. Useful to extract
     the base name of a file using functional syntax.

     *Usage:*
        - _Calls should, and exit will be compatible with:_

          `FileName' is an atom or a string
          (`filenames:atom_or_str/1')

          `BaseName' is an atom or a string
          (`filenames:atom_or_str/1')



 - PREDICATE: extension/2:
     `extension(FileName,Extension)'

     `Extension' is the extension (suffix) of `FileName'. Equivalent
     to `file_name_extension(FileName,_,Extension)'. Useful to
     extract the extension of a file using functional syntax.

     *Usage:*
        - _Calls should, and exit will be compatible with:_

          `FileName' is an atom or a string
          (`filenames:atom_or_str/1')

          `Extension' is an atom or a string
          (`filenames:atom_or_str/1')




File: ciao.info,  Node: file_utils (library),  Next: terms (library),  Prev: File name manipulation,  Up: Top

file_utils (library)
********************

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#55 (2000/2/11, 21:19:43 CET)

* Menu:

* Usage and interface (file_utils)::
* Documentation on exports (file_utils)::


File: ciao.info,  Node: Usage and interface (file_utils),  Next: Documentation on exports (file_utils),  Prev: file_utils (library),  Up: file_utils (library)

Usage and interface (`file_utils')
==================================

   * *Library usage:*

     `:- use_module(library(file_utils)).'

   * *Exports:*
        - _Predicates:_

          `file_terms/2', `copy_stdout/1', `file_to_string/2',
          `stream_to_string/2'.


   * *Other modules used:*
        - _System library modules:_

          `read', `streams'.




File: ciao.info,  Node: Documentation on exports (file_utils),  Prev: Usage and interface (file_utils),  Up: file_utils (library)

Documentation on exports (`file_utils')
=======================================

 - PREDICATE: file_terms/2:
     *Usage 1:* `file_terms(@File,?Terms)'
        - _Description:_ Transform a file `File' to/from a list of
          terms `Terms'.

        - _The following properties should hold upon exit:_

          `@File' is a source name.   (`streams_basic:sourcename/1')

          `?Terms' is a list.   (`basic_props:list/1')

     *Usage 2:* `file_terms(File,Terms)'
        - _Description:_ Unifies `Terms' with the list of all terms
          in `File'.

        - _The following properties should hold at call time:_

          `File' is a source name.   (`streams_basic:sourcename/1')

          `Terms' is a free variable.   (`term_typing:var/1')

        - _The following properties should hold upon exit:_

          `File' is a source name.   (`streams_basic:sourcename/1')

          `Terms' is a list.   (`basic_props:list/1')

     *Usage 3:* `file_terms(File,Terms)'
        - _Description:_ Writes the terms in list `Terms' (including
          the ending '.') onto file `File'.

        - _The following properties should hold at call time:_

          `File' is a source name.   (`streams_basic:sourcename/1')

          `Terms' is a list.   (`basic_props:list/1')

        - _The following properties should hold upon exit:_

          `File' is a source name.   (`streams_basic:sourcename/1')

          `Terms' is a list.   (`basic_props:list/1')



 - PREDICATE: copy_stdout/1:
     *Usage:* `copy_stdout(+File)'
        - _Description:_ Copies file `File' to standard output.

        - _The following properties should hold upon exit:_

          `+File' is a source name.   (`streams_basic:sourcename/1')



 - PREDICATE: file_to_string/2:
     *Usage:* `file_to_string(+FileName,-String)'
        - _Description:_ Reads all the characters from the file
          `FileName' and returns them in `String'.

        - _Call and exit should be _compatible_ with:_

          `+FileName' is a source name.
          (`streams_basic:sourcename/1')

          `-String' is a string (a list of character codes).
          (`basic_props:string/1')



 - PREDICATE: stream_to_string/2:
     *Usage:* `stream_to_string(+Stream,-String)'
        - _Description:_ Reads all the characters from `Stream' and
          returns them in `String'.

        - _Call and exit should be _compatible_ with:_

          `+Stream' is an open stream.   (`streams_basic:stream/1')

          `-String' is a string (a list of character codes).
          (`basic_props:string/1')




File: ciao.info,  Node: terms (library),  Next: Printing status and error messages,  Prev: file_utils (library),  Up: Top

terms (library)
***************

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.3#124 (1999/11/27, 4:4:5 MET)

* Menu:

* Usage and interface (terms)::
* Documentation on exports (terms)::


File: ciao.info,  Node: Usage and interface (terms),  Next: Documentation on exports (terms),  Prev: terms (library),  Up: terms (library)

Usage and interface (`terms')
=============================

   * *Library usage:*

     `:- use_module(library(terms)).'

   * *Exports:*
        - _Predicates:_

          `copy_args/3', `arg/2', `atom_concat/2'.




File: ciao.info,  Node: Documentation on exports (terms),  Prev: Usage and interface (terms),  Up: terms (library)

Documentation on exports (`terms')
==================================

 - PREDICATE: copy_args/3:
     No further documentation available for this predicate.




 - PREDICATE: arg/2:
     No further documentation available for this predicate.




 - PREDICATE: atom_concat/2:
     `atom_concat(Atms,Atm)'

     `Atm' is the atom resulting from concatenating all atoms in the
     list `Atms' in the order in which they appear.





File: ciao.info,  Node: Printing status and error messages,  Next: A simple pretty-printer for Ciao programs,  Prev: terms (library),  Up: Top

Printing status and error messages
**********************************

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.3#108 (1999/11/18, 13:48:3 MET)

   This is a very simple library for printing status and error
messages to the console.

* Menu:

* Usage and interface (messages)::
* Documentation on exports (messages)::
* Documentation on multifiles (messages)::
* Known bugs and planned improvements (messages)::


File: ciao.info,  Node: Usage and interface (messages),  Next: Documentation on exports (messages),  Prev: Printing status and error messages,  Up: Printing status and error messages

Usage and interface (`messages')
================================

   * *Library usage:*

     `:- use_module(library(messages)).'

   * *Exports:*
        - _Predicates:_

          `error_message/1', `error_message/2', `error_message/3',
          `warning_message/1', `warning_message/2',
          `warning_message/3', `note_message/1', `note_message/2',
          `note_message/3', `simple_message/1', `simple_message/2',
          `optional_message/2', `optional_message/3',
          `debug_message/1', `debug_message/2', `debug_goal/2',
          `debug_goal/3'.

        - _Multifiles:_

          `callme/2', `issue_debug_messages/1'.


   * *Other modules used:*
        - _System library modules:_

          `assertions/meta_props', `format', `lists', `filenames'.




File: ciao.info,  Node: Documentation on exports (messages),  Next: Documentation on multifiles (messages),  Prev: Usage and interface (messages),  Up: Printing status and error messages

Documentation on exports (`messages')
=====================================

 - PREDICATE: error_message/1:
     _Meta-predicate_ with arguments: `error_message(addmodule)'.

     *Usage:* `error_message(Text)'
        - _Description:_ The text provided in `Text' is printed as an
          ERROR message.

        - _The following properties should hold at call time:_

          `Text' is a string (a list of character codes).
          (`basic_props:string/1')



 - PREDICATE: error_message/2:
     _Meta-predicate_ with arguments: `error_message(?,addmodule)'.

     *Usage:* `error_message(Text,ArgList)'
        - _Description:_ The text provided in `Text' is printed as an
          ERROR message, using the arguments in `ArgList' to
          interpret any variable-related formatting commands embedded
          in `Text'.

        - _The following properties should hold at call time:_

          `Text' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')

          `ArgList' is a list.   (`basic_props:list/1')



 - PREDICATE: error_message/3:
     _Meta-predicate_ with arguments: `error_message(?,?,addmodule)'.

     *Usage:* `error_message(Lc,Text,ArgList)'
        - _Description:_ The text provided in `Text' is printed as an
          ERROR message, using the arguments in `ArgList' to
          interpret any variable-related formatting commands embedded
          in `Text', and reporting error location `Lc' (file and line
          numbers).

        - _The following properties should hold at call time:_

          `Lc' is of type `^loc(atm,int,int)'.
          (`meta_props:regtype/2')

          `Text' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')

          `ArgList' is a list.   (`basic_props:list/1')



 - PREDICATE: warning_message/1:
     _Meta-predicate_ with arguments: `warning_message(addmodule)'.

     *Usage:* `warning_message(Text)'
        - _Description:_ The text provided in `Text' is printed as a
          WARNING message.

        - _The following properties should hold at call time:_

          `Text' is a string (a list of character codes).
          (`basic_props:string/1')



 - PREDICATE: warning_message/2:
     _Meta-predicate_ with arguments: `warning_message(?,addmodule)'.

     *Usage:* `warning_message(Text,ArgList)'
        - _Description:_ The text provided in `Text' is printed as a
          WARNING message, using the arguments in `ArgList' to
          interpret any variable-related formatting commands embedded
          in `Text'.

        - _The following properties should hold at call time:_

          `Text' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')

          `ArgList' is a list.   (`basic_props:list/1')



 - PREDICATE: warning_message/3:
     _Meta-predicate_ with arguments:
     `warning_message(?,?,addmodule)'.

     *Usage:* `warning_message(Lc,Text,ArgList)'
        - _Description:_ The text provided in `Text' is printed as a
          WARNING message, using the arguments in `ArgList' to
          interpret any variable-related formatting commands embedded
          in `Text', and reporting error location `Lc' (file and line
          numbers).

        - _The following properties should hold at call time:_

          `Lc' is of type `^loc(atm,int,int)'.
          (`meta_props:regtype/2')

          `Text' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')

          `ArgList' is a list.   (`basic_props:list/1')



 - PREDICATE: note_message/1:
     _Meta-predicate_ with arguments: `note_message(addmodule)'.

     *Usage:* `note_message(Text)'
        - _Description:_ The text provided in `Text' is printed as a
          NOTE.

        - _The following properties should hold at call time:_

          `Text' is a string (a list of character codes).
          (`basic_props:string/1')



 - PREDICATE: note_message/2:
     _Meta-predicate_ with arguments: `note_message(?,addmodule)'.

     *Usage:* `note_message(Text,ArgList)'
        - _Description:_ The text provided in `Text' is printed as a
          NOTE, using the arguments in `ArgList' to interpret any
          variable-related formatting commands embedded in `Text'.

        - _The following properties should hold at call time:_

          `Text' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')

          `ArgList' is a list.   (`basic_props:list/1')



 - PREDICATE: note_message/3:
     _Meta-predicate_ with arguments: `note_message(?,?,addmodule)'.

     *Usage:* `note_message(Lc,Text,ArgList)'
        - _Description:_ The text provided in `Text' is printed as a
          NOTE, using the arguments in `ArgList' to interpret any
          variable-related formatting commands embedded in `Text',
          and reporting error location `Lc' (file and line numbers).

        - _The following properties should hold at call time:_

          `Lc' is of type `^loc(atm,int,int)'.
          (`meta_props:regtype/2')

          `Text' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')

          `ArgList' is a list.   (`basic_props:list/1')



 - PREDICATE: simple_message/1:
     *Usage:* `simple_message(Text)'
        - _Description:_ The text provided in `Text' is printed.

        - _The following properties should hold at call time:_

          `Text' is a string (a list of character codes).
          (`basic_props:string/1')



 - PREDICATE: simple_message/2:
     *Usage:* `simple_message(Text,ArgList)'
        - _Description:_ The text provided in `Text' is printed as a
          message, using the arguments in `ArgList'.

        - _The following properties should hold at call time:_

          `Text' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')

          `ArgList' is a list.   (`basic_props:list/1')



 - PREDICATE: optional_message/2:
     *Usage:* `optional_message(Text,Opts)'
        - _Description:_ The text provided in `Text' is printed as a
          message, but only if the atom `-v' is a member of `Opts'.
          These predicates are meant to be used for optional
          messages, which are only to be printed when _verbose_
          output is requested explicitly.

        - _The following properties should hold at call time:_

          `Text' is a string (a list of character codes).
          (`basic_props:string/1')

          `Opts' is a list of `atm's.   (`basic_props:list/2')



 - PREDICATE: optional_message/3:
     *Usage:* `optional_message(Text,ArgList,Opts)'
        - _Description:_ The text provided in `Text' is printed as a
          message, using the arguments in `ArgList', but only if the
          atom `-v' is a member of `Opts'. These predicates are meant
          to be used for optional messages, which are only to be
          printed when _verbose_ output is requested explicitly.

        - _The following properties should hold at call time:_

          `Text' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')

          `ArgList' is a list.   (`basic_props:list/1')

          `Opts' is a list of `atm's.   (`basic_props:list/2')



 - PREDICATE: debug_message/1:
     _Meta-predicate_ with arguments: `debug_message(addmodule)'.

     *Usage:* `debug_message(Text)'
        - _Description:_ The text provided in `Text' is printed as a
          debugging message. These messages are turned `on' by
          defining a fact of `issue_debug_messages/1' with the module
          name as argument.

        - _The following properties should hold at call time:_

          `Text' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')



 - PREDICATE: debug_message/2:
     _Meta-predicate_ with arguments: `debug_message(?,addmodule)'.

     *Usage:* `debug_message(Text,ArgList)'
        - _Description:_ The text provided in `Text' is printed as a
          debugging message, using the arguments in `ArgList' to
          interpret any variable-related formatting commands embedded
          in `Text'. These messages are turned `on' by defining a
          fact of `issue_debug_messages/1' which the module name as
          argument.

        - _The following properties should hold at call time:_

          `Text' is an atom or string describing how the arguments
          should be formatted. If it is an atom it will be converted
          into a string with `name/2'.   (`format:format_control/1')

          `ArgList' is a list.   (`basic_props:list/1')



 - PREDICATE: debug_goal/2:
     _Meta-predicate_ with arguments: `debug_goal(goal,addmodule)'.

     *Usage:* `debug_goal(Goal,Text)'
        - _Description:_ `Goal' is called. The text provided in
          `Text' is then printed as a debugging message. The whole
          process (including running `Goal') is turned `on' by
          defining a fact of `issue_debug_messages/1' with the module
          name as argument.



 - PREDICATE: debug_goal/3:
     _Meta-predicate_ with arguments: `debug_goal(goal,?,addmodule)'.

     *Usage:* `debug_goal(Goal,Text,ArgList)'
        - _Description:_ `Goal' is called. The text provided in
          `Text' is then printed as a debugging message, using the
          arguments in `ArgList' to interpret any variable-related
          formatting commands embedded in `Text'. Note that the
          variables in `ArgList' can be computed by `Goal'. The whole
          process (including running `Goal') is turned `on' by
          defining a fact of `issue_debug_messages/1' with the module
          name as argument.




File: ciao.info,  Node: Documentation on multifiles (messages),  Next: Known bugs and planned improvements (messages),  Prev: Documentation on exports (messages),  Up: Printing status and error messages

Documentation on multifiles (`messages')
========================================

 - PREDICATE: callme/2:
     No further documentation available for this predicate.

     The predicate is _multifile_.




 - PREDICATE: issue_debug_messages/1:
     The predicate is _multifile_.

     The predicate is of type _data_.

     *Usage:* `issue_debug_messages(Module)'
        - _Description:_ Printing of debugging messages is enabled
          for module `Module'.

        - _The following properties should hold upon exit:_

          `Module' is currently instantiated to an atom.
          (`term_typing:atom/1')




File: ciao.info,  Node: Known bugs and planned improvements (messages),  Prev: Documentation on multifiles (messages),  Up: Printing status and error messages

Known bugs and planned improvements (`messages')
================================================

   * Debug message switching should really be done with an expansion,
     for performance.


File: ciao.info,  Node: A simple pretty-printer for Ciao programs,  Next: Pretty-printing assertions,  Prev: Printing status and error messages,  Up: Top

A simple pretty-printer for Ciao programs
*****************************************

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 0.9#100 (1999/5/26, 12:36:46 MEST)

   This library module writes out to standard output a clause or a
list of clauses.

* Menu:

* Usage and interface (pretty_print)::
* Documentation on exports (pretty_print)::
* Documentation on internals (pretty_print)::


File: ciao.info,  Node: Usage and interface (pretty_print),  Next: Documentation on exports (pretty_print),  Prev: A simple pretty-printer for Ciao programs,  Up: A simple pretty-printer for Ciao programs

Usage and interface (`pretty_print')
====================================

   * *Library usage:*

     `:- use_module(library(pretty_print)).'

   * *Exports:*
        - _Predicates:_

          `pretty_print/2', `pretty_print/3'.


   * *Other modules used:*
        - _System library modules:_

          `vndict', `write'.




File: ciao.info,  Node: Documentation on exports (pretty_print),  Next: Documentation on internals (pretty_print),  Prev: Usage and interface (pretty_print),  Up: A simple pretty-printer for Ciao programs

Documentation on exports (`pretty_print')
=========================================

 - PREDICATE: pretty_print/2:
     *Usage:* `pretty_print(Cls,Flags)'
        - _Description:_ Prints each clause in the list `Cls' after
          numbering its variables.

        - _The following properties should hold at call time:_

          `pretty_print:clauses(Cls)'  (`pretty_print:clauses/1')

          `Flags' is a list of `flag's.   (`basic_props:list/2')



 - PREDICATE: pretty_print/3:
     *Usage:* `pretty_print(Cls,Flags,Ds)'
        - _Description:_ Prints each clause in the list `Cls' after
          using the corresponding variable names dictionary in `Ds'
          to name its variables.

        - _The following properties should hold at call time:_

          `pretty_print:clauses(Cls)'  (`pretty_print:clauses/1')

          `Flags' is a list of `flag's.   (`basic_props:list/2')

          `Ds' is a dictionary of variable names.
          (`vndict:varnamedict/1')




File: ciao.info,  Node: Documentation on internals (pretty_print),  Prev: Documentation on exports (pretty_print),  Up: A simple pretty-printer for Ciao programs

Documentation on internals (`pretty_print')
===========================================

 - REGTYPE: clauses/1:
     A regular type, defined as follows:
               clauses([]).
               clauses([_1|_2]) :-
                       clause(_1),
                       clauses(_2).
               clauses(_1) :-
                       clause(_1).




 - REGTYPE: clause/1:
     A regular type, defined as follows:
               clause(_1) :-
                       clterm(_1).
               clause((_1,_2)) :-
                       clterm(_1),
                       term(_2).




 - REGTYPE: clterm/1:
     A regular type, defined as follows:
               clterm(clause(_1,_2)) :-
                       callable(_1),
                       body(_2).
               clterm(directive(_1)) :-
                       body(_1).
               clterm((_1:-_2)) :-
                       callable(_1),
                       body(_2).
               clterm(_1) :-
                       callable(_1).




 - REGTYPE: body/1:
     A well formed body, including cge expressions and &-concurrent
     expressions. The atomic goals may or may not have a key in the
     form `^(goal:any)', and may or may not be module qualified, but
     if they are it has to be in the form `^(^(moddesc:goal):any)'.

     *Usage:* `body(X)'
        - _Description:_ `X' is a printable body.



 - REGTYPE: flag/1:
     A keyword `ask/1' flags whether to output _asks_ or _whens_ and
     `nl/1' whether to separate clauses with a blank line or not.

     *Usage:* `flag(X)'
        - _Description:_ `X' is a flag for the pretty-printer.




File: ciao.info,  Node: Pretty-printing assertions,  Next: The Ciao library browser,  Prev: A simple pretty-printer for Ciao programs,  Up: Top

Pretty-printing assertions
**************************

   *Author(s):* Francisco Bueno Carrillo.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#2 (1999/11/29, 18:2:53 MET)

   This module defines some predicates which are useful for writing
assertions in a readable form.

* Menu:

* Usage and interface (assrt_write)::
* Documentation on exports (assrt_write)::


File: ciao.info,  Node: Usage and interface (assrt_write),  Next: Documentation on exports (assrt_write),  Prev: Pretty-printing assertions,  Up: Pretty-printing assertions

Usage and interface (`assrt_write')
===================================

   * *Library usage:*

     `:- use_module(library(assrt_write)).'

   * *Exports:*
        - _Predicates:_

          `write_assertion/6', `write_assertion_as_comment/6'.


   * *Other modules used:*
        - _System library modules:_

          `format', `assertions/assrt_lib', `messages',
          `assertions/assertions_props'.




File: ciao.info,  Node: Documentation on exports (assrt_write),  Prev: Usage and interface (assrt_write),  Up: Pretty-printing assertions

Documentation on exports (`assrt_write')
========================================

 - PREDICATE: write_assertion/6:
     *Usage:* `write_assertion(Goal,Status,Type,Body,Dict,Flag)'
        - _Description:_ Writes the (normalized) assertion to current
          output.

        - _Call and exit should be _compatible_ with:_

          `Status' is an acceptable status for an assertion.
          (`assertions_props:assrt_status/1')

          `Type' is an admissible kind of assertion.
          (`assertions_props:assrt_type/1')

          `Body' is a normalized assertion body.
          (`assertions_props:nabody/1')

          `Dict' is a dictionary of variable names.
          (`assertions_props:dictionary/1')

          `Flag' is `status' or `nostatus'.
          (`assrt_write:status_flag/1')



 - PREDICATE: write_assertion_as_comment/6:
     *Usage:*
     `write_assertion_as_comment(Goal,Status,Type,Body,Dict,Flag)'
        - _Description:_ Writes the (normalized) assertion to current
          output as a Prolog comment.

        - _Call and exit should be _compatible_ with:_

          `Status' is an acceptable status for an assertion.
          (`assertions_props:assrt_status/1')

          `Type' is an admissible kind of assertion.
          (`assertions_props:assrt_type/1')

          `Body' is a normalized assertion body.
          (`assertions_props:nabody/1')

          `Dict' is a dictionary of variable names.
          (`assertions_props:dictionary/1')

          `Flag' is `status' or `nostatus'.
          (`assrt_write:status_flag/1')




File: ciao.info,  Node: The Ciao library browser,  Next: Code translation utilities,  Prev: Pretty-printing assertions,  Up: Top

The Ciao library browser
************************

   *Author(s):* Angel Fernandez Pineda.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.3#39 (1999/7/21, 12:8:4 MEST)

   `librowser' library provides a set of predicates wich enables the
user to interactively find Ciao/Prolog libraries and/or any predicate
exported by them.

   This is a simple example:

     ?- apropos('*find*').
     persdbrt_sql: dbfindall/4
     persdbrtsql: dbfindall/4
     conc_aggregates: findall/3
     linda: rd_findall/3
     vndict: find_name/4
     internals: $find_file/8
     aggregates: findall/4,findall/3
     
     yes
     ?-

   Librowser is specially usefull when using inside GNU Emacs, just
place the cursor over a librowser response and press C-cTAB in order
to get help on the related predicate. Refer to the *"Using Ciao
inside GNU Emacs"* chapter for further information.

* Menu:

* Usage and interface (librowser)::
* Documentation on exports (librowser)::
* Documentation on internals (librowser)::


File: ciao.info,  Node: Usage and interface (librowser),  Next: Documentation on exports (librowser),  Prev: The Ciao library browser,  Up: The Ciao library browser

Usage and interface (`librowser')
=================================

   * *Library usage:*

     It is not necesary to use this library at user programs. It was
     designed to be used at the Ciao _toplevel_ shell: `ciaosh'. In
     order to do so, just make use of `use_module/1' as follows:

     `use_module(library(librowser))'.

     Then, the library interface must be read. This is automatically
     done when calling any predicate at librowser, and the entire
     process will take a little moment.So, you should want to perform
     such a process after loading the Ciao toplevel:

          Ciao 0.9 #75: Fri Apr 30 19:04:24 MEST 1999
          ?- use_module(library(librowser)).
          
          yes
          ?- update.

     Whether you want this process to be automatically performed when
     loading `ciaosh', you may include those lines in your _.ciaorc_
     personal initialization file.

   * *Exports:*
        - _Predicates:_

          `update/0', `browse/2', `where/1', `describe/1',
          `system_lib/1', `apropos/1'.


   * *Other modules used:*
        - _System library modules:_

          `filenames', `read', `system', `streams', `patterns',
          `lists'.




File: ciao.info,  Node: Documentation on exports (librowser),  Next: Documentation on internals (librowser),  Prev: Usage and interface (librowser),  Up: The Ciao library browser

Documentation on exports (`librowser')
======================================

 - PREDICATE: update/0:
     This predicate will scan the Ciao system libraries for predicate
     definitions. This may be done once time before calling any other
     predicate at this library.

     update/0 will also be automatically called (once) when calling
     any other predicate at librowser.

     *Usage:*
        - _Description:_ Creates an internal database of modules at
          Ciao system libraries.



 - PREDICATE: browse/2:
     This predicate is fully reversible, and is provided to inspect
     concrete predicate specifications. For example:
          ?- browse(M,findall/A).
          
          A = 3,
          M = conc_aggregates ? ;
          
          A = 4,
          M = aggregates ? ;
          
          A = 3,
          M = aggregates ? ;
          
          no
          ?-

     *Usage:* `browse(Module,Spec)'
        - _Description:_ Asocciates the given `Spec' predicate
          specification with the `Module' which exports it.

        - _The following properties should hold at call time:_

          `Module' is a module name (an atom)
          (`librowser:module_name/1')

          `Spec' is a *Functor/Arity* predicate specification
          (`librowser:pred_spec/1')



 - PREDICATE: where/1:
     This predicate will print at the screen the module needed in
     order to import a given predicate specification. For example:
          ?- where(findall/A).
          findall/3 exported at module conc_aggregates
          findall/4 exported at module aggregates
          findall/3 exported at module aggregates
          
          yes
          ?-

     *Usage:* `where(Spec)'
        - _Description:_ Display what module to load in order to
          import the given `Spec'.

        - _The following properties should hold at call time:_

          `Spec' is a *Functor/Arity* predicate specification
          (`librowser:pred_spec/1')



 - PREDICATE: describe/1:
     This one is used to find out which predicates were exported by a
     given module. Very usefull when you know the library, but not
     the concrete predicate. For example:
          ?- describe(librowser).
          Predicates at library librowser :
          
          apropos/1
          system_lib/1
          describe/1
          where/1
          browse/2
          update/0
          
          yes
          ?-

     *Usage:* `describe(Module)'
        - _Description:_ Display a list of exported predicates at the
          given `Module'

        - _The following properties should hold at call time:_

          `Module' is a module name (an atom)
          (`librowser:module_name/1')



 - PREDICATE: system_lib/1:
     It retrieves on backtracking all Ciao system libraries stored in
     the internal database. Certainly, those which were scanned at
     `update/0' calling.

     *Usage:* `system_lib(Module)'
        - _Description:_ `Module' variable will be successively
          instantiated to the system libaries stored in the internal
          database.

        - _The following properties should hold at call time:_

          `Module' is a module name (an atom)
          (`librowser:module_name/1')



 - PREDICATE: apropos/1:
     This tool makes use of regular expresions in order to find
     predicate specifications. It is very usefull whether you can't
     renember the full name of a predicate. Regular expresions take
     the same format as described in library `patterns'. Example:
          ?- apropos('atom_*').
          
          metaterms: atom_concat/2
          concurrency: atom_lock_state/2
          atomic_basic: atom_concat/3,atom_length/2,atom_codes/2
          iso_byte_char: atom_chars/2
          
          yes
          ?-

     *Usage:* `apropos(RegSpec)'
        - _Description:_ This will search any predicate specification
          `Spec' which matches the given `RegSpec' incomplete
          predicate specification.

        - _The following properties should hold at call time:_

          `RegSpec' is a Pattern/Arity specification.
          (`librowser:apropos_spec/1')




File: ciao.info,  Node: Documentation on internals (librowser),  Prev: Documentation on exports (librowser),  Up: The Ciao library browser

Documentation on internals (`librowser')
========================================

 - REGTYPE: apropos_spec/1:
     Defined as:
          apropos_spec(_1).
          apropos_spec(Pattern/Arity) :-
                  pattern(Pattern),
                  int(Arity).

     *Usage:* `apropos_spec(S)'
        - _Description:_ `S' is a Pattern/Arity specification.




File: ciao.info,  Node: Code translation utilities,  Next: Low-level concurrency/multithreading primitives,  Prev: The Ciao library browser,  Up: Top

Code translation utilities
**************************

   *Author(s):* Angel Fernandez Pineda.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.3#110 (1999/11/22, 11:52:54 MET)

   This library offers a general way to perform clause body
expansions. Goal, fact and spec translation predicates are
authomatically called when needed, while this utility navigates
through the meta-argument specification of the body itself. All
predicates within this library must be called at _second-pass
expansions_, since it uses information stored at `c_itf' library.

* Menu:

* Usage and interface (expansion_tools)::
* Documentation on exports (expansion_tools)::
* Documentation on internals (expansion_tools)::
* Known bugs and planned improvements (expansion_tools)::


File: ciao.info,  Node: Usage and interface (expansion_tools),  Next: Documentation on exports (expansion_tools),  Prev: Code translation utilities,  Up: Code translation utilities

Usage and interface (`expansion_tools')
=======================================

   * *Library usage:*

     This library is provided as a tool for those modules which
     performs source-to-source code translation, usually known as
     _code expanders_. It may be loaded as other modules using a
     `use_module/1'. Nothing special needs to be done.

   * *Exports:*
        - _Predicates:_

          `imports_meta_pred/3', `body_expander/6', `arg_expander/6'.


   * *Other modules used:*
        - _System library modules:_

          `compiler/c_itf'.




File: ciao.info,  Node: Documentation on exports (expansion_tools),  Next: Documentation on internals (expansion_tools),  Prev: Usage and interface (expansion_tools),  Up: Code translation utilities

Documentation on exports (`expansion_tools')
============================================

 - PREDICATE: imports_meta_pred/3:
     Macro provided in order to know meta-predicate specifications
     accessible from a module.

     *Usage:* `imports_meta_pred(Module,MetaSpec,AccessibleAt)'
        - _Description:_ Tells whether `MetaSpec' meta-predicate
          specification is accessible from `Module'. `AccessibleAt'
          will be binded to '-' whether meta-predicate is a builtin
          one. If not, it will be unified with the module which
          defines the meta-predicate.

        - _The following properties should hold at call time:_

          `Module' is an atom.   (`basic_props:atm/1')

          `MetaSpec' is any term.   (`basic_props:term/1')

          `AccessibleAt' is a free variable.   (`term_typing:var/1')



 - PREDICATE: body_expander/6:
     This predicate is the main translation tool. It navigates
     through a clause body, when a single _goal_ appears, user-code
     is called in order to perform a translation. Whether user-code
     fails to translate the involved goal, it remains the same.
     Regardless that goal is translated or not, an argument expansion
     will be performed over all goals if applicable (see
     `arg_expander/6' predicate).

     Variable (unknown at compile time) goals will also be attempt to
     translate.

     _Meta-predicate_ with arguments:
     `body_expander(pred(3),pred(3),pred(3),?,?,?)'.

     *Usage:*
     `body_expander(GoalTrans,FactTrans,SpecTrans,Module,Body,ExpandedBody)'
        - _Description:_ Translates `Body' to `ExpandedBody' by the
          usage of user-defined translators `GoalTrans', `FactTrans'
          and `SpecTrans'. The module where the original body appears
          must be unified with `Module' argument.

        - _The following properties should hold at call time:_

          `GoalTrans' is a user-defined predicate which performs
          _goal_ meta-type translation
          (`expansion_tools:goal_expander/1')

          `FactTrans' is a user-defined predicate which performs
          _fact_ meta-type translation
          (`expansion_tools:fact_expander/1')

          `SpecTrans' is a user-defined predicate which performs
          _spec_ meta-type translation
          (`expansion_tools:spec_expander/1')

          `Module' is an atom.   (`basic_props:atm/1')

          `Body' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')

          `ExpandedBody' is a free variable.   (`term_typing:var/1')



 - PREDICATE: arg_expander/6:
     This predicate is an auxiliary translation tool, which is used by
     `body_expander/6' predicate. It remains exported as a macro. The
     predicate navigates through the _meta-argument specification_ of
     a goal. Whether a _goal,fact or spec_ argument appears,
     user-code is called in order to perform a translation. Whether
     user-code fails to translate the involved argument, it remains
     the same. Builtins as ','/2 or ';'/2 are treated as
     meta-predicates defining _goal_ meta-arguments. When a _goal_
     meta-argument is located, `body_expander/6' will be called in
     order to navigate through it. Notice that a _goal_ meta-argument
     may be unified with another goal defining another meta-argument,
     so navigation is required. If arguments are not known to
     arg_expander/6, translation will not occur. This is posible
     whether goal or qualifing module are variables.

     _Meta-predicate_ with arguments:
     `arg_expander(pred(3),pred(3),pred(3),?,?,?)'.

     *Usage:*
     `arg_expander(GoalTrans,FactTrans,SpecTrans,Module,Goal,ExpandedGoal)'
        - _Description:_ Translates `Goal' to `ExpandedGoal' by
          applying user-defined translators (`GoalTrans', `FactTrans'
          and `SpecTrans') to each meta-argument present at such
          goal. The module where the original goal appears must be
          unified with `Module' argument.

        - _The following properties should hold at call time:_

          `GoalTrans' is a user-defined predicate which performs
          _goal_ meta-type translation
          (`expansion_tools:goal_expander/1')

          `FactTrans' is a user-defined predicate which performs
          _fact_ meta-type translation
          (`expansion_tools:fact_expander/1')

          `SpecTrans' is a user-defined predicate which performs
          _spec_ meta-type translation
          (`expansion_tools:spec_expander/1')

          `Module' is an atom.   (`basic_props:atm/1')

          `Goal' is currently a term which is not a free variable.
          (`term_typing:nonvar/1')

          `ExpandedBody' is a free variable.   (`term_typing:var/1')




File: ciao.info,  Node: Documentation on internals (expansion_tools),  Next: Known bugs and planned improvements (expansion_tools),  Prev: Documentation on exports (expansion_tools),  Up: Code translation utilities

Documentation on internals (`expansion_tools')
==============================================

 - PROPERTY: expander_pred/1:
     *Usage:* `expander_pred(Pred)'
        - _Description:_ `Pred' is a user-defined predicate used to
          perform code translations. First argument will be binded to
          the corresponding term to be translated. Second argument
          must be binded to the corresponding translation. Third
          argument will be binded to the current module were first
          argument appears. Additional arguments will be user-defined.




File: ciao.info,  Node: Known bugs and planned improvements (expansion_tools),  Prev: Documentation on internals (expansion_tools),  Up: Code translation utilities

Known bugs and planned improvements (`expansion_tools')
=======================================================

   * _pred(N)_ meta-arguments are not supported at this moment.


File: ciao.info,  Node: Low-level concurrency/multithreading primitives,  Next: conc_aggregates (library),  Prev: Code translation utilities,  Up: Top

Low-level concurrency/multithreading primitives
***********************************************

   *Author(s):* Manuel Carro.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#145 (2000/5/18, 16:13:40 CEST)

   This module provides basic mechanisms for using concurrency and
implementing multi-goal applications.  It provides a means for
arbitrary goals to be specified to be run in a separate stack set; in
that case, they are assigned a goal identifier with which further
accesses (e.g., asking for more solutions) to the goal can be made.
Additionally, in some architectures, these goals can be assigned an
O.S. thread, separate from the one which made the initial call, thus
providing concurrency and, in multiprocessors, parallelism
capabilities.

   As for now, the memory space of the threads (c.f., stack sets) is
separate in the sense that goals are copied to the new stack set, and
bindings of variables are not seen among stack sets which allows
forward and backward execution to proceed independently in each stack
set, at the cost of the initial goal copy. However, the program space
(including, specially, the concurrent predicates) are shared and seen
by all the goals and threads, and should be used as the primary means
of communication and synchronization. Higer level libraries can be
built using these basic blocks.

   Additionally, a small set of lock primitives are provided. Locks
are associated with atom names. Whereas the concurrent database
facilities are enough to implement locks, semaphores, messages, etc.,
the predicates implementing atom-based locks are faster than the ones
accessing the concurrent database (but they are less powerful).

* Menu:

* Usage and interface (concurrency)::
* Documentation on exports (concurrency)::
* Known bugs and planned improvements (concurrency)::


File: ciao.info,  Node: Usage and interface (concurrency),  Next: Documentation on exports (concurrency),  Prev: Low-level concurrency/multithreading primitives,  Up: Low-level concurrency/multithreading primitives

Usage and interface (`concurrency')
===================================

   * *Library usage:*

     These predicates are builtin in Ciao, so nothing special has to
     be done to use them.

   * *Exports:*
        - _Predicates:_

          `eng_call/4', `eng_call/3', `eng_backtrack/2', `eng_cut/1',
          `eng_release/1', `eng_wait/1', `eng_kill/1',
          `eng_killothers/0', `eng_self/1', `eng_status/0',
          `lock_atom/1', `unlock_atom/1', `atom_lock_state/2'.




File: ciao.info,  Node: Documentation on exports (concurrency),  Next: Known bugs and planned improvements (concurrency),  Prev: Usage and interface (concurrency),  Up: Low-level concurrency/multithreading primitives

Documentation on exports (`concurrency')
========================================

 - PREDICATE: eng_call/4:
     _Meta-predicate_ with arguments: `eng_call(goal,?,?,?)'.

     *Usage:*
     `eng_call(+Goal,+EngineCreation,+ThreadCreation,-GoalId)'
        - _Description:_ Calls `Goal' in a new engine (stack set),
          possibly using a new thread, and returns a `GoalId' to
          designate this new goal henceforth. `EngineCreation' can be
          either `wait' or `create'; the distinction is not yet
          meaningful. `ThreadCreation' can be one of `self', `wait',
          or `create'. In the first case the creating thread is used
          to execute `Goal', and thus it has to wait until its first
          result or failure. The call will fail if `Goal' fails, and
          succeed otherwise. However, the call will always suceed
          when a remote thread is started. The space and identifiers
          reclaimed for the thread must be explicitly deallocated by
          calling `eng_release/1'.

        - _The following properties should hold at call time:_

          `+Goal' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')

          `+EngineCreation' is an atom.   (`basic_props:atm/1')

          `+ThreadCreation' is an atom.   (`basic_props:atm/1')

          `-GoalId' is an integer.   (`basic_props:int/1')



 - PREDICATE: eng_call/3:
     _Meta-predicate_ with arguments: `eng_call(goal,?,?)'.

     *Usage:* `eng_call(+Goal,+EngineCreation,+ThreadCreation)'
        - _Description:_ Similar to `eng_call/4', but the thread (if
          created) and stack areas are automatically released upon
          success or failure of the goal. No `GoalId' is provided for
          further interaction with the goal.

        - _The following properties should hold at call time:_

          `+Goal' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')

          `+EngineCreation' is an atom.   (`basic_props:atm/1')

          `+ThreadCreation' is an atom.   (`basic_props:atm/1')



 - PREDICATE: eng_backtrack/2:
     *Usage:* `eng_backtrack(+GoalId,+ThreadCreation)'
        - _Description:_ Performs backtracking on the goal designed
          by `GoalId'. A new thread can be used to perform
          backtracking, according to `ThreadCreation' (same as in
          `eng_call/4'). Fails if the goal is backtracked over by the
          local thread, and there are no more solutions. Always
          succeeds if executed by a remote thread. The engine is
          *not* automatically released up upon failure:
          `eng_release/1' must be called to that end.

        - _The following properties should hold at call time:_

          `+GoalId' is an integer.   (`basic_props:int/1')

          `+ThreadCreation' is an atom.   (`basic_props:atm/1')



 - PREDICATE: eng_cut/1:
     *Usage:* `eng_cut(+GoalId)'
        - _Description:_ Performs a _cut_ in the execution of the
          goal `GoalId'. The next call to `eng_backtrack/2' will
          therefore backtrack all the way and fail.

        - _The following properties should hold at call time:_

          `+GoalId' is an integer.   (`basic_props:int/1')



 - PREDICATE: eng_release/1:
     *Usage:* `eng_release(+GoalId)'
        - _Description:_ Cleans up and releases the engine executing
          the goal designed by `GoalId'. The engine must be idle,
          i.e., currently not exedcuting any goal.  `eng_wait/1' can
          be used to ensure this.

        - _The following properties should hold at call time:_

          `+GoalId' is an integer.   (`basic_props:int/1')



 - PREDICATE: eng_wait/1:
     *Usage:* `eng_wait(+GoalId)'
        - _Description:_ Waits for the engine executing the goal
          denoted by `GoalId' to finish the computation (i.e., it has
          finished searching for a solution, either with success or
          failure).

        - _The following properties should hold at call time:_

          `+GoalId' is an integer.   (`basic_props:int/1')



 - PREDICATE: eng_kill/1:
     *Usage:* `eng_kill(+GoalId)'
        - _Description:_ Kills the thread executing `GoalId' (if
          any), and frees the memory used up by the stack set.
          Usually one should wait ( `eng_wait/1') for a goal, and
          then release it, but killing the thread explicitly allows
          recovering from error states. A goal cannot kill itself.
          This feature should be used with caution, because there are
          situations where killing a thread might render the system
          in an unstable state. Threads should cooperate in their
          killing, but if the killed thread is blocked in a I/O
          operation, or inside an internal critical region, this
          cooperation is not possible and the system, although
          stopped, might very well end up in a incosistent state.

        - _The following properties should hold at call time:_

          `+GoalId' is an integer.   (`basic_props:int/1')



 - PREDICATE: eng_killothers/0:
     *Usage:*
        - _Description:_ Kills threads and releases stack sets of all
          active goals, but the one calling `eng_killothers'. Again,
          a safety measure. The same cautions as with `eng_kill/1'
          should be taken.



 - PREDICATE: eng_self/1:
     *Usage:* `eng_self(?GoalId)'
        - _Description:_ `GoalId' is unified with the identifier of
          the goal within which `eng_self/1' is executed.

        - _The following properties should hold at call time:_

          `?GoalId' is an integer.   (`basic_props:int/1')



 - PREDICATE: eng_status/0:
     *Usage:*
        - _Description:_ Prints to standard output the current status
          of the stack sets.



 - PREDICATE: lock_atom/1:
     *Usage:* `lock_atom(+Atom)'
        - _Description:_ The semaphore associated to `Atom' is
          accessed; if its value is nonzero, it is atomically
          decremented and the execution of this thread proceeds.
          Otherwise, the goal waits until a nonzero value is reached.
          The semaphore is then atomically decremented and the
          execution of this thread proceeds.

        - _The following properties should hold at call time:_

          `+Atom' is an atom.   (`basic_props:atm/1')



 - PREDICATE: unlock_atom/1:
     *Usage:* `unlock_atom(+Atom)'
        - _Description:_ The semaphore associated to `Atom' is
          atomically incremented.

        - _The following properties should hold at call time:_

          `+Atom' is an atom.   (`basic_props:atm/1')



 - PREDICATE: atom_lock_state/2:
     *Usage 1:* `atom_lock_state(+Atom,+Value)'
        - _Description:_ Sets the semaphore associated to `Atom' to
          `Value'. This is usually done at the beginning of the
          execution, but can be executed at any time. If not called,
          semaphore associated to atoms are by default inited to 1.
          It should be used with caution: arbitrary use can transform
          programs using locks in a mess of internal relations. The
          change of a semaphore value in a place other than the
          initialization stage of a program is *not* among the
          allowed operations as defined by Dijkstra [Dij65,BA82].

        - _The following properties should hold at call time:_

          `+Atom' is an atom.   (`basic_props:atm/1')

          `+Value' is an integer.   (`basic_props:int/1')

     *Usage 2:* `atom_lock_state(+Atom,-Value)'
        - _Description:_ Consults the `Value' of the semaphore
          associated to `Atom'. Use sparingly and mainly as a medium
          to check state correctness. Not among the operations on
          semaphore by Djikstra.

        - _The following properties should hold at call time:_

          `+Atom' is an atom.   (`basic_props:atm/1')

          `-Value' is an integer.   (`basic_props:int/1')




File: ciao.info,  Node: Known bugs and planned improvements (concurrency),  Prev: Documentation on exports (concurrency),  Up: Low-level concurrency/multithreading primitives

Known bugs and planned improvements (`concurrency')
===================================================

   * *This library is being rewritten at the moment. The Prolog
     interface herein described may not correspond exactly with the
     existing implementation. This note will be removed when the
     documentation corresponds to the implementation.*

   * Available architectures implementing POSIX threads and in
     Windows 32 environments.

   * Some implementation of threads have a limit on the total number
     of threads that can be created by a process. Thread creation, in
     this case, just hangs. A better solution is planned for the
     future.


File: ciao.info,  Node: conc_aggregates (library),  Next: The socket interface,  Prev: Low-level concurrency/multithreading primitives,  Up: Top

conc_aggregates (library)
*************************

   *Author(s):* Concurrent-safe (and incomplete) version of the
aggregates predicates, based on the regular versions by Richard A.
O'Keefe and David H.D. Warren. Concurrency-safeness provided by
Manuel Carro..

   This module implements thread-safe aggregation predicates. Its use
and results should be the same as those in the aggregates library,
but several goals can use them concurrently without the interference
and wrong results (due to implementation reasons) aggregates might
lead to. This particular implementation is completely based on the
one used in the aggregates library.

* Menu:

* Usage and interface (conc_aggregates)::
* Documentation on exports (conc_aggregates)::
* Known bugs and planned improvements (conc_aggregates)::


File: ciao.info,  Node: Usage and interface (conc_aggregates),  Next: Documentation on exports (conc_aggregates),  Prev: conc_aggregates (library),  Up: conc_aggregates (library)

Usage and interface (`conc_aggregates')
=======================================

   * *Library usage:*

     `:- use_module(library(conc_aggregates)).'

   * *Exports:*
        - _Predicates:_

          `findall/3'.


   * *Other modules used:*
        - _System library modules:_

          `prolog_sys'.




File: ciao.info,  Node: Documentation on exports (conc_aggregates),  Next: Known bugs and planned improvements (conc_aggregates),  Prev: Usage and interface (conc_aggregates),  Up: conc_aggregates (library)

Documentation on exports (`conc_aggregates')
============================================

 - PREDICATE: findall/3:
     _Meta-predicate_ with arguments: `findall(?,goal,?)'.

     *Usage:* `findall(?Template,+Generator,?List)' < * ISO * >
        - _Description:_ A special case of bagof, where all free
          variables in the `Generator' are taken to be existentially
          quantified. Safe in concurrent applications.




File: ciao.info,  Node: Known bugs and planned improvements (conc_aggregates),  Prev: Documentation on exports (conc_aggregates),  Up: conc_aggregates (library)

Known bugs and planned improvements (`conc_aggregates')
=======================================================

   * Thread-safe `setof/3' is not yet implemented.

   * Thread-safe `bagof/3' is not yet implemented.


File: ciao.info,  Node: The socket interface,  Next: *** PART VII - Ciao Prolog extensions,  Prev: conc_aggregates (library),  Up: Top

The socket interface
********************

   *Author(s):* Manuel Carro, Daniel Cabeza.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#169 (2000/7/6, 13:27:35 CEST)

   This module defines primitives to open sockets, send, and receive
data from them. This allows communicating with other processes, on
the same machine or across the Internet. The reader should also
consult standard bibliography on the topic for a proper use of these
primitives.

* Menu:

* Usage and interface (sockets)::
* Documentation on exports (sockets)::


File: ciao.info,  Node: Usage and interface (sockets),  Next: Documentation on exports (sockets),  Prev: The socket interface,  Up: The socket interface

Usage and interface (`sockets')
===============================

   * *Library usage:*

     `:- use_module(library(sockets)).'

   * *Exports:*
        - _Predicates:_

          `connect_to_socket/3', `socket_recv/2',
          `hostname_address/2', `socket_recv_code/3', `socket_send/2',
          `select_socket/5', `socket_accept/2', `bind_socket/3',
          `connect_to_socket_type/4'.

        - _Regular Types:_

          `socket_type/1'.


   * *Other modules used:*
        - _System library modules:_

          `sockets/sockets_c'.




File: ciao.info,  Node: Documentation on exports (sockets),  Prev: Usage and interface (sockets),  Up: The socket interface

Documentation on exports (`sockets')
====================================

 - PREDICATE: connect_to_socket/3:
     *Usage:* `connect_to_socket(+Host,+Port,-Stream)'
        - _Description:_ Calls `connect_to_socket_type/4' with
          SOCK_STREAM connection type. This is the connection type
          you want in order to use the `write/2' and `read/2'
          predicates (and other stream IO related predicates).

        - _Call and exit should be _compatible_ with:_

          `+Host' is an atom.   (`basic_props:atm/1')

          `+Port' is an integer.   (`basic_props:int/1')

          `-Stream' is an open stream.   (`streams_basic:stream/1')



 - PREDICATE: socket_recv/2:
     *Usage:* `socket_recv(+Stream,?String)'
        - _Description:_ As `socket_recv_code/3', but the return code
          is ignored.

        - _Call and exit should be _compatible_ with:_

          `+Stream' is an open stream.   (`streams_basic:stream/1')

          `?String' is a string (a list of character codes).
          (`basic_props:string/1')



 - REGTYPE: socket_type/1:
     Defines the atoms which can be used to specify the socket type
     recognized by `connect_to_socket_type/4'. Defined as follows:
          socket_type(stream).
          socket_type(dgram).
          socket_type(raw).
          socket_type(seqpacket).
          socket_type(rdm).

     *Usage:* `socket_type(T)'
        - _Description:_ `T' is a valid socket type.



 - PREDICATE: hostname_address/2:
     *Usage:* `hostname_address(+Hostname,?Address)'
        - _Description:_ `Address' is unified with the atom
          representing the address (in AF_INET format) corresponding
          to `Hostname'.

        - _Call and exit should be _compatible_ with:_

          `+Hostname' is an atom.   (`basic_props:atm/1')

          `?Address' is an atom.   (`basic_props:atm/1')



 - PREDICATE: socket_recv_code/3:
     *Usage:* `socket_recv_code(+Stream,?String,?Length)'
        - _Description:_ Receives a `String' from the socket
          associated to `Stream', and returns its `Length'. If
          `Length' is -1, no more data is available.

        - _Call and exit should be _compatible_ with:_

          `+Stream' is an open stream.   (`streams_basic:stream/1')

          `?String' is a string (a list of character codes).
          (`basic_props:string/1')

          `?Length' is an integer.   (`basic_props:int/1')



 - PREDICATE: socket_send/2:
     *Usage:* `socket_send(+Stream,+String)'
        - _Description:_ Sends `String' to the socket associated to
          `Stream'. The socket has to be in connected state. `String'
          is not supposed to be NULL terminated, since it is a Prolog
          string. If a NULL terminated string is needed at the other
          side, it has to be explicitly created in Prolog.

        - _Call and exit should be _compatible_ with:_

          `+Stream' is an open stream.   (`streams_basic:stream/1')

          `+String' is a string (a list of character codes).
          (`basic_props:string/1')



 - PREDICATE: select_socket/5:
     *Usage:*
     `select_socket(+Socket,-NewStream,+TO_ms,+Streams,-ReadStreams)'
        - _Call and exit should be _compatible_ with:_

          `+Socket' is an integer.   (`basic_props:int/1')

          `-NewStream' is an open stream.   (`streams_basic:stream/1')

          `+TO_ms' is an integer.   (`basic_props:int/1')

          `+Streams' is a list of `stream's.   (`basic_props:list/2')

          `-ReadStreams' is a list of `stream's.
          (`basic_props:list/2')



 - PREDICATE: socket_accept/2:
     *Usage:* `socket_accept(+Sock,-Stream)'
        - _Description:_ Creates a new `Stream' connected to `Sock'.

        - _Call and exit should be _compatible_ with:_

          `+Sock' is an integer.   (`basic_props:int/1')

          `-Stream' is an open stream.   (`streams_basic:stream/1')



 - PREDICATE: bind_socket/3:
     *Usage:* `bind_socket(?Port,+Length,-Socket)'
        - _Description:_ Returs an AF_INET `Socket' bound to `Port'
          (which may be assigned by the OS or defined by the caller),
          and listens to it (hence no listen call in this set of
          primitives). `Length' specifies the maximum number of
          pending connections.

        - _Call and exit should be _compatible_ with:_

          `?Port' is an integer.   (`basic_props:int/1')

          `+Length' is an integer.   (`basic_props:int/1')

          `-Socket' is an integer.   (`basic_props:int/1')



 - PREDICATE: connect_to_socket_type/4:
     *Usage:* `connect_to_socket_type(+Host,+Port,+Type,-Stream)'
        - _Description:_ Returns a `Stream' which connects to `Host'.
          The `Type' of connection can be defined. A `Stream' is
          returned, which can be used to `write/2' to, to `read/2', to
          `socket_send/2' to, or to `socket_recv/2' from the socket.

        - _Call and exit should be _compatible_ with:_

          `+Host' is currently instantiated to an atom.
          (`term_typing:atom/1')

          `+Port' is an integer.   (`basic_props:int/1')

          `+Type' is a valid socket type.   (`sockets:socket_type/1')

          `-Stream' is an open stream.   (`streams_basic:stream/1')




File: ciao.info,  Node: *** PART VII - Ciao Prolog extensions,  Next: Pure Prolog package,  Prev: The socket interface,  Up: Top

PART VII - Ciao Prolog extensions
*********************************

   The libraries documented in this part extend the Ciao language in
several different ways. The extensions include:
   * pure Prolog programming (well, this can be viewed more as a
     restriction than an extension);

   * feature terms or _records_ (i.e., structures with names for each
     field);

   * parallel programming (e.g., &-Prolog style);

   * functional syntax;

   * higher-order library;

   * global variables;

   * `setarg' and `undo';

   * delaying predicate execution;

   * active modules;

   * breadth-first execution;

   * iterative deepening-based execution;

   * constraint logic programming;

   * object oriented programming.


File: ciao.info,  Node: Pure Prolog package,  Next: argnames (library),  Prev: *** PART VII - Ciao Prolog extensions,  Up: Top

Pure Prolog package
*******************

   This library package allows the use of _pure Prolog_ in a Ciao
module/program. It is based on the fact that if an _engine module_ is
imported explicitly then all of them have to be imported explicitly.
The engine modules are:
   * `engine(arithmetic)'

     *Note Arithmetic::.

   * `engine(atomic_basic)'

     *Note Basic predicates handling names of constants::.

   * `engine(attributes)'

     *Note Attributed variables::.

   * `engine(basic_props)'

     *Note Basic data types and properties::.

   * `engine(basiccontrol)'

     *Note Control constructs/predicates::.

   * `engine(data_facts)'

     *Note Fast/concurrent update of facts::.

   * `engine(exceptions)'

     *Note Exception handling::.

   * `engine(io_aux)'

     *Note Message printing primitives::.

   * `engine(io_basic)'

     *Note Basic input/output::.

   * `engine(prolog_flags)'

     *Note Changing system behaviour and various flags::.

   * `engine(streams_basic)'

     *Note Basic file/stream handling::.

   * `engine(system_info)'

     *Note Gathering some basic internal info::.

   * `engine(term_basic)'

     *Note Basic term manipulation::.

   * `engine(term_compare)'

     *Note Comparing terms::.

   * `engine(term_typing)'

     *Note Extra-logical properties for typing::.

   Note that if any of these modules is explicitely imported in a
program then the language defaults to Pure Prolog, plus the
functionality added by the modules explicitely imported.

   It is recommended that if you explicitely import an engine module
you also use this package, which will guarantee that the predicate
`true/0' is defined (note that this is the only Ciao builtin which
cannot be redefined).

* Menu:

* Usage and interface (pure)::


File: ciao.info,  Node: Usage and interface (pure),  Prev: Pure Prolog package,  Up: Pure Prolog package

Usage and interface (`pure')
============================

   * *Library usage:*

     `:- use_package(pure).'

     or

     `:- module(...,...,[pure]).'


File: ciao.info,  Node: argnames (library),  Next: Independent and-parallel execution,  Prev: Pure Prolog package,  Up: Top

argnames (library)
******************

* Menu:

* Usage and interface (argnames)::


File: ciao.info,  Node: Usage and interface (argnames),  Prev: argnames (library),  Up: argnames (library)

Usage and interface (`argnames')
================================

   * *Library usage:*

     `:- use_package(argnames).'

     or

     `:- module(...,...,[argnames]).'

   * *New operators defined:*

     `$/2' [150,xfx], `=>/2' [950,xfx], `argnames/1' [1150,fx].

   * *Other modules used:*
        - _System library modules:_

          `aggregates', `dynamic', `iso_misc', `iso_byte_char',
          `iso_incomplete', `operators', `read', `write'.




File: ciao.info,  Node: Independent and-parallel execution,  Next: functions (library),  Prev: argnames (library),  Up: Top

Independent and-parallel execution
**********************************

   *Author(s):* Manuel Hermenegildo, Manuel Carro.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.3#120 (1999/11/26, 12:5:17 MET)

   This library allows and-parallel execution of goals in
(Herbrand-)independent fashion. It resembles the execution rules of
&-Prolog [HG90]. Basically, goals are run in and-parallel _provided
that their arguments do not share bindings_, i.e., are not bound to
terms which contain a common variable.

* Menu:

* Usage and interface (andprolog)::
* Documentation on exports (andprolog)::
* Known bugs and planned improvements (andprolog)::


File: ciao.info,  Node: Usage and interface (andprolog),  Next: Documentation on exports (andprolog),  Prev: Independent and-parallel execution,  Up: Independent and-parallel execution

Usage and interface (`andprolog')
=================================

   * *Library usage:*

     `:- use_module(library(andprolog)).'

   * *Exports:*
        - _Predicates:_

          `', `=>/2', `active_agents/1'.

        - _Properties:_

          `indep/1', `indep/2'.


   * *Other modules used:*
        - _System library modules:_

          `assertions/doc_props', `concurrency/concurrency'.




File: ciao.info,  Node: Documentation on exports (andprolog),  Next: Known bugs and planned improvements (andprolog),  Prev: Usage and interface (andprolog),  Up: Independent and-parallel execution

Documentation on exports (`andprolog')
======================================

 - PREDICATE:
     `'

     `GoalA' and `GoalB' are run in independent and-parallel fashion.
     This is just a first sketch, and valid only for deterministic
     independent goals.

     _Meta-predicate_ with arguments: `'.




 - PREDICATE: =>/2:
     `=>(A,B)'

     If `A' is true `B' is run in parallel, otherwise sequentially.

     _Meta-predicate_ with arguments: `=>(goal,goal)'.

     *Usage:* `=>(A,B)'
        - _The following properties should hold at call time:_

          `B' is of the form `goal&goal'.
          (`andprolog:andcallable/1')

        - _The following properties hold globally:_

          Documentation is still incomplete: `=>(A,B)' may not
          conform the functionality documented.
          (`doc_props:doc_incomplete/1')



 - PROPERTY: indep/1:
     `indep(X)'

     The variables in each pair of the list ``X'' are pairwise
     independent.

     *Usage:* `indep(X)'
        - _Description:_ The variables in pairs in ``X'' are pairwise
          independent.



 - PROPERTY: indep/2:
     `indep(X,Y)'

     `X' and `Y' are _independent_, i.e., they are bound to terms
     which have no variables in common. For example, `indep(X,Y)'
     holds for `X=f(Z),Y=g(K)' and also for `X=f(a),Y=X' (since both
     `X' and `Y' are bound to ground terms). It does not hold for
     `X=f(Z),Y=g(Z)' and for `X=Y'.

     *Usage:* `indep(X,Y)'
        - _Description:_ `X' and `Y' do not have variables in common.



 - PREDICATE: active_agents/1:
     *Usage:* `active_agents(?NumberOfAgents)'
        - _Description:_ Tests/sets the number of active agents
          looking for goals to execute. As for now, those agents are
          resource-consuming, even when they are just looking for
          work, and not executing any user goals.

        - _The following properties should hold at call time:_

          `?NumberOfAgents' is an integer.   (`basic_props:int/1')




File: ciao.info,  Node: Known bugs and planned improvements (andprolog),  Prev: Documentation on exports (andprolog),  Up: Independent and-parallel execution

Known bugs and planned improvements (`andprolog')
=================================================

   * *Beware:* it is highly unstable and probably not correct at all
     at the moment! It is provided for the sole purpose of
     experimentation and development.

   * The fact that only the first solution is returned for the
     conjunction is due to performance matters, and we expect to
     remove it in a near future.

   * CGEs (i.e., `=>') are not supported.

   * The `indep/1', `indep/2', and `ground/1' are not very efficient;
     they might be replaced by native versions in a future.


File: ciao.info,  Node: functions (library),  Next: Some Higher-Order Predicates,  Prev: Independent and-parallel execution,  Up: Top

functions (library)
*******************

* Menu:

* Usage and interface (functions)::


File: ciao.info,  Node: Usage and interface (functions),  Prev: functions (library),  Up: functions (library)

Usage and interface (`functions')
=================================

   * *Library usage:*

     `:- use_package(functions).'

     or

     `:- module(...,...,[functions]).'

   * *New operators defined:*

     `function/1' [1150,fx], `:=/2' [800,xfx], `~/1' [50,fx].

   * *Other modules used:*
        - _System library modules:_

          `aggregates', `dynamic', `iso_misc', `iso_byte_char',
          `iso_incomplete', `operators', `read', `write'.




File: ciao.info,  Node: Some Higher-Order Predicates,  Next: global (library),  Prev: functions (library),  Up: Top

Some Higher-Order Predicates
****************************

   *Author(s):* Daniel Cabeza.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#65 (2000/3/15, 22:9:28 CET)

   This library implements a few basic higher-order predicates. These
add functionality to the basic higher-order functionality of Ciao.
Examples of the latter are:

   Using pred(1):

       list(L, between(1,6))
       list(L, functor(_,2))
       list(L, >(0))

   Using pred(2):

* Menu:

* Usage and interface (hiord)::
* Documentation on exports (hiord)::


File: ciao.info,  Node: Usage and interface (hiord),  Next: Documentation on exports (hiord),  Prev: Some Higher-Order Predicates,  Up: Some Higher-Order Predicates

Usage and interface (`hiord')
=============================

   * *Library usage:*

     `:- use_module(library(hiord)).'

   * *Exports:*
        - _Predicates:_

          `map/3', `foldl/4'.




File: ciao.info,  Node: Documentation on exports (hiord),  Prev: Usage and interface (hiord),  Up: Some Higher-Order Predicates

Documentation on exports (`hiord')
==================================

 - PREDICATE: map/3:
     _Meta-predicate_ with arguments: `map(?,pred(2),?)'.

     *Usage:* `map(LList,Op,RList)'
        - _Description:_ Examples of use:
                 map([1,3,2], arg(f(a,b,c,d)), [a,c,b]) or
                 map([1,3,2], nth([a,b,c,d]), [a,c,b])
                 map(["D","C"], append("."), ["D.","C."])




 - PREDICATE: foldl/4:
     _Meta-predicate_ with arguments: `foldl(?,?,pred(3),?)'.

     *Usage:* `foldl(List,Seed,Op,Result)'
        - _Description:_ Example of use:
               ?- foldl(["daniel","cabeza","gras"], "",
                        (:(X,Y,Z) :- append(X, " "||Y, Z)), R).
               
               R = "daniel cabeza gras " ?





File: ciao.info,  Node: global (library),  Next: Miscellaneous predicates,  Prev: Some Higher-Order Predicates,  Up: Top

global (library)
****************

   *Version:* 0.4#5 (1998/2/24)

* Menu:

* Usage and interface (global)::
* Documentation on exports (global)::


File: ciao.info,  Node: Usage and interface (global),  Next: Documentation on exports (global),  Prev: global (library),  Up: global (library)

Usage and interface (`global')
==============================

   * *Library usage:*

     `:- use_module(library(global)).'

   * *Exports:*
        - _Predicates:_

          `set_global/2', `get_global/2', `push_global/2',
          `pop_global/2', `del_global/1'.




File: ciao.info,  Node: Documentation on exports (global),  Prev: Usage and interface (global),  Up: global (library)

Documentation on exports (`global')
===================================

 - PREDICATE: set_global/2:
     No further documentation available for this predicate.




 - PREDICATE: get_global/2:
     No further documentation available for this predicate.




 - PREDICATE: push_global/2:
     No further documentation available for this predicate.




 - PREDICATE: pop_global/2:
     No further documentation available for this predicate.




 - PREDICATE: del_global/1:
     No further documentation available for this predicate.





File: ciao.info,  Node: Miscellaneous predicates,  Next: Delaying predicates (freeze),  Prev: global (library),  Up: Top

Miscellaneous predicates
************************

   *Author(s):* Manuel Carro, Daniel Cabeza.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.3#95 (1999/11/8, 18:37:30 MET)

   This module implements some miscellaneous non-logical (but
sometimes very useful) predicates.

* Menu:

* Usage and interface (odd)::
* Documentation on exports (odd)::


File: ciao.info,  Node: Usage and interface (odd),  Next: Documentation on exports (odd),  Prev: Miscellaneous predicates,  Up: Miscellaneous predicates

Usage and interface (`odd')
===========================

   * *Library usage:*

     `:- use_module(library(odd)).'

   * *Exports:*
        - _Predicates:_

          `setarg/3', `undo/1'.




File: ciao.info,  Node: Documentation on exports (odd),  Prev: Usage and interface (odd),  Up: Miscellaneous predicates

Documentation on exports (`odd')
================================

 - PREDICATE: setarg/3:
     *Usage:* `setarg(Index,Term,NewArg)'
        - _Description:_ Replace destructively argument `Index' in
          `Term' by `NewArg'. The assignment is undone on
          backtracking. This is a major change to the normal behavior
          of data assignment in Ciao Prolog.

        - _The following properties should hold at call time:_

          `Index' is currently instantiated to an integer.
          (`term_typing:integer/1')

          `Term' is a compound term.   (`basic_props:struct/1')

          `NewArg' is any term.   (`basic_props:term/1')

        - _The following properties hold upon exit:_

          `Index' is currently instantiated to an integer.
          (`term_typing:integer/1')

          `Term' is a compound term.   (`basic_props:struct/1')

          `NewArg' is any term.   (`basic_props:term/1')



 - PREDICATE: undo/1:
     *Usage:* `undo(Goal)'
        - _Description:_  `call(`Goal')' is executed on backtracking.
          This is a major change to the normal control of Ciao Prolog
          execution.

        - _The following properties should hold at call time:_

          `Goal' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')

        - _The following properties hold upon exit:_

          `Goal' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')




File: ciao.info,  Node: Delaying predicates (freeze),  Next: Delaying predicates (when),  Prev: Miscellaneous predicates,  Up: Top

Delaying predicates (freeze)
****************************

   *Author(s):* Manuel Carro, Daniel Cabeza.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#72 (2000/3/19, 19:9:14 CET)

   This library offers a simple implementation of `freeze/2',
`frozen/2', etc. [Col82,Nai85,Nai91,Car87] based on the use of
attributed variables [Hol92,Hol90].

* Menu:

* Usage and interface (freeze)::
* Documentation on exports (freeze)::
* Documentation on multifiles (freeze)::


File: ciao.info,  Node: Usage and interface (freeze),  Next: Documentation on exports (freeze),  Prev: Delaying predicates (freeze),  Up: Delaying predicates (freeze)

Usage and interface (`freeze')
==============================

   * *Library usage:*

     `:- use_module(library(freeze)).'

   * *Exports:*
        - _Predicates:_

          `freeze/2', `frozen/2'.

        - _Multifiles:_

          `verify_attribute/2', `combine_attributes/2'.




File: ciao.info,  Node: Documentation on exports (freeze),  Next: Documentation on multifiles (freeze),  Prev: Usage and interface (freeze),  Up: Delaying predicates (freeze)

Documentation on exports (`freeze')
===================================

 - PREDICATE: freeze/2:
     _Meta-predicate_ with arguments: `freeze(?,goal)'.

     *Usage:* `freeze(X,Goal)'
        - _Description:_ If `X' is free delay `Goal' until `X' is
          non-variable.

        - _The following properties should hold at call time:_

          `Goal' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')



 - PREDICATE: frozen/2:
     _Meta-predicate_ with arguments: `frozen(?,goal)'.

     *Usage:* `frozen(X,Goal)'
        - _Description:_ `Goal' is currently delayed until variable
          `X' becomes bound.

        - _The following properties should hold upon exit:_

          `Goal' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')




File: ciao.info,  Node: Documentation on multifiles (freeze),  Prev: Documentation on exports (freeze),  Up: Delaying predicates (freeze)

Documentation on multifiles (`freeze')
======================================

 - PREDICATE: verify_attribute/2:
     No further documentation available for this predicate.

     The predicate is _multifile_.




 - PREDICATE: combine_attributes/2:
     No further documentation available for this predicate.

     The predicate is _multifile_.





File: ciao.info,  Node: Delaying predicates (when),  Next: Active modules (high-level distributed execution),  Prev: Delaying predicates (freeze),  Up: Top

Delaying predicates (when)
**************************

   *Author(s):* Manuel Carro.

   *Version:* 1.5#172 (2000/7/12, 16:45:31 CEST)

   *Version of last change:* 1.5#165 (2000/6/26, 17:11:16 CEST)

   `when/2' delays a predicate until some condition in its variable
is met. For example, we may want to find out the maximum of two
numbers, but we are not sure when they will be instantiated. We can
write the standard `max/3' predicate (but changing its name to
`gmax/3' to denote that the first and second arguments must be
ground) as

     gmax(X, Y, X):- X > Y, !.
     gmax(X, Y, Y):- X =< Y.

   and then define a 'safe' `max/3' as

     max(X, Y, Z):-
             when((ground(X),ground(Y)), gmax(X, Y, Z)).

   which can be called as follows:

     ?- max(X, Y, Z) , Y = 0, X = 8.
     
     X = 8,
     Y = 0,
     Z = 8 ?
     
     yes

   Alternatively, `max/3' could have been defined as

     max(X, Y, Z):-
             when(ground((X, Y)), gmax(X, Y, Z)).

   with the same effects as above. More complex implementations are
possible. Look, for example, at the `max.pl' implementation under the
`when' library directory, where a `max/3' predicate is implemented
which waits on all the arguments until there is enough information to
determine their values:

     ?- use_module(library('when/max')).
     
     yes
     ?- max(X, Y, Z), Z = 5, Y = 4.
     
     X = 5,
     Y = 4,
     Z = 5 ?
     
     yes

* Menu:

* Usage and interface (when)::
* Documentation on exports (when)::
* Documentation on multifiles (when)::
* Known bugs and planned improvements (when)::


File: ciao.info,  Node: Usage and interface (when),  Next: Documentation on exports (when),  Prev: Delaying predicates (when),  Up: Delaying predicates (when)

Usage and interface (`when')
============================

   * *Library usage:*

     `:- use_module(library(when)).'

   * *Exports:*
        - _Predicates:_

          `when/2'.

        - _Regular Types:_

          `wakeup_exp/1'.

        - _Multifiles:_

          `verify_attribute/2', `combine_attributes/2'.


   * *Other modules used:*
        - _System library modules:_

          `metaterms', `sort', `sets'.




File: ciao.info,  Node: Documentation on exports (when),  Next: Documentation on multifiles (when),  Prev: Usage and interface (when),  Up: Delaying predicates (when)

Documentation on exports (`when')
=================================

 - PREDICATE: when/2:
     _Meta-predicate_ with arguments: `when(?,goal)'.

     *Usage:* `when(WakeupCond,Goal)'
        - _Description:_ Delays / executes `Goal' according to
          `WakeupCond' given. The `WakeupCond's now acceptable are
          `ground(T)' ( `Goal' is delayed until `T' is ground),
          `nonvar(T)' ( `Goal' is delayed until `T' is not a
          variable), and conjunctions and disjunctions of conditions:

               wakeup_exp(ground(_)).
               wakeup_exp(nonvar(_)).
               wakeup_exp((C1, C2)):- wakeup_exp(C1), wakeup_exp(C2).
               wakeup_exp((C1; C2)):- wakeup_exp(C1), wakeup_exp(C2).

          `when/2' only fails it the `WakeupCond' is not legally
          formed. If `WakeupCond' is met at the time of the call no
          delay mechanism is involved -- but there exists a time
          penalty in the condition checking.

          In case that an instantiation fires the execution of
          several predicates, the order in which these are executed
          is not defined.

        - _The following properties should hold at call time:_

          `WakeupCond' is a legal expression for delaying goals.
          (`when:wakeup_exp/1')

          `Goal' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')



 - REGTYPE: wakeup_exp/1:
     *Usage:* `wakeup_exp(T)'
        - _Description:_ `T' is a legal expression for delaying goals.




File: ciao.info,  Node: Documentation on multifiles (when),  Next: Known bugs and planned improvements (when),  Prev: Documentation on exports (when),  Up: Delaying predicates (when)

Documentation on multifiles (`when')
====================================

 - PREDICATE: verify_attribute/2:
     No further documentation available for this predicate.

     The predicate is _multifile_.




 - PREDICATE: combine_attributes/2:
     No further documentation available for this predicate.

     The predicate is _multifile_.





File: ciao.info,  Node: Known bugs and planned improvements (when),  Prev: Documentation on multifiles (when),  Up: Delaying predicates (when)

Known bugs and planned improvements (`when')
============================================

   * Redundant conditions are not removed.

   * Floundered goals are not appropriately printed.


File: ciao.info,  Node: Active modules (high-level distributed execution),  Next: Breadth-first execution,  Prev: Delaying predicates (when),  Up: Top

Active modules (high-level distributed execution)
*************************************************

   *Author(s):* Manuel Hermenegildo, Daniel Cabeza.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#141 (2000/5/11, 13:33:29 CEST)

   Active modules [CH95] provide a high-level model of inter-process
communication and distributed execution (note that using Ciao's
communication and concurrency primitives, such as sockets, concurrent
predicates, etc.). An _active module_ (or an _active object_) is an
ordinary module to which computational resources are attached, and
which resides at a given location on the network. Compiling an active
module produces an executable which, when running, acts as a server
for a number of predicates, the predicates exported by the module.
Predicates exported by an active module can be accessed by a program
on the network by simply "using" the module, which then imports such
"remote predicates." The process of loading an active module does not
involve transferring any code, but rather setting up things so that
calls in the module using the active module are executed as remote
procedure calls to the active module. This occurs in the same way
independently of whether the active module and the using module are
in the same machine or in different machines across the network.

   Except for having compiling it in a special way (see below), an
active module is identical from the programmer point of view to an
ordinary module. A program using an active module imports it and uses
it in the same way as any other module, except that it uses "
`use_active_module'" rather than " `use_module'" (see below). Also,
an active module has an address (network address) which must be known
in order to use it. In order to use an active module it is necessary
to know its address.

   (1)

   From the implementation point of view, active modules are
essentially daemons: executables which are started as independent
processes at the operating system level. Communication with active
modules is implemented using sockets (thus, the address of an active
module is an IP socket address in a particular machine). Requests to
execute goals in the module are sent through the socket by remote
programs. When such a request arrives, the process running the active
module takes it and executes it, returning through the socket the
computed answers. These results are then taken and used by the remote
processes. Backtracking over such remote calls works as usual and
transparently. The only limitation (this may change in the future,
but it is currently done for efficiency reasons) is that all
alternative answers are precomputed (and cached) upon the first call
to an active module and thus _an active module should not export a
predicate which has an infinite number of answers_.

   The first thing to do is to select a method whereby the client(s)
(the module(s) that will use the active module) can find out in which
machine/port (IP address/socket number) the server (i.e., the active
module) will be listening once started. The easiest way to do this is
to use of the redezvous methods which are provided in the Ciao
distribution in the `library/actmods' directory, such as
`tmpbased...' or `filebased...'.

   The first is based on saving the IP address and socket number of
the server in a file in a predefined directory (generally `/tmp', but
this can be changed by changing `tmpbased_common.pl').

   The second one is similar but saves the info in the directory in
which the server is started (as _<module_name>_`.addr'). The clients
must be started in the same directory. However, they can be started
in different machines, provided this directory is shared (e.g., by
NFS or Samba).

   These rendezvous methods are encoded in two modules: a first one,
called `...publish.pl', is used by the server to publish its info.
The second one, called `...locate.pl', is used by the client(s) to
locate the server info. For efficiency, the client methods maintain a
cache of addresses, so that the server information only needs to be
read from the file system the first time the active module is
accessed.

   Active modules are compiled using the `-a' option of the Ciao
compiler (this can also be done from the interactive top-level shell
using `make_actmod/2'). For example, issuing the following command:

       ciaoc -a 'actmods/filebased_publish' simple_server

   compiles the simple server example that comes with the
distribution (in the `actmods/example' directory). The
`simple_client_with_main' example (in the same directory) can be
compiled as usual:

       ciaoc simple_client_with_main

   Now, if the server is running (e.g., `simple_server &' in Un*x or
double-clicking on it in Win32) when the client is executed it will
connect with the server to access the predicate(s) that it imports
from it.

   A simpler even client `simple_client.pl' can be loaded into the
top level and its predicates called as usual (and they will connect
with the server if it is running).

   The architecture of the active modules model in Ciao allows
defining other methods for this communication to happen. For example,
one can implement a name server. This can itself be an active module
which resides at a fixed and known machine and port number (this is
known as a _service_ and is defined in `/etc/services' in a Un*x
machine). In order the best way is to mimick the code of the
redezvous methods provided in the Ciao distribution.

   Security: in the access method (?).

* Menu:

* Usage and interface (actmods)::
* Documentation on new declarations (actmods)::

   ---------- Footnotes ----------

   (1) It is also possible to provide active modules via a WWW
address. However, we find it more straightforward to simply use
socket addresses. In any case, this is generally hidden inside the
access method and can be thus made transparent to the user.


File: ciao.info,  Node: Usage and interface (actmods),  Next: Documentation on new declarations (actmods),  Prev: Active modules (high-level distributed execution),  Up: Active modules (high-level distributed execution)

Usage and interface (`actmods')
===============================

   * *Library usage:*

     `:- use_package(actmods).'

     or

     `:- module(...,...,[actmods]).'

   * *New declarations defined:*

     `use_active_module/2'.



File: ciao.info,  Node: Documentation on new declarations (actmods),  Prev: Usage and interface (actmods),  Up: Active modules (high-level distributed execution)

Documentation on new declarations (`actmods')
=============================================

 - DECLARATION: use_active_module/2:
     *Usage:* :- `use_active_module(AModule,Predicates)'.
        - _Description:_ Specifies that this code imports from the
          _active module_ defined in `AModule' the predicates in
          `Imports'. The imported predicates must be exported by the
          active module.

        - _The following properties should hold at call time:_

          `AModule' is a source name.   (`streams_basic:sourcename/1')

          `Predicates' is a list of `predname's.
          (`basic_props:list/2')




File: ciao.info,  Node: Breadth-first execution,  Next: Iterative-deepening execution,  Prev: Active modules (high-level distributed execution),  Up: Top

Breadth-first execution
***********************

   *Author(s):* Daniel Cabeza, Manuel Carro.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#143 (2000/5/12, 13:54:34 CEST)

   This package implements breadth-first execution of predicates.
Predicates written with operators `'<-'/1' (facts) and `'<-'/2'
(clauses) are executed using breadth-first search. This may be useful
in search problems when a complete proof procedure is needed. An
example of code would be:
     :- module(chain, _, [bf]).
     
     test(bf) :- bfchain(a,d).
     test(df) :- chain(a,d).   % loops!
     
     bfchain(X,X) <- .
     bfchain(X,Y) <- arc(X,Z), bfchain(Z,Y).
     
     chain(X,X).
     chain(X,Y) :- arc(X,Z), chain(Z,Y).
     
     arc(a,b).
     arc(a,d).
     arc(b,c).
     arc(c,a).

   There is another version, called `bf/af', which ensures
AND-fairness by goal shuffling. This version correctly says "`no'"
executing the following test:
     :- module(sublistapp, [test/0,sublistapp/2], ['bf/af']).
     
     test :- sublistapp([a],[b]).
     
     sublistapp(S,L) <- append(_,S,Y), append(Y,_,L).
     
     append([], L, L) <- .
     append([X|Xs], L, [X|Ys]) <- append(Xs, L, Ys).

* Menu:

* Usage and interface (bf)::
* Known bugs and planned improvements (bf)::


File: ciao.info,  Node: Usage and interface (bf),  Next: Known bugs and planned improvements (bf),  Prev: Breadth-first execution,  Up: Breadth-first execution

Usage and interface (`bf')
==========================

   * *Library usage:*

     `:- use_package(bf).'

     or

     `:- module(...,...,[bf]).'

   * *New operators defined:*

     `<-/2' [1200,xfx], `<-/1' [1200,xf].


File: ciao.info,  Node: Known bugs and planned improvements (bf),  Prev: Usage and interface (bf),  Up: Breadth-first execution

Known bugs and planned improvements (`bf')
==========================================

   * Does not correctly work in user files.


File: ciao.info,  Node: Iterative-deepening execution,  Next: Constraint programming over rationals,  Prev: Breadth-first execution,  Up: Top

Iterative-deepening execution
*****************************

   *Author(s):* Claudio Vaucheret, Manuel Hermenegildo.

   This package applies a _compiling control_ technique to implement
_depth first iterative deepening_ execution [BibRef:
iterative-deepening]. It changes the usual _depth-first_ computation
rule by _iterative-deepening_ on those predicates specifically
marked. This is very useful in search problems when a complete proof
procedure is needed.

   When this computation rule is used, first all goals are expanded
only up to a given depth. If no solution is found or more solutions
are needed by backtracking, the depth limit is incremented and the
whole goal is repeated. Although it might seem that this approach is
very inefficient because all higher levels are repeated for the
deeper ones, it has been shown that is performs only about b/(b - 1)
times as many operations than the corresponding breadth-first search,
(where b is the branching factor of the proof tree) while the waste
of memory is the same as depth first.

   The usage is by means of the following directive:

   `:- iterative(Name, FirstCut, Formula).'

   which states than the predicate 'Name' given in functor/arity form
will be executed using iterative deepening rule starting at the depth
'FirstCut' with depth being incremented by the predicate 'Formula'.
This predicate compute the new depth using the previous one. It must
implement a dilating function i.e. the new depth must be greater. For
example, to start with depth 5 and increment by 10 you can write:

   `:- iterative(p/1,5,f).'

   `f(X,Y) :- Y is X + 10.'

   or if you prefer,

   `:- iterative(p/1,5,(_(X,Y):- Y is X + 10)).'

   You can also use a fourth parameter to set a limiting depth. All
goals below the given depth limit simply fail. Thus, with the
following directive:

   `:- iterative(p/1,5,(_(X,Y):- Y is X + 10),100).'

   all goals deeper than 100 will fail.

   An example of code using this package would be:

     :- module(example_id, _,[id]).
     
     test(id) :-
             idchain(a,d).
     test(df) :-
             chain(a,d).   % loops!
     
     :- iterative(idchain/2, 3, ( _(X,Z) :- Z is X + 1) ).
     
     idchain(X,X).
     idchain(X,Y) :-
             arc(X,Z),
             idchain(Z,Y).
     
     chain(X,X).
     chain(X,Y) :-
             arc(X,Z),
             chain(Z,Y).
     
     arc(a,b).
     arc(a,d).
     arc(b,c).
     arc(c,a).

   The order of solutions are first the shallower and then the
deeper. Solutions which are between two cutoff are given in the usual
left to right order. For example,

     :- module(_,_,[id]).
     
     :- iterative(p/1,0,(_(X,Z) :- Z is X + 1),2). % all goals deeper than 2 will fail
     
     %:- iterative(p/1,1,(_(X,Z) :- Z is X + 3)). % change the solutions' order
                                                  % to goal p(X).
     
     p(X) :- q(X).
     p(a).
     
     q(X) :- r(X).
     q(b).
     
     r(X) :- s(X).
     r(c).
     
     s(d).

   It is possible to preserve the iterative-deepening behavior for
calls to predicates defined in other modules. These modules should
obviously also use this package. In addition _all_ predicates from
such modules should imported, i.e., the directive `:-
use_module(module)', should be used in this case instead of `:-
use_module(module,[...])'. Otherwise calls to predicates outside the
module will be treated in the usual way i.e. by depth-first
computation.

   Another complete proof procedure implemented is the `bf' package (
breadth first execution).

* Menu:

* Usage and interface (id)::


File: ciao.info,  Node: Usage and interface (id),  Prev: Iterative-deepening execution,  Up: Iterative-deepening execution

Usage and interface (`id')
==========================

   * *Library usage:*

     `:- use_package(id).'

     or

     `:- module(...,...,[id]).'


File: ciao.info,  Node: Constraint programming over rationals,  Next: Constraint programming over reals,  Prev: Iterative-deepening execution,  Up: Top

Constraint programming over rationals
*************************************

   *Author(s):* Christian Holzbaur, Daniel Cabeza.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#156 (2000/5/30, 11:0:51 CEST)

   *Note:* This package is currently being adapted to the new
characteristics of the Ciao module system. This new version now works
right now to some extent, but it is under further development at the
moment. Use with (lots of) caution.

* Menu:

* Usage and interface (clpq)::
* Other information (clpq)::


File: ciao.info,  Node: Usage and interface (clpq),  Next: Other information (clpq),  Prev: Constraint programming over rationals,  Up: Constraint programming over rationals

Usage and interface (`clpq')
============================

   * *Library usage:*

     `:- use_package(clpq).'

     or

     `:- module(...,...,[clpq]).'


File: ciao.info,  Node: Other information (clpq),  Prev: Usage and interface (clpq),  Up: Constraint programming over rationals

Other information (`clpq')
==========================

* Menu:

* Some CLP(Q) examples::


File: ciao.info,  Node: Some CLP(Q) examples,  Prev: Other information (clpq),  Up: Other information (clpq)

Some CLP(Q) examples
--------------------

(Other examples can be found in the source and library directories.)

   * 'Reversible' Fibonacci (clpq):

     :- module(_, [fib/2], []).
     :- use_package(clpq).
     
     fib(X,Y):- X .=. 0, Y .=. 0.
     fib(X,Y):- X .=. 1, Y .=. 1.
     fib(N,F) :-
             N .>. 1,
             N1 .=. N - 1,
             N2 .=. N - 2,
             fib(N1, F1),
             fib(N2, F2),
             F .=. F1+F2.

   * Matrix multiplication (clpq):

     :- use_package(clpq).
     :- use_module(library(write)).
     
     mmultiply([],_,[]).
     mmultiply([V0|Rest], V1, [Result|Others]):-
                 mmultiply(Rest, V1, Others),
                     multiply(V1,V0,Result).
     
     multiply([],_,[]).
     multiply([V0|Rest], V1, [Result|Others]):-
                 multiply(Rest, V1, Others),
                     vmul(V0,V1,Result).
     
     vmul([],[],0).
     vmul([H1|T1], [H2|T2], Result):-
             vmul(T1,T2, Newresult),
             Result .=. H1*H2+Newresult.
     
     matrix(1,[[1,2,3,4,5],[4,0,-1,5,6],[7,1,-2,8,9],[-1,0,1,3,2],[1,5,-3,2,4]]).
     matrix(2,[[3,2,1,0,-1],[-2,1,3,0,2],[1,2,0,-1,5],[1,3,2,4,5],[-5,1,4,2,2]]).
     
     %% Call with: ?- go(M).
     
     go(M):-
             matrix(1,M1),
             matrix(2,M2),
             mmultiply(M1, M, M2).

   * Queens (clpq):



File: ciao.info,  Node: Constraint programming over reals,  Next: Object oriented programming,  Prev: Constraint programming over rationals,  Up: Top

Constraint programming over reals
*********************************

   *Author(s):* Christian Holzbaur, Daniel Cabeza.

   *Note:* This package is currently being adapted to the new
characteristics of the Ciao module system. This new version now works
right now to some extent, but it under further development at the
moment. Use with (lots of) caution.

* Menu:

* Usage and interface (clpr)::
* Other information (clpr)::


File: ciao.info,  Node: Usage and interface (clpr),  Next: Other information (clpr),  Prev: Constraint programming over reals,  Up: Constraint programming over reals

Usage and interface (`clpr')
============================

   * *Library usage:*

     `:- use_package(clpr).'

     or

     `:- module(...,...,[clpr]).'


File: ciao.info,  Node: Other information (clpr),  Prev: Usage and interface (clpr),  Up: Constraint programming over reals

Other information (`clpr')
==========================

* Menu:

* Some CLP(R) examples::


File: ciao.info,  Node: Some CLP(R) examples,  Prev: Other information (clpr),  Up: Other information (clpr)

Some CLP(R) examples
--------------------

(Other examples can be found in the source and library directories.)

   * 'Reversible' Fibonacci (clpr):

     :- module(_, [fib/2], []).
     :- use_package(clpr).
     
     fib(X,Y):- X .=. 0, Y .=. 0.
     fib(X,Y):- X .=. 1, Y .=. 1.
     fib(N,F) :-
             N .>. 1,
             N1 .=. N - 1,
             N2 .=. N - 2,
             fib(N1, F1),
             fib(N2, F2),
             F .=. F1+F2.

   * Dirichlet problem for Laplace's equation (clpr):



File: ciao.info,  Node: Object oriented programming,  Next: Declaring classes and interfaces,  Prev: Constraint programming over reals,  Up: Top

Object oriented programming
***************************

   *Author(s):* Angel Fernandez Pineda.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.3#63 (1999/9/29, 19:54:17 MEST)

   O'Ciao is a set of libraries which allows object-oriented
programming in Ciao Prolog. It extends the Ciao Prolog module system
by introducing two new concepts:

   * Inheritance.

   * Instantiation.

   _Polymorphism_ is the third fundamental concept provided by object
oriented programming. This concept is not mentioned here since
*traditional PROLOG systems are polymorphic by nature*.

   Classes are declared in the same way as modules. However, they may
be enriched with inheritance declarations and other object-oriented
constructs. For an overview of the fundamentals of O'Ciao, see
`http://www.clip.dia.fi.upm.es/~clip/papers/ociao-tr.ps.gz'. However,
we will introduce the concepts in a tutorial way via examples.

* Menu:

* Early examples::
* Recommendations on when to use objects::
* Limitations on object usage::


File: ciao.info,  Node: Early examples,  Next: Recommendations on when to use objects,  Prev: Object oriented programming,  Up: Object oriented programming

Early examples
==============

   The following one is a very simple example which declares a class
- a simple stack. Note that if you replace _class/1_ declaration with
a _module/1_ declaration, it will compile correctly, and can be used
as a normal Prolog module.

     %%----------------------------------------------%%
     %% A class for stacks.                          %%
     %%----------------------------------------------%%
     
     %% Class declaration: the current source defines a class.
     :- class(stack,[],[]).
     
     % State declaration: storage/1 is an attribute.
     :- dynamic storage/1.
     
     % Interface declaration: the following predicates will
     % be available at run-time.
     :- export(push/1).
     :- export(pop/1).
     :- export(top/1).
     :- export(is_empty/0).
     
     % Methods
     
     push(Item) :-
             nonvar(Item),
             asserta_fact(storage(Item)).
     
     pop(Item) :-
             var(Item),
             retract_fact(storage(Item)).
     
     top(Top) :-
             storage(Top), !.
     
     is_empty :-
             storage(_), !, fail.
     is_empty.

   If we load this code at the Ciao toplevel shell:

             ?- use_package(objects).
     
             yes
             ?- use_class(library('class/examples/stack')).
     
             yes
             ?-

   we can create two stack _instances_ :

             ?- St1 new stack,St2 new stack.
     
             St1 = stack('9254074093385163'),
             St2 = stack('9254074091') ? ,

   and then, we can operate on them separately:

             1 ?- St1:push(8),St2:push(9).
     
             St1 = stack('9254074093385163'),
             St2 = stack('9254074091') ?
     
             yes
             1 ?- St1:top(I),St2:top(K).
     
             I = 8,
             K = 9,
             St1 = stack('9254074093385163'),
             St2 = stack('9254074091') ?
     
             yes
             1 ?-

   The interesting point is that there are two stacks. If the
previous example had been a normal module, we would have a stack ,
but *only one* stack.

   The next example introduces the concepts of _inheritable_
predicate, _constructor_, _destructor_ and _virtual method_. Refer to
the following sections for further explanation.

     %%----------------------------------------------%%
     %% A generic class for item storage.            %%
     %%----------------------------------------------%%
     :- class(generic).
     
     % Public interface declaration:
     :- export([set/1,get/1,callme/0]).
     
     % An attribute
     :- data datum/1.
     
     % Inheritance declaration: datum/1 will be available to
     % descendant classes (if any).
     :- inheritable(datum/1).
     
     % Attribute initialization: attributes are easily initialized
     % by writing clauses for them.
     datum(none).
     
     % Methods
     
     set(X) :-
             type_check(X),
             set_fact(datum(X)).
     
     get(X) :-
             datum(X).
     
     callme :-
             a_virtual(IMPL),
             display(IMPL),
             display(' implementation of a_virtual/0 '),
             nl.
     
     % Constructor: in this case, every time an instance
     % of this class is created, it will display a message.
     generic :-
             display(' generic class constructor '),
             nl.
     
     % Destructor: analogous to the previous constructor,
     % it will display a message every time an instance
     % of this class is eliminated.
     destructor :-
             display(' generic class destructor '),
             nl.
     
     % Predicates:
     % cannot be called as messages (X:method)
     
     % Virtual declaration: tells the system to use the most
     % descendant implementation of a_virtual/1 when calling
     % it from inside this code (see callme/0).
     % If there is no descendant implementation for it,
     % the one defined bellow will be used.
     :- virtual a_virtual/1.
     
     a_virtual(generic).
     
     :- virtual type_check/1.
     
     type_check(X) :-
             nonvar(X).

   And the following example, is an extension of previous class. This
is performed by establishing an inheritance relationship:

     %%----------------------------------------------%%
     %% This class provides additional functionality %%
     %% to the "generic" class.                      %%
     %%----------------------------------------------%%
     :- class(specific).
     
     % Establish an inheritance relationship with class "generic".
     :- inherit_class(library('class/examples/generic')).
     
     % Override inherited datum/1.
     % datum/1 is said to be overriden because there are both an
     % inherited definition (from class "generic") and a local one,
     % which overrides the one inherited.
     :- data datum/1.
     :- inheritable datum/1.
     
     % Extend the public interface inherited from "generic".
     % note that set/1 and a_virtual/0 are also overriden.
     % undo/0 is a new functionality added.
     :- export([set/1,undo/0]).
     
     % Methods
     
     set(Value) :-
             inherited datum(OldValue),
             !,
             inherited set(Value),
             asserta_fact(datum(OldValue)).
     set(Value) :-
             inherited set(Value).
     
     undo :-
             retract_fact(datum(Last)), !,
             asserta_fact(inherited(datum(Last))).
     undo :-
             retractall_fact(inherited(datum(_))).
     
     % Constructor
     specific :-
             generic,
             retractall_fact(inherited(datum(_))),
             display(' specific class constructor '),
             nl.
     
     % Destructor
     destructor :-
             display(' specific class destructor '),
             nl.
     
     % Predicates
     
     % New implementation of a_virtual/1.
     % Since this predicate was declared virtual, the
     % implementation below will be called from the inherited
     % method callme/0 instead of the version defined at "generic".
     a_virtual(specific).

   *Additional examples* may be found on the _library/class/examples_
directory relative to your Ciao Prolog instalation.


File: ciao.info,  Node: Recommendations on when to use objects,  Next: Limitations on object usage,  Prev: Early examples,  Up: Object oriented programming

Recommendations on when to use objects
======================================

   We would like to give some advice in the use of object oriented
programming, in conjunction with the declarative paradigm.

   You should reconsider using O'Ciao in the following cases:

   * The pretended "objects" have no state,i.e., no data or dynamic
     predicates. In this case, a normal module will suffice.

   * There is state, but there will be only one instance of a
     pretended class. Again, a module suffices.

   * The "objects" are data structures (list,trees,etc) already
     supported by Prolog. However, it does make sense to model, using
     objects, data structures whose change implies a side-effect such
     as drawing a particular window on the screen.


   We recommend the usage of O'Ciao in the following cases:

   * You feel you will need to have several copies of a "module".

   * Local copies of a module are needed instead of a global module
     beeing modified by several ones.

   * The "classes" are a representation of external entities to
     Prolog. For example: the X-Window system.

   * There is state or code outside the Prolog system which needs to
     be manipulated. For example: interfaces to Java or Tcl/Tk code.

   * You are not familiar with Prolog, but you know about object
     oriented programming. O'Ciao may be used as a learning tool to
     introduce yourself on the declarative programming paradigm.



File: ciao.info,  Node: Limitations on object usage,  Prev: Recommendations on when to use objects,  Up: Object oriented programming

Limitations on object usage
===========================

   O'Ciao run-time speed is limited by the usage of meta-programming
structures, for instance: `X = (Object:mymethod(25)), call(X)'.
O'Ciao will optimize static manipulation of objects (those that can
be determined at compile time).


File: ciao.info,  Node: Declaring classes and interfaces,  Next: Compile-time usage of objects,  Prev: Object oriented programming,  Up: Top

Declaring classes and interfaces
********************************

   *Author(s):* Angel Fernandez Pineda.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#162 (2000/6/14, 17:7:15 CEST)

   O'Ciao classes are declared in the same way as traditional prolog
modules. The general mechanism of _source expansion_ will translate
object-oriented declarations to normal prolog code. This is done
transparently to the user.

   Abstract _interfaces_ are restricted classes which declare
exported predicates with no implementation. The implementation itselt
will be provided by some class using an `implements/1' declaration.
Only `export/1' and `data/1' declarations are allowed when declaring
an interface. Normal classes may treated as interfaces just ignoring
all exported predicate implementations.

* Menu:

* Usage and interface (class)::
* Documentation on new declarations (class)::
* Documentation on exports (class)::
* Other information (class)::
* Known bugs and planned improvements (class)::


File: ciao.info,  Node: Usage and interface (class),  Next: Documentation on new declarations (class),  Prev: Declaring classes and interfaces,  Up: Declaring classes and interfaces

Usage and interface (`class')
=============================

   * *Library usage:*

     To declare a class the compiler must be told to use the `class'
     _source expansion_. To do so, source code must start with a
     module declaration which loads the class package:
                     :- class(ClassName).

     or a `module/3' declaration, as follows:
                     :- module(ClassName,[],[class]).

     interfaces are declared in a similar way:
                     :- interface(InterfaceName).

     Please, do not use SICStus-like module declaration, with a
     non-empty export list. In other case, some non-sense errors will
     be reported by normal Ciao module system.

     Most of the regular Ciao declarations may be used when defining
     a class, such as `concurrent/1', `dynamic/1', `discontiguous/1',
     `multifile/1', and so on.

     However, there are some restrictions wich apply to those
     declarations:
        * `meta_predicate/1' declaration is not allowed to hold
          _addmodule and pred(N) meta-arguments_, except for
          previously declared multifiles.

        * Attribute and multifile predicates must be declared before
          any clause of the related predicate.

        * There is no sense in declaring an attribute as
          meta_predicate.

     It is a good practique to put all your declarations at the very
     begining of the file, just before the code itself.

   * *Exports:*
        - _Predicates:_

          `inherited/1', `self/1', `constructor/0', `destructor/0'.


   * *New declarations defined:*

     `export/1', `public/1', `inheritable/1', `data/1', `dynamic/1',
     `concurrent/1', `inherit_class/1', `implements/1', `virtual/1'.

   * *Other modules used:*
        - _System library modules:_

          `objects/objects_rt'.




File: ciao.info,  Node: Documentation on new declarations (class),  Next: Documentation on exports (class),  Prev: Usage and interface (class),  Up: Declaring classes and interfaces

Documentation on new declarations (`class')
===========================================

 - DECLARATION: export/1:
     Declares a method or attribute to be part of the _public
     interface_.

     The public interface is the set of predicates wich will be
     accesible from any code establishing an usage relationship with
     this class (see `use_class/1' for further information).

     Publishing an attribute or method is very similar to _exporting_
     a predicate in a Prolog module.

     Whether an inherited and exported predicate is overriden, it
     must be explicitly exported again.

     An inherited (but not exported) predicate may become exported,
     without overriding it by the usage of this declaration.

     *Usage:* :- `export(Spec)'.
        - _Description:_ `Spec' will be part of the public (exported)
          interface.

        - _The following properties should hold at call time:_

          `Spec' is a method or attribute specification.
          (`objects_rt:method_spec/1')



 - DECLARATION: public/1:
     Just an alias for `export/1'.

     *Usage:* :- `public(Spec)'.
        - _Description:_ This declaration may be used instead of
          `export/1'.

        - _The following properties should hold at call time:_

          `Spec' is a method or attribute specification.
          (`objects_rt:method_spec/1')



 - DECLARATION: inheritable/1:
     Declares a method or attribute to be inherited by descendant
     classes. Notice that all *public predicates are inheritable by
     default*. There is no need to mark them as inheritable.

     Traditionaly, object oriented languages makes use of the
     _protected_ concept. Inheritable/1 may be used as the same
     concept.

     The set of inheritable predicates is called the _inheritable
     interface_.

     *Usage:* :- `inheritable(MethodSpec)'.
        - _Description:_ `MethodSpec' is accessible to descendant
          classes.

        - _The following properties should hold at call time:_

          `MethodSpec' is a method or attribute specification.
          (`objects_rt:method_spec/1')



 - DECLARATION: data/1:
     Declares an _attribute_ at current class. Attributes are used to
     build the internal state of instances. So, each instance will
     own a particular copy of those attribute definitions. In this
     way, one instance may have different state from another.

     O'Ciao attributes are restricted to hold simple facts. It is not
     possible to hold a Head :- Body clause at an instance attribute.

     Notice that attributes are _multi-evaluated_ by nature, and may
     be manipulated by the habitual *assert/retract* family of
     predicates.

     Attributes may also be initialized. In order to do so, simply
     put some clauses after the attribute definition. Each time an
     instance is created, its initial state will be built from those
     _initialization clauses_.

     Note: whether a data/1 declaration appears inside an interface,
     it will be automatically exported.

     *Usage:* :- `data Spec'.
        - _Description:_ `Spec' is an attribute.

        - _The following properties should hold at call time:_

          `Spec' is a method or attribute specification.
          (`objects_rt:method_spec/1')



 - DECLARATION: dynamic/1:
     Just an alias for `data/1'.

     *Usage:* :- `dynamic Spec'.
        - _Description:_ You may use this declaration instead of
          `data/1'.

        - _The following properties should hold at call time:_

          `Spec' is a method or attribute specification.
          (`objects_rt:method_spec/1')



 - DECLARATION: concurrent/1:
     Declares a _concurrent attribute_ at current class. Concurrent
     attributes are just the same as normal attributes, those
     declared using `data/1', except for they may freeze the calling
     thread instead of failing when no more choice points are
     remaining on the concurrent attribute.

     In order to get more information about concurrent behavior take
     a look to the concurrent/1 built-in declaration on Ciao Prolog
     module system.

     *Usage:* :- `concurrent Spec'.
        - _Description:_ Declares `Spec' to be a concurrent attribute.

        - _The following properties should hold at call time:_

          `Spec' is a method or attribute specification.
          (`objects_rt:method_spec/1')



 - DECLARATION: inherit_class/1:
     Makes any public and/or inheritable predicate at inherited class
     to become accesible by any instance derived from current class.

     Inherited class is also called the _super class_.

     Only one inherit_class/1 declaration is allowed to be present at
     current source.

     Notice that inheritance is public by default. Any public and/or
     inheritable declaration will remain the same to descendant
     classes. However, any inherited predicate may be _overriden_
     (redefined).

     A predicate is said to be _overriden_ when it has been inherited
     from super class, but there are clauses (or a `data/1'
     declaration) present at current class for such a predicate.

     Whether a *public* predicate is overriden, the local definition
     must also be exported, otherwise an error is reported.

     Whether an *inheritable* predicate (not public) is overriden,
     the local definition must also be marked as inheritable or
     exported, otherwise an error is also reported.

     Note: whether inherit_class/1 appears inside an interface, it
     will be used as an `implements/1' declaration.

     *Usage:* :- `inherit_class(Source)'.
        - _Description:_ Establish an _inheritance relationship_
          between current class and the class defined at `Source'
          file.

        - _The following properties should hold at call time:_

          `Source' is a valid path to a prolog file containing a
          class declaration (without .pl extension).
          (`objects_rt:class_source/1')



 - DECLARATION: implements/1:
     Forces current source to provide an implementation for the given
     interface file. Such interface file may declare another class or
     a specific interface.

     Every public predicate present at given interface file will be
     automatically declared as public at current source, so you
     *must* provide an implementation for such predicates.

     The effect of this declaration is called _interface
     inheritance_,and there is no restriction on the number of
     implements/1 declarations present at current code.

     *Usage:* :- `implements(Interface)'.
        - _Description:_ Current source is supposed to provide an
          implementation for `Interface'.

        - _The following properties should hold at call time:_

          `Interface' is a valid path to a prolog file containing a
          class declaration or an interface declaration (without .pl
          extension).   (`objects_rt:interface_source/1')



 - DECLARATION: virtual/1:
     This declaration may be used whenever descendant classes are to
     implement different versions of a given predicate.

     _virtual_ predicates give a chance to handle, in an uniform way,
     different implementations of the same functionality.

     Whether a virtual predicate is declared as a method, there must
     be at least one clause of it present at current source. Whenever
     no special implementation is needed at current class, a
     never-fail/allways-fail clause may be defined (depending on your
     needs). For example:

             :- virtual([ test1/1 , test2/2 ]).
             test1(_).
             test2(_,_) :- fail.

     This kind of virtual methods are also known as _abstract
     methods_, since implementation is fully delegated to descendant
     classes.

     An attribute may be also declared as a virtual one, but there is
     no need to write clauses for it.

     *Usage:* :- `virtual(VirtualMethodSpec)'.
        - _Description:_ All calls to `VirtualMethodSpec' predicate
          in current source will use the most descendant
          implementation of it.

        - _The following properties should hold at call time:_

          `VirtualMethodSpec' is a method specification.
          (`objects_rt:virtual_method_spec/1')




File: ciao.info,  Node: Documentation on exports (class),  Next: Other information (class),  Prev: Documentation on new declarations (class),  Up: Declaring classes and interfaces

Documentation on exports (`class')
==================================

 - PREDICATE: inherited/1:
     This predicate qualificator may be used whenever you need to
     reference an attribute or method on the super class.

     Since methods and attributes may be redefined, this qualificator
     is need to distinguish between a locally declared predicate and
     the inherited one, which has the same name.

     There is no need to use inherited/1 if a particular inherited
     predicate has not been redefined at current class.

     *Usage:* `inherited(Goal)'
        - _Description:_ References a given `Goal' at the super class

        - _The following properties should hold at call time:_

          `Goal' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')



 - PREDICATE: self/1:
     Determines which instance is currently executing self/1 goal.

     Predicate will fail if argument is not a free variable.
     Otherwise, it will allways succeed, retrieving the instance
     identifier which is executing current code.

     This functionality is very usefull since an object must have
     knowledge of other object's identifier in order to send messages
     to it.For example:

     :- concurrent ack/0.

     send_data_to_object(Data,Obj) :- self(X), Obj:take_this(Data,X),
     current_fact(ack).

     acknowledge :- asserta_fact(ack).

     take_this(Data,Sender) :- validate_data(Data),
     Sender:acknowledge.

     *Usage:* `self(Variable)'
        - _Description:_ Retrieves current instance identifier in
          `Variable'

        - _The following properties should hold at call time:_

          `Variable' is a free variable.   (`term_typing:var/1')

        - _The following properties should hold upon exit:_

          `Variable' is an unique term which identifies an object.
          (`objects_rt:instance_id/1')



 - PREDICATE: constructor/0:
     A _constructor_ is a special case of method which complains the
     following conditions:

        * The constructor functor matches the current class name.

        * A constructor may hold any number of arguments.

        * If an inheritance relationship was defined, an inherited
          constructor must be manually called (see below).

        * When instance creation takes place, any of the declared
          constructors are implicitly called. The actual constructor
          called depends on the `new/2' goal specified by the user.

     This is a simple example of constructor declaration for the foo
     class:

                     foo :-
                         display('an instance was born').

     Constructor declaration is not mandatory, and there may be more
     than one constructor declarations (with different arity) at the
     source code.

     This functionality is usefull when some computation is needed at
     instance creation. For example: opening a socket, clearing the
     screen, etc.

     Whenever an inheritance relationship is established, and there
     is any constructor defined at the super class, you must call
     manually an inherited constructor. Here is an example:

                     :- class(foo).
                     :- inherit_class(myclass).
          
                     foo :-
                         myclass(0),
                         display('an instance was born').
          
                     foo(N) :- myclass(N).

     Consequences may be unpredictable, if you forget to call an
     inherited constructor. You should also take care not to call an
     inherited constructor twice.

     All defined constructors are inheritable by default. A
     constructor may also be declared as public (by the user), but it
     is not mandatory.

     *Usage:*
        - _Description:_ Constructors are implicitly declared



 - PREDICATE: destructor/0:
     A _destructor_ is a special case of method which will be
     automatically called when instance destruction takes place.

     A destructor will never be wanted to be part of the public
     interface, and there is no need to mark them as inheritable,
     since all inherited destructors are called by O'Ciao just before
     yours.

     This is a simple example of destructor declaration:

                     destructor :-
                         display('goodbye, cruel world!!!').

     Destructor declaration is not mandatory. Failure or sucess of
     destructors will be ignored by O'Ciao, and they will be called
     only once.

     This functionality is useful when some computation is need at
     instance destruction. For example: closing an open file.

     *Usage:*
        - _Description:_ Destructors are implicitly declared




File: ciao.info,  Node: Other information (class),  Next: Known bugs and planned improvements (class),  Prev: Documentation on exports (class),  Up: Declaring classes and interfaces

Other information (`class')
===========================

   This describes the errors reported when declaring a class or an
interface. The first section will explain compile-time errors, this
is, any semantic error which may be determined at compile time. The
second section will explain run-time errors, this is, any exception
that may be raisen by the incorrect usage of O'Ciao. Some of those
errors may be not reported at compile time, due to the use of
meta-programational structures. For example:

   `functor(X,my_method,0),call(X).'

   O'Ciao is not able to check whether my_method/0 is a valid method
or not. So, this kind of checking is left to run time.

* Menu:

* Class and Interface error reporting at compile time::
* Class and Interface error reporting at run time::
* Normal Prolog module system interaction::


File: ciao.info,  Node: Class and Interface error reporting at compile time,  Next: Class and Interface error reporting at run time,  Prev: Other information (class),  Up: Other information (class)

Class and Interface error reporting at compile time
---------------------------------------------------

   * *ERROR : multiple inheritance not allowed.*

     There are two or more inherit_class/1 declarations found at your
     code. Only one declaration is allowed, since there is no
     multiple code inheritance support.

   * *ERROR : invalid inheritance declaration.*

     The given parameter to inherit_class/1 declaration is not a
     valid path to a Prolog source.

   * *ERROR : sorry, addmodule meta-arg is not allowed at _F/A_. *

     You are trying to declare _F/A_ as meta-predicate, and one of
     the meta-arguments is _addmodule_. This is not allowed in O'Ciao
     due to implementation restrictions. For example:

     `:- meta_predicate example(addmodule).'

     `example(X,FromModule) :- call(FromModule:X).'

   * *ERROR : invalid attribute declaration for _Arg_. *

     Argument to data/1 or dynamic/1 declaration is not a valid
     predicate specification of the form _Functor/Arity_. For example:

     `:- data attr.'

     `:- dynamic attr(_).'

     `:- data attr/m.'

     etc,etc...

   * *ERROR : pretended attribute _F/A_ was assumed to be a method.*

     You put some clauses of _F/A_ before the corresponding data/1 or
     dynamic/1 declaration. For example:

     `attr(initial_value).'

     `:- data attr/1.'

     It is a must to declare attributes before any clause of the
     given predicate.

   * *ERROR : destructor/0 is not allowed to be an attribute.*

     There is a :- data(destructor/0) or :- dynamic(destructor/0).
     declaration in your code. This is not allowed since destructor/0
     is a reserved predicate, and must be allways a method.

   * *ERROR : _Constructor_ is not allowed to be an attribute.*

     As the previos error, you are trying to declare a constructor as
     an attribute. A constructor must be allways a method.

   * *ERROR : invalid multifile: destructor/0 is a reserved
     predicate.*

     There is a :- multifile(destructor/0). declaration in your code.
     This is not allowed since destructor/0 is a reserved predicate,
     and must be allways a method.

   * *ERROR : invalid multifile: _Constructor_ is a reserved
     predicate.*

     As the previos error, you are trying to declare a constructor as
     a multifile. Any constructor must allways be a method.

   * *ERROR : multifile declaration of _F/A_ ignored: it was assumed
     to be a method.*

     You put some clauses of _F/A_ before the corresponding
     multifile/1 declaration. For example:

     example(a,b).

     `:- multifile example/2.'

     Multifile predicates must be declared before any clause of the
     given predicate.

   * *ERROR : invalid multifile declaration: multifile(_Arg_). *

     Given argument to multifile/1 declaration is not a valid
     predicate specification, of the form _Functor/Arity_.

   * *ERROR : invalid public declaration: _Arg_. *

     Given argument _Arg_ to public/1 or export/1 declaration is not
     a valid predicate specification, of the form _Functor/Arity_.

   * *ERROR : invalid inheritable declaration: inheritable(_Arg_). *

     Given argument _Arg_ to inheritable/1 declaration is not a valid
     predicate specification, of the form _Functor/Arity_.

   * *ERROR : destructor/0 is not allowed to be virtual.*

     There is a :- virtual(destructor/0) declaration present at your
     code. Destructors and/or constructors are not allowed to be
     virtual.

   * *ERROR : _Constructor_ is not allowed to be virtual.*

     As the previous error, you are trying to declare a constructor
     as virtual. This is not allowed.

   * *ERROR : invalid virtual declaration: virtual(_Arg_). *

     Given argument to virtual/1 declaration is not a valid predicate
     specification, of the form _Functor/Arity_.

   * *ERROR : clause of _F/A_ ignored : only facts are allowed as
     initial state.*

     You declared _F/A_ as an attribute, then you put some clauses of
     that predicate in the form _Head :- Body_. For example:

     `:- data my_attribute/1.'

     `my_attribute(X) :- X>=0 , X<=2.'

     This is not allowed since attributes are assumed to hold simple
     facts. The correct usage for those _initialization clauses_ is:

     `:- data my_attribute/1.'

     `my_attribute(0).'

     `my_attribute(1).'

     `my_attribute(2).'

   * *ERROR : multifile _F/A_ is not allowed to be public.*

     The given _F/A_ predicate is both present at multifile/1 and
     public/1 declarations. For example:

     `:- public(p/1).'

     `:- multifile(p/1).'

     This is not allowed since multifile predicates are not related
     to Object Oriented Programming.

   * *ERROR : multifile _F/A_ is not allowed to be inheritable.*

     Analogous to previous error.

   * *ERROR : multifile _F/A_ is not allowed to be virtual.*

     Analogous to previous error.

   * *ERROR : virtual _F/A_ must be a method or attribute defined at
     this class.*

     There is a virtual/1 declaration for _F/A_, but there is not any
     clause of that predicate nor a `data/1' declaration. You must
     declare at least one clause for every virtual method. Virtual
     attributes does not require any clause but a `data/1'
     declaration must be present.

   * *ERROR : implemented interface _Module_ is not a valid
     interface.*

     There is an `implements/1' declaration present at your code
     where given _Module_ is not declared as class nor interface.

   * *ERROR : predicate _F/A_ is required both as method (at _Itf1_
     interface) and attribute (at _Itf2_ interface).*

     There is no chance to give a correct implementation for _F/A_
     predicate since _Itf1_ and _Itf2_ interfaces require different
     definitions. To avoid this error, you must remove one of the
     related `implements/1' declaration.

   * *ERROR : inherited _Source_ must be a class.*

     There is an :- inherit_class(_Source_) declaration, but that
     source was not declared as a class.

   * *ERROR : circular inheritance: _Source_ is not a valid
     super-class.*

     Establishing an inheritance relationship with _Source_ will
     cause current class to be present twice in the inheritance line.
     This is not allowed. The cause of this is error is simple :
     There is some inherited class from _Source_ which also
     establishes an inheritance relationship with current source.

   * *ERROR : method/attribute _F/A_ must be implemented.*

     Some of the implemented interfaces requires _F/A_ to be defined,
     but there is no definition for such predicate, even an inherited
     one.

   * *ERROR : local implementation of _F/A_ hides inheritable/public
     definition.*

     There is an inherited definition for _F/A_ which is been
     redefined at current class, but there is no valid
     inheritable/public declaration for the last one. Overriden
     public predicates must be also declared as public. Overriden
     inheritable predicates must be declared either as public or
     inheritable.

   * *ERROR : public predicate _F/A_ was not defined nor inherited.*

     There is a `public/1' declaration for _F/A_, but there is no
     definition for it at current class nor an inherited one.

   * *ERROR : argument to self/1 must be a free variable.*

     Argument to self/1 is not a variable, for example: `self(abc)'.

   * *ERROR : unknown inherited attribute in _Goal_.*

     _Goal_ belongs to assert/retract family of predicates, and given
     argument is not a valid inherited attribute. The most probable
     causes of this error are:

        * The given predicate is defined at super-class, but you
          forgot to mark it as inheritable (or public), at such class.

        * The given predicate was not defined (at super-class) as an
          attribute, just as a method.

   * *ERROR : unknown inherited goal: _Goal_.*

     The given _Goal_ was not found at super-class, or it is not
     accessible. Check whether _Goal_ was marked as inheritable (or
     public) at super-class.

   * *ERROR : invalid argument: _F/A_ is not an attribute.*

     You are trying to pass a method as an argument to any predicate
     which expect a _fact_ predicate.

   * *ERROR : unknown inherited fact: _Fact_.*

     There is a call to any predicate which expects a _fact_ argument
     (those declared as data or dynamic),but the actual argument is
     not an inherited attribute.For example:

     `asserta_fact(inherited(not_an_attribute(8)))'

     where not_an_attribute/1 was not declared as data or dynamic by
     the super-class (or corresponding ascendant).

   * *ERROR : unknown inherited spec: _F/A_.*

     There is a reference to an inherited predicate specification,
     but the involved predicate has not been inherited.

   * *WARNING : meta-predicate specification of _F/A_ ignored since
     this is an attribute.*

     You declared _F/A_ both as an attribute and a meta-predicate.
     For example:

     `:- meta_predicate attr(goal).'

     `:- data attr/1.'

     There is no sense in declaring an attribute as meta-predicate.

   * *WARNING : class destructor is public*

     There is a :- public(destructor/0) declaration present at your
     code. Marking a destructor as public is a very bad idea since
     anybody may destroy or corrupt an instance before the proper
     time.

   * *WARNING : class destructor is inheritable*

     Analogous to previous error.

   * *WARNING : There is no call to inherited constructor/s*

     You have not declared any constructor at your class, but there
     is any inherited constructor that should be called. Whenever you
     do not need constructors, but there is an inheritance
     relationship (where super-class declares a constructor), you
     should write a simple constructor as the following example:
             :- class(myclass).
             :- inherit_class(other_class).
          
             myclass :-
                     other_class.

   * *WARNING : multifile _F/A_ hides inherited predicate.*

     You declared as multifle a predicate which matches an inherited
     predicate name. Any reference to the inherited predicate must be
     done by the ways of the inherited/1 qualificator.



File: ciao.info,  Node: Class and Interface error reporting at run time,  Next: Normal Prolog module system interaction,  Prev: Class and Interface error reporting at compile time,  Up: Other information (class)

Class and Interface error reporting at run time
-----------------------------------------------

   * *EXCEPTION : error(existence_error(object_goal,_Goal_),_Mod_).*

     Called _Goal_ from module (or class) _Mod_ is unknown or has not
     been published.



File: ciao.info,  Node: Normal Prolog module system interaction,  Prev: Class and Interface error reporting at run time,  Up: Other information (class)

Normal Prolog module system interaction
---------------------------------------

   O'Ciao works in conjunction with the Ciao Prolog module system,
which also reports its own error messages. This will cause Ciao to
report a little criptic error messages due to the general mechanism
of source-to-source expansion. Those are some tips you must consider
when compiling a class:

   * Any error relative to method 'm' with arity A will be reported
     for predicate 'obj$m'/A+1. For example :

     `WARNING: (lns 28-30) [Item,Itema] - singleton variables in
     obj$remove/2'

     This error is relative to method remove/1.

   * `set_prolog_flag/1' declaration will be usefull when declaring
     multiple constructors. It will avoid some awful warnings.
     Example:

             :- class(myclass).
          
             %% Use this declaration whenever several constructors are needed.
          
             :- set_prolog_flag(multi_arity_warnings,off).
          
             myclass(_).
          
             myclass(_,_).
          
             :- set_prolog_flag(multi_arity_warnings,on).


File: ciao.info,  Node: Known bugs and planned improvements (class),  Prev: Other information (class),  Up: Declaring classes and interfaces

Known bugs and planned improvements (`class')
=============================================

   * addmodule and pred(N) meta-arguments are not allowed on
     meta-predicates.


File: ciao.info,  Node: Compile-time usage of objects,  Next: Run time usage of objects,  Prev: Declaring classes and interfaces,  Up: Top

Compile-time usage of objects
*****************************

   *Author(s):* Angel Fernandez Pineda.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#90 (2000/3/24, 14:29:27 CET)

   This package is required to enable user code to create objects and
manipulate them, as well as loading any needed class.

* Menu:

* Usage and interface (objects)::
* Documentation on new declarations (objects)::
* Other information (objects)::


File: ciao.info,  Node: Usage and interface (objects),  Next: Documentation on new declarations (objects),  Prev: Compile-time usage of objects,  Up: Compile-time usage of objects

Usage and interface (`objects')
===============================

   * *Library usage:*

     Any code which needs to use objects must include the objects
     package:
              :- module(_ModuleName_,_Exports_,[objects]).
     You can use objects even if your code is a class. Note that
     declaring a class does not automatically enables the code to
     create instances.
              :- class(_ModuleName_,[],[objects]).

     This package enables both static and dynamic usage of objects.

   * *New declarations defined:*

     ` use_class/1', ` instance_of/2', ` new/2'.

   * *Other modules used:*
        - _System library modules:_

          `objects/objects_rt'.




File: ciao.info,  Node: Documentation on new declarations (objects),  Next: Other information (objects),  Prev: Usage and interface (objects),  Up: Compile-time usage of objects

Documentation on new declarations (`objects')
=============================================

 - DECLARATION: use_class/1:
     It establishes an usage relationship between the given file
     (which is supposed to declare a class) and current source. Usage
     relationships are needed in order to enable code to create
     instances of the given class, and to make calls to instances
     derived from such class.

     Since an interface is some kind of class, they may be used
     within this declaration but only for semantic checking
     porpouses. Instances will not be derived from interfaces.

     use_class/1 is used in the same way as `use_module/1'.

     *Usage:* :- ` use_class(ClassSource)'.
        - _Description:_ Establish usage relationship with
          `ClassSource'.

        - _The following properties should hold at call time:_

          `ClassSource' is a valid path to a prolog file containing a
          class declaration (without .pl extension).
          (`objects_rt:class_source/1')



 - DECLARATION: instance_of/2:
     Statically declares an identifier to be an instance of a given
     class.

     It may be used as `new/2' predicate except for:
        * The instance identifier will not be a variable, it must be
          provided by the user, and must be unique.

        * Instance creation will never fail, even if the constructor
          fails.

     For every statically declared object the given constructor will
     be called at program startup. Those instances may be destroyed
     manually, but it is not recommended.

     When reloading the involved class from the Ciao toplevel shell.
     It may destroy statically declared instances, and create them
     again.

     Statically declared instances must be called using a
     specifically designed module-qualification:
     `ClassName(Object):Goal'. For example:
              :- module(example,[main/0],[objects]).
              :- use_class(library(counter)).
              :- cnt instance_of counter(10).
          
              main :-
                   counter(cnt):decrease(1),
                   counter(cnt):current_value(X),
                   display(X).
     But *statically written code* (only) is allowed to use
     module-style qualifications as a macro:
              main :-
                   cnt:decrease(1),
                   cnt:current_value(X),
                   display(X).
     Notice that dynamically expanded goals such as
     `X=cnt,X:decrease(1)' will not work, use
     `X=counter(cnt),X:decrease(1)' instead.

     *Usage:* :- ` instance_of(Object,Constructor)'.
        - _Description:_ Declares `Object' to be an instance of the
          class denoted by `Constructor'.

        - _The following properties should hold at call time:_

          `Object' is an unique term which identifies an object.
          (`objects_rt:instance_id/1')

          `Constructor' is a term whose functor matches a class name.
          (`objects_rt:constructor/1')



 - DECLARATION: new/2:
     This declaration has the same effect as ` instance_of/2'.

     *Usage:* :- ` new(Object,Constructor)'.
        - _Description:_ Just an alias for ` instance_of/2'.

        - _The following properties should hold at call time:_

          `Object' is an unique term which identifies an object.
          (`objects_rt:instance_id/1')

          `Constructor' is a term whose functor matches a class name.
          (`objects_rt:constructor/1')




File: ciao.info,  Node: Other information (objects),  Prev: Documentation on new declarations (objects),  Up: Compile-time usage of objects

Other information (`objects')
=============================

   Compile-time errors are restricted to some local analysis. Since
there is no type declaration in the Prolog language, there is no
posibility to determine whenever a given variable will hold an
instance of any class.

   However, little semantic analysis is performed. User may aid to
perform such an analysis by the usage of run time checks (which are
also detected at compile time), or static declarations. For example:

   `clause(Obj) :- Obj:a_method(334).'

   O'Ciao may be not able to determine whenever a_method/1 is a valid
method for instance Obj, unless some help is provided:

   `clause(Obj) :- Obj instance_of myclass,Obj:a_method(334).'

   In such case, O'Ciao will report any semantic error at
compile-time.

   Most of the run-time errors are related to normal Ciao Prolog
module system. Since objects are treated as normal Prolog modules at
run time, there is no further documentation here about that stuff.

* Menu:

* Error reporting at compile time (objects)::
* Error reporting at run time (objects)::


File: ciao.info,  Node: Error reporting at compile time (objects),  Next: Error reporting at run time (objects),  Prev: Other information (objects),  Up: Other information (objects)

Error reporting at compile time (objects)
-----------------------------------------

   * *ERROR : invalid instance identifier _ID_: must be an atom*

     There is a `instance_of/2' or `new/2' declaration where first
     argument _ID_ must be an unique atom, but currently it is not.
     Statically declared instances needs an identifier to be provided
     by the user.

   * *ERROR : instance identifier _ID_ already in use*

     There are two or more `instance_of/2' declarations with the same
     first argument _ID_. Instance identifiers must be unique.

   * *ERROR : invalid use_class/1 declaration: _SourceFile_ is not a
     class*

     Those are the causes for this error:

        * The given _SourceFile_ does not exist, or is not accesible.

        * The given _SourceFile_ is not a Prolog source.

        * The given _SourceFile_ is a valid Prolog source, but it
          does not declare a class.


   * *ERROR : unknown class on _ID_ instance declaration*

     The class defined on the `instance_of/2' declaration for _ID_
     instance has not been loaded by a `use_class/1' declaration.

   * *ERROR : instance identifier _ID_ is an exisisting Prolog module*

     There is an statically declared instance whose identifier may
     cause interference with the Ciao Prolog module system. Use
     another instance identifier.

   * *ERROR : unknown constructor on _ID_ instance declaration*

     The given constructor on the `instance_of/2' declaration for
     _ID_ has not been defined at the corresponding class.

   * *ERROR : constructor is needed on _ID_ instance declaration*

     No constructor was defined on the `instance_of/2' declaration
     for _ID_ and default constructor is not allowed. You must
     provide a constructor.

   * *ERROR : static instance _ID_ was derived from a different
     constructor at _AnotherModule_*

     _ID_ has been declared to be an static instance both on
     _AnotherModule_ and current source, but different constructors
     were used. The most probable causes for this error are:

        * Occasionally, there is another module using the same
          instance identifier and it was not noticed by you. Another
          different identifier may be used instead.

        * It was you intention to use the same object as declared by
          the other module. In this case, the same constructor must
          be used.


   * *ERROR : invalid first argument in call to new(_Arg_,_)*

     There is a new/1 goal in your code where first argument is not a
     free variable. For example:

     `myobj new myclass'

     First argument must be a variable in order to receive a run-time
     generated object identifier.

   * *ERROR : unknown class in call to new(?,_Constructor_) *

     The given _Constructor_ in call to new/2 does not correspond to
     any used class at current code. The most probable cause of this
     may be:

        * You forgot to include a `use_class/1' declaration in your
          code.

        * There is a spelling mistake in the constructor.For example:

          :- use_class(myclass).

          foo(X) :- X new mclass.


   * *ERROR : can not create an instance from an interface:
     new(?,_Constructor_) *

     Given _Constructor_ references an interface rather than a class.
     Instances can not be derived from interface-expanded code.

   * *ERROR : unknown constructor in call to new(?,_Constructor_) *

     As the previous error, there is a mistake in the given
     _Constructor_. This error is reported when you are trying to
     call a constructor which was not defined at the corresponding
     class. Check the class definition to find what is going on.

     Another cause for this error is the incorrect usage of the
     default constructor. Whenever there are one or more constructors
     defined at the involved class, you are restricted to chose one
     of them. This seems that default constructor will be available,
     if and only if, there are no constructors defined at the
     involved class.

   * *ERROR : call to non-public _ID:Goal_*

     You are trying to call a method which was not declared as public
     by the class specified in `instance_of/2' declaration for _ID_.

   * *ERROR : call to inaccessible predicate at instance _ID:Goal_*

     There is a call to _Goal_ at statically declared instance _ID_
     which is unknown or was not declared as public.

   * *ERROR : unknown instance _ID_ of class _Class_ at _Goal_*

     There is a call to _Goal_ where involved statically declared
     instance _ID_ is unknown or is not derived from _Class_. Check
     whether it was declared by a `instance_of/2' declaration.

   * *ERROR : inaccessible attribute _Fact_ at instance _ID_*

     There is an attempt to use _ID:Fact_ but it was not declared as
     public.

   * *ERROR : unknown attribute _Fact_ at instance _ID_*

     There is an attempt to use _ID:Fact_ but it is unknown or it is
     not an attribute (may be a method).

   * *WARNING : invalid call to new(?,_)*

     There is a call to new/2 in you code where first argument
     variable has been determined to hold any other instance. For
     example:

     `foo :- X new myclass,X new otherclass.'

     or

     `foo(X) :- X instance_of myclass, X new myclass.'

     The related call to new/2 will allways fail.

   * *WARNING : called _Goal_ is not public at any used class*

     There is a call to _Var_:_Goal_ where _Var_ has not been
     determined to be compatible with any class. However, _Goal_ is
     not public at any class specified by the `use_class/1'
     declaration.

     This is a warning (not an error) since _Var_:_Goal_ may be not
     related to Object Oriented Programing.



File: ciao.info,  Node: Error reporting at run time (objects),  Prev: Error reporting at compile time (objects),  Up: Other information (objects)

Error reporting at run time (objects)
-------------------------------------

   * *EXCEPTION : instantiation_error( '1st argument must be free
     variable')*

     Calling to new/1 requieres first argument to be a free variable.
     For example:

     `X = this_will_raise_an_exception,X new myclass.'

   * *EXCEPTION : instantiation_error('class not given')*

     You called new/2 using a free variable as second argument.

   * *EXCEPTION : instantiation_error(inaccesible_class(_Class_),
     from(_Module_)) *

     _Module_ tried to create an instance of _Class_ by the ways of
     new/2, but there is no usage relationship between _Module_ and
     _Class_.

   * *EXCEPTION : instantiation_error(invalid_constructor(
     _Constructor_)) *

     _Constructor_ was not defined by the corresponding class.



File: ciao.info,  Node: Run time usage of objects,  Next: *** PART VIII - Interfaces to other languages and systems,  Prev: Compile-time usage of objects,  Up: Top

Run time usage of objects
*************************

   *Author(s):* Angel Fernandez Pineda, Angel Fernandez Pineda.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#4 (1999/11/29, 19:11:21 MET)

   This library provides run-time support for object creation and
manipulation. Objects are also called class instances, or simply
instances.

   Objects in Ciao are treated as normal modules. This is, an object
is a run-time generated Prolog module, which may be identified by an
unique term across the whole application.

   This is a very simple example of how to create an instance, and
how to make calls to it:

                 AnObj new myclass,
                 AnObj:mymethod.

   In order to make any object accessible from code, an usage
relationship must be established between the class (from which
instances are derived) and the code itself. Refer to `use_class/1'
predicate or `use_class/1' declaration in order to do so.

* Menu:

* Usage and interface (objects_rt)::
* Documentation on exports (objects_rt)::
* Known bugs and planned improvements (objects_rt)::


File: ciao.info,  Node: Usage and interface (objects_rt),  Next: Documentation on exports (objects_rt),  Prev: Run time usage of objects,  Up: Run time usage of objects

Usage and interface (`objects_rt')
==================================

   * *Library usage:*

     This library is automatically loaded when using the _objects_
     package:
              :- module(_ModuleName_,_Exports_,[objects]).
     Nothing special needs to be done.

   * *Exports:*
        - _Predicates:_

          `new/2', `instance_of/2', `derived_from/2', `interface/2',
          `instance_codes/2', `destroy/1', `use_class/1'.

        - _Properties:_

          `constructor/1', `class_name/1', `interface_name/1',
          `instance_id/1', `class_source/1', `interface_source/1',
          `method_spec/1', `virtual_method_spec/1'.


   * *Other modules used:*
        - _System library modules:_

          `aggregates', `dynamic', `iso_misc', `iso_byte_char',
          `iso_incomplete', `operators', `read', `write', `dynmods',
          `prolog_sys', `system'.




File: ciao.info,  Node: Documentation on exports (objects_rt),  Next: Known bugs and planned improvements (objects_rt),  Prev: Usage and interface (objects_rt),  Up: Run time usage of objects

Documentation on exports (`objects_rt')
=======================================

 - PREDICATE: new/2:
     Dynamic instance creation takes place by the ways of this
     predicate.

     It takes a free variable as first argument which will be
     instantiated to an internal object identifier.

     Second argument must be instantiated to a class constructor.
     Class constructors are designed to perform an initialization on
     the new created instance. Notice that instance initialization
     may involve some kind of computation, not only _state
     initialization_.

     A class constructor is made by a functor, which must match the
     intended class name, and any number of parameters. For example:

                      Obj new myclass(1500,'hello, world!!!')

     Those parameters depends (obviously) on the constructors defined
     at the class source. If no constructors where defined, no
     parameters are needed. This is called the default constructor.
     An example:

                      Obj new myclass

     The default constructor can not be called if there is any
     constructor available at the class source.

     Instantiation will raise an exception and fail whenever any of
     this conditions occur:
        * First argument is not a free variable.

        * Second argument functor is a class, but there is no usage
          relationship with it.

        * Second argument functor is not a class.

        * The given constructor is unknown.

        * The given constructor fails (notice that default
          constructor never fails).

     Objects may also be statically declared, refer to
     `instance_of/2' declaration.

     *Usage:* `new(InstanceVar,Constructor)'
        - _Description:_ Creates a new instance of the class
          specified by `Constructor' returning its identifier in
          `InstanceVar'

        - _The following properties should hold at call time:_

          `InstanceVar' is a free variable.   (`term_typing:var/1')

          `Constructor' is a term whose functor matches a class name.
          (`objects_rt:constructor/1')

        - _The following properties should hold upon exit:_

          `InstanceVar' is an unique term which identifies an object.
          (`objects_rt:instance_id/1')



 - PREDICATE: instance_of/2:
     This predicate is used to perform dynamic type checking. You may
     check whether a particular instance belongs to a particular
     class or related descendants.

     instance_of/2 is used to perform static semantic analisys over
     object oriented code constructions.

     By the use of instance_of/2 you may help to perform such
     analisys.

     *Usage 1:* `instance_of(Instance,Class)'
        - _Description:_ Test whether `Instance' was derived from any
          descendant of `Class', or that class itself

        - _The following properties should hold at call time:_

          `Instance' is an unique term which identifies an object.
          (`objects_rt:instance_id/1')

          `Class' is an atom denoting a class.
          (`objects_rt:class_name/1')

     *Usage 2:* `instance_of(Instance,Class)'
        - _Description:_ Retrieves, on backtracking, the inheritance
          line of `Instance' commencing on the creation class (that
          specified on call to `new/2') and continuing on the rest of
          ascendant classes, if any.

        - _The following properties should hold at call time:_

          `Instance' is an unique term which identifies an object.
          (`objects_rt:instance_id/1')

          `Class' is a free variable.   (`term_typing:var/1')

        - _The following properties should hold upon exit:_

          `Class' is an atom denoting a class.
          (`objects_rt:class_name/1')



 - PREDICATE: derived_from/2:
     Test whether an object identifier was derived directly from a
     class, by the usage of `new/2' or a static instance declaration (
     `instance_of/2').

     *Usage 1:* `derived_from(Instance,Class)'
        - _Description:_ Test derivation of `Instance' from `Class'

        - _The following properties should hold at call time:_

          `Instance' is an unique term which identifies an object.
          (`objects_rt:instance_id/1')

          `Class' is an atom denoting a class.
          (`objects_rt:class_name/1')

     *Usage 2:* `derived_from(Instance,Class)'
        - _Description:_ Retrieves the `Class' responsable of the
          derivation of `Instance'.

        - _The following properties should hold at call time:_

          `Instance' is an unique term which identifies an object.
          (`objects_rt:instance_id/1')

          `Class' is a free variable.   (`term_typing:var/1')

        - _The following properties should hold upon exit:_

          `Class' is an atom denoting a class.
          (`objects_rt:class_name/1')



 - PREDICATE: interface/2:
     This predicate is used to ensure a given interface to be
     implemented by a given instance.

     *Usage 1:* `interface(Instance,Interface)'
        - _Description:_ Check whether `Instance' implements the
          given `Interface'.

        - _The following properties should hold at call time:_

          `Instance' is an unique term which identifies an object.
          (`objects_rt:instance_id/1')

          `Interface' is an unique atom which identifies a public
          interface.   (`objects_rt:interface_name/1')

     *Usage 2:* `interface(Instance,Interfaces)'
        - _Description:_ Retrieves on backtracking all the
          implemented `Interfaces' of `Instance'.

        - _The following properties should hold at call time:_

          `Instance' is an unique term which identifies an object.
          (`objects_rt:instance_id/1')

          `Interfaces' is a free variable.   (`term_typing:var/1')

        - _The following properties should hold upon exit:_

          `Interfaces' is an unique atom which identifies a public
          interface.   (`objects_rt:interface_name/1')



 - PREDICATE: instance_codes/2:
     Retrieves a character string representation from an object
     identifier and vice-versa.

     *Usage 1:* `instance_codes(Instance,String)'
        - _Description:_ Retrieves a `String' representation of given
          `Instance'.

        - _The following properties should hold at call time:_

          `Instance' is an unique term which identifies an object.
          (`objects_rt:instance_id/1')

          `String' is a free variable.   (`term_typing:var/1')

        - _The following properties should hold upon exit:_

          `String' is a string (a list of character codes).
          (`basic_props:string/1')

     *Usage 2:* `instance_codes(Instance,String)'
        - _Description:_ Reproduces an `Instance' from its `String'
          representation. Such an instance must be alive across the
          application: this predicate will fail whether the involved
          instance has been destroyed.

        - _The following properties should hold at call time:_

          `Instance' is a free variable.   (`term_typing:var/1')

          `String' is a string (a list of character codes).
          (`basic_props:string/1')

        - _The following properties should hold upon exit:_

          `Instance' is an unique term which identifies an object.
          (`objects_rt:instance_id/1')



 - PREDICATE: destroy/1:
     As well as instances are created, they must be destroyed when no
     longer needed in order to release system resources.

     Unfortunately, current O'Ciao implementation does not support
     automatic instance destruction, so user must manually call
     _destroy/1_ in order to do so.

     The programmer *must ensure* that no other references to the
     involved object are left in memory when destroy/1 is called. If
     not, unexpected results may be obtained.

     *Usage:* `destroy(Instance)'
        - _Description:_ Destroys the object identified by `Instance'.

        - _The following properties should hold at call time:_

          `Instance' is an unique term which identifies an object.
          (`objects_rt:instance_id/1')



 - PREDICATE: use_class/1:
     The behaviour of this predicate is identical to that provided by
     the declaration of the same name `use_class/1'. It allows user
     programs to dynamically load classes. Whether the given source
     is not a class it will perform a `use_module/1' predicate call.

     *Usage:* `use_class(ClassSource)'
        - _Description:_ Dynamically loads the given `ClassSource'

        - _The following properties should hold at call time:_

          `ClassSource' is a valid path to a prolog file containing a
          class declaration (without .pl extension).
          (`objects_rt:class_source/1')



 - PROPERTY: constructor/1:
     *Usage:* `constructor(Cons)'
        - _Description:_ `Cons' is a term whose functor matches a
          class name.



 - PROPERTY: class_name/1:
     *Usage:* `class_name(ClassName)'
        - _Description:_ `ClassName' is an atom denoting a class.



 - PROPERTY: interface_name/1:
     *Usage:* `interface_name(Interface)'
        - _Description:_ `Interface' is an unique atom which
          identifies a public interface.



 - PROPERTY: instance_id/1:
     *Usage:* `instance_id(ID)'
        - _Description:_ `ID' is an unique term which identifies an
          object.



 - PROPERTY: class_source/1:
     *Usage:* `class_source(Source)'
        - _Description:_ `Source' is a valid path to a prolog file
          containing a class declaration (without .pl extension).



 - PROPERTY: interface_source/1:
     *Usage:* `interface_source(Source)'
        - _Description:_ `Source' is a valid path to a prolog file
          containing a class declaration or an interface declaration
          (without .pl extension).



 - PROPERTY: method_spec/1:
     There is no difference between method or attribute
     specifications, and habitual predicate specifications. It is
     just a Functor/Arity term.

     *Usage:* `method_spec(Spec)'
        - _Description:_ `Spec' is a method or attribute
          specification.



 - PROPERTY: virtual_method_spec/1:
     *Usage:* `virtual_method_spec(Spec)'
        - _Description:_ `Spec' is a method specification.




File: ciao.info,  Node: Known bugs and planned improvements (objects_rt),  Prev: Documentation on exports (objects_rt),  Up: Run time usage of objects

Known bugs and planned improvements (`objects_rt')
==================================================

   * Not really a bug: when loading code which declares static
     instances from the toplevel shell, predicate `use_module/1')
     will not work properly: those instances may be not correctly
     created, and predicates will fail whenever they are not supposed
     to do. This may be avoided by reloading again the involved
     module, but make sure it is modified and saved to disk before
     doing so.


File: ciao.info,  Node: *** PART VIII - Interfaces to other languages and systems,  Next: foreign_interface (library),  Prev: Run time usage of objects,  Up: Top

PART VIII - Interfaces to other languages and systems
*****************************************************

   The following interfaces to/from Ciao Prolog are documented in
this part:
   * External interface (e.g., to C).

   * Socket interface.

   * Tcl/tk interface.

   * Web interface (http, html, xml, etc.);

   * Persistent predicate databases (interface between the Prolog
     internal database and the external file system).

   * SQL-like database interface (interface between the Prolog
     internal database and external SQL/ODBC systems).

   * Java interface.

   * Calling emacs from Prolog.


File: ciao.info,  Node: foreign_interface (library),  Next: Utilities for on-demand compilation of foreign files,  Prev: *** PART VIII - Interfaces to other languages and systems,  Up: Top

foreign_interface (library)
***************************

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#137 (2000/5/10, 11:29:26 CEST)

* Menu:

* Usage and interface (foreign_interface)::
* Documentation on exports (foreign_interface)::


File: ciao.info,  Node: Usage and interface (foreign_interface),  Next: Documentation on exports (foreign_interface),  Prev: foreign_interface (library),  Up: foreign_interface (library)

Usage and interface (`foreign_interface')
=========================================

   * *Library usage:*

     `:- use_package(foreign_interface).'

     or

     `:- module(...,...,[foreign_interface]).'

   * *Exports:*
        - _Properties:_

          `size_of/3', `do_not_free/2', `returns/2', `foreign/1',
          `foreign/2', `native/1', `native/2'.

        - _Regular Types:_

          `address/1', `byte/1', `byte_list/1', `int_list/1'.




File: ciao.info,  Node: Documentation on exports (foreign_interface),  Prev: Usage and interface (foreign_interface),  Up: foreign_interface (library)

Documentation on exports (`foreign_interface')
==============================================

 - REGTYPE: address/1:
     *Usage:* `address(Address)'
        - _Description:_ `Address' is a valid memory address.



 - REGTYPE: byte/1:
     *Usage:* `byte(Byte)'
        - _Description:_ `Byte' is a byte



 - REGTYPE: byte_list/1:
     *Usage:* `byte_list(List)'
        - _Description:_ `List' is a list of bytes.



 - REGTYPE: int_list/1:
     *Usage:* `int_list(List)'
        - _Description:_ `List' is a list of integers.



 - PROPERTY: size_of/3:
     *Usage:* `size_of(Name,ListVar,SizeVar)'
        - _Description:_ For predicate `Name', the size of the
          argument of type `byte_list/1', `ListVar', is given by the
          argument of type integer `SizeVar'.



 - PROPERTY: do_not_free/2:
     *Usage:* `do_not_free(Name,Var)'
        - _Description:_ For predicate `Name', the C argument passed
          to (returned from) the foreign function will not be freed
          after calling the foreign function.



 - PROPERTY: returns/2:
     *Usage:* `returns(Name,Var)'
        - _Description:_ The result of the foreign function that
          implements the Prolog predicate `Name' is unified with the
          Prolog variable `Var'. Cannot be used without `foreign/1' or
          `foreign/2'.



 - PROPERTY: foreign/1:
     *Usage:* `foreign(Name)'
        - _Description:_ The Prolog predicate `Name' is implemented
          using the foreign function `Name'.



 - PROPERTY: foreign/2:
     *Usage:* `foreign(PrologName,ForeignName)'
        - _Description:_ The Prolog predicate `PrologName' is
          implemented using the foreign function `ForeignName'.



 - PROPERTY: native/1:
     *Usage:* `native(Name)'
        - _Description:_ The Prolog predicate `Name' is implemented
          using the native function `Name'.



 - PROPERTY: native/2:
     *Usage:* `native(PrologName,ForeignName)'
        - _Description:_ The Prolog predicate `PrologName' is
          implemented using the native function prolog_`ForeignName'.




File: ciao.info,  Node: Utilities for on-demand compilation of foreign files,  Next: davinci (library),  Prev: foreign_interface (library),  Up: Top

Utilities for on-demand compilation of foreign files
****************************************************

   *Author(s):* Manuel Carro, Jose Morales.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.3#36 (1999/7/20, 10:37:31 MEST)

   This module provides two predicates which give the user
information regarding how to compile external (C) files in order to
link them with the Ciao Prolog engine at runtime.

   These predicates are not intended to be called directly by the
end-user. Instead, a tool or module whose aim is generating
dynamically loadable files from source files should use the
predicates in this file in order to find out what are the proper
compiler and linker to use, and which options must be passed to them
in the current architecture.

* Menu:

* Usage and interface (foreign_compilation)::
* Documentation on exports (foreign_compilation)::


File: ciao.info,  Node: Usage and interface (foreign_compilation),  Next: Documentation on exports (foreign_compilation),  Prev: Utilities for on-demand compilation of foreign files,  Up: Utilities for on-demand compilation of foreign files

Usage and interface (`foreign_compilation')
===========================================

   * *Library usage:*

     `:- use_module(library(foreign_compilation)).'

   * *Exports:*
        - _Predicates:_

          `compiler_and_opts/2', `linker_and_opts/2'.


   * *Other modules used:*
        - _System library modules:_

          `system'.




File: ciao.info,  Node: Documentation on exports (foreign_compilation),  Prev: Usage and interface (foreign_compilation),  Up: Utilities for on-demand compilation of foreign files

Documentation on exports (`foreign_compilation')
================================================

 - PREDICATE: compiler_and_opts/2:
     *Usage:* `compiler_and_opts(?Compiler,?Opts)'
        - _Description:_ If you want to compile a foreign language
          file for dynamic linking in the current operating system
          and architecture, you have to use the compiler `Compiler'
          and gite it the options `Opts'. A variable in `Opts' means
          that no special option is needed.

        - _The following properties should hold at call time:_

          `?Compiler' is currently instantiated to an atom.
          (`term_typing:atom/1')

          `?Opts' is a list of `atom's.   (`basic_props:list/2')



 - PREDICATE: linker_and_opts/2:
     *Usage:* `linker_and_opts(?Linker,?Options)'
        - _Description:_ If you want to link a foreign language file
          for dynamic linking in the current operating system and
          architecture, you have to use the linker `Compiler' and
          gite it the options `Opts'. A variable in `Opts' means that
          no special option is needed.

        - _The following properties should hold at call time:_

          `?Linker' is currently instantiated to an atom.
          (`term_typing:atom/1')

          `?Options' is a list of `atom's.   (`basic_props:list/2')




File: ciao.info,  Node: davinci (library),  Next: The Tcl/Tk interface,  Prev: Utilities for on-demand compilation of foreign files,  Up: Top

davinci (library)
*****************

   *Author(s):* Francisco Bueno.

   This library allows connecting a Ciao Prolog application with
daVinci V2.X.

   The communication is based on a two-way channel: after daVinci is
started, messages are sent in to it and read in from it on demand by
different Prolog predicates. Messages are sent via writing the term
as text; messages are received by reading text and returning an atom.
Commands sent and answers received are treated as terms from the
Prolog side, since for daVinci they are text but have term syntax;
the only difficulty lies in strings, for which special Prolog syntax
is provided.

   See accompanying file `library('davinci/commands')' for examples
on the use of this library.

   daVinci is developed by U. of Bremen, Germany.

* Menu:

* Usage and interface (davinci)::
* Documentation on exports (davinci)::


File: ciao.info,  Node: Usage and interface (davinci),  Next: Documentation on exports (davinci),  Prev: davinci (library),  Up: davinci (library)

Usage and interface (`davinci')
===============================

   * *Library usage:*

     `:- use_module(library(davinci)).'

   * *Exports:*
        - _Predicates:_

          `davinci/0', `topd/0', `davinci_get/1', `davinci_get_all/1',
          `davinci_put/1', `davinci_quit/0', `davinci_ugraph/1',
          `davinci_lgraph/1', `ugraph2term/2', `formatting/2'.


   * *Other modules used:*
        - _System library modules:_

          `aggregates', `prompt', `errhandle', `format', `read',
          `graphs/ugraphs', `write', `system'.




File: ciao.info,  Node: Documentation on exports (davinci),  Prev: Usage and interface (davinci),  Up: davinci (library)

Documentation on exports (`davinci')
====================================

 - PREDICATE: davinci/0:
     No further documentation available for this predicate.




 - PREDICATE: topd/0:
     No further documentation available for this predicate.




 - PREDICATE: davinci_get/1:
     No further documentation available for this predicate.




 - PREDICATE: davinci_get_all/1:
     No further documentation available for this predicate.




 - PREDICATE: davinci_put/1:
     No further documentation available for this predicate.




 - PREDICATE: davinci_quit/0:
     No further documentation available for this predicate.




 - PREDICATE: davinci_ugraph/1:
     No further documentation available for this predicate.




 - PREDICATE: davinci_lgraph/1:
     No further documentation available for this predicate.




 - PREDICATE: ugraph2term/2:
     No further documentation available for this predicate.




 - PREDICATE: formatting/2:
     No further documentation available for this predicate.





File: ciao.info,  Node: The Tcl/Tk interface,  Next: The PiLLoW Web Programming Library,  Prev: davinci (library),  Up: Top

The Tcl/Tk interface
********************

   *Author(s):* Montse Iglesias.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#16 (1999/12/14, 17:12:49 MET)

   The `tcltk' library package is a bidirectional interface to the
_Tcl_ (pronounced Tickle) language and _Tk_ toolkit. Tcl is an
interpreter scripting language with many extensions packages, in
particular the graphical interface toolkit Tk

* Menu:

* Usage and interface (tcltk)::
* Documentation on exports (tcltk)::


File: ciao.info,  Node: Usage and interface (tcltk),  Next: Documentation on exports (tcltk),  Prev: The Tcl/Tk interface,  Up: The Tcl/Tk interface

Usage and interface (`tcltk')
=============================

   * *Library usage:*

     `:- use_module(library(tcltk)).'

   * *Exports:*
        - _Predicates:_

          `tcl_new/1', `tcl_eval/3', `tcl_delete/1', `tcl_event/3',
          `tk_event_loop/1', `tk_loop/1', `tk_new/2', `tk_new/4',
          `tk_next_event/2'.

        - _Regular Types:_

          `tclInterpreter/1', `tclCommand/1'.


   * *Other modules used:*
        - _System library modules:_

          `tcltk/tcltk_low_level', `write', `strings', `lists'.




File: ciao.info,  Node: Documentation on exports (tcltk),  Prev: Usage and interface (tcltk),  Up: The Tcl/Tk interface

Documentation on exports (`tcltk')
==================================

 - REGTYPE: tclInterpreter/1:
     To use Tcl, you must create a _Tcl interpreter_ object and send
     commands to it.

     *Usage:* `tclInterpreter(I)'
        - _Description:_ `I' is a reference to a _Tcl_ interpreter.



 - REGTYPE: tclCommand/1:
     A _Tcl_ command is specified as follows:
                Command         --> Atom  { other than [] }
                                  | Number
                                  | chars(PrologString)
                                  | write(Term)
                                  | format(Fmt,Args)
                                  | dq(Command)
                                  | br(Command)
                                  | sqb(Command)
                                  | min(Command)
                                  | ListOfCommands
                ListOfCommands  --> []
                                  |[Command|ListOfCommands]

     where:

    Atom

    Number
          denote their printed representations.

    chars(PrologString)
          denotes the string represented by _PrologString_ (a list of
          character codes).

    write(Term)
          denotes the string that is printed by the corresponding
          built-in pridicate.

    format(Term)
          denotes the string that is printed by the corresponding
          built-in pridicate.

    dq(Command)
          denotes the string specified by _Command_, enclosed in
          double quotes.

    br(Command)
          denotes the string specified by _Command_, enclosed in
          braces.

    sqb(Command)
          denotes the string specified by _Command_, enclosed in
          square brackets.

    min(Command)
          denotes the string specified by _Command_, immediately
          preceded by a hyphen.

    ListOfCommands
          denotes the strings denoted by each element, separated by
          spaces.

     *Usage:* `tclCommand(C)'
        - _Description:_ `C' is a _Tcl_ command.



 - PREDICATE: tcl_new/1:
     *Usage:* `tcl_new(-TclInterpreter)'
        - _Description:_ Creates a new interpreter, initializes it,
          and returns a reference to it in `TclInterpreter'.

        - _Call and exit should be _compatible_ with:_

          `-TclInterpreter' is a reference to a _Tcl_ interpreter.
          (`tcltk:tclInterpreter/1')



 - PREDICATE: tcl_eval/3:
     *Usage:* `tcl_eval(+TclInterpreter,+Command,-Result)'
        - _Description:_ Evaluates the commands given. The result
          will be stored as a string in _Result_. If there is an
          error in the _Command_, an exception is raised. The error
          messages will be _Tcl Exception: _, if the error is in the
          syntax of the tcltk code or _Prolog Exception: _, if the
          error is in the prolog term.

        - _Call and exit should be _compatible_ with:_

          `+TclInterpreter' is a reference to a _Tcl_ interpreter.
          (`tcltk:tclInterpreter/1')

          `+Command' is a _Tcl_ command.   (`tcltk:tclCommand/1')

          `-Result' is a string (a list of character codes).
          (`basic_props:string/1')



 - PREDICATE: tcl_delete/1:
     *Usage:* `tcl_delete(+TclInterpreter)'
        - _Description:_ Deletes the interpreter in `TclInterpreter'
          and the memory used by it

        - _Call and exit should be _compatible_ with:_

          `+TclInterpreter' is a reference to a _Tcl_ interpreter.
          (`tcltk:tclInterpreter/1')



 - PREDICATE: tcl_event/3:
     *Usage:* `tcl_event(+TclInterpreter,+Command,-Events)'
        - _Description:_ Lets _TclInterpreter_ interpret the command
          specified by _Command_. _Events_ is a list of terms stored
          from Tcl by the _prolog_event_.

        - _Call and exit should be _compatible_ with:_

          `+TclInterpreter' is a reference to a _Tcl_ interpreter.
          (`tcltk:tclInterpreter/1')

          `+Command' is a _Tcl_ command.   (`tcltk:tclCommand/1')

          `-Events' is a list.   (`basic_props:list/1')



 - PREDICATE: tk_event_loop/1:
     *Usage:* `tk_event_loop(+TclInterpreter)'
        - _Description:_ Waits an event and execute the term
          associated to it. Sends the unified term to obtain the
          value of the tcl array of _prolog_variables_.

        - _Call and exit should be _compatible_ with:_

          `+TclInterpreter' is a reference to a _Tcl_ interpreter.
          (`tcltk:tclInterpreter/1')



 - PREDICATE: tk_loop/1:
     *Usage:* `tk_loop(+TclInterpreter)'
        - _Description:_ Passes control to Tk until all windows are
          gone.

        - _Call and exit should be _compatible_ with:_

          `+TclInterpreter' is a reference to a _Tcl_ interpreter.
          (`tcltk:tclInterpreter/1')



 - PREDICATE: tk_new/2:
     *Usage:* `tk_new(+Options,-TclInterpreter)'
        - _Description:_ Performs basic Tcl and Tk initialization and
          creates the main window of a Tk application._Options_ is a
          list of optional elements according to :

         name
               Sets the Tk application name. The application name
               will be displayed in the main window and is also used
               for communicating between applications in Tk. Default
               name is an empty string.

         display
               Gives the name of the screen on which to create the
               main window. Default is normally determined by the
               DISPLAY environment variable.

         file
               Open the sript file, commands will not be read from
               standard input and the execution returns back to
               Prolog only after all windows (and the interpreter)
               have been deleted.

        - _Call and exit should be _compatible_ with:_

          `+Options' is a list.   (`basic_props:list/1')

          `-TclInterpreter' is a reference to a _Tcl_ interpreter.
          (`tcltk:tclInterpreter/1')



 - PREDICATE: tk_new/4:
     No further documentation available for this predicate.




 - PREDICATE: tk_next_event/2:
     *Usage:* `tk_next_event(+TclInterpreter,-Event)'
        - _Description:_ Processes events until there is at least one
          Prolog event associated with _TclInterpreter_. _Event_ is
          the term correspondig to the head of a queue of events
          stored from Tcl with the _prolog_event_ command.

        - _Call and exit should be _compatible_ with:_

          `+TclInterpreter' is a reference to a _Tcl_ interpreter.
          (`tcltk:tclInterpreter/1')

          `-Event' is a string (a list of character codes).
          (`basic_props:string/1')




File: ciao.info,  Node: The PiLLoW Web Programming Library,  Next: HTML/XML/CGI programming,  Prev: The Tcl/Tk interface,  Up: Top

The PiLLoW Web Programming Library
**********************************

   *Author(s):* Daniel Cabeza, Manuel Hermenegildo,
<clip@clip.dia.fi.upm.es>, `http://www.clip.dia.fi.upm.es/', The CLIP
Group, School of Computer Science, Technical University of Madrid.

   This package implements the PiLLoW library [CHV96a]. The following
three chapters document, respectively, the predicates for
HTML/XML/CGI programming, the predicate for HTTP conectivity, and the
types used in the definition of the predicates (key for fully
understanding the other predicates). You can find a paper and some
additional information in the `library/pillow/doc' directory of the
distribution, and in the WWW at
`http://clip.dia.fi.upm.es/Software/pillow/pillow.html'. There is
also a _PiLLoW on-line tutorial_ (slides) at
`http://clip.dia.fi.upm.es/logalg/slides/C_pillow/C_pillow.html'
which illustrates the basic features and provides a number of
examples of PiLLoW use.

* Menu:

* Installing PiLLoW::
* Usage and interface (pillow)::


File: ciao.info,  Node: Installing PiLLoW,  Next: Usage and interface (pillow),  Prev: The PiLLoW Web Programming Library,  Up: The PiLLoW Web Programming Library

Installing PiLLoW
=================

   To correctly install PiLLoW, first, make sure you downloaded the
right version of PiLLoW (there are different versions for different
LP/CLP systems; the version that comes with Ciao is of course the
right one for Ciao). Then, please follow these steps:

  1. Copy the files in the `images' directory to a WWW accessible
     directory in your server.

  2. Edit the file `icon_address.pl' and change the fact to point to
     the URL to be used to access the images above.

  3. In the Ciao system the files are in the correct place, in other
     systems copy the files `pillow.pl' and `icon_address.pl' to a
     suitable directory so that your Prolog system will find them.



File: ciao.info,  Node: Usage and interface (pillow),  Prev: Installing PiLLoW,  Up: The PiLLoW Web Programming Library

Usage and interface (`pillow')
==============================

   * *Library usage:*

     `:- use_package(pillow).'

     or

     `:- module(...,...,[pillow]).'

   * *New operators defined:*

     `$/2' [150,xfx], `$/1' [150,fx].

   * *Other modules used:*
        - _System library modules:_

          `pillow/http', `pillow/html'.




File: ciao.info,  Node: HTML/XML/CGI programming,  Next: HTTP conectivity,  Prev: The PiLLoW Web Programming Library,  Up: Top

HTML/XML/CGI programming
************************

   *Author(s):* Daniel Cabeza, Manuel Hermenegildo, Sacha Varma.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#114 (2000/4/11, 20:23:43 CEST)

   This module implements the predicates of the PiLLoW package
related to HTML/ XML generation and parsing, CGI and form handlers
programming, and in general all the predicates which do not imply the
use of the HTTP protocol.

* Menu:

* Usage and interface (html)::
* Documentation on exports (html)::
* Documentation on multifiles (html)::
* Other information (html)::


File: ciao.info,  Node: Usage and interface (html),  Next: Documentation on exports (html),  Prev: HTML/XML/CGI programming,  Up: HTML/XML/CGI programming

Usage and interface (`html')
============================

   * *Library usage:*

     `:- use_module(library(html)).'

   * *Exports:*
        - _Predicates:_

          `output_html/1', `html2terms/2', `xml2terms/2',
          `html_template/3', `html_report_error/1',
          `get_form_input/1', `get_form_value/3',
          `form_empty_value/1', `form_default/3', `set_cookie/2',
          `get_cookies/1', `url_query/2', `my_url/1', `url_info/2',
          `url_info_relative/3', `form_request_method/1',
          `icon_address/2', `html_protect/1', `http_lines/3'.

        - _Multifiles:_

          `html_expansion/2'.


   * *Other modules used:*
        - _System library modules:_

          `strings', `lists', `system', `pillow/pillow_aux',
          `pillow/pillow_types'.




File: ciao.info,  Node: Documentation on exports (html),  Next: Documentation on multifiles (html),  Prev: Usage and interface (html),  Up: HTML/XML/CGI programming

Documentation on exports (`html')
=================================

 - PREDICATE: output_html/1:
     `output_html(HTMLTerm)'

     Outputs `HTMLTerm', interpreted as an `html_term/1', to current
     output stream.




 - PREDICATE: html2terms/2:
     `html2terms(String,Terms)'

     `String' is a character list containing HTML code and `Terms' is
     its prolog structured representation.

     *Usage 1:* `html2terms(-string,+html_term)'
        - _Description:_ Translates an HTML-term into the HTML code
          it represents.

     *Usage 2:* `html2terms(+string,?canonic_html_term)'
        - _Description:_ Translates HTML code into a structured
          HTML-term.



 - PREDICATE: xml2terms/2:
     `xml2terms(String,Terms)'

     `String' is a character list containing XML code and `Terms' is
     its prolog structured representation.

     *Usage 1:* `xml2terms(-string,+html_term)'
        - _Description:_ Translates a XML-term into the XML code it
          represents.

     *Usage 2:* `xml2terms(+string,?canonic_xml_term)'
        - _Description:_ Translates XML code into a structured
          XML-term.



 - PREDICATE: html_template/3:
     `html_template(Chars,Terms,Dict)'

     Interprets `Chars' as an HTML template returning in `Terms' the
     corresponding structured HTML-term, which includes variables,
     and unifying `Dict' with a dictionary of those variables (an
     incomplete list of _name_`='_Var_ pairs). An HTML template is
     standard HTML code, but in which "slots" can be defined and
     given an identifier. These slots represent parts of the HTML
     code in which other HTML code can be inserted, and are
     represented in the HTML-term as free variables. There are two
     kinds of variables in templates:
        * Variables representing page contents. A variable with name
          _name_ is defined with the special tag `<V>'_name_`</V>'.

        * Variables representing tag attributes. They occur as an
          attribute or an attribute value starting with `_', followed
          by its name, which must be formed by alphabetic characters.


     As an example, suposse the following HTML template:
          <html>
          <body bgcolor=_bgcolor>
          <v>content</v>
          </body>
          </html>
     The following query in the Ciao toplevel shows how the template
     is parsed, and the dictionary returned:
          ?- file_to_string('template.html',_S), html_template(_S,Terms,Dict).
          
          Dict = [bgcolor=_A,content=_B|_],
          Terms = [env(html,[],["
          ",env(body,[bgcolor=_A],["
          ",_B,"
          "]),"
          "]),"
          "] ?
          
          yes
     If a dictionary with values is supplied at call time, then
     variables are unified accordingly inside the template:
          ?- file_to_string('template.html',_S),
             html_template(_S,Terms,[content=b("hello world!"),bgcolor="white"]).
          
          Terms = [env(html,[],["
          ",env(body,[bgcolor="white"],["
          ",b("hello world!"),"
          "]),"
          "]),"
          "] ?
          
          yes




 - PREDICATE: html_report_error/1:
     *Usage:* `html_report_error(Error)'
        - _Description:_ Outputs error `Error' as a standard HTML
          page.



 - PREDICATE: get_form_input/1:
     `get_form_input(Dict)'

     Translates input from the form (with either the POST or GET
     methods, and even with CONTENT_TYPE multipart/form-data) to a
     dictionary `Dict' of _attribute_=_value_ pairs. It translates
     empty values (which indicate only the presence of an attribute)
     to the atom `'$empty'', values with more than one line (from
     text areas or files) to a list of lines as strings, the rest to
     atoms or numbers (using `name/2').




 - PREDICATE: get_form_value/3:
     `get_form_value(Dict,Var,Val)'

     Unifies `Val' with the value for attribute `Var' in dictionary
     `Dict'. Does not fail: value is `''' if not found (this
     simplifies the programming of form handlers when they can be
     accessed directly).




 - PREDICATE: form_empty_value/1:
     *Usage:* `form_empty_value(Term)'
        - _Description:_ Checks that `Term', a value comming from a
          text area is empty (can have spaces, newlines and
          linefeeds).



 - PREDICATE: form_default/3:
     *Usage:* `form_default(+Val,+Default,-NewVal)'
        - _Description:_ Useful when a form is only partially filled,
          or when the executable can be invoked either by a link or
          by a form, to set form defaults. If the value of `Val' is
          empty then `NewVal'=`Default', else `NewVal'=`Val'.



 - PREDICATE: set_cookie/2:
     `set_cookie(Name,Value)'

     Sets a cookie of name `Name' and value `Value'. Must be invoked
     before outputting any data, including the `cgi_reply' html-term.




 - PREDICATE: get_cookies/1:
     `get_cookies(Cookies)'

     Unifies `Cookies' with a dictionary of _attribute_=_value_ pairs
     of the active cookies for this URL.




 - PREDICATE: url_query/2:
     `url_query(Dict,URLArgs)'

     Translates a dictionary `Dict' of parameter values into a string
     `URLArgs' for appending to a URL pointing to a form handler.




 - PREDICATE: my_url/1:
     `my_url(URL)'

     Unifies `URL' with the Uniform Resource Locator (WWW address) of
     this cgi executable.




 - PREDICATE: url_info/2:
     `url_info(URL,URLTerm)'

     Translates a URL `URL' to a Prolog structure `URLTerm' which
     details its various components, and vice-versa. For now non-HTTP
     URLs make the predicate fail.




 - PREDICATE: url_info_relative/3:
     `url_info_relative(URL,BaseURLTerm,URLTerm)'

     Translates a relative URL `URL' which appears in the HTML page
     refered to by `BaseURLTerm' into `URLTerm', a Prolog structure
     containing its absolute parameters. Absolute URLs are translated
     as with `url_info/2'. E.g.
          url_info_relative("dadu.html",
                            http('www.foo.com',80,"/bar/scoob.html"), Info)
     gives `Info = http('www.foo.com',80,"/bar/dadu.html")'.




 - PREDICATE: form_request_method/1:
     *Usage:* `form_request_method(Method)'
        - _Description:_ Unifies `Method' with the method of
          invocation of the form handler (`GET' or `POST').

        - _The following properties hold upon exit:_

          `Method' is an atom.   (`basic_props:atm/1')



 - PREDICATE: icon_address/2:
     `icon_address(Img,IAddress)'

     The PiLLoW image `Img' has URL `IAddress'.




 - PREDICATE: html_protect/1:
     `html_protect(Goal)'

     Calls `Goal'. If an error occurs during its execution, or it
     fails, an HTML page is output informing about the incident.
     Normaly the whole execution of a CGI is protected thus.

     _Meta-predicate_ with arguments: `html_protect(goal)'.

     *Usage:*
        - _Calls should, and exit will be compatible with:_

          `Goal' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')



 - PREDICATE: http_lines/3:
     *Usage:* `http_lines(Lines,String,Tail)'
        - _Description:_ `Lines' is a list of the lines with occur in
          `String' until `Tail'. The lines may end UNIX-style or
          DOS-style in `String', in `Lines' they have not end of line
          characters. Suitable to be used in DCGs.

        - _Calls should, and exit will be compatible with:_

          `Lines' is a list of `string's.   (`basic_props:list/2')

          `String' is a string (a list of character codes).
          (`basic_props:string/1')

          `Tail' is a string (a list of character codes).
          (`basic_props:string/1')




File: ciao.info,  Node: Documentation on multifiles (html),  Next: Other information (html),  Prev: Documentation on exports (html),  Up: HTML/XML/CGI programming

Documentation on multifiles (`html')
====================================

 - PREDICATE: html_expansion/2:
     The predicate is _multifile_.

     *Usage:* `html_expansion(Term,Expansion)'
        - _Description:_ Hook predicate to define macros. Expand
          occurrences of `Term' into `Expansion', in `output_html/1'.
          Take care to not transform something into itself!




File: ciao.info,  Node: Other information (html),  Prev: Documentation on multifiles (html),  Up: HTML/XML/CGI programming

Other information (`html')
==========================

   The code uses input from from L. Naish's forms and F. Bueno's
previous Chat interface. Other people who have contributed is (please
inform us if we leave out anybody): Markus Fromherz, Samir Genaim.


File: ciao.info,  Node: HTTP conectivity,  Next: PiLLoW types,  Prev: HTML/XML/CGI programming,  Up: Top

HTTP conectivity
****************

   *Author(s):* Daniel Cabeza.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.3#114 (1999/11/24, 0:57:16 MET)

   This module implements the HTTP protocol, which allows retrieving
data from HTTP servers.

* Menu:

* Usage and interface (http)::
* Documentation on exports (http)::


File: ciao.info,  Node: Usage and interface (http),  Next: Documentation on exports (http),  Prev: HTTP conectivity,  Up: HTTP conectivity

Usage and interface (`http')
============================

   * *Library usage:*

     `:- use_module(library(http)).'

   * *Exports:*
        - _Predicates:_

          `fetch_url/3'.


   * *Other modules used:*
        - _System library modules:_

          `strings', `lists', `pillow/pillow_aux',
          `pillow/pillow_types', `pillow/http_ll'.




File: ciao.info,  Node: Documentation on exports (http),  Prev: Usage and interface (http),  Up: HTTP conectivity

Documentation on exports (`http')
=================================

 - PREDICATE: fetch_url/3:
     `fetch_url(URL,Request,Response)'

     Fetches the document pointed to by `URL' from Internet, using
     request parameters `Request', and unifies `Response' with the
     parameters of the response. Fails on timeout. Note that
     redirections are not handled automatically, that is, if
     `Response' contains terms of the form
     `status(redirection,301,_)' and `location(NewURL)', the program
     should in most cases access location `NewURL'.

     *Usage:* `fetch_url(URL,Request,Response)'
        - _The following properties should hold at call time:_

          `URL' specifies a URL.   (`pillow_types:url_term/1')

          `Request' is a list of `http_request_param's.
          (`basic_props:list/2')

        - _The following properties hold upon exit:_

          `Response' is a list of `http_response_param's.
          (`basic_props:list/2')




File: ciao.info,  Node: PiLLoW types,  Next: Persistent predicate database,  Prev: HTTP conectivity,  Up: Top

PiLLoW types
************

   *Author(s):* Daniel Cabeza.

   Here are defined the regular types used in the documentation of
the predicates of the PiLLoW package.

* Menu:

* Usage and interface (pillow_types)::
* Documentation on exports (pillow_types)::


File: ciao.info,  Node: Usage and interface (pillow_types),  Next: Documentation on exports (pillow_types),  Prev: PiLLoW types,  Up: PiLLoW types

Usage and interface (`pillow_types')
====================================

   * *Library usage:*

     `:- use_module(library(pillow_types)).'

   * *Exports:*
        - _Regular Types:_

          `canonic_html_term/1', `canonic_xml_term/1', `html_term/1',
          `form_dict/1', `form_assignment/1', `form_value/1',
          `value_dict/1', `url_term/1', `http_request_param/1',
          `http_response_param/1', `http_date/1', `weekday/1',
          `month/1', `hms_time/1'.




File: ciao.info,  Node: Documentation on exports (pillow_types),  Prev: Usage and interface (pillow_types),  Up: PiLLoW types

Documentation on exports (`pillow_types')
=========================================

 - REGTYPE: canonic_html_term/1:
     A term representing HTML code in canonical, structured way. It
     is a list of terms defined by the following predicate:
          canonic_html_item(comment(S)) :-
                  string(S).
          canonic_html_item(declare(S)) :-
                  string(S).
          canonic_html_item(env(Tag,Atts,Terms)) :-
                  atm(Tag),
                  list(Atts,tag_attrib),
                  canonic_html_term(Terms).
          canonic_html_item($(Tag,Atts)) :-
                  atm(Tag),
                  list(Atts,tag_attrib).
          canonic_html_item(S) :-
                  string(S).

          tag_attrib(Att) :-
                  atm(Att).
          tag_attrib(Att=Val) :-
                  atm(Att),
                  string(Val).
     Each structure represents one HTML construction:
    *env(*_tag_*,*_attribs_*,*_terms_*)*
          An HTML environment, with name _tag_, list of attributes
          _attribs_ and contents _terms_.

    *$(*_tag_*,*_attribs_*)*
          An HTML element of name _tag_ and list of attributes
          _attribs_. `($)/2' is defined by the pillow package as an
          infix, binary operator.

    *comment(*_string_*)*
          An HTML comment (translates to/from `<!--'_string_`-->').

    *declare(*_string_*)*
          An HTML declaration, they are used only in the header
          (translates to/from `<!'_string_`>').

    _string_
          Normal text is represented as a list of character codes.

     For example, the term
          env(a,[href="www.therainforestsite.com"],
                ["Visit ",img$[src="TRFS.gif"]])
     is output to (or parsed from):
          <a href="www.therainforestsite.com">Visit <img src="TRFS.gif"></a>

     *Usage:* `canonic_html_term(HTMLTerm)'
        - _Description:_ `HTMLTerm' is a term representing HTML code
          in canonical form.



 - REGTYPE: canonic_xml_term/1:
     A term representing XML code in canonical, structured way. It is
     a list of terms defined by the following predicate (see
     `tag_attrib/1' definition in `canonic_html_term/1'):
          canonic_xml_item(Term) :-
                  canonic_html_item(Term).
          canonic_xml_item(xmldecl(Atts)) :-
                  list(Atts,tag_attrib).
          canonic_xml_item(env(Tag,Atts,Terms)) :-
                  atm(Tag),
                  list(Atts,tag_attrib),
                  canonic_xml_term(Terms).
          canonic_xml_item(elem(Tag,Atts)) :-
                  atm(Tag),
                  list(Atts,tag_attrib).
     In addition to the structures defined by `canonic_html_term/1'
     (the `($)/2' structure appears only in malformed XML code), the
     following structures can be used:
    *elem(*_tag_*,*_atts_*)*
          Specifies an XML empty element of name _tag_ and list of
          attributes _atts_. For example, the term
               elem(arc,[weigh="3",begin="n1",end="n2"])
          is output to (or parsed from):
               <arc weigh="3" begin="n1" end="n2"/>

    *xmldecl(*_atts_*)*
          Specifies an XML declaration with attributes _atts_
          (translates to/from `<?xml '_atts_`?>')

     *Usage:* `canonic_xml_term(XMLTerm)'
        - _Description:_ `XMLTerm' is a term representing XML code in
          canonical form.



 - REGTYPE: html_term/1:
     A term which represents HTML or XML code in a structured way. In
     addition to the structures defined by `canonic_html_term/1' or
     `canonic_xml_term/1', the following structures can be used:
    *begin(*_tag_*,*_atts_*)*
          It translates to the start of an HTML environment of name
          _tag_ and attributes _atts_. There exists also a
          *begin(_tag_)* structure. Useful, in conjunction with the
          next structure, when including in a document output
          generated by an existing piece of code (e.g. _tag_ =
          `pre'). Its use is otherwise discouraged.

    *end(*_tag_*)*
          Translates to the end of an HTML environment of name _tag_.

    *start*
          Used at the beginning of a document (translates to
          `<html>').

    *end*
          Used at the end of a document (translates to `</html>').

    `--'
          Produces a horizontal rule (translates to `<hr>').

    *\\*
          Produces a line break (translates to `<br>').

    *$*
          Produces a paragraph break (translates to `<p>').

    *image(*_address_*)*
          Used to include an image of address (URL) _address_
          (equivalent to `img$[src='_address_`]').

    *image(*_address_*,*_atts_*)*
          As above with the list of attributes _atts_.

    *ref(*_address_*,*_text_*)*
          Produces a hypertext link, _address_ is the URL of the
          referenced resource, _text_ is the text of the reference
          (equivalent to `a([href='_address_`],'_text_`)').

    *label(*_name_*,*_text_*)*
          Labels _text_ as a target destination with label _name_
          (equivalent to `a([name='_name_`],'_text_`)').

    *heading(*_n_*,*_text_*)*
          Produces a heading of level _n_ (between 1 and 6), _text_
          is the text to be used as heading. Useful when one wants a
          heading level relative to another heading (equivalent to
          `h'_n_`('_text_`)').

    *itemize(*_items_*)*
          Produces a list of bulleted items, _items_ is a list of
          corresponding HTML terms (translates to a `<ul>'
          environment).

    *enumerate(*_items_*)*
          Produces a list of numbered items, _items_ is a list of
          corresponding HTML terms (translates to a `<ol>'
          environment).

    *description(*_defs_*)*
          Produces a list of defined items, _defs_ is a list whose
          elements are definitions, each of them being a Prolog
          sequence (composed by `','/2' operators). The last element
          of the sequence is the definition, the other (if any) are
          the defined terms (translates to a `<dl>' environment).

    *nice_itemize(*_img_*,*_items_*)*
          Produces a list of bulleted items, using the image _img_ as
          bullet. The predicate `icon_address/2' provides a colored
          bullet.

    *preformatted(*_text_*)*
          Used to include preformatted text, _text_ is a list of HTML
          terms, each element of the list being a line of the
          resulting document (translates to a `<pre>' environment).

    *verbatim(*_text_*)*
          Used to include text verbatim, special HTML characters
          (`<,>,&,"' and space) are translated into its quoted HTML
          equivalent.

    *prolog_term(*_term_*)*
          Includes any prolog term _term_, represented in functional
          notation. Variables are output as `_'.

    *nl*
          Used to include a newline in the HTML source (just to
          improve human readability).

    *entity(*_name_*)*
          Includes the entity of name _name_ (ISO-8859-1 special
          character).

    *start_form(*_addr_*,*_atts_*)*
          Specifies the beginning of a form. _addr_ is the address
          (URL) of the program that will handle the form, and _atts_
          other attributes of the form, as the method used to invoke
          it. If _atts_ is not present (there is only one argument)
          the method defaults to POST.

    *start_form*
          Specifies the beginning of a form without assigning address
          to the handler, so that the form handler will be the
          cgi-bin executable producing the form.

    *end_form*
          Specifies the end of a form.

    *checkbox(*_name_*,*_state_*)*
          Specifies an input of type `checkbox' with name _name_,
          _state_ is `on' if the checkbox is initially checked.

    *radio(*_name_*,*_value_*,*_selected_*)*
          Specifies an input of type `radio' with name _name_
          (several radio buttons which are interlocked must share
          their name), _value_ is the the value returned by the
          button, if _selected_=_value_ the button is initially
          checked.

    *input(*_type_*,*_atts_*)*
          Specifies an input of type _type_ with a list of attributes
          _atts_. Possible values of _type_ are `text', `hidden',
          `submit', `reset', ldots

    *textinput(*_name_*,*_atts_*,*_text_*)*
          Specifies an input text area of name _name_. _text_
          provides the default text to be shown in the area, _atts_ a
          list of attributes.

    *option(*_name_*,*_val_*,*_options_*)*
          Specifies a simple option selector of name _name_,
          _options_ is the list of available options and _val_ is the
          initial selected option (if _val_ is not in _options_ the
          first item is selected by default) (translates to a
          `<select>' environment).

    *menu(*_name_*,*_atts_*,*_items_*)*
          Specifies a menu of name _name_, list of attributes _atts_
          and list of options _items_. The elements of the list
          _items_ are marked with the prefix operator `$' to indicate
          that they are selected (translates to a `<select>'
          environment).

    *form_reply*

    *cgi_reply*
          This two are equivalent, they do not generate HTML, rather,
          the CGI protocol requires this content descriptor to be
          used at the beginning by CGI executables (including form
          handlers) when replying (translates to `Content-type:
          text/html').

    *pr*
          Includes in the page a graphical logo with the message
          "Developed using the PiLLoW Web programming library", which
          points to the manual and library source.

    _name_*(*_text_*)*
          A term with functor _name_/1, different from the special
          functors defined herein, represents an HTML environment of
          name _name_ and included text _text_. For example, the term
                  address('clip@clip.dia.fi.upm.es')
          is translated into the HTML source
                  <address>clip@clip.dia.fi.upm.es</address>

    _name_*(*_atts_*,*_text_*)*
          A term with functor _name_/2, different from the special
          functors defined herein, represents an HTML environment of
          name _name_, attributes _atts_ and included text _text_.
          For example, the term

                  a([href='http://www.clip.dia.fi.upm.es/'],"Clip home")
          represents the HTML source
                  <a href="http://www.clip.dia.fi.upm.es/">Clip home</a>

     *Usage:* `html_term(HTMLTerm)'
        - _Description:_ `HTMLTerm' is a term representing HTML code.



 - REGTYPE: form_dict/1:
     *Usage:* `form_dict(Dict)'
        - _Description:_ `Dict' is a dictionary of values of the
          attributes of a form. It is a list of `form_assignment'



 - REGTYPE: form_assignment/1:
     *Usage:* `form_assignment(Eq)'
        - _Description:_ `Eq' is an assignment of value of an
          attribute of a form. It is defined by:
               form_assignment(A=V) :-
                       atm(A),
                       form_value(V).

               form_value(A) :-
                       atm(A).
               form_value(N) :-
                       num(N).
               form_value(L) :-
                       list(L,string).




 - REGTYPE: form_value/1:
     *Usage:* `form_value(V)'
        - _Description:_ `V' is a value of an attribute of a form.



 - REGTYPE: value_dict/1:
     *Usage:* `value_dict(Dict)'
        - _Description:_ `Dict' is a dictionary of values. It is a
          list of pairs _atom_=_constant_.



 - REGTYPE: url_term/1:
     A term specifying an Internet Uniform Resource Locator.
     Currently only HTTP URLs are supported. Example:
     `http('www.clip.dia.fi.upm.es',80,"/Software/Ciao/")'. Defined as
          url_term(http(Host,Port,Document)) :-
                  atm(Host),
                  int(Port),
                  string(Document).

     *Usage:* `url_term(URL)'
        - _Description:_ `URL' specifies a URL.



 - REGTYPE: http_request_param/1:
     A parameter of an HTTP request:
        * *head:* Specify that the document content is not wanted.

        * *timeout(*_T_*):* _T_ specifies the time in seconds to wait
          for the response. Default is 300 seconds.

        * *if_modified_since(*_Date_*):* Get document only if newer
          than _Date_. _Date_ has the format defined by `http_date/1'.

        * *user_agent(*_Agent_*):* Provides a user-agent field,
          _Agent_ is an atom. The string `"PiLLoW/1.1"' (or whatever
          version of PiLLoW is used) is appended.

        * *authorization(*_Scheme_,_Params_*):* To provide
          credentials. See RFC 1945 for details.

        * *_option_(*_Value_*):* Any unary term, being _Value_ an
          atom, can be used to provide another valid option (e.g.
          `from('user@machine')').

     *Usage:* `http_request_param(Request)'
        - _Description:_ `Request' is a parameter of an HTTP request.



 - REGTYPE: http_response_param/1:
     A parameter of an HTTP response:
        * *content(*_String_*):* _String_ is the document content
          (list of bytes). If the `head' parameter of the HTTP
          request is used, an empty list is get here.

        * *status(*_Type,Code,Reason_*):* _Type_ is an atom denoting
          the response type, _Code_ is the status code (an integer),
          and _Reason_ is a string holding the reason phrase.

        * *message_date(*_Date_*):* _Date_ is the date of the
          response, with format defined by `http_date/1'.

        * *location(*_Loc_*):* This parameter appears when the
          document has moved, _Loc_ is an atom holding the new
          location.

        * *http_server(*_Server_*):* _Server_ is the server
          responding, as a string.

        * *authenticate(*_Params_*):* Returned if document is
          protected, _Params_ is a list of chagenges. See RFC 1945
          for details.

        * *allow(*_Methods_*):* _Methods_ are the methods allowed by
          the server, as a list of atoms.

        * *content_encoding(*_Encoding_*):* _Encoding_ is an atom
          defining the encoding.

        * *content_length(*_Length_*):* _Length_ is the length of the
          document (an integer).

        * *content_type(*_Type,Subtype,Params_*):* Specifies the
          document content type, _Type_ and _Subtype_ are atoms,
          _Params_ a list of parameters (e.g.
          `content_type(text,html,[])').

        * *expires(*_Date_*):* _Date_ is the date after which the
          entity should be considered stale. Format defined by
          `http_date/1'.

        * *last_modified(*_Date_*):* _Date_ is the date at which the
          sender believes the resource was last modified. Format
          defined by `http_date/1'.

        * *pragma(*_String_*):* Miscellaneous data.

        * *_header_(*_String_*):* Any other functor _header_/1 is an
          extension header.

     *Usage:* `http_response_param(Response)'
        - _Description:_ `Response' is a parameter of an HTTP
          response.



 - REGTYPE: http_date/1:
     `http_date(Date)'

     `Date' is a term defined as
          http_date(date(WeekDay,Day,Month,Year,Time)) :-
                  weekday(WeekDay),
                  int(Day),
                  month(Month),
                  int(Year),
                  hms_time(Time).
     .

     *Usage:* `http_date(Date)'
        - _Description:_ `Date' is a term denoting a date.



 - REGTYPE: weekday/1:
     A regular type, defined as follows:
               weekday('Monday').
               weekday('Tuesday').
               weekday('Wednesday').
               weekday('Thursday').
               weekday('Friday').
               weekday('Saturday').
               weekday('Sunday').




 - REGTYPE: month/1:
     A regular type, defined as follows:
               month('January').
               month('February').
               month('March').
               month('April').
               month('May').
               month('June').
               month('July').
               month('August').
               month('September').
               month('October').
               month('November').
               month('December').




 - REGTYPE: hms_time/1:
     *Usage:* `hms_time(Time)'
        - _Description:_ `Time' is an atom of the form `hh:mm:ss'




File: ciao.info,  Node: Persistent predicate database,  Next: Using the persdb library,  Prev: PiLLoW types,  Up: Top

Persistent predicate database
*****************************

   *Author(s):* J.M. Gomez, D. Cabeza, and M. Hermenegildo,
`clip@dia.fi.upm.es', `http://www.clip.dia.fi.upm.es/', The CLIP
Group, Facultad de Informa'tica, Universidad Polite'cnica de Madrid.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 0.8#31 (1998/12/27, 19:17:20 MET)

* Menu:

* Introduction to persistent predicates::
* Persistent predicates::
* Using file-based persistent predicates::
* Implementation Issues::
* Using persistent predicates from the top level::
* Usage and interface (persdbrt)::
* Documentation on exports (persdbrt)::
* Documentation on multifiles (persdbrt)::
* Documentation on internals (persdbrt)::
* Known bugs and planned improvements (persdbrt)::


File: ciao.info,  Node: Introduction to persistent predicates,  Next: Persistent predicates,  Prev: Persistent predicate database,  Up: Persistent predicate database

Introduction to persistent predicates
=====================================

   This library implements a _generic persistent predicate database_.
The basic notion implemented by the library is that of a persistent
predicate. The persistent predicate concept provides a simple, yet
powerful generic persistent data access method [CHGT98,Par97]. A
persistent predicate is a special kind of dynamic, data predicate
that "resides" in some persistent medium (such as a set of files, a
database, etc.) that is typically external to the program using such
predicates. The main effect is that any changes made to to a
persistent predicate from a program "survive" across executions.
I.e., if the program is halted and restarted the predicate that the
new process sees is in precisely the same state as it was when the
old process was halted (provided no change was made in the meantime
to the storage by other processes or the user).

   Persistent predicates appear to a program as ordinary predicates,
and calls to these predicates can appear in clause bodies in the
usual way. However, the definitions of these predicates do not appear
in the program. Instead, the library maintains automatically the
definitions of predicates which have been declared as persistent in
the persistent storage.

   Updates to persistent predicates can be made by calling predicates
similar to `assertz_fact/1' and `retract_fact/1'. The library makes
sure that each update is a transactional update, in the sense that if
the update terminates, then the permanent storage has definitely been
modified. For example, if the program making the updates is halted
just after the update and then restarted, then the updated state of
the predicate will be seen. This provides security against possible
data loss due to, for example, a system crash. Also, due to the
atomicity of the transactions, persistent predicates allow concurrent
updates from several programs.


File: ciao.info,  Node: Persistent predicates,  Next: Using file-based persistent predicates,  Prev: Introduction to persistent predicates,  Up: Persistent predicate database

Persistent predicates, files, and relational databases
======================================================

   The concept of persistent predicates provided by this library
essentially implements a light-weight, simple, and at the same time
powerful form of relational database (a deductive database), and
which is standalone, in the sense that it does not require external
support, other than the file management capabilities provided by the
operating system. This is due to the fact that the persistent
predicates are in fact stored in one or more auxiliary files in a
given directory.

   This type of database is specially useful when building small to
medium-sized standalone applications in Prolog which require
persistent storage. In many cases it provides a much easier way of
implementing such storage than using files under direct program
control. For example, interactive applications can use persistent
predicates to represent their internal state in a way that is close
to the application. The persistence of such predicates then allows
automatically restoring the state to that at the end of a previous
session. Using persistent predicates amounts to simply declaring some
predicates as such and eliminates having to worry about opening
files, closing them, recovering from system crashes, etc.

   In other cases, however, it may be convenient to use a relational
database as persistent storage. This may be the case, for example,
when the data already resides in such a database (where it is perhaps
accessed also by other applications) or the volume of data is very
large.  `persdb_sql' [CCG98] is a companion library which implements
the same notion of persistent predicates used herein, but keeping the
storage in a relational database. This provides a very natural and
transparent way to access SQL database relations from a Prolog
program. In that library, facilities are also provided for reflecting
more complex _views_ of the database relations as predicates. Such
views can be constructed as conjunctions, disjunctions, projections,
etc. of database relations, and may include SQL-like aggregation
operations.

   A nice characteristic of the notion of persistent predicates used
in both of these libraries is that it abstracts away how the
predicate is actually stored. Thus, a program can use persistent
predicates stored in files or in external relational databases
interchangeably, and the type of storage used for a given predicate
can be changed without having to modify the program (except for
replacing the corresponding `persistent/2' declarations).

   An example application of the `persdb' and `persdb_sql' libraries
(and also the `pillow' library [CH97]), is `WebDB' [GCH98].  `WebDB'
is a generic, highly customizable _deductive database engine_ with an
_html interface_.  `WebDB' allows creating and maintaining
Prolog-based databases as well as relational databases (residing in
conventional relational database engines) using any standard WWW
browser.


File: ciao.info,  Node: Using file-based persistent predicates,  Next: Implementation Issues,  Prev: Persistent predicates,  Up: Persistent predicate database

Using file-based persistent predicates
======================================

   Persistent predicates can be declared statically, using
`persistent/2' declarations (which is the preferred method, when
possible), or dynamically via calls to `make_persistent/2'.
Currently, persistent predicates may only contain facts, i.e., they
are _dynamic_ predicates of type `data/1', and _should be declared as
such_.

   Predicates declared as persistent are linked to a directory, and
the persistent state of the predicate will be kept in several files
in that directory. The files in which the persistent predicates are
stored are in readable, plain ASCII format, and in Prolog syntax. One
advantage of this approach is that such files can also be created or
edited by hand, in a text editor, or even by other applications.

   An example definition of a persistent predicate implemented by
files follows:

     :- persistent(p/3,dbdir).
     
     :- multifile persistent_dir/2.
     :- data persistent_dir/2.
     
     persistent_dir(dbdir, '/home/clip/public_html/db').

   The first line declares the predicate `p/3' persistent. The
argument `dbdir' is a key used to index into a fact of the relation
`persistent_dir/2', which specifies the directory where the
corresponding files will be kept. The effect of the declaration,
together with the `persistent_dir/2' fact, is that, although the
predicate is handled in the same way as a normal data predicate, in
addition the system will create and maintain efficiently a persistent
version of `p/3' via files in the directory
`/home/clip/public_html/db'.

   The level of indirection provided by the `dbdir' argument makes it
easy to place the storage of several persistent predicates in a
common directory, by specifying the same key for all of them. It also
allows changing the directory for several such persistent predicates
by modifying only one fact in the program. Furthermore, the
`persistent_dir/2' predicate can even be dynamic and specified at
run-time.


File: ciao.info,  Node: Implementation Issues,  Next: Using persistent predicates from the top level,  Prev: Using file-based persistent predicates,  Up: Persistent predicate database

Implementation Issues
=====================

   We outline the current implementation approach. This
implementation attempts to provide at the same time efficiency and
security. To this end, up to three files are used for each predicate
(the persistence set): the data file, the operations file, and the
backup file. In the updated state the facts (tuples) that define the
predicate are stored in the data file and the operations file is
empty (the backup file, which contains a security copy of the data
file, may or may not exist).

   While a program using a persistent predicate is running, any
insertion (assert) or deletion (retract) operations on the predicate
are performed on both the program memory and on the persistence set.
However, in order to incurr only a small overhead in the execution,
rather than changing the data file directly, a record of each of the
insertion and deletion operations is _appended_ to the operations
file. The predicate is then in a transient state, in that the
contents of the data file do not reflect exactly the current state of
the corresponding predicate. However, the complete persistence set
does.

   When a program starts, when it is halted, or, periodically, when
it is idle for some time, all pending operations in the operations
file are performed on the data file. A backup of the data file is
created first to prevent data loss if the system crashes during this
operation. The order in which this updating of files is done ensures
that, if at any point the process dies, on restart data will be
completely recovered. This process of updating the persistence set
can also be triggered at any point in the execution of a program by
calling `update_files/2'.


File: ciao.info,  Node: Using persistent predicates from the top level,  Next: Usage and interface (persdbrt),  Prev: Implementation Issues,  Up: Persistent predicate database

Using persistent predicates from the top level
==============================================

   Special care must be taken when using persistent predicates from
the top level. This includes not only defining persistent predicates
on the fly from de top level (which is not really very useful in
practice) but also the more frequent case of loading into the top
level modules or user files which use persistent predicates. As
mentioned before, the persistence set is updated automatically each
time a program using the corresponding persistent predicates is run
or halted. However, since the top level itself is also a standard
program, persistent predicates would only be updated whenever the top
level is started, when they are typically still not loaded.

   If a program launched from a top level needs to update the
persistence sets of any persistent predicate it must be done by
calling the `update_files/2' method explicitly.


File: ciao.info,  Node: Usage and interface (persdbrt),  Next: Documentation on exports (persdbrt),  Prev: Using persistent predicates from the top level,  Up: Persistent predicate database

Usage and interface (`persdbrt')
================================

   * *Library usage:*

     Typically, this library is used including the 'persdb' package
     into the syntax list of the module, or using the `syntax/1'
     declaration:
    In a module:
                       :- module(bar, [main/1], [persdb]).
          or
                       :- module(bar, [main/1]).
                       :- include(library(persdb)).

    In a _user_ file:
                       :- syntax([persdb]).
          or
                       :- include(library(persdb)).
          This syntax file loads the run-time and compile-time
     versions of the library (`persdbtr.pl' and `persdbrt.pl') and
     includes some needed declarations.

   * *Exports:*
        - _Predicates:_

          `passertz_fact/1', `pretract_fact/1', `pcurrent_fact/1',
          `init_persdb/0', `initialize_db/0', `make_persistent/2',
          `update_files/2'.

        - _Multifiles:_

          `persistent_dir/2', `$is_persistent/2'.


   * *Other modules used:*
        - _System library modules:_

          `lists', `streams', `read', `system',
          `file_locks/file_locks'.




File: ciao.info,  Node: Documentation on exports (persdbrt),  Next: Documentation on multifiles (persdbrt),  Prev: Usage and interface (persdbrt),  Up: Persistent predicate database

Documentation on exports (`persdbrt')
=====================================

 - PREDICATE: passertz_fact/1:
     _Meta-predicate_ with arguments: `passertz_fact(fact)'.

     *Usage:* `passertz_fact(Fact)'
        - _Description:_ Persistent version of `assertz_fact/1': the
          current instance of `Fact' is interpreted as a fact (i.e.,
          a relation tuple) and is added at the end of the definition
          of the corresponding predicate. The predicate concerned
          must be declared `persistent'. Any uninstantiated variables
          in the `Fact' will be replaced by new, private variables.

        - _The following properties should hold at call time:_

          `Fact' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')



 - PREDICATE: pretract_fact/1:
     _Meta-predicate_ with arguments: `pretract_fact(fact)'.

     *Usage:* `pretract_fact(Fact)'
        - _Description:_ Persistent version of `retract_fact/1':
          deletes on backtracking all the facts which unify with
          `Fact'. The predicate concerned must be declared
          `persistent'.

        - _The following properties should hold at call time:_

          `Fact' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')



 - PREDICATE: pcurrent_fact/1:
     _Meta-predicate_ with arguments: `pcurrent_fact(fact)'.

     *Usage:* `pcurrent_fact(Fact)'
        - _Description:_ Persistent version of `current_fact/1': the
          fact `Fact' exists in the current database. The predicate
          concerned must be declared `persistent'. Provides on
          backtracking all the facts (tuples) which unify with `Fact'.

        - _The following properties should hold at call time:_

          `Fact' is a term which represents a goal, i.e., an atom or
          a structure.   (`basic_props:callable/1')



 - PREDICATE: init_persdb/0:
     *Usage:*
        - _Description:_ Executes `initialize_db/0' if no
          initialization has been done yet. Needed when accesing
          persistent predicates before doing any of `passertz_fact/1',
          `pretract_fact/1', or `pcurrent_fact/1'.



 - PREDICATE: initialize_db/0:
     *Usage:*
        - _Description:_ Initializes the whole database, updating the
          state of the declared persistent predicates.



 - PREDICATE: make_persistent/2:
     _Meta-predicate_ with arguments: `make_persistent(spec,?)'.

     *Usage:* `make_persistent(PredDesc,Keyword)'
        - _Description:_ Dynamic version of the `persistent'
          declaration.

        - _The following properties should hold at call time:_

          `PredDesc' is a Name/Arity structure denoting a predicate
          name:
               predname(P/A) :-
                       atm(P),
                       int(A).

          (`basic_props:predname/1')

          `Keyword' is an atom corresponding to a directory
          identifier.   (`persdbrt:keyword/1')



 - PREDICATE: update_files/2:
     *Usage:* `update_files(PredDesc,Arity)'
        - _Description:_ Updates the state of the given persistent
          predicate and its corresponding persistence set.

        - _The following properties should hold upon exit:_

          `PredDesc' is a Name/Arity structure denoting a predicate
          name:
               predname(P/A) :-
                       atm(P),
                       int(A).

          (`basic_props:predname/1')

          `Arity' is an integer.   (`basic_props:int/1')




File: ciao.info,  Node: Documentation on multifiles (persdbrt),  Next: Documentation on internals (persdbrt),  Prev: Documentation on exports (persdbrt),  Up: Persistent predicate database

Documentation on multifiles (`persdbrt')
========================================

 - PREDICATE: persistent_dir/2:
     The predicate is _multifile_.

     The predicate is of type _data_.

     *Usage:* `persistent_dir(Keyword,Location_Path)'
        - _Description:_ Relates identifiers of locations (the
          `Keyword's) with descriptions of such locations
          (`Location_Path's). `Location_Path' is *a directory* and it
          means that the definition for the persistent predicates
          associated with `Keyword' is kept in files in that
          directory. These files, in the updated state, contain the
          actual definition of the predicate in Prolog syntax (but
          with module names resolved).

        - _The following properties should hold at call time:_

          `Keyword' is an atom corresponding to a directory
          identifier.   (`persdbrt:keyword/1')

          `Location_Path' is an atom which is the name of a directory.
          (`persdbrt:directoryname/1')



 - PREDICATE: $is_persistent/2:
     No further documentation available for this predicate.

     The predicate is _multifile_.





File: ciao.info,  Node: Documentation on internals (persdbrt),  Next: Known bugs and planned improvements (persdbrt),  Prev: Documentation on multifiles (persdbrt),  Up: Persistent predicate database

Documentation on internals (`persdbrt')
=======================================

 - REGTYPE: keyword/1:
     An atom which identifies a fact of the `persistent_dir/2'
     relation. This fact relates this atom to a directory in which
     the persistent storage for one or more persistent predicates is
     kept.

     *Usage:* `keyword(X)'
        - _Description:_ `X' is an atom corresponding to a directory
          identifier.



 - REGTYPE: directoryname/1:
     *Usage:* `directoryname(X)'
        - _Description:_ `X' is an atom which is the name of a
          directory.




File: ciao.info,  Node: Known bugs and planned improvements (persdbrt),  Prev: Documentation on internals (persdbrt),  Up: Persistent predicate database

Known bugs and planned improvements (`persdbrt')
================================================

   * Shouldn't the declarations for persistent_dir/2 be inside
     persdb.pl? (would save a lot of writing).

   * make_persistent/2 should really be persistent/2 (since it
     doesn't really make a predicate persistent but rather declares
     it as such, i.e., we do not use make_data/1, we use data/1) ?

   * having to use pcurrent_fact is not so nice

   * passert, pretract, etc. should really be overloaded versions of
     assert, retract etc., i.e., it should be possible to use
     assertz_fact directly

   * we need also asserta_fact, right? Otherwise isn't it difficult
     to do many things?


File: ciao.info,  Node: Using the persdb library,  Next: SQL persistent database interface,  Prev: Persistent predicate database,  Up: Top

Using the persdb library
************************

   Through the following examples we will try to illustrate the two
mains ways of declaring and using persistent predicates: statically
(the preferred method) and dynamically (necessary when the new
persistent predicates have to be defined at run-time). The final
example is a small application implementing a simple persistent queue.

* Menu:

* An example of persistent predicates (static version)::
* An example of persistent predicates (dynamic version)::
* A simple application / a persistent queue::


File: ciao.info,  Node: An example of persistent predicates (static version),  Next: An example of persistent predicates (dynamic version),  Prev: Using the persdb library,  Up: Using the persdb library

An example of persistent predicates (static version)
====================================================

     :- include(library(persdb)).
     
     %% Required declarations for persistent_dir/2.
     :- multifile persistent_dir/2.
     :- data persistent_dir/2.
     
     %% Declare the directory associated to the key "db" where the
     %% persistence sets of the persistent predicates are stored:
     persistent_dir(db,'./').
     
     %% Declare a persistent predicate:
     :- persistent(bar/1, db).
     
     %% Read a term, storing it in a new fact of the persistent predicate
     %% and list all the current facts of that predicate
     main:-
          read(X),
          passertz_fact(bar(X)),
          findall(Y,bar(Y),L),
          write(L).


File: ciao.info,  Node: An example of persistent predicates (dynamic version),  Next: A simple application / a persistent queue,  Prev: An example of persistent predicates (static version),  Up: Using the persdb library

An example of persistent predicates (dynamic version)
=====================================================

     :- include(library(persdb)).
     
     %% Required declarations for persistent_dir/2.
     :- multifile persistent_dir/2.
     :- data persistent_dir/2.
     
     main([X]):-
     %%   Declare the directory associated to the key "db"
          asserta_fact(persistent_dir(db,'./')),
     %%   Declare the predicate bar/1 as dynamic (and data) at run-time
          data(bar/1),
     %%   Declare the predicate bar/1 as persistent at run-time
          make_persistent(bar/1, db),
          passertz_fact(bar(X)),
          findall(Y, bar(Y), L),
          write(L).


File: ciao.info,  Node: A simple application / a persistent queue,  Prev: An example of persistent predicates (dynamic version),  Up: Using the persdb library

A simple application / a persistent queue
=========================================

     :- module(queue, [main/0],[]).
     
     :- use_module(library(read)).
     :- use_module(library(write)).
     :- use_module(library(aggregates)).
     
     :- include(library(persdb)).
     
     :- multifile persistent_dir/2.
     :- data persistent_dir/2.
     
     :- persistent(queue/1, queue_dir).
     
     persistent_dir(queue_dir,'./pers').
     
     main:-
          write('Action ( in(Term). | out. | list. | halt. ): '),
          read(A),
          (  handle_action(A)
          -> true
          ;  write('Unknown command.'), nl ),
          main.
     
     handle_action(halt) :-
          halt.
     handle_action(in(Term)) :-
          passertz_fact(queue(Term)),
          main.
     handle_action(out) :-
          (  pretract_fact(queue(Term))
          -> write('Out '), write(Term)
          ;  write('FIFO empty.') ),
          nl,
          main.
     handle_action(list) :-
          findall(Term,pcurrent_fact(queue(Term)),Terms),
          write('Contents: '), write(Terms), nl,
          main.


File: ciao.info,  Node: SQL persistent database interface,  Next: Prolog to SQL translator,  Prev: Using the persdb library,  Up: Top

SQL persistent database interface
*********************************

   *Author(s):* I. Caballero, D. Cabeza, J.M. Go'mez, and M.
Hermenegildo, `clip@dia.fi.upm.es', `http://www.clip.dia.fi.upm.es/',
The CLIP Group, Facultad de Informa'tica, Universidad Polite'cnica de
Madrid.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#105 (2000/4/3, 14:21:58 CEST)

   The purpose of this library is to implement an instance of the
generic concept of persistent predicates, where external relational
databases are used for storage (see the documentation of the `persdb'
library and [CHGT98,Par97] for details). To this end, this library
exports SQL persistent versions of the `assertz_fact/1',
`retract_fact/1' and `retractall_fact/1' builtin predicates.
Persistent predicates also allow concurrent updates from several
programs, since each update is atomic.

   The notion of persistence provides a very natural and transparent
way to access database relations from a Prolog program. Stub
definitions are provided for such predicates which access the
database when the predicate is called (using the `db_client'
library). A Prolog to SQL translator is used to generate the required
SQL code dynamically (see library `pl2sql').

   This library also provides facilities for reflecting more complex
views of the database relations as Prolog predicates. Such views can
be constructed as conjunctions, disjunctions, projections, etc. of
database relations. Also, SQL-like aggregation operations are
supported.

* Menu:

* Implementation of the Database Interface::
* Example(s)::
* Usage and interface (persdbrtsql)::
* Documentation on exports (persdbrtsql)::
* Documentation on multifiles (persdbrtsql)::
* Documentation on internals (persdbrtsql)::
* Known bugs and planned improvements (persdbrtsql)::


File: ciao.info,  Node: Implementation of the Database Interface,  Next: Example(s),  Prev: SQL persistent database interface,  Up: SQL persistent database interface

Implementation of the Database Interface
========================================

   The architecture of the low-level implementation of the database
interface was defined with two goals in mind:

   * to simplify the communication between the Prolog system and the
     relational database engines as much as possible, and

   * to give as much flexibility as possible to the overall system.
     This includes simultaneous access to several databases, allowing
     both the databases and clients to reside on the same physical
     machine or different machines, and allowing the clients to
     reside in Win95/NT or Unix machines.

   In order to allow the flexibility mentioned above, a client-sever
architecture was chosen. The following figure depicts the overall
architecture of the system:


[Image file: autofigarchitecture.eps]

   At the server side, a "database mediator server" connects on one
side to the databases using the ODBC interface (this interface is
available for the databases of the RadioWeb project, as well as for
the majority of the databases running in the Win95/NT operating
systems) and on the other it is connected to the network by TCP/IP
using a fixed socket number / service (currently fixed to socket
number 2020).

   The mediator server must run on the Windows (NT/95) operating
system, on the machine where the databases are also running. The
(Prolog) clients which connect to it can be run locally at the server
machine. In addition, remote clients running on different machines
can also connect to the mediator server by connecting to its socket
number (service). Such clients can run on either Unix or Windows
systems.

   After the connection is established a client can send commands to
the mediator server which will pass them to the corresponding
database server, and then the data will traverse in the opposite
direction. These messages include logging on and off from the
database, sending SQL queries, and receiving the responses.

   The low level implementation of the current library is
accomplished by providing several abstraction levels over the socket
interface library of the Prolog engine. These layers of abstraction
implement the persistent predicate view, build the appropriate
commands for the database using a translator of Prolog goals to SQL
commands, issue such commands using the mediator send/receive
procedures, parse the responses, and present such responses to the
Prolog engine via backtracking.


File: ciao.info,  Node: Example(s),  Next: Usage and interface (persdbrtsql),  Prev: Implementation of the Database Interface,  Up: SQL persistent database interface

Example(s)
==========

     :- include(library('persdb_sql/persdb_sql')).
     :- use_module(library(format)).
     
     %% ------------------------------------------------- %%
     %% First sample database : 'SA 6.0 Sample' %%
     %% ------------------------------------------------- %%
     
     %% Declare product/4 a persistent predicate, storage in 'radiowebdb':
     :- sql_persistent(product( int,    int, string, string ),
                   product( quantity,   id,      name,   size   ),
                   sampledb).
     sql_persistent_location(sampledb, %% The 'sampledb' descriptor:
              db('ASA 6.0 Sample','dba', 'sql','r2d5.dia.fi.upm.es':2020)).
     
     main0 :-
     %% Prints the contents of the relation 'product/4' by backtracking over it:
              format("Printing table:\n",[]),
              product(Quantity, Id, Name, Size),
              format("Tuple: ~w \t ~w \t ~w \t ~w \n",
                     [Quantity, Id, Name, Size]),
              fail.
     main0 :-
              format("Done.\n",[]).
     
     %% Generalizing table printing:
     %% Prints the contents of Pred by backtracking over it
     print_predicate(Pred):-
             format("Printing relation:\n",[]),
             Pred, %% predicate call
             Pred=..[_|Args],
             format("\t Tuple: ~w \n",[Args]),
             fail.
     print_predicate(_Pred):-
             format("Done.~n",[]).
     
     main1 :- %% similar to main0:
     %% Prints the contents of the relation 'product/4' by backtracking over it:
             print_predicate(product(_Quantity,_Id,_Name,_Size)).
     
     main2 :- %% Issues a complex query inside a db_findall:
              dbfindall(sampledb,
                        foo(Quantity, Id, Name, Size, Bar),
                        ( product(Quantity, Id, Name, Size),
                          I^N^S^(Bar is avg(Q,product(Q, I, N, S)))
                        ),
                        Results),
              format("Results = ~w~n",[Results]).
     main21 :- %% Using db_call
              dbcall(sampledb,
                  (product(Quantity, Id, Name, Size),
                   product(Quantity, Id1, _Name1, _Size1),Id1>Id)),
     %%       product(Quantity, Id, Name, Size),
     %%          product(Quantity, Id1, Name1, Size1),
     %%          Id1>Id,
              format("Tuple: ~w \t ~w \t ~w \t ~w \n",
                     [Quantity, Id, Name, Size]).
     
     main22 :-  % get the set of tables from a database
             sql_get_tables(sampledb,TablesList),
             display(TablesList).
     
     main23 :- % get table attributes and its types
             sql_table_types(sampledb, 'Customer', AttList),
             display(AttList).
     
     %% ------------------------------------------------- %%
     %% Second sample database : 'Literature'             %%
     %% ------------------------------------------------- %%
     
     :- sql_persistent(authors(string,string,int),
                    authors(firstName,lastName,id), %% 'id' is the primary key
                    literature_db).
     sql_persistent_location(literature_db,
             db('Literature','dba','sql','r2d5.dia.fi.upm.es':2020)).
     
     main3:- %% Prints the contents of authors
              print_predicate(authors(_FirstName,_LastName,_Id)) .
     
     main4:- %% assert a persistent fact
              dbassertz_fact(authors('Pedro','Calderon de la Barca',17)).
     
     main6:- %% retract a persistent fact
              dbretract_fact(authors('Pedro','Calderon de la Barca',17)).
     
     
     main9:- %% checking if a persistent fact is a current fact
             dbcurrent_fact(authors(_X,_Y,_Z)).


File: ciao.info,  Node: Usage and interface (persdbrtsql),  Next: Documentation on exports (persdbrtsql),  Prev: Example(s),  Up: SQL persistent database interface

Usage and interface (`persdbrtsql')
===================================

   * *Library usage:*

     Typically, this library is used including the 'persdb_sql'
     package into the package list of the module, or using the
     `use_package/1' declaration:
    In a module:
               	:- module(bar, [main/1], [persdb_sql]).
          or
                       :- module(bar, [main/1]).
                       :- include(library(persdb_sql)).

    In a _user_ file:
               	:- use_package([persdb_sql]).
          or
                       :- include(library(persdb_sql)).
          This loads the run-time and compile-time versions of the
     library (`persdbtr_sql.pl' and `persdbrt_sql.pl') and includes
     some needed declarations.

   * *Exports:*
        - _Predicates:_

          `init_sql_persdb/0', `dbassertz_fact/1', `dbretract_fact/1',
          `dbcurrent_fact/1', `dbretractall_fact/1',
          `make_sql_persistent/3', `dbfindall/4', `dbcall/2',
          `sql_query/3', `sql_get_tables/2', `sql_table_types/3'.

        - _Multifiles:_

          `sql_persistent_location/2'.


   * *Other modules used:*
        - _System library modules:_

          `persdb_sql/db_client', `persdb_sql/pl2sql',
          `persdb_sql/sqltypes', `dynamic', `terms', `metaterms',
          `messages', `lists', `aggregates',
          `persdb_sql/insert_compiler/pl2sqlinsert'.




File: ciao.info,  Node: Documentation on exports (persdbrtsql),  Next: Documentation on multifiles (persdbrtsql),  Prev: Usage and interface (persdbrtsql),  Up: SQL persistent database interface

Documentation on exports (`persdbrtsql')
========================================

 - PREDICATE: init_sql_persdb/0:
     *Usage:*
        - _Description:_ Internal predicate, used to transform
          predicates statically declared as persistent (see
          `sql_persistent/3') into real persistent predicates.



 - PREDICATE: sql_persistent/3:
     No further documentation available for this predicate.




 - PREDICATE: dbassertz_fact/1:
     *Usage:* `dbassertz_fact(+Fact)'
        - _Description:_ Persistent extension of `assertz_fact/1':
          the current instance of `Fact' is interpreted as a fact
          (i.e., a relation tuple) and is added to the end of the
          definition of the corresponding predicate. If any integrity
          constraint violation is done (database stored predicates),
          an error will be displayed. The predicate concerned must be
          statically ( `sql_persistent/3') or dinamically (
          `make_sql_persistent/3') declared. Any uninstantiated
          variables in the `Fact' will be replaced by new, private
          variables. *Note:* _assertion of facts with uninstantiated
          variables not implemented at this time._

        - _Call and exit should be _compatible_ with:_

          `+Fact' is a fact (a term whose main functor is not
          `':-'/2').   (`persdbrtsql:fact/1')



 - PREDICATE: dbretract_fact/1:
     *Usage:* `dbretract_fact(+Fact)'
        - _Description:_ Persistent extension of `retract_fact/1':
          deletes on backtracking all the facts which unify with
          `Fact'. The predicate concerned must be statically (
          `sql_persistent/3') or dinamically (
          `make_sql_persistent/3') declared.

        - _Call and exit should be _compatible_ with:_

          `+Fact' is a fact (a term whose main functor is not
          `':-'/2').   (`persdbrtsql:fact/1')



 - PREDICATE: dbcurrent_fact/1:
     *Usage:* `dbcurrent_fact(+Fact)'
        - _Description:_ Persistent extension of `current_fact/1':
          the fact `Fact' exists in the current database. The
          predicate concerned must be declared `sql_persistent/3'.
          Provides on backtracking all the facts (tuples) which unify
          with `Fact'.

        - _Call and exit should be _compatible_ with:_

          `+Fact' is a fact (a term whose main functor is not
          `':-'/2').   (`persdbrtsql:fact/1')



 - PREDICATE: dbretractall_fact/1:
     *Usage:* `dbretractall_fact(+Fact)'
        - _Description:_ Persistent extension of `retractall_fact/1':
          when called deletes all the facts which unify with `Fact'.
          The predicate concerned must be statically (
          `sql_persistent/3') or dinamically (
          `make_sql_persistent/3') declared.

        - _Call and exit should be _compatible_ with:_

          `+Fact' is a fact (a term whose main functor is not
          `':-'/2').   (`persdbrtsql:fact/1')



 - PREDICATE: make_sql_persistent/3:
     _Meta-predicate_ with arguments:
     `make_sql_persistent(addmodule,?,?)'.

     *Usage:*
     `make_sql_persistent(PrologPredTypes,TableAttributes,Keyword)'
        - _Description:_ Dynamic version of the `sql_persistent/3'
          declaration.

        - _The following properties should hold upon exit:_

          `PrologPredTypes' is a structure describing a Prolog
          predicate name with its types.
          (`persdbrtsql:prologPredTypes/1')

          `TableAttributes' is a structure describing a table name
          and some attributes.   (`persdbrtsql:tableAttributes/1')

          `Keyword' is the name of a persistent storage location.
          (`persdbrtsql:persLocId/1')



 - PREDICATE: dbfindall/4:
     *Usage:* `dbfindall(+DBId,+Pattern,+ComplexGoal,-Results)'
        - _Description:_ Similar to `findall/3', but `Goal' is
          executed in database `DBId'. Certain restrictions and
          extensions apply to both `Pattern' and `ComplexGoal'
          stemming from the Prolog to SQL translation involved (see
          the corresponding type definitions for details).

        - _Call and exit should be _compatible_ with:_

          `+DBId' a unique identifier of a database session
          connection.   (`db_client:dbconnection/1')

          `+Pattern' is a database projection term.
          (`pl2sql:projterm/1')

          `+ComplexGoal' is a database query goal.
          (`pl2sql:querybody/1')

          `-Results' is a list.   (`basic_props:list/1')



 - PREDICATE: dbcall/2:
     *Usage:* `dbcall(+DBId,+ComplexGoal)'
        - _Description:_ Internal predicate, used by the transformed
          versions of the persistent predicates. Not meant to be
          called directly by users. It is exported by the library so
          that it can be used by the transformed versions of the
          persistent predicates in the modules in which they reside.
          Sends `ComplexGoal' to database `DBId' for evaluation.
          `ComplexGoal' must be a call to a persistent predicate
          which resides in database `DBId'.

        - _Call and exit should be _compatible_ with:_

          `+DBId' a unique identifier of a database session
          connection.   (`db_client:dbconnection/1')

          `+ComplexGoal' is a database query goal.
          (`pl2sql:querybody/1')



 - PREDICATE: sql_query/3:
     *Usage:* `sql_query(+DBId,+SQLString,AnswerTableTerm)'
        - _Description:_ `ResultTerm' is the response from database
          `DBId' to the SQL query in `SQLString' to database `DBId'.
          `AnswerTableTerm' can express a set of tuples, an error
          answer or a 'ok' response (see `answertableterm/1' for
          details). At the moment, `sql_query/3' log in and out for
          each query. This should be changed to log in only the first
          time and log out on exit and/or via a timer in the standard
          way.

        - _Call and exit should be _compatible_ with:_

          `+DBId' a unique identifier of a database session
          connection.   (`db_client:dbconnection/1')

          `+SQLString' is a string containing SQL code.
          (`pl2sql:sqlstring/1')

          `AnswerTableTerm' is a response from the ODBC database
          interface.   (`db_client:answertableterm/1')



 - PREDICATE: sql_get_tables/2:
     *Usage 1:* `sql_get_tables(+Location,-Tables)'
        - _Description:_ `Tables' contains the tables available in
          `Location'.

        - _Call and exit should be _compatible_ with:_

          `persdbrtsql:persLocation(+Location)'
          (`persdbrtsql:persLocation/1')

          `-Tables' is a list of `atm's.   (`basic_props:list/2')

     *Usage 2:* `sql_get_tables(+DbConnection,-Tables)'
        - _Description:_ `Tables' contains the tables available in
          `DbConnection'.

        - _Call and exit should be _compatible_ with:_

          `+DbConnection' a unique identifier of a database session
          connection.   (`db_client:dbconnection/1')

          `-Tables' is a list of `atm's.   (`basic_props:list/2')



 - PREDICATE: sql_table_types/3:
     *Usage 1:* `sql_table_types(+Location,+Table,-AttrTypes)'
        - _Description:_ `AttrTypes' are the attributes and types of
          `Table' in `Location'.

        - _Call and exit should be _compatible_ with:_

          `persdbrtsql:persLocation(+Location)'
          (`persdbrtsql:persLocation/1')

          `+Table' is an atom.   (`basic_props:atm/1')

          `-AttrTypes' is a list.   (`basic_props:list/1')

     *Usage 2:* `sql_table_types(+DbConnection,+Table,-AttrTypes)'
        - _Description:_ `AttrTypes' are the attributes and types of
          `Table' in `DbConnection'.

        - _Call and exit should be _compatible_ with:_

          `+DbConnection' a unique identifier of a database session
          connection.   (`db_client:dbconnection/1')

          `+Table' is an atom.   (`basic_props:atm/1')

          `-AttrTypes' is a list.   (`basic_props:list/1')



 - REGTYPE: socketname/1:
     *Usage:* `socketname(IPP)'
        - _Description:_ `IPP' is a structure describing a complete
          TCP/IP port address.



 - REGTYPE: dbname/1:
     *Usage:* `dbname(DBId)'
        - _Description:_ `DBId' is the identifier of an ODBC database.



 - REGTYPE: user/1:
     *Usage:* `user(User)'
        - _Description:_ `User' is a user name in the ODBC database.



 - REGTYPE: passwd/1:
     *Usage:* `passwd(Passwd)'
        - _Description:_ `Passwd' is the password for the user name
          in the ODBC database.



 - REGTYPE: projterm/1:
     *Usage:* `projterm(DBProjTerm)'
        - _Description:_ `DBProjTerm' is a database projection term.



 - REGTYPE: querybody/1:
     *Usage:* `querybody(DBGoal)'
        - _Description:_ `DBGoal' is a database query goal.



 - (: UNDOC_REEXPORT) sqltype/1:
     Imported from `sqltypes' (see the corresponding documentation
     for details).





File: ciao.info,  Node: Documentation on multifiles (persdbrtsql),  Next: Documentation on internals (persdbrtsql),  Prev: Documentation on exports (persdbrtsql),  Up: SQL persistent database interface

Documentation on multifiles (`persdbrtsql')
===========================================

 - PREDICATE: sql_persistent_location/2:
     Relates names of locations (the `Keyword's) with descriptions of
     such locations (`Location's).

     The predicate is _multifile_.

     The predicate is of type _data_.

     *Usage 1:* `sql_persistent_location(Keyword,Location)'
        - _Description:_ `Keyword' is an identifier for the
          persistent data location `Location'.

        - _Call and exit should be _compatible_ with:_

          `Keyword' is the name of a persistent storage location.
          (`persdbrtsql:persLocId/1')

          `persdbrtsql:persLocation(Location)'
          (`persdbrtsql:persLocation/1')

     *Usage 2:* `sql_persistent_location(Keyword,DBLocation)'
        - _Description:_ In this usage, `DBLocation' is a _relational
          database_, in which case the predicate is stored as tuples
          in the database.

        - _The following properties should hold upon exit:_

          `Keyword' is the name of a persistent storage location.
          (`persdbrtsql:persLocId/1')

          `DBLocation' is a structure describing a database.
          (`persdbrtsql:database_desc/1')




File: ciao.info,  Node: Documentation on internals (persdbrtsql),  Next: Known bugs and planned improvements (persdbrtsql),  Prev: Documentation on multifiles (persdbrtsql),  Up: SQL persistent database interface

Documentation on internals (`persdbrtsql')
==========================================

 - PREDICATE: db_query/4:
     *Usage:* `db_query(+DBId,+ProjTerm,+Goal,ResultTerm)'
        - _Description:_ `ResultTerm' contains all the tuples which
          are the response from database `DBId' to the Prolog query
          `Goal', projected onto `ProjTerm'. Uses `pl2sqlstring/3'
          for the Prolog to SQL translation and `sql_query/3' for
          posing the actual query.

        - _Call and exit should be _compatible_ with:_

          `+DBId' a unique identifier of a database session
          connection.   (`db_client:dbconnection/1')

          `+ProjTerm' is a database projection term.
          (`pl2sql:projterm/1')

          `+Goal' is a database query goal.   (`pl2sql:querybody/1')

          `ResultTerm' is a tuple of values from the ODBC database
          interface.   (`db_client:tuple/1')



 - PREDICATE: db_query_one_tuple/4:
     *Usage:* `db_query_one_tuple(+DBId,+ProjTerm,+Goal,ResultTerm)'
        - _Description:_ `ResultTerm' is one of the tuples which are
          the response from database `DBId' to the Prolog query
          `Goal', projected onto `ProjTerm'. Uses `pl2sqlstring/3'
          for the Prolog to SQL translation and
          `sql_query_one_tuple/3' for posing the actual query. After
          last tuple has been reached, a null tuple is unified with
          ResultTerm, and the connection to the database finishes.

        - _Call and exit should be _compatible_ with:_

          `+DBId' a unique identifier of a database session
          connection.   (`db_client:dbconnection/1')

          `+ProjTerm' is a database projection term.
          (`pl2sql:projterm/1')

          `+Goal' is a database query goal.   (`pl2sql:querybody/1')

          `ResultTerm' is a predicate containing a tuple.
          (`db_client:answertupleterm/1')



 - PREDICATE: sql_query_one_tuple/3:
     *Usage:* `sql_query_one_tuple(+DBId,+SQLString,ResultTuple)'
        - _Description:_ `ResultTuple' contains an element from the
          set of tuples which represents the response in `DBId' to the
          SQL query `SQLString'. If the connection is kept, succesive
          calls return consecutive tuples, until the last tuple is
          reached. Then a null tuple is unified with `ResultTuple'
          and the connection is finished (calls to `db_logoff/1' and
          `odbc_disconnect/1').

        - _Call and exit should be _compatible_ with:_

          `+DBId' a unique identifier of a database session
          connection.   (`db_client:dbconnection/1')

          `+SQLString' is a string containing SQL code.
          (`pl2sql:sqlstring/1')

          `ResultTuple' is a tuple of values from the ODBC database
          interface.   (`db_client:tuple/1')



 - REGTYPE: dbconnection/1:
     *Usage:* `dbconnection(H)'
        - _Description:_ `H' a unique identifier of a database
          session connection.



 - REGTYPE: tuple/1:
     *Usage:* `tuple(T)'
        - _Description:_ `T' is a tuple of values from the ODBC
          database interface.




File: ciao.info,  Node: Known bugs and planned improvements (persdbrtsql),  Prev: Documentation on internals (persdbrtsql),  Up: SQL persistent database interface

Known bugs and planned improvements (`persdbrtsql')
===================================================

   * At least in the shell, reloading a file after changing the
     definition of a persistent predicate does not eliminate the old
     definition...

   * Functionality missing: some questions need to be debugged.

   * Warning: still using kludgey string2term and still using some
     non-uniquified temp files.

   * Needs to be unified with the file-based library.


File: ciao.info,  Node: Prolog to SQL translator,  Next: Low-level socket interface to SQL/ODBC databases,  Prev: SQL persistent database interface,  Up: Top

Prolog to SQL translator
************************

   *Author(s):* C. Draxler. Adapted by M. Hermenegildo and I.
Caballero.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 0.9#96 (1999/5/21, 19:53:48 MEST)

   This library performs translation of Prolog queries into SQL. The
code is an adaptation for Ciao of the Prolog to SQL compiler written
by Christoph Draxler, CIS Centre for Information and Speech
Processing, Ludwig-Maximilians-University Munich,
`draxler@cis.uni-muenchen.de', Version 1.1. Many thanks to Christoph
for allowing us to include this adaptation of his code with Ciao.

   The translator needs to know the correspondence between Prolog
predicates and the SQL tables in the database. To this end this
module exports two multifile predicates, `relation/3' and
`attribute/4'. See the description of these predicates for details on
how such correspondance is specified.

   The main entry points to the translator are `pl2sqlstring/3' and
`pl2sqlterm/3'. Details on the types of queries allowed can be found
in the description of these predicates.

   *Example:* the following program would print out a term
representing the SQL query corresponding to the given Prolog query:

     :- use_module(library('persdb_sql/pl2sql')).
     :- use_module(library(strings)).
     
     :- multifile [relation/3,attribute/4].
     :- data [relation/3,attribute/4].
     
     relation(product,3,'PRODUCT').
     attribute(1,'PRODUCT','ID',int).
     attribute(2,'PRODUCT','QUANTITY',int).
     attribute(3,'PRODUCT','NAME',string).
     
     main :-
          pl2sqlstring( f(L,K),
               ((product(L,N,a); product(L,N,b)),
                \+ product(2,3,b),
                L + 2 > avg(Y, Z^product(Z,Y,a)),
                K is N + max(X, product(X,2,b))
                ), T),
          write_string(T).
     
     %%     printqueries(T).

   *Note:* while the translator can be used directly in programs, it
is more convenient to use a higher-level abstraction: persistent
predicates (implemented in the `persdb' library). The notion of
persistent predicates provides a completely transparent interface
between Prolog and relational databases. When using this library, the
Prolog to SQL translation is called automatically as needed.

* Menu:

* Usage and interface (pl2sql)::
* Documentation on exports (pl2sql)::
* Documentation on multifiles (pl2sql)::
* Documentation on internals (pl2sql)::
* Known bugs and planned improvements (pl2sql)::


File: ciao.info,  Node: Usage and interface (pl2sql),  Next: Documentation on exports (pl2sql),  Prev: Prolog to SQL translator,  Up: Prolog to SQL translator

Usage and interface (`pl2sql')
==============================

   * *Library usage:*

     `:- use_module(library(pl2sql)).'

   * *Exports:*
        - _Predicates:_

          `pl2sqlstring/3', `pl2sqlterm/3', `printqueries/1',
          `sqlterm2string/2'.

        - _Regular Types:_

          `querybody/1', `projterm/1', `sqlstring/1'.

        - _Multifiles:_

          `relation/3', `attribute/4'.


   * *Other modules used:*
        - _System library modules:_

          `persdb_sql/sqltypes', `write', `read', `dec10_io',
          `system', `iso_misc', `lists', `aggregates', `messages'.




File: ciao.info,  Node: Documentation on exports (pl2sql),  Next: Documentation on multifiles (pl2sql),  Prev: Usage and interface (pl2sql),  Up: Prolog to SQL translator

Documentation on exports (`pl2sql')
===================================

 - PREDICATE: pl2sqlstring/3:
     *Usage:*
     `pl2sqlstring(+ProjectionTerm,+DatabaseGoal,-SQLQueryString)'
        - _Description:_ This is the top level predicate which
          translates complex Prolog goals into the corresponding SQL
          code.

          The query code is prepared in such a way that the result is
          projected onto the term `ProjectionTerm' (also in a similar
          way to the first argument of `setof/3')). See the predicate
          `translate_projection/3' for restrictions on this term.

          `SQLQueryString' contains the code of the SQL query, ready
          to be sent to an SQL server.

        - _Call and exit should be _compatible_ with:_

          `+ProjectionTerm' is a database projection term.
          (`pl2sql:projterm/1')

          `+DatabaseGoal' is a database query goal.
          (`pl2sql:querybody/1')

          `-SQLQueryString' is a string containing SQL code.
          (`pl2sql:sqlstring/1')



 - REGTYPE: querybody/1:
     `DBGoal' is a goal meant to be executed in the external
     database. It can be a complex term containing conjunctions,
     disjunctions, and negations, of:

        * Atomic goals, which must have been defined via `relation/3'
          and `attribute/4' and reside in the (same) database. Their
          arguments must be either ground or free variables. If they
          are ground, they must be bound to constants of the type
          declared for that argument. If an argument is a free
          variable, it may _share_ with (i.e., be the same variable
          as) other free variables in other goal arguments.

        * Database comparison goals, whose main functor must be a
          database comparison operator (see `pl2sql': `comparison/2')
          and whose arguments must be _database arithmetic
          expressions_.

        * Database calls to is/2. The left side of such a call may be
          either unbound, in which case it is bound to the result of
          evaluating the right side, or bound in which case an
          equality condition is tested. The right side must be a
          _database arithmetic expression_.


     The binding of variables follows Prolog rules:

        * variables are bound by positive base goals and on the left
          side of the `is/2' predicate.

        * Comparison operations, negated goals, and right sides of the
          `is/2' predicate do not return variable bindings and may
          even require all arguments to be bound for a safe
          evaluation.


     Database arithmetic expressions may contain:

        * Numeric constants (i.e., integers, reals, etc.).

        * Bound variables, i.e., variables which will be bound during
          execution through occurrence within a positive database
          goal, or by a preceding arithmetic function.

        * Database arithmetic functions, which are a subset of those
          typically accepted within `is/2' (see `pl2sql':
          `arithmetic_functor/2').

        * Database aggregation functions, each of which has two
          arguments: a variable indicating the argument over which
          the function is to be computed, and a goal argument which
          must contain in at least one argument position the variable
          (e.g. `avg(Seats,plane(Type,Seats))'). The goal argument
          may only be a conjunction of (positive or negative) base
          goals. See `pl2sql': `aggregate_functor/2' for the
          admissible aggregate functions.


     In addition, variables can be existentially quantified using
     `^/2' (in a similar way to how it is done in `setof/3').

     Note that it is assumed that the arithmetic operators in Prolog
     and SQL are the same, i.e., `+' is addition in Prolog and in
     SQL, etc.

     *Usage:* `querybody(DBGoal)'
        - _Description:_ `DBGoal' is a database query goal.



 - REGTYPE: projterm/1:
     `DBProjTerm' is a term onto which the result of a database query
     code is (in a similar way to the first argument of `setof/3')).

     A `ProjectionTerm' must meet the following restrictions:

        * The functor of `ProjectionTerm' may not be one of the
          built-in predicates, i.e. ',', ';', etc. are not allowed.

        * Only variables and constants are allowed as arguments,
          i.e., no structured terms may appear.


     *Usage:* `projterm(DBProjTerm)'
        - _Description:_ `DBProjTerm' is a database projection term.



 - REGTYPE: sqlstring/1:
          sqlstring(S) :-
                  string(S).

     *Usage:* `sqlstring(S)'
        - _Description:_ `S' is a string containing SQL code.



 - PREDICATE: pl2sqlterm/3:
     *Usage:*
     `pl2sqlterm(+ProjectionTerm,+DatabaseGoal,-SQLQueryTerm)'
        - _Description:_ Similar to `pl2sqlstring/3' except that
          `SQLQueryTerm' is a representation of the SQL query as a
          Prolog term.

        - _Call and exit should be _compatible_ with:_

          `+ProjectionTerm' is a database projection term.
          (`pl2sql:projterm/1')

          `+DatabaseGoal' is a database query goal.
          (`pl2sql:querybody/1')

          `-SQLQueryTerm' is a list of `sqlterm's.
          (`basic_props:list/2')



 - PREDICATE: printqueries/1:
     *Usage:* `printqueries(SQLTermList)'
        - _Description:_ Print to standard output in SQL the list of
          SQL term `SQLTermList'.

        - _Call and exit should be _compatible_ with:_

          `SQLTermList' is a list of `sqlterm's.
          (`basic_props:list/2')



 - PREDICATE: sqlterm2string/2:
     *Usage:* `sqlterm2string(+Queries,-QueryString)'
        - _Description:_ `QueryString' is a string representation of
          the list of queries in Prolog-term format in `Queries'.

        - _Call and exit should be _compatible_ with:_

          `+Queries' is a list of `sqlterm's.   (`basic_props:list/2')

          `-QueryString' is a string containing SQL code.
          (`pl2sql:sqlstring/1')



 - (: UNDOC_REEXPORT) sqltype/1:
     Imported from `sqltypes' (see the corresponding documentation
     for details).





File: ciao.info,  Node: Documentation on multifiles (pl2sql),  Next: Documentation on internals (pl2sql),  Prev: Documentation on exports (pl2sql),  Up: Prolog to SQL translator

Documentation on multifiles (`pl2sql')
======================================

 - PREDICATE: relation/3:
     The predicate is _multifile_.

     The predicate is of type _data_.

     *Usage:* `relation(PredName,Arity,TableName)'
        - _Description:_ This predicate, together with `attribute/4',
          defines the correspondence between Prolog predicates and the
          SQL tables in the database. These two relations constitute
          an extensible meta-database which maps Prolog predicate
          names to SQL table names, and Prolog predicate argument
          positions to SQL attributes.

          `PredName' is the chosen Prolog name for an SQL table.
          `Arity' is the number of arguments of the predicate.
          `TableName' is the name of the SQL table in the Database
          Management System.

        - _Call and exit should be _compatible_ with:_

          `PredName' is an atom.   (`basic_props:atm/1')

          `Arity' is an integer.   (`basic_props:int/1')

          `TableName' is an atom.   (`basic_props:atm/1')



 - PREDICATE: attribute/4:
     The predicate is _multifile_.

     The predicate is of type _data_.

     *Usage:* `attribute(ANumber,TblName,AName,AType)'
        - _Description:_ This predicate maps the argument positions
          of a Prolog predicate to the SQL attributes of its
          corresponding table. The types of the arguments need to be
          specified, and this information is used for consistency
          checking during the translation and for output formatting.
          A minimal type system is provided to this end. The
          allowable types are given by `sqltype/1'.

          `ANumber' is the argument number in the Prolog relation.
          `TblName' is the name of the SQL table in the Database
          Management System. `AName' is the name of the corresponding
          attribute in the table. `AType' is the (translator) data
          type of the attribute.

        - _Call and exit should be _compatible_ with:_

          `ANumber' is an integer.   (`basic_props:int/1')

          `TblName' is an atom.   (`basic_props:atm/1')

          `AName' is an atom.   (`basic_props:atm/1')

          `AType' is an SQL data type supported by the translator.
          (`sqltypes:sqltype/1')




File: ciao.info,  Node: Documentation on internals (pl2sql),  Next: Known bugs and planned improvements (pl2sql),  Prev: Documentation on multifiles (pl2sql),  Up: Prolog to SQL translator

Documentation on internals (`pl2sql')
=====================================

 - PREDICATE: query_generation/3:
     *Usage:*
     `query_generation(+ListOfConjunctions,+ProjectionTerm,-ListOfQueries)'
        - _Description:_ For each Conjunction in
          `ListOfConjunctions', translate the pair
          `(ProjectionTerm,Conjunction)' to an SQL query and connect
          each such query through a UNION-operator to result in the
          `ListOfQueries'.

          A Conjunction consists of positive or negative subgoals.
          Each subgoal is translated as follows:

             * the functor of a goal that is not a comparison
               operation is translated to a relation name with a
               range variable,

             * negated goals are translated to NOT EXISTS-subqueries
               with * projection,

             * comparison operations are translated to comparison
               operations in the WHERE-clause,

             * aggregate function terms are translated to aggregate
               function (sub)queries.


          The arguments of a goal are translated as follows:

             * `variables of a goal' are translated to qualified
               attributes,

             * variables occurring in several goals are translated to
               equality comparisons (equi join) in the WHERE-clause,

             * constant arguments are translated to equality
               comparisons in the WHERE-clause.


          Arithmetic functions are treated specially (
          `translate_arithmetic_function/5'). See also `querybody/1'
          for details on the syntax accepted and restrictions.




 - PREDICATE: translate_conjunction/5:
     *Usage:*
     `translate_conjunction(Conjunction,SQLFrom,SQLWhere,Dict,NewDict)'
        - _Description:_ Translates a conjunction of goals
          (represented as a list of goals preceeded by existentially
          quantified variables) to FROM-clauses and WHERE-clauses of
          an SQL query. A dictionary containing the associated SQL
          table and attribute names is built up as an accumulator
          pair (arguments `Dict' and `NewDict').



 - PREDICATE: translate_goal/5:
     *Usage:* `translate_goal(Goal,SQLFrom,SQLWhere,Dict,NewDict)'
        - _Description:_ Translates:

             * a positive database goal to the associated FROM- and
               WHERE clause of an SQL query,

             * a negated database goal to a negated existential
               subquery,

             * an arithmetic goal to an arithmetic expression or an
               aggregate function query,

             * a comparison goal to a comparison expression, and

             * a negated comparison goal to a comparison expression
               with the opposite comparison operator.





 - PREDICATE: translate_arithmetic_function/5:
     *Usage:*
     `translate_arithmetic_function(Result,Expression,SQLWhere,Dict,NewDict)'
        - _Description:_ Arithmetic functions (left side of is/2
          operator is bound to value of expression on right side) may
          be called with either:

             * `Result' unbound: then `Result' is bound to the value
               of the evaluation of `Expression',

             * `Result' bound: then an equality condition is returned
               between the value of `Result' and the value of the
               evaluation of `Expression'.

               Only the equality test shows up in the WHERE clause of
               an SQLquery.




 - PREDICATE: translate_comparison/5:
     *Usage:*
     `translate_comparison(LeftArg,RightArg,CompOp,Dict,SQLComparison)'
        - _Description:_ Translates the left and right arguments of a
          comparison term into the appropriate comparison operation
          in SQL. The result type of each argument expression is
          checked for type compatibility.



 - PREDICATE: aggregate_function/3:
     *Usage:*
     `aggregate_function(AggregateFunctionTerm,Dict,AggregateFunctionQuery)'
        - _Description:_ Supports the Prolog aggregate function terms
          listed in `aggregate_functor/2' within arithmetic
          expressions. Aggregate functions are translated to the
          corresponding SQL built-in aggregate functions.



 - PREDICATE: comparison/2:
     *Usage:* `comparison(PrologOperator,SQLOperator)'
        - _Description:_ Defines the mapping between Prolog operators
          and SQL operators:
               comparison(=,=).
               comparison(<,<).
               comparison(>,>).
               comparison(@<,<).
               comparison(@>,>).

        - _Call and exit should be _compatible_ with:_

          `PrologOperator' is an atom.   (`basic_props:atm/1')

          `SQLOperator' is an atom.   (`basic_props:atm/1')



 - PREDICATE: negated_comparison/2:
     *Usage:* `negated_comparison(PrologOperator,SQLOperator)'
        - _Description:_ Defines the mapping between Prolog operators
          and the complementary SQL operators:
               negated_comparison(=,<>).
               negated_comparison(\==,=).
               negated_comparison(>,=<).
               negated_comparison(=<,>).
               negated_comparison(<,>=).
               negated_comparison(>=,<).

        - _Call and exit should be _compatible_ with:_

          `PrologOperator' is an atom.   (`basic_props:atm/1')

          `SQLOperator' is an atom.   (`basic_props:atm/1')



 - PREDICATE: arithmetic_functor/2:
     *Usage:* `arithmetic_functor(PrologFunctor,SQLFunction)'
        - _Description:_ Defines the admissible arithmetic functions
          on the Prolog side and their correspondence on the SQL side:
               arithmetic_functor(+,+).
               arithmetic_functor(-,-).
               arithmetic_functor(*,*).
               arithmetic_functor(/,/).

        - _Call and exit should be _compatible_ with:_

          `PrologFunctor' is an atom.   (`basic_props:atm/1')

          `SQLFunction' is an atom.   (`basic_props:atm/1')



 - PREDICATE: aggregate_functor/2:
     *Usage:* `aggregate_functor(PrologFunctor,SQLFunction)'
        - _Description:_ Defines the admissible aggregate functions
          on the Prolog side and their correspondence on the SQL side:
               aggregate_functor(avg,'AVG').
               aggregate_functor(min,'MIN').
               aggregate_functor(max,'MAX').
               aggregate_functor(sum,'SUM').
               aggregate_functor(count,'COUNT').

        - _Call and exit should be _compatible_ with:_

          `PrologFunctor' is an atom.   (`basic_props:atm/1')

          `SQLFunction' is an atom.   (`basic_props:atm/1')




File: ciao.info,  Node: Known bugs and planned improvements (pl2sql),  Prev: Documentation on internals (pl2sql),  Up: Prolog to SQL translator

Known bugs and planned improvements (`pl2sql')
==============================================

   * Need to separate db predicate names by module.

   * Warning: using kludgy SQL term to string conversion because of
     bugs in sqlterm2string/2.


File: ciao.info,  Node: Low-level socket interface to SQL/ODBC databases,  Next: Low-level Prolog to Java interface,  Prev: Prolog to SQL translator,  Up: Top

Low-level socket interface to SQL/ODBC databases
************************************************

   *Author(s):* D. Cabeza, M. Carro, I. Caballero, and M.
Hermenegildo..

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.3#53 (1999/9/15, 23:37:55 MEST)

   This library provides a socket-based interface to SQL Databases,
using the database mediator server ODBC interface developed by C.
Taboch and I. Caballero. The interface currently works for databases
running in Win95/NT machines via ODBC. This low-level interface was
defined with two goals in mind:

   * To simplify the communication between the Prolog system and the
     relational database engines as much as possible.

   * To give as much flexibility to the overall system. This includes
     supporting simultaneous access to several databases, and also
     allowing both the databases and clients to reside on the same or
     different physical Win95/NT machines. The clients can reside
     also in Unix/Linux machines. It is also possible to access
     database selections in either tuple at a time or set at a time
     fashion, as needed.


   In order to allow the flexibility mentioned above, a socket
(TCP/IP) client-server architecture was chosen. The interface has two
main components:

   * At the server side, a _database mediator server_ connects on one
     side to the databases using the ODBC interface and on the other
     to a fixed port number (service), on which the mediator server
     listens for requests. The source code (and executables) for this
     server (slightly modified versions of C. Taboch original code)
     are in the same directory as this library. This executable must
     be running on the Windows (NT/95) machine where the databas(es)
     is(are) also running.(1)

   * At the client side a Prolog client can connect to the database
     by loading this library and calling the appropriate predicates.
     The Prolog client can run on either Windows or Unix/Linux
     systems, locally at the server machine or remotely in different
     machines. The mediator server port number (service) used is
     currently fixed to 2020. After the connection is established a
     client can send commands to the mediator server which will pass
     them to the corresponding database server, and then the response
     data will return in the opposite direction. These messages
     include login on and off from the database, sending SQL queries,
     and receiving the responses.


   *Example:*
     :- use_module(library('persdb_sql/db_client')).
     :- use_module(library(format)).
     :- use_module(library(lists)).
     
     :- multifile issue_debug_messages/1.
     :- data issue_debug_messages/1.
     issue_debug_messages('db_client').
     
     main0:- %% getting the tables existing in a database
             odbc_connect('r2d5.dia.fi.upm.es':2020,Stream),
             db_login(Stream,'DaletDemo',dalet_admin,dalet_admin,
     %%        db_login(Stream,'ASA 6.0 Sample',dba,sql,
                      dbconnection(Stream,DbHandle)),
     %%        db_get_tables(dbconnection(Stream,DbHandle),TablesList),
             db_table_types(dbconnection(Stream,DbHandle),'Titles',AttList),
             db_logoff(dbconnection(Stream,DbHandle)),
             odbc_disconnect(Stream),
             format("Results: ~w \n",AttList).
     
     
     main1 :- %% accessing the whole table in one go
             odbc_connect('r2d5.dia.fi.upm.es':2020,Stream),
             db_login(Stream,'ASA 6.0 Sample',dba,sql,Conn),
             db_eval_sql(Conn,"SELECT fname,lname,address from ""DBA"".customer
                        WHERE ((Id>100) AND (Id<105))",Term),
             write(Term), nl,nl,nl,nl,nl,nl,nl,nl,nl,nl,nl,nl,nl,nl,nl,
             functor(Term,X,_Y),
             write(X),nl,
             Term=..[_|L],
             write('That is L'),nl,
             write(L),nl,L=[M],length(M,N),write(N),
     %        db_eval_sql(Conn,"SELECT id,name,description,color from
     %                    ""DBA"".product WHERE size='One size fits all'
     %                    OR size='Large'",Term2),
     %        write(Term2), nl,
             db_logoff(Conn),
             odbc_disconnect(Stream).
     
     main2:- %% accessing tuples one by one
             odbc_connect('r2d5.dia.fi.upm.es':2020,Stream),
             db_login(Stream,'ASA 6.0 Sample',dba,sql,Conn),
             db_stmt_handle(Conn,
                   "SELECT fname,lname,address from ""DBA"".customer
                    WHERE ((Id>100) AND (Id<105))",QueryConn),
             db_one_tuple(QueryConn,Answer),
             format("First Tuple: ~w \n",Answer),
             db_one_tuple(QueryConn,Answer2),
             format("Second Tuple: ~w \n",Answer2),
             db_logoff(Conn),
             odbc_disconnect(Stream).
     
     main3:- %% bringing tuples (one to one) from Literature Database
             %% TO SEE : check it
             odbc_connect('r2d5.dia.fi.upm.es':2020,Stream),
             db_login(Stream,'Literature',dba,sql,Conn),
             db_stmt_handle(Conn,"SELECT * FROM AUTHORS ORDER BY ID",QueryConn),
             print_all_one_by_one(QueryConn),
             db_logoff(Conn),
             odbc_disconnect(Stream).
     
     print_all_one_by_one(QueryConn):-
             db_one_tuple(QueryConn,Answer),
             Answer\=[],
             !,
             format(" ~w \n",Answer),
             print_all_one_by_one(QueryConn).
     print_all_one_by_one(_QueryConn):-
             write(' Finished fetching query statement.'),
             nl.
     
     main4:- %% inserting a tuple into the Literature database
             odbc_connect('r2d5.dia.fi.upm.es':2020,Stream),
             db_login(Stream,'Literature',dba,sql,Conn),
             db_stmt_handle(Conn,
                    "INSERT INTO AUTHORS values ('Martin Gaite',
                     'Carmen',10,'1910-7-10 00:00:00:000')",_QueryConn),
             db_logoff(Conn),
             odbc_disconnect(Stream).
     
     main5:- %% creating a view
             odbc_connect('r2d5.dia.fi.upm.es':2020,Stream),
             db_login(Stream,'Literature',dba,sql,Conn),
             db_stmt_handle(Conn,
                    "CREATE VIEW AntoniosDateOfBirth AS SELECT
                     LastName,Date_of_birth FROM
                     AUTHORS where FirstName='Antonio';",_QueryConn),
             db_logoff(Conn),
             odbc_disconnect(Stream).
     
     main6:- %% printing the view
             odbc_connect('r2d5.dia.fi.upm.es':2020,Stream),
             db_login(Stream,'Literature',dba,sql,Conn),
             db_eval_sql(Conn,"select * from AntoniosDateOfBirth",Term),
             write(Term),
             db_logoff(Conn),
             odbc_disconnect(Stream).
     
     main7:- %% dropping a view
             odbc_connect('r2d5.dia.fi.upm.es':2020,Stream),
             db_login(Stream,'Literature',dba,sql,Conn),
             db_eval_sql(Conn,"DROP VIEW AntoniosDateOfBirth",Term),
             write(Term),
             db_logoff(Conn),
             odbc_disconnect(Stream).

* Menu:

* Usage and interface (db_client)::
* Documentation on exports (db_client)::
* Documentation on internals (db_client)::
* Known bugs and planned improvements (db_client)::

   ---------- Footnotes ----------

   (1) The server can be downloaded from the same site(s) as the Ciao
system. The downloaded package contains complete installation
instructions for the server. Before trying to run the Ciao Prolog
side of things, make sure that the server is correctly installed and
running, and that it can be accessed from the small sample client
that comes with the server distribution. Once this is achieved,
connection from Ciao should not pose problems.


File: ciao.info,  Node: Usage and interface (db_client),  Next: Documentation on exports (db_client),  Prev: Low-level socket interface to SQL/ODBC databases,  Up: Low-level socket interface to SQL/ODBC databases

Usage and interface (`db_client')
=================================

   * *Library usage:*

     `:- use_module(library(db_client)).'

   * *Exports:*
        - _Predicates:_

          `odbc_connect/2', `db_login/5', `db_eval_sql/3',
          `db_stmt_handle/3', `db_one_tuple/2', `db_get_tables/2',
          `db_table_types/3', `db_logoff/1', `odbc_disconnect/1',
          `match_string/3'.

        - _Regular Types:_

          `socketname/1', `dbname/1', `user/1', `passwd/1',
          `dbconnection/1', `answertableterm/1', `tuple/1',
          `dbqueryconnection/1', `answertupleterm/1'.


   * *Other modules used:*
        - _System library modules:_

          `sockets/sockets', `write', `strings', `lists',
          `persdb_sql/string2term', `messages'.




File: ciao.info,  Node: Documentation on exports (db_client),  Next: Documentation on internals (db_client),  Prev: Usage and interface (db_client),  Up: Low-level socket interface to SQL/ODBC databases

Documentation on exports (`db_client')
======================================

 - PREDICATE: odbc_connect/2:
     *Usage:* `odbc_connect(+DbAddress,-Stream)'
        - _Description:_ Opens a socket connection to port
          `DbAddress', which should be the address of a database
          mediator server. `Stream' is the identifier of the
          corresponding Prolog stream. It is simply a call to
          `connect_to_socket/3'

        - _Call and exit should be _compatible_ with:_

          `+DbAddress' is a structure describing a complete TCP/IP
          port address.   (`db_client:socketname/1')

          `-Stream' is an open stream.   (`streams_basic:stream/1')



 - PREDICATE: db_login/5:
     *Usage:* `db_login(+Stream,+DbName,+User,+Passwd,-DbConnection)'
        - _Description:_ Logs on to the database `DbName' with user
          `User' and password `Passwd' via connection `Stream'.
          `DbConnection' contains the identifier of the session, to
          be used in the calls to other predicates defining the
          interface. It fails and display an error message if the
          login is not succesfully completed.

        - _Call and exit should be _compatible_ with:_

          `+Stream' is an open stream.   (`streams_basic:stream/1')

          `+DbName' is the identifier of an ODBC database.
          (`db_client:dbname/1')

          `+User' is a user name in the ODBC database.
          (`db_client:user/1')

          `+Passwd' is the password for the user name in the ODBC
          database.   (`db_client:passwd/1')

          `-DbConnection' a unique identifier of a database session
          connection.   (`db_client:dbconnection/1')



 - REGTYPE: socketname/1:
          socketname(IPAddress:PortNumber) :-
                  atm(IPAddress),
                  int(PortNumber).

     *Usage:* `socketname(IPP)'
        - _Description:_ `IPP' is a structure describing a complete
          TCP/IP port address.



 - REGTYPE: dbname/1:
          dbname(DBId) :-
                  atm(DBId).

     *Usage:* `dbname(DBId)'
        - _Description:_ `DBId' is the identifier of an ODBC database.



 - REGTYPE: user/1:
          user(User) :-
                  atm(User).

     *Usage:* `user(User)'
        - _Description:_ `User' is a user name in the ODBC database.



 - REGTYPE: passwd/1:
          passwd(Passwd) :-
                  atm(Passwd).

     *Usage:* `passwd(Passwd)'
        - _Description:_ `Passwd' is the password for the user name
          in the ODBC database.



 - REGTYPE: dbconnection/1:
          dbconnection(dbconnection(DbStream,DbHandle)) :-
                  stream(DbStream),
                  dbhandle(DbHandle).

     *Usage:* `dbconnection(H)'
        - _Description:_ `H' a unique identifier of a database
          session connection.



 - PREDICATE: db_eval_sql/3:
     *Usage:* `db_eval_sql(+DbConnection,+Sentence,-AnswerTableTerm)'
        - _Description:_ Evaluates the SQL code in `Sentence' in
          database session `DbConnection'. `AnswerTableTerm' is the
          response. If a wrong answer is obtained, `AnswerTableTerm'
          will indicate the error (see `answertableterm' for details).

        - _Call and exit should be _compatible_ with:_

          `+DbConnection' a unique identifier of a database session
          connection.   (`db_client:dbconnection/1')

          `+Sentence' is a string of SQL code.
          (`db_client:sqlstring/1')

          `-AnswerTableTerm' is a response from the ODBC database
          interface.   (`db_client:answertableterm/1')



 - REGTYPE: answertableterm/1:
     Represents the types of responses that will be returned from the
     ODBC database interface. These can be a set of answer tuples, or
     the atom `ok' in case of a successful addition or deletion.

     *Usage:* `answertableterm(AT)'
        - _Description:_ `AT' is a response from the ODBC database
          interface.



 - REGTYPE: tuple/1:
          tuple(T) :-
                  list(T,atm).

     *Usage:* `tuple(T)'
        - _Description:_ `T' is a tuple of values from the ODBC
          database interface.



 - PREDICATE: db_stmt_handle/3:
     *Usage:*
     `db_stmt_handle(+DbConnection,+Sentence,-DbQueryConnection)'
        - _Description:_ Evaluates the SQL code in `Sentence' in
          database session `DbConnection'. If `Sentence' is a
          succesfull selection, `DbQueryConnection' is a _handle_ to
          the set of tuples produced by this selection. The
          individual members of this set can then be accessed via
          `DbQueryConnection' using the `db_one_tuple/2' predicate.
          If `Sentence' is not succesfull or is not a selection,
          `DbQueryConnection' will contain the answer received.

        - _Call and exit should be _compatible_ with:_

          `+DbConnection' a unique identifier of a database session
          connection.   (`db_client:dbconnection/1')

          `+Sentence' is a string of SQL code.
          (`db_client:sqlstring/1')

          `-DbQueryConnection' is a unique identifier of a query
          answer in a database session connection.
          (`db_client:dbqueryconnection/1')



 - REGTYPE: dbqueryconnection/1:
          dbqueryconnection(dbqueryconnection(DbStream,DbHandle,StmtHandle)) :-
                  stream(DbStream),
                  dbhandle(DbHandle),
                  stmthandle(StmtHandle).

     *Usage:* `dbqueryconnection(H)'
        - _Description:_ `H' is a unique identifier of a query answer
          in a database session connection.



 - PREDICATE: db_one_tuple/2:
     *Usage:* `db_one_tuple(+DbQueryConnection,-TupleTerm)'
        - _Description:_ `TupleTerm' represents the last tuple read
          from handle `DbQueryConnection'. Will be an empty list if
          all the answers have already been read. It displays an
          error if any unformatted string is fetched.

        - _Call and exit should be _compatible_ with:_

          `+DbQueryConnection' is a unique identifier of a query
          answer in a database session connection.
          (`db_client:dbqueryconnection/1')

          `-TupleTerm' is a predicate containing a tuple.
          (`db_client:answertupleterm/1')



 - REGTYPE: answertupleterm/1:
          answertupleterm([]).
          answertupleterm(tup(T)) :-
                  tuple(T).

     *Usage:* `answertupleterm(X)'
        - _Description:_ `X' is a predicate containing a tuple.



 - PREDICATE: db_get_tables/2:
     *Usage:* `db_get_tables(+DbConnection,-Tables)'
        - _Description:_ `Tables' contains the tables available in
          `DbConnection'.

        - _Call and exit should be _compatible_ with:_

          `+DbConnection' a unique identifier of a database session
          connection.   (`db_client:dbconnection/1')

          `-Tables' is a list of `atm's.   (`basic_props:list/2')



 - PREDICATE: db_table_types/3:
     *Usage:* `db_table_types(+DbConnection,+Table,-AttrTypes)'
        - _Description:_ `AttrTypes' are the attributes and types of
          `Table' in `DbConnection'.

        - _Call and exit should be _compatible_ with:_

          `+DbConnection' a unique identifier of a database session
          connection.   (`db_client:dbconnection/1')

          `+Table' is an atom.   (`basic_props:atm/1')

          `-AttrTypes' is a list.   (`basic_props:list/1')



 - PREDICATE: db_logoff/1:
     *Usage:* `db_logoff(+DbConnection)'
        - _Description:_ Logs off from the database identified by
          `DbConnection'. It fails and display an error message if
          the login is not succesfully completed.

        - _Call and exit should be _compatible_ with:_

          `+DbConnection' a unique identifier of a database session
          connection.   (`db_client:dbconnection/1')



 - PREDICATE: odbc_disconnect/1:
     *Usage:* `odbc_disconnect(+Stream)'
        - _Description:_ Closes the socket connection to `Stream'. It
          is simply a call to `close/1'.

        - _Call and exit should be _compatible_ with:_

          `+Stream' is an open stream.   (`streams_basic:stream/1')



 - PREDICATE: match_string/3:
     No further documentation available for this predicate.





File: ciao.info,  Node: Documentation on internals (db_client),  Next: Known bugs and planned improvements (db_client),  Prev: Documentation on exports (db_client),  Up: Low-level socket interface to SQL/ODBC databases

Documentation on internals (`db_client')
========================================

 - REGTYPE: dbhandle/1:
          dbhandle(H) :-
                  string(H).

     *Usage:* `dbhandle(H)'
        - _Description:_ `H' is the internal database identifier
          (handle) of a database session.



 - REGTYPE: stmthandle/1:
          stmthandle(H) :-
                  string(H).

     *Usage:* `stmthandle(H)'
        - _Description:_ `H' is the internal statement identifier
          (handle) of a query answer in a database session connection.




File: ciao.info,  Node: Known bugs and planned improvements (db_client),  Prev: Documentation on internals (db_client),  Up: Low-level socket interface to SQL/ODBC databases

Known bugs and planned improvements (`db_client')
=================================================

   * Need to fix the problem with parametric types being
     meta_predicates ... list(_,tuple/1).


File: ciao.info,  Node: Low-level Prolog to Java interface,  Next: Low-level Java to Prolog interface,  Prev: Low-level socket interface to SQL/ODBC databases,  Up: Top

Low-level Prolog to Java interface
**********************************

   *Author(s):* Jesu's Correas.

   This module defines the low level Prolog to Java interface. This
interface allows a Prolog program to start a Java process, and create
Java objects, invoke methods, set/get attributes (fields), and handle
Java events.

   Although the Java side interface is explained in Javadoc format,
the general interface structure is detailed here.

* Menu:

* Low-Level Prolog to Java Interface Structure::
* Java event handling from Prolog::
* Java exception handling from Prolog::
* Usage and interface (javart)::
* Documentation on exports (javart)::


File: ciao.info,  Node: Low-Level Prolog to Java Interface Structure,  Next: Java event handling from Prolog,  Prev: Low-level Prolog to Java interface,  Up: Low-level Prolog to Java interface

Low-Level Prolog to Java Interface Structure
============================================

   This low-level prolog to java interface is made up of two parts: a
Prolog part and a Java part. The Prolog part receives requests from a
Prolog program and sends them to the Java part through a socket. The
Java part receives requests from the socket and performs the actions
included in the requests.

   If an event is thrown in the java side, an asynchronous message
must be sent away to the prolog side, in order to launch a prolog
goal to handle the event. This asynchronous communication is made by
the means of a second socket. The nature of this communication needs
the use of threads both in java and prolog: one thread to deal with
the 'sequential program flow,' and other thread (may be several) to
do the job of event handling.

   In the java side the threads are automatically created by the
context of the objects we use: adding an event listener implies
automatically that there will be a thread ready to launch it when the
event raises. The prolog side is different: there must be a thread in
the low-level interface that listens to the asynchronous socket to
launch the goals requested.

* Menu:

* Prolog side::
* Java side::


File: ciao.info,  Node: Prolog side,  Next: Java side,  Prev: Low-Level Prolog to Java Interface Structure,  Up: Low-Level Prolog to Java Interface Structure

Prolog side
-----------

   The prolog side receives the actions to do in the java side from
the user program, and sends them to the java side through the socket
connection. When the action is done in the java side, the result is
returned to the user program, or the action fails if any problem in
the java side is found.

   In order to send and receive prolog terms and java object
references using a socket, this layer must transform this elements in
a serialized representation, just like the java serialization package
does. This transformation is done in our implementation using the
`fast_read/1' and `fast_write/1' predicates included in Ciao, so any
prolog element can be translated to and from a list of bytes.

   Prolog data representation of java elements is very simple in this
low-level interface. Java primitive types such as integers and
characters are translated into Prolog terms, and even some Java
objects are translated that way (e. g. Java strings). Java objects
are represented in Prolog as compound terms with a reference to
identify the corresponding Java object. Data conversion is made
automatically when the interface is used, so the Prolog user programs
do not have to deal with the complexity of this tasks.


File: ciao.info,  Node: Java side,  Prev: Prolog side,  Up: Low-Level Prolog to Java Interface Structure

Java side
---------

   The java side of this layer is more complex than the prolog side.
The tasks this part have to deal to are the following:

   * Wait for requests from the prolog side.

   * Translate the prolog terms received in a 'serialized' form in a
     more useful java representation.

   * Interpret the requests received from the prolog side.

   * Handle the set of objects created by or derived from the
     requests received from de prolog side.

   * Handle the events raised in the java side, and launch the
     listeners added in the prolog side.

   * Handle the exceptions raised in the java side, and send to the
     prolog side.


   In the implementation of the java side, two items must be
carefully designed: the handling of java objects, and the
representation of prolog data structures. The last item is specially
important because all the interactions between prolog and java are
made using prolog structures, an easy way to standardize the
different data management of both languages. Even the requests
themselves are encapsulated using prolog structures. The overload of
this encapsulation is not significant in terms of socket traffic, due
to the optimal implementation of the prolog serialized term.

   The java side must handle the objects created from the prolog side
dinamically, and these objects must be accessed as fast as possible
from the set of objects. The java API provides a powerful
implementation of Hash tables that achieves all the requirements of
our implementation.

   On the other hand, the java representation of prolog terms is made
using the inheritance of java classes. In the java side exists a
representation of a generic prolog term, implemented as an abstract
class in java. Variables, atoms, compound terms, lists, and numeric
terms are classes in the java side which inherit from the term class.
Java objects can be seen also under the prolog representation as
compound terms, where the single argument corresponds to the Hash key
of the actual java object in the Hash table referred to before. This
behaviour makes the handling of mixed java and prolog elements easy.
Prolog goals are represented in the java side as objects which
contain a prolog compound term with the term representing the goal.
This case will be seen more in depth next, when the java to prolog is
explained.


File: ciao.info,  Node: Java event handling from Prolog,  Next: Java exception handling from Prolog,  Prev: Low-Level Prolog to Java Interface Structure,  Up: Low-level Prolog to Java interface

Java event handling from Prolog
===============================

   Java event handling is based on a delegation model since version
1.1.x. This approach to event handling is very powerful and elegant,
but a user program cannot handle all the events that can raise on a
given object: for each kind of event, a listener must be implemented
and added specifically. However, the Java 2 API includes a special
listener (`AWTEventListener') that can manage the internal java event
queue.

   The prolog to java interface has been designed to emulate the java
event handler, and is also based on event objects and listeners. The
low level prolog to java interface implements its own event manager,
to handle those events that have prolog listeners associated to the
object that raises the event. From the prolog side can be added
listeners to objects for specific events. The java side includes a
list of goals to launch from the object and event type.

   Due to the events nature, the event handler must work in a
separate thread to manage the events asynchronously. The java side
has its own mechanisms to work this way. The prolog side must be
implemented specially for event handling using threads. The
communication between java and prolog is also asynchronous, and a
additional socket stream is used to avoid interferences with the main
socket stream. The event stream will work in this implementation only
in one way: from java to prolog. If an event handler needs to send
back requests to java, it will use the main socket stream, just like
the requests sent directly from a prolog program.

   The internal process of register a Prolog event handler to a Java
event is shown in the next figure:


[Image file: autofigip2jbn-events-pl-reg.eps]

   When an event raises, the low-level Prolog to Java interface have
to send to the Prolog user program the goal to evaluate. Graphically,
the complete process takes the tasks involved in the following figure:


[Image file: autofigip2jbn-events-pl-fire.eps]


File: ciao.info,  Node: Java exception handling from Prolog,  Next: Usage and interface (javart),  Prev: Java event handling from Prolog,  Up: Low-level Prolog to Java interface

Java exception handling from Prolog
===================================

   Java exception handling is very similar to the peer prolog
handling: it includes some specific statements to trap exceptions
from user code. In the java side, the exceptions can be originated
from an incorrect request, or can be originated in the code called
from the request. Both exception types will be sent to prolog using
the main socket stream, leaving the prolog program manage the
exception. However, the first kind of exceptions are prefixed, so the
user program can distinguish from the second type of exceptions.

   In order to handle exceptions properly using the prolog to java
and java to prolog interfaces simultaneously, in both sides of the
interface will be filtered those exceptions coming from their own
side: this avoids an endless loop of exceptions bouncing from one
side to another.


File: ciao.info,  Node: Usage and interface (javart),  Next: Documentation on exports (javart),  Prev: Java exception handling from Prolog,  Up: Low-level Prolog to Java interface

Usage and interface (`javart')
==============================

   * *Library usage:*

     `:- use_module(library(javart)).'

   * *Exports:*
        - _Predicates:_

          `java_create_object/2', `java_delete_object/1',
          `java_invoke_method/2', `java_get_value/2',
          `java_set_value/2', `java_connection/0',
          `java_remote_connection/1', `java_disconnection/0',
          `java_add_listener/3', `java_remove_listener/3'.

        - _Regular Types:_

          `machine_name/1', `java_constructor/1', `java_object/1',
          `java_method/1', `java_field/1', `java_event/1',
          `prolog_goal/1'.


   * *Other modules used:*
        - _System library modules:_

          `concurrency/concurrency', `format', `lists', `read',
          `write', `javall/javasock', `system'.




File: ciao.info,  Node: Documentation on exports (javart),  Prev: Usage and interface (javart),  Up: Low-level Prolog to Java interface

Documentation on exports (`javart')
===================================

 - PREDICATE: java_create_object/2:
     *Usage:* `java_create_object(+java_constructor,-java_object)'
        - _Description:_ New java object creation. The constructor
          must be a compound term as defined by its type, with the
          full class name as functor (e.g., 'java.lang.String'), and
          the parameters passed to the constructor as arguments of
          the structure.

        - _Call and exit should be _compatible_ with:_

          `+java_constructor' is a java constructor (structure with
          functor as constructor full name, and arguments as
          constructor arguments).   (`javart:java_constructor/1')

          `-java_object' is a java object (a structure with functor
          '$java_object', and argument an integer given by the java
          side).   (`javart:java_object/1')



 - REGTYPE: machine_name/1:
     *Usage:* `machine_name(X)'
        - _Description:_ `X' is the network name of a machine.



 - REGTYPE: java_constructor/1:
     *Usage:* `java_constructor(X)'
        - _Description:_ `X' is a java constructor (structure with
          functor as constructor full name, and arguments as
          constructor arguments).



 - REGTYPE: java_object/1:
     *Usage:* `java_object(X)'
        - _Description:_ `X' is a java object (a structure with
          functor '$java_object', and argument an integer given by
          the java side).



 - PREDICATE: java_delete_object/1:
     *Usage:* `java_delete_object(+java_object)'
        - _Description:_ Java object deletion. It removes the object
          given as argument from the Java object table.

        - _Call and exit should be _compatible_ with:_

          `+java_object' is a java object (a structure with functor
          '$java_object', and argument an integer given by the java
          side).   (`javart:java_object/1')



 - PREDICATE: java_invoke_method/2:
     *Usage:* `java_invoke_method(+java_object,+java_method)'
        - _Description:_ Invokes a java method on an object. Given a
          Java object reference, invokes the method represented with
          the second argument.

        - _Call and exit should be _compatible_ with:_

          `+java_object' is a java object (a structure with functor
          '$java_object', and argument an integer given by the java
          side).   (`javart:java_object/1')

          `+java_method' is a java method (structure with functor as
          method name, and arguments as method ones, plus a result
          argument. This result argument is unified with the atom
          'Yes' if the java method returns void).
          (`javart:java_method/1')



 - REGTYPE: java_method/1:
     *Usage:* `java_method(X)'
        - _Description:_ `X' is a java method (structure with functor
          as method name, and arguments as method ones, plus a result
          argument. This result argument is unified with the atom
          'Yes' if the java method returns void).



 - PREDICATE: java_get_value/2:
     *Usage:* `java_get_value(+java_object,+java_field)'
        - _Description:_ Gets the value of a field. Given a Java
          object as first argument, it instantiates the variable
          given as second argument. This field must be uninstantiated
          in the java_field functor, or this predicate will fail.

        - _Call and exit should be _compatible_ with:_

          `+java_object' is a java object (a structure with functor
          '$java_object', and argument an integer given by the java
          side).   (`javart:java_object/1')

          `+java_field' is a java field (structure on which the
          functor name is the field name, and the single argument is
          the field value).   (`javart:java_field/1')



 - PREDICATE: java_set_value/2:
     *Usage:* `java_set_value(+java_object,+java_field)'
        - _Description:_ Sets the value of a Java object field. Given
          a Java object reference, it assigns the value included in
          the java_field compound term. The field value in the
          java_field structure must be instantiated.

        - _Call and exit should be _compatible_ with:_

          `+java_object' is a java object (a structure with functor
          '$java_object', and argument an integer given by the java
          side).   (`javart:java_object/1')

          `+java_field' is a java field (structure on which the
          functor name is the field name, and the single argument is
          the field value).   (`javart:java_field/1')



 - REGTYPE: java_field/1:
     *Usage:* `java_field(X)'
        - _Description:_ `X' is a java field (structure on which the
          functor name is the field name, and the single argument is
          the field value).



 - PREDICATE: java_connection/0:
     *Usage:*
        - _Description:_ Starts the Java server on the local machine,
          connects it through the data and event sockets, and starts
          the event handling thread.



 - PREDICATE: java_remote_connection/1:
     *Usage:* `java_remote_connection(+machine_name)'
        - _Description:_ Starts the Java server in machine_name,
          connects it through the data and event sockets, and starts
          the event handling thread.



 - PREDICATE: java_disconnection/0:
     *Usage:*
        - _Description:_ Closes the connection with the java process.



 - PREDICATE: java_add_listener/3:
     _Meta-predicate_ with arguments: `java_add_listener(?,?,goal)'.

     *Usage:*
     `java_add_listener(+java_object,+java_event,+prolog_goal)'
        - _Description:_ Adds a listener to an event on an object.
          Given a Java object reference, it registers the goal
          received as third argument to be launched when the Java
          event raises.

        - _Call and exit should be _compatible_ with:_

          `+java_object' is a java object (a structure with functor
          '$java_object', and argument an integer given by the java
          side).   (`javart:java_object/1')

          `+java_event' is a java event represented as an atom with
          the full event constructor name (e.g.,
          'java.awt.event.ActionListener').   (`javart:java_event/1')

          `+prolog_goal' is a prolog predicate. Prolog term that
          represents the goal that must be invoked when the event
          raises on the object. The predicate arguments can be java
          objects, or even the result of java methods. These java
          objects will be evaluated when the event raises (instead of
          when the listener is added). The arguments that represent
          java objects must be instantiated to already created
          objects. The variables will be kept uninstantiated when the
          event raises and the predicate is called.
          (`javart:prolog_goal/1')



 - REGTYPE: java_event/1:
     *Usage:* `java_event(X)'
        - _Description:_ `X' is a java event represented as an atom
          with the full event constructor name (e.g.,
          'java.awt.event.ActionListener').



 - REGTYPE: prolog_goal/1:
     *Usage:* `prolog_goal(X)'
        - _Description:_ `X' is a prolog predicate. Prolog term that
          represents the goal that must be invoked when the event
          raises on the object. The predicate arguments can be java
          objects, or even the result of java methods. These java
          objects will be evaluated when the event raises (instead of
          when the listener is added). The arguments that represent
          java objects must be instantiated to already created
          objects. The variables will be kept uninstantiated when the
          event raises and the predicate is called.



 - PREDICATE: java_remove_listener/3:
     *Usage:*
     `java_remove_listener(+java_object,+java_event,+prolog_goal)'
        - _Description:_ It removes a listener from an object event
          queue. Given a Java object reference, goal registered for
          the given event is removed.

        - _Call and exit should be _compatible_ with:_

          `+java_object' is a java object (a structure with functor
          '$java_object', and argument an integer given by the java
          side).   (`javart:java_object/1')

          `+java_event' is a java event represented as an atom with
          the full event constructor name (e.g.,
          'java.awt.event.ActionListener').   (`javart:java_event/1')

          `+prolog_goal' is a prolog predicate. Prolog term that
          represents the goal that must be invoked when the event
          raises on the object. The predicate arguments can be java
          objects, or even the result of java methods. These java
          objects will be evaluated when the event raises (instead of
          when the listener is added). The arguments that represent
          java objects must be instantiated to already created
          objects. The variables will be kept uninstantiated when the
          event raises and the predicate is called.
          (`javart:prolog_goal/1')




File: ciao.info,  Node: Low-level Java to Prolog interface,  Next: Low-level Prolog to Java socket connection,  Prev: Low-level Prolog to Java interface,  Up: Top

Low-level Java to Prolog interface
**********************************

   *Author(s):* Jesu's Correas.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#40 (2000/2/8, 16:32:42 CET)

   This module defines a low level Java to Prolog interface. This
Prolog side of the Java to Prolog interface only has one public
predicate: a server that listens at the socket connection with Java,
and executes the commands received from the Java side.

   In order to evaluate the goals received from the Java side, this
module can work in two ways: executing them in the same engine, or
starting a thread for each goal. The easiest way is to launch them in
the same engine, but the goals must be evaluated sequentially: once a
goal provides the first solution, all the subsequent goals must be
finished before this goal can backtrack to provide another solution.
The Prolog side of this interface works as a top-level, and the goals
partially evaluated are not independent.

   The solution of this goal dependence is to evaluate the goals in a
different prolog engine. Although Ciao includes a mechanism to
evaluate goals in different engines, the approach used in this
interface is to launch each goal in a different thread.

   The decision of what kind of goal evaluation is selected is done
by the Java side. Each evaluation type has its own command terms, so
the Java side can choose the type it needs.

   A Prolog server starts by calling the `prolog_server/0' predicate.
The user predicates and libraries to be called from Java must be
included in the executable file, or be accesible using the built-in
predicates dealing with code loading.

* Menu:

* Usage and interface (jtopl)::
* Documentation on exports (jtopl)::
* Documentation on internals (jtopl)::


File: ciao.info,  Node: Usage and interface (jtopl),  Next: Documentation on exports (jtopl),  Prev: Low-level Java to Prolog interface,  Up: Low-level Java to Prolog interface

Usage and interface (`jtopl')
=============================

   * *Library usage:*

     `:- use_module(library(jtopl)).'

   * *Exports:*
        - _Predicates:_

          `prolog_server/0'.


   * *Other modules used:*
        - _System library modules:_

          `concurrency/concurrency', `system', `read', `write',
          `dynamic', `lists', `format', `dynmods', `atom2term',
          `javall/javasock'.




File: ciao.info,  Node: Documentation on exports (jtopl),  Next: Documentation on internals (jtopl),  Prev: Usage and interface (jtopl),  Up: Low-level Java to Prolog interface

Documentation on exports (`jtopl')
==================================

 - PREDICATE: prolog_server/0:
     *Usage:*
        - _Description:_ Prolog server entry point. Reads from the
          standard input the node name and port number where the java
          client resides, and starts the prolog server listening at
          the data socket. This predicate acts as a server: it
          includes an endless read-process loop until the
          `prolog_exit' command is received.





File: ciao.info,  Node: Documentation on internals (jtopl),  Prev: Documentation on exports (jtopl),  Up: Low-level Java to Prolog interface

Documentation on internals (`jtopl')
====================================

 - REGTYPE: command/1:
     *Usage:* `command(X)'
        - _Description:_ `X' is a command received from the java
          client, to be executed by the Prolog process. The command
          is represented as an atom or a functor with arity 1. The
          command to be executed must be one of the following types:
             * `prolog_launch_query(Q)' Compound term to create a new
               query, received as single argument of this structure.
               A reference to the new query is returned to Java.

             * `prolog_launch_query_on_thread(Q)' Compound term to
               evaluate a new query using a separate thread. A
               reference to the new query is returned to Java.

             * `prolog_next_solution(ID)' Compound term to get the
               next solution of a goal identified by the single
               argument of the structure. A term representing the
               goal instantiated with the next solution is returned
               to Java.

             * `prolog_terminate_query(ID)' Compound term to
               terminate the goal identified by the argument. If the
               thread option is disabled, a cut is made in the goal
               search tree, and the goal is removed from the goal
               table; if the thread option is enabled, the thread
               evaluating the goal is terminated.

             * `prolog_exit' Atom to terminate the current Prolog
               process.





 - REGTYPE: answer/1:
     *Usage:* `answer(X)'
        - _Description:_ `X' is a response sent from the prolog
          server. Is represented as an atom or a functor with arity 1
          or 2, depending on the functor name.




 - REGTYPE: prolog_query/1:
     *Usage:* `prolog_query(X)'
        - _Description:_ `X' is a query to be launched from the
          prolog server.



 - PREDICATE: shell_s/0:
     *Usage:*
        - _Description:_ Command execution loop. This predicate is
          called when the connection to Java is established, and
          performs an endless loop dealing with the following tasks:

             * reads a command from the socket. All the commands are
               explained in the `command' type description,

             * processes the command using the
               `process_first_command/1' and `process_next_command/1'
               predicates, and

             * returns the results of the command execution.





 - PREDICATE: process_first_command/1:
     *Usage:* `process_first_command(+Command)'
        - _Description:_ Processes the first command of a query.
          Using the threads option, it processes all the commands
          received from the prolog server.

        - _Call and exit should be _compatible_ with:_

          `+Command' is a command received from the java client, to
          be executed by the Prolog process. The command is
          represented as an atom or a functor with arity 1. The
          command to be executed must be one of the following types:
             * `prolog_launch_query(Q)' Compound term to create a new
               query, received as single argument of this structure.
               A reference to the new query is returned to Java.

             * `prolog_launch_query_on_thread(Q)' Compound term to
               evaluate a new query using a separate thread. A
               reference to the new query is returned to Java.

             * `prolog_next_solution(ID)' Compound term to get the
               next solution of a goal identified by the single
               argument of the structure. A term representing the
               goal instantiated with the next solution is returned
               to Java.

             * `prolog_terminate_query(ID)' Compound term to
               terminate the goal identified by the argument. If the
               thread option is disabled, a cut is made in the goal
               search tree, and the goal is removed from the goal
               table; if the thread option is enabled, the thread
               evaluating the goal is terminated.

             * `prolog_exit' Atom to terminate the current Prolog
               process.


          (`jtopl:command/1')



 - PREDICATE: process_next_command/2:
     *Usage:* `process_next_command(+Id,+Command)'
        - _Description:_ Process the commands received from the
          prolog server when a query is being handled.

        - _Call and exit should be _compatible_ with:_

          `undefined:prolog_query_id(+Id)'  (undefined property)

          `+Command' is a command received from the java client, to
          be executed by the Prolog process. The command is
          represented as an atom or a functor with arity 1. The
          command to be executed must be one of the following types:
             * `prolog_launch_query(Q)' Compound term to create a new
               query, received as single argument of this structure.
               A reference to the new query is returned to Java.

             * `prolog_launch_query_on_thread(Q)' Compound term to
               evaluate a new query using a separate thread. A
               reference to the new query is returned to Java.

             * `prolog_next_solution(ID)' Compound term to get the
               next solution of a goal identified by the single
               argument of the structure. A term representing the
               goal instantiated with the next solution is returned
               to Java.

             * `prolog_terminate_query(ID)' Compound term to
               terminate the goal identified by the argument. If the
               thread option is disabled, a cut is made in the goal
               search tree, and the goal is removed from the goal
               table; if the thread option is enabled, the thread
               evaluating the goal is terminated.

             * `prolog_exit' Atom to terminate the current Prolog
               process.


          (`jtopl:command/1')



 - PREDICATE: solve/1:
     *Usage:* `solve(+Query)'
        - _Description:_ Runs the query processing the commands
          received from the java side, and handles query nesting. It
          is used only with the thread option disabled.

        - _Call and exit should be _compatible_ with:_

          `+Query' is a query to be launched from the prolog server.
          (`jtopl:prolog_query/1')



 - PREDICATE: solve_on_thread/1:
     *Usage:* `solve_on_thread(+Query)'
        - _Description:_ Runs the query on a separate thread and
          stores the solutions on the `query_solutions/2' data
          predicate.

        - _Call and exit should be _compatible_ with:_

          `+Query' is a query to be launched from the prolog server.
          (`jtopl:prolog_query/1')



 - PREDICATE: get_query_id/1:
     *Usage:* `get_query_id(-Id)'
        - _Description:_ Produces the query id for the next query,
          when is invoked the threads option disabled.

        - _Call and exit should be _compatible_ with:_

          `undefined:prolog_query_id(-Id)'  (undefined property)



 - PREDICATE: prolog_parse/2:
     *Usage:* `prolog_parse(+String,-Term)'
        - _Description:_ Parses the string received as first argument
          and returns the prolog term as second argument.
          *Important:* This is a private predicate but could be
          called from java side, to parse strings to Prolog terms.

        - _Call and exit should be _compatible_ with:_

          `+String' is a string (a list of character codes).
          (`basic_props:string/1')

          `-Term' is any term.   (`basic_props:term/1')



 - PREDICATE: read_command/1:
     *Usage:* `read_command(-Command)'
        - _Description:_ Reads from the input stream a new prolog
          server command.

        - _Call and exit should be _compatible_ with:_

          `-Command' is a command received from the java client, to
          be executed by the Prolog process. The command is
          represented as an atom or a functor with arity 1. The
          command to be executed must be one of the following types:
             * `prolog_launch_query(Q)' Compound term to create a new
               query, received as single argument of this structure.
               A reference to the new query is returned to Java.

             * `prolog_launch_query_on_thread(Q)' Compound term to
               evaluate a new query using a separate thread. A
               reference to the new query is returned to Java.

             * `prolog_next_solution(ID)' Compound term to get the
               next solution of a goal identified by the single
               argument of the structure. A term representing the
               goal instantiated with the next solution is returned
               to Java.

             * `prolog_terminate_query(ID)' Compound term to
               terminate the goal identified by the argument. If the
               thread option is disabled, a cut is made in the goal
               search tree, and the goal is removed from the goal
               table; if the thread option is enabled, the thread
               evaluating the goal is terminated.

             * `prolog_exit' Atom to terminate the current Prolog
               process.


          (`jtopl:command/1')



 - PREDICATE: write_answer/1:
     *Usage:* `write_answer(+Answer)'
        - _Description:_ writes to the output socket stream the given
          answer.

        - _Call and exit should be _compatible_ with:_

          `+Answer' is a response sent from the prolog server. Is
          represented as an atom or a functor with arity 1 or 2,
          depending on the functor name.

          (`jtopl:answer/1')




File: ciao.info,  Node: Low-level Prolog to Java socket connection,  Next: Calling emacs from Prolog,  Prev: Low-level Java to Prolog interface,  Up: Top

Low-level Prolog to Java socket connection
******************************************

   *Author(s):* Jesu's Correas.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#152 (2000/5/26, 13:36:48 CEST)

   This module defines a low level socket interface, to be used by
javart and jtopl. Includes all the code related directly to the
handling of sockets. This library should not be used by any user
program, because is a very low-level connection to Java. Use `javart'
(Prolog to Java low-level interface) or `jtopl' (Java to Prolog
interface) libraries instead.

* Menu:

* Usage and interface (javasock)::
* Documentation on exports (javasock)::


File: ciao.info,  Node: Usage and interface (javasock),  Next: Documentation on exports (javasock),  Prev: Low-level Prolog to Java socket connection,  Up: Low-level Prolog to Java socket connection

Usage and interface (`javasock')
================================

   * *Library usage:*

     `:- use_module(library(javasock)).'

   * *Exports:*
        - _Predicates:_

          `socket_connection/2', `socket_disconnection/0',
          `java_fast_read/2', `java_fast_write/2', `java_stream/3'.


   * *Other modules used:*
        - _System library modules:_

          `fastrw', `read', `sockets/sockets', `dynamic', `format'.




File: ciao.info,  Node: Documentation on exports (javasock),  Prev: Usage and interface (javasock),  Up: Low-level Prolog to Java socket connection

Documentation on exports (`javasock')
=====================================

 - PREDICATE: socket_connection/2:
     *Usage:* `socket_connection(+Node,+Stream)'
        - _Description:_ Given a stream connected to a node, it gets
          the socket port from the given stream and creates the
          sockets to connect to the java process.

        - _Call and exit should be _compatible_ with:_

          `+Node' is currently instantiated to an atom.
          (`term_typing:atom/1')

          `+Stream' is an open stream.   (`streams_basic:stream/1')



 - PREDICATE: socket_disconnection/0:
     *Usage:*
        - _Description:_ It closes the sockets to disconnect from the
          java process.



 - PREDICATE: java_fast_read/2:
     *Usage:* `java_fast_read(+Type,-Term)'
        - _Description:_ It reads from the given stream type one term
          and unifies it with the term received as second argument.
          This is the basic predicate used to receive data from the
          Java side. The first argument reflects the socket type:
          event or data. The second argument is unified with the data
          received from the socket.

        - _Call and exit should be _compatible_ with:_

          `+Type' is currently instantiated to an atom.
          (`term_typing:atom/1')

          `-Term' is any term.   (`basic_props:term/1')



 - PREDICATE: java_fast_write/2:
     *Usage:* `java_fast_write(+Type,+Term)'
        - _Description:_  It writes on the given stream type the term
          received as second argument. This is the basic predicate
          used to send data to the Java side. The first argument
          reflects the socket type: event or data. The second
          argument is the term to be sent to the Java side.

        - _Call and exit should be _compatible_ with:_

          `+Type' is currently instantiated to an atom.
          (`term_typing:atom/1')

          `+Term' is any term.   (`basic_props:term/1')



 - PREDICATE: java_stream/3:
     The predicate is of type _dynamic_.

     *Usage:* `java_stream(DataStream,EventStream,Address)'
        - _Description:_ Stores the identifiers of the streams used.
          A fact is asserted when the connection to the Java process
          is established. It Contains the data and event streams, and
          the network address where the Java process is running.

        - _Call and exit should be _compatible_ with:_

          `DataStream' is an atom.   (`basic_props:atm/1')

          `EventStream' is an integer.   (`basic_props:int/1')

          `Address' is a valid host name.
          (`javasock:machine_name/1')




File: ciao.info,  Node: Calling emacs from Prolog,  Next: linda (library),  Prev: Low-level Prolog to Java socket connection,  Up: Top

Calling emacs from Prolog
*************************

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#54 (2000/2/10, 21:32:23 CET)

   This library provides a _prolog-emacs interface_. This interface
is complementary to (and independent from) the emacs mode, which is
used to develop programs from within the `emacs' editor/environment.
Instead, this library allows calling `emacs' from a running Prolog
program. This facilitates the use of `emacs' as a "user interface"
for a Prolog program. Emacs can be made to:

   * Visit a file, which can then be edited.

   * Execute arbitrary _emacs lisp_ code, sent from Prolog.


In order for this library to work correctly, the following is needed:

   * You should be running the `emacs' editor on the same machine
     where the executable calling this library is executing.

   * This `emacs' should be running the _emacs server_. This can be
     done by including the following line in your `.emacs' file:

          ;; Start a server that emacsclient can connect to.
          (server-start)

     Or typing `M-x server-start' within `emacs'.


This suffices for using `emacs' to edit files. For running arbitrary
code the following also needs to be added to the `.emacs' file:

`(setq enable-local-eval t)'
     Allows executing lisp code without asking.

`(setq enable-local-eval nil)'
     Does not allow executing lisp code without asking.

`(setq enable-local-eval 'maybe)'
     Allows executing lisp code only if user agrees after asking
     (asks interactively for every invocation).

*Examples:*

Assuming that a `.pl' file loads this library, then:

`..., emacs_edit('foo'), ...'
     Opens file `foo' for editing in `emacs'.

`..., emacs_eval_nowait("(run-ciao-toplevel)"), ...'
     Starts execution of a Ciao top-level within `emacs'.

* Menu:

* Usage and interface (emacs)::
* Documentation on exports (emacs)::


File: ciao.info,  Node: Usage and interface (emacs),  Next: Documentation on exports (emacs),  Prev: Calling emacs from Prolog,  Up: Calling emacs from Prolog

Usage and interface (`emacs')
=============================

   * *Library usage:*

     `:- use_module(library(emacs)).'

   * *Exports:*
        - _Predicates:_

          `emacs_edit/1', `emacs_edit_nowait/1', `emacs_eval/1',
          `emacs_eval_nowait/1'.

        - _Regular Types:_

          `elisp_string/1'.


   * *Other modules used:*
        - _System library modules:_

          `metaterms', `lists', `terms', `system'.




File: ciao.info,  Node: Documentation on exports (emacs),  Prev: Usage and interface (emacs),  Up: Calling emacs from Prolog

Documentation on exports (`emacs')
==================================

 - PREDICATE: emacs_edit/1:
     *Usage:* `emacs_edit(+filename)'
        - _Description:_ Opens the given file for editing in `emacs'.
          Waits for editing to finish before continuing.



 - PREDICATE: emacs_edit_nowait/1:
     *Usage:* `emacs_edit_nowait(+filename)'
        - _Description:_ Opens the given file for editing in `emacs'
          and continues without waiting for editing to finish.



 - PREDICATE: emacs_eval/1:
     *Usage:* `emacs_eval(+elisp_string)'
        - _Description:_ Executes in emacs the lisp code given as
          argument. Waits for the command to finish before continuing.



 - PREDICATE: emacs_eval_nowait/1:
     *Usage:* `emacs_eval_nowait(+elisp_string)'
        - _Description:_ Executes in emacs the lisp code given as
          argument and continues without waiting for it to finish.



 - REGTYPE: elisp_string/1:
     *Usage:* `elisp_string(L)'
        - _Description:_ `L' is a string containing `emacs' lisp code.




File: ciao.info,  Node: linda (library),  Next: *** PART IX - Abstract data types,  Prev: Calling emacs from Prolog,  Up: Top

linda (library)
***************

   *Version:* 0.9#66 (1999/4/29, 12:28:0 MEST)

   This is a SICStus-like linda package. Note that this is
essentially quite obsolete, and provided mostly in case it is needed
for compatibility, since Ciao now supports all Linda functionality
(and more) through the concurrent fact database.

* Menu:

* Usage and interface (linda)::
* Documentation on exports (linda)::


File: ciao.info,  Node: Usage and interface (linda),  Next: Documentation on exports (linda),  Prev: linda (library),  Up: linda (library)

Usage and interface (`linda')
=============================

   * *Library usage:*

     `:- use_module(library(linda)).'

   * *Exports:*
        - _Predicates:_

          `linda_client/1', `close_client/0', `in/1', `in/2',
          `in_noblock/1', `out/1', `rd/1', `rd/2', `rd_noblock/1',
          `rd_findall/3', `linda_timeout/2', `halt_server/0',
          `open_client/2', `in_stream/2', `out_stream/2'.


   * *Other modules used:*
        - _System library modules:_

          `read', `fastrw', `sockets/sockets'.




File: ciao.info,  Node: Documentation on exports (linda),  Prev: Usage and interface (linda),  Up: linda (library)

Documentation on exports (`linda')
==================================

 - PREDICATE: linda_client/1:
     No further documentation available for this predicate.




 - PREDICATE: close_client/0:
     No further documentation available for this predicate.




 - PREDICATE: in/1:
     No further documentation available for this predicate.




 - PREDICATE: in/2:
     No further documentation available for this predicate.




 - PREDICATE: in_noblock/1:
     No further documentation available for this predicate.




 - PREDICATE: out/1:
     No further documentation available for this predicate.




 - PREDICATE: rd/1:
     No further documentation available for this predicate.




 - PREDICATE: rd/2:
     No further documentation available for this predicate.




 - PREDICATE: rd_noblock/1:
     No further documentation available for this predicate.




 - PREDICATE: rd_findall/3:
     No further documentation available for this predicate.




 - PREDICATE: linda_timeout/2:
     No further documentation available for this predicate.




 - PREDICATE: halt_server/0:
     No further documentation available for this predicate.




 - PREDICATE: open_client/2:
     No further documentation available for this predicate.




 - PREDICATE: in_stream/2:
     No further documentation available for this predicate.




 - PREDICATE: out_stream/2:
     No further documentation available for this predicate.





File: ciao.info,  Node: *** PART IX - Abstract data types,  Next: counters (library),  Prev: linda (library),  Up: Top

PART IX - Abstract data types
*****************************

   This part includes libraries which implement some generic data
structures (abstract data types) that are used frequently in programs
or in the Ciao system itself.


File: ciao.info,  Node: counters (library),  Next: Identity lists,  Prev: *** PART IX - Abstract data types,  Up: Top

counters (library)
******************

   *Version:* 0.4#5 (1998/2/24)

* Menu:

* Usage and interface (counters)::
* Documentation on exports (counters)::


File: ciao.info,  Node: Usage and interface (counters),  Next: Documentation on exports (counters),  Prev: counters (library),  Up: counters (library)

Usage and interface (`counters')
================================

   * *Library usage:*

     `:- use_module(library(counters)).'

   * *Exports:*
        - _Predicates:_

          `setcounter/2', `getcounter/2', `inccounter/2'.




File: ciao.info,  Node: Documentation on exports (counters),  Prev: Usage and interface (counters),  Up: counters (library)

Documentation on exports (`counters')
=====================================

 - PREDICATE: setcounter/2:
     No further documentation available for this predicate.




 - PREDICATE: getcounter/2:
     No further documentation available for this predicate.




 - PREDICATE: inccounter/2:
     No further documentation available for this predicate.





File: ciao.info,  Node: Identity lists,  Next: Term manipulation,  Prev: counters (library),  Up: Top

Identity lists
**************

   *Author(s):* Francisco Bueno.

   *Version:* 0.4#5 (1998/2/24)

   The operations in this module handle lists by performing equality
checks via identity instead of unification.

* Menu:

* Usage and interface (idlists)::
* Documentation on exports (idlists)::


File: ciao.info,  Node: Usage and interface (idlists),  Next: Documentation on exports (idlists),  Prev: Identity lists,  Up: Identity lists

Usage and interface (`idlists')
===============================

   * *Library usage:*

     `:- use_module(library(idlists)).'

   * *Exports:*
        - _Predicates:_

          `member_0/2', `memberchk/2', `list_insert/2', `add_after/4',
          `add_before/4', `delete/3', `subtract/3', `union_idlists/3'.




File: ciao.info,  Node: Documentation on exports (idlists),  Prev: Usage and interface (idlists),  Up: Identity lists

Documentation on exports (`idlists')
====================================

 - PREDICATE: member_0/2:
     No further documentation available for this predicate.




 - PREDICATE: memberchk/2:
     `memberchk(X,Xs)'

     Checks that `X' is an element of (list) `Xs'.




 - PREDICATE: list_insert/2:
     *Usage:* `list_insert(-List,+Term)'
        - _Description:_ Adds `Term' to the end of (tail-opened)
          `List' if there is not an element in `List' identical to
          `Term'.



 - PREDICATE: add_after/4:
     *Usage:* `add_after(+L0,+E0,+E,-L)'
        - _Description:_ Adds element `E' after the first element
          identical to `E0' (or at end) of list `L0', returning in
          `L' the new list.



 - PREDICATE: add_before/4:
     *Usage:* `add_before(+L0,+E0,+E,-L)'
        - _Description:_ Adds element `E' before the first element
          identical to `E0' (or at start) of list `L0', returning in
          `L' the new list.



 - PREDICATE: delete/3:
     *Usage:* `delete(+List,+Element,-Rest)'
        - _Description:_ `Rest' has the same elements of `List'
          except for all the occurrences of elements identical to
          `Element'.



 - PREDICATE: subtract/3:
     *Usage:* `subtract(+Set,+Set0,-Difference)'
        - _Description:_ `Difference' has the same elements of `Set'
          except those which have an identical occurrence in `Set0'.



 - PREDICATE: union_idlists/3:
     *Usage:* `union_idlists(+List1,+List2,-List)'
        - _Description:_ `List' has the elements which are in `List1'
          but are not identical to an element in `List2' followed by
          the elements in `List2'.




File: ciao.info,  Node: Term manipulation,  Next: Lists of numbers,  Prev: Identity lists,  Up: Top

Term manipulation
*****************

   *Version:* 1.5#43 (2000/2/4, 19:53:51 CET)

* Menu:

* Usage and interface (metaterms)::
* Documentation on exports (metaterms)::


File: ciao.info,  Node: Usage and interface (metaterms),  Next: Documentation on exports (metaterms),  Prev: Term manipulation,  Up: Term manipulation

Usage and interface (`metaterms')
=================================

   * *Library usage:*

     `:- use_module(library(metaterms)).'

   * *Exports:*
        - _Predicates:_

          `varset/2', `varsbag/3', `ask/2', `instance/2', `variant/2'.


   * *Other modules used:*
        - _System library modules:_

          `lists', `idlists', `sort', `write'.




File: ciao.info,  Node: Documentation on exports (metaterms),  Prev: Usage and interface (metaterms),  Up: Term manipulation

Documentation on exports (`metaterms')
======================================

 - PREDICATE: varset/2:
     `varset(Term,Xs)'

     `Xs' is the sorted list of all the variables in `Term'.




 - PREDICATE: varsbag/3:
     `varsbag(Term,Vs,Xs)'

     `Vs' is the list of all the variables in `Term' ordered as they
     appear in `Term' left-to-right depth-first (including
     duplicates) plus `Xs'.




 - PREDICATE: ask/2:
     `ask(Term1,Term2)'

     `Term1' and `Term2' unify without producing bindings for the
     variables of `Term1'. I.e., `instance(`Term1',`Term2')' holds.




 - PREDICATE: instance/2:
     `instance(Term1,Term2)'

     `Term1' is an instance of `Term2'.




 - PREDICATE: variant/2:
     `variant(Term1,Term2)'

     `Term1' and `Term2' are identical up to renaming.





File: ciao.info,  Node: Lists of numbers,  Next: Pattern (regular expression) matching,  Prev: Term manipulation,  Up: Top

Lists of numbers
****************

   *Version:* 0.9#99 (1999/5/26, 11:33:15 MEST)

* Menu:

* Usage and interface (numlists)::
* Documentation on exports (numlists)::


File: ciao.info,  Node: Usage and interface (numlists),  Next: Documentation on exports (numlists),  Prev: Lists of numbers,  Up: Lists of numbers

Usage and interface (`numlists')
================================

   * *Library usage:*

     `:- use_module(library(numlists)).'

   * *Exports:*
        - _Predicates:_

          `get_primes/2', `sum_list/2', `sum_list/3',
          `sum_list_of_lists/2', `sum_list_of_lists/3'.

        - _Regular Types:_

          `intlist/1', `numlist/1'.


   * *Other modules used:*
        - _System library modules:_

          `lists'.




File: ciao.info,  Node: Documentation on exports (numlists),  Prev: Usage and interface (numlists),  Up: Lists of numbers

Documentation on exports (`numlists')
=====================================

 - PREDICATE: get_primes/2:
     *Usage:* `get_primes(N,Primes)'
        - _Description:_ Computes the `N'th first prime numbers in
          ascending order.

        - _The following properties should hold at call time:_

          `N' is an integer.   (`basic_props:int/1')

        - _The following properties should hold upon exit:_

          `Primes' is a list of integers.   (`numlists:intlist/1')



 - REGTYPE: intlist/1:
     *Usage:* `intlist(X)'
        - _Description:_ `X' is a list of integers.



 - REGTYPE: numlist/1:
     *Usage:* `numlist(X)'
        - _Description:_ `X' is a list of numbers.



 - PREDICATE: sum_list/2:
     *Usage:* `sum_list(List,N)'
        - _Description:_ `N' is the total sum of the elements of
          `List'.

        - _The following properties should hold at call time:_

          `List' is a list of numbers.   (`numlists:numlist/1')

        - _The following properties should hold upon exit:_

          `N' is a number.   (`basic_props:num/1')



 - PREDICATE: sum_list/3:
     *Usage:* `sum_list(List,N0,N)'
        - _Description:_ `N' is the total sum of the elements of
          `List' plus `N0'.

        - _The following properties should hold at call time:_

          `List' is a list of numbers.   (`numlists:numlist/1')

          `N0' is a number.   (`basic_props:num/1')

        - _The following properties should hold upon exit:_

          `N' is a number.   (`basic_props:num/1')



 - PREDICATE: sum_list_of_lists/2:
     *Usage:* `sum_list_of_lists(Lists,N)'
        - _Description:_ `N' is the total sum of the elements of the
          lists of `Lists'.

        - _The following properties should hold at call time:_

          `List' is a list of `numlist's.   (`basic_props:list/2')

        - _The following properties should hold upon exit:_

          `N' is a number.   (`basic_props:num/1')



 - PREDICATE: sum_list_of_lists/3:
     *Usage:* `sum_list_of_lists(Lists,N0,N)'
        - _Description:_ `N' is the total sum of the elements of the
          lists of `Lists' plus `N0'.

        - _The following properties should hold at call time:_

          `List' is a list of `numlist's.   (`basic_props:list/2')

          `N0' is a number.   (`basic_props:num/1')

        - _The following properties should hold upon exit:_

          `N' is a number.   (`basic_props:num/1')




File: ciao.info,  Node: Pattern (regular expression) matching,  Next: Graphs,  Prev: Lists of numbers,  Up: Top

Pattern (regular expression) matching
*************************************

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.3#49 (1999/9/8, 21:8:9 MEST)

   This library provides facilities for matching strings and terms
against _patterns_ (i.e., _regular expressions_).

* Menu:

* Usage and interface (patterns)::
* Documentation on exports (patterns)::


File: ciao.info,  Node: Usage and interface (patterns),  Next: Documentation on exports (patterns),  Prev: Pattern (regular expression) matching,  Up: Pattern (regular expression) matching

Usage and interface (`patterns')
================================

   * *Library usage:*

     `:- use_module(library(patterns)).'

   * *Exports:*
        - _Predicates:_

          `match_pattern/2', `match_pattern/3',
          `case_insensitive_match/2', `letter_match/2',
          `match_pattern_pred/2'.

        - _Regular Types:_

          `pattern/1'.


   * *Other modules used:*
        - _System library modules:_

          `lists'.




File: ciao.info,  Node: Documentation on exports (patterns),  Prev: Usage and interface (patterns),  Up: Pattern (regular expression) matching

Documentation on exports (`patterns')
=====================================

 - PREDICATE: match_pattern/2:
     *Usage:* `match_pattern(Pattern,String)'
        - _Description:_ Matches `String' against `Pattern'. For
          example, `match_pattern("*.pl","foo.pl")' succeeds.

        - _The following properties should hold at call time:_

          `Pattern' is a pattern to match against.
          (`patterns:pattern/1')

          `String' is a string (a list of character codes).
          (`basic_props:string/1')



 - PREDICATE: match_pattern/3:
     *Usage:* `match_pattern(Pattern,String,Tail)'
        - _Description:_ Matches `String' against `Pattern'. `Tail'
          is the remainder of the string after the match. For
          example, `match_pattern("??*","foo.pl",Tail)' succeeds,
          instantiating `Tail' to `"o.pl"'.

        - _The following properties should hold at call time:_

          `Pattern' is a pattern to match against.
          (`patterns:pattern/1')

          `String' is a string (a list of character codes).
          (`basic_props:string/1')

          `Tail' is a string (a list of character codes).
          (`basic_props:string/1')



 - PREDICATE: case_insensitive_match/2:
     *Usage:* `case_insensitive_match(Pred1,Pred2)'
        - _Description:_ Tests if two predicates `Pred1' and `Pred2'
          match in a case-insensitive way.



 - PREDICATE: letter_match/2:
     No further documentation available for this predicate.




 - REGTYPE: pattern/1:
     Special characters for `Pattern' are:
    *
          Matches any string, including the null string.

    ?
          Matches any single character.

    [...]
          Matches any one of the enclosed characters. A pair of
          characters separated by a minus sign denotes a range; any
          character lexically between those two characters,
          inclusive, is matched. If the first character following the
          [ is a ^ then any character not enclosed is matched. No
          other character is special inside this construct. To
          include a ] in a character set, you must make it the first
          character. To include a `-', you must use it in a context
          where it cannot possibly indicate a range: that is, as the
          first character, or immediately after a range.

    |
          specifies an alternative. Two regular expressions A and B
          with | in between form an expression that matches anything
          that either A or B will match.

    {...}
          groups alternatives inside larger patterns.

    \
          Quotes a special character (including itself).

     *Usage:* `pattern(P)'
        - _Description:_ `P' is a pattern to match against.



 - PREDICATE: match_pattern_pred/2:
     *Usage:* `match_pattern_pred(Pred1,Pred2)'
        - _Description:_ Tests if two predicates `Pred1' and `Pred2'
          match using regular expressions.




File: ciao.info,  Node: Graphs,  Next: Unweighted graph-processing utilities,  Prev: Pattern (regular expression) matching,  Up: Top

Graphs
******

   *Author(s):* F. Bueno.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#83 (2000/3/23, 19:23:58 CET)

* Menu:

* Usage and interface (graphs)::
* Documentation on exports (graphs)::
* Documentation on internals (graphs)::


File: ciao.info,  Node: Usage and interface (graphs),  Next: Documentation on exports (graphs),  Prev: Graphs,  Up: Graphs

Usage and interface (`graphs')
==============================

   * *Library usage:*

     `:- use_module(library(graphs)).'

   * *Exports:*
        - _Predicates:_

          `dgraph_to_ugraph/2', `dlgraph_to_lgraph/2',
          `edges_to_ugraph/2', `edges_to_lgraph/2'.

        - _Regular Types:_

          `dgraph/1', `dlgraph/1'.


   * *Other modules used:*
        - _System library modules:_

          `sort', `graphs/ugraphs', `graphs/lgraphs'.




File: ciao.info,  Node: Documentation on exports (graphs),  Next: Documentation on internals (graphs),  Prev: Usage and interface (graphs),  Up: Graphs

Documentation on exports (`graphs')
===================================

 - REGTYPE: dgraph/1:
     `dgraph(Graph)'

     A directed graph is a term `graph(V,E)' where `V' is a list of
     vertices and `E' is a list of edges (none necessarily sorted).
     Edges are pairs of vertices which are directed, i.e., `(a,b)'
     represents `a->b'. Two vertices `a' and `b' are equal only if
     `a==b'.

     *Usage:* `dgraph(Graph)'
        - _Description:_ `Graph' is a directed graph.



 - REGTYPE: dlgraph/1:
     `dlgraph(Graph)'

     A labeled directed graph is a directed graph where edges are
     triples of the form `(a,l,b)' where `l' is the label of the edge
     `(a,b)'.

     *Usage:* `dlgraph(Graph)'
        - _Description:_ `Graph' is a directed labeled graph.



 - PREDICATE: dgraph_to_ugraph/2:
     *Usage:* `dgraph_to_ugraph(+Graph,-UGraph)'
        - _Description:_ Converts `Graph' to `UGraph'.

        - _The following properties should hold at call time:_

          `+Graph' is a directed graph.   (`graphs:dgraph/1')

          `-UGraph' is a free variable.   (`term_typing:var/1')

        - _The following properties should hold upon exit:_

          `+Graph' is a directed graph.   (`graphs:dgraph/1')

          `-UGraph' is an ugraph.   (`ugraphs:ugraph/1')



 - PREDICATE: dlgraph_to_lgraph/2:
     *Usage:* `dlgraph_to_lgraph(+Graph,-LGraph)'
        - _Description:_ Converts `Edges' to `LGraph'.

        - _The following properties should hold at call time:_

          `+Graph' is a directed labeled graph.   (`graphs:dlgraph/1')

          `-LGraph' is a free variable.   (`term_typing:var/1')

        - _The following properties should hold upon exit:_

          `+Graph' is a directed labeled graph.   (`graphs:dlgraph/1')

          `-LGraph' is a labeled graph of `term' terms.
          (`lgraphs:lgraph/2')



 - PREDICATE: edges_to_ugraph/2:
     *Usage:* `edges_to_ugraph(+Edges,-UGraph)'
        - _Description:_ Converts `Graph' to `UGraph'.

        - _The following properties should hold at call time:_

          `+Edges' is a list of `pair's.   (`basic_props:list/2')

          `-UGraph' is a free variable.   (`term_typing:var/1')

        - _The following properties should hold upon exit:_

          `+Edges' is a list of `pair's.   (`basic_props:list/2')

          `-UGraph' is an ugraph.   (`ugraphs:ugraph/1')



 - PREDICATE: edges_to_lgraph/2:
     *Usage:* `edges_to_lgraph(+Edges,-LGraph)'
        - _Description:_ Converts `Edges' to `LGraph'.

        - _The following properties should hold at call time:_

          `+Edges' is a list of `triple's.   (`basic_props:list/2')

          `-LGraph' is a free variable.   (`term_typing:var/1')

        - _The following properties should hold upon exit:_

          `+Edges' is a list of `triple's.   (`basic_props:list/2')

          `-LGraph' is a labeled graph of `term' terms.
          (`lgraphs:lgraph/2')




File: ciao.info,  Node: Documentation on internals (graphs),  Prev: Documentation on exports (graphs),  Up: Graphs

Documentation on internals (`graphs')
=====================================

 - REGTYPE: pair/1:
     *Usage:* `pair(P)'
        - _Description:_ `P' is a pair `(_,_)'.



 - REGTYPE: triple/1:
     *Usage:* `triple(P)'
        - _Description:_ `P' is a triple `(_,_,_)'.




File: ciao.info,  Node: Unweighted graph-processing utilities,  Next: wgraphs (library),  Prev: Graphs,  Up: Top

Unweighted graph-processing utilities
*************************************

   *Author(s):* M. Carlsson, adapted from shared code written by
Richard A O'Keefe. Mods by F.Bueno and M.Carro..

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 0.9#105 (1999/6/4, 12:24:49 MEST)

   An unweighted directed graph (ugraph) is represented as a list of
(vertex-neighbors) pairs, where the pairs are in standard order (as
produced by keysort with unique keys) and the neighbors of each
vertex are also in standard order (as produced by sort), and every
neighbor appears as a vertex even if it has no neighbors itself.

   An undirected graph is represented as a directed graph where for
each edge `(U,V)' there is a symmetric edge `(V,U)'.

   An edge `(U,V)' is represented as the term `U-V'.

   A vertex can be any term. Two vertices are distinct iff they are
not identical ( `==/2').

   A path is represented as a list of vertices. No vertex can appear
twice in a path.

* Menu:

* Usage and interface (ugraphs)::
* Documentation on exports (ugraphs)::


File: ciao.info,  Node: Usage and interface (ugraphs),  Next: Documentation on exports (ugraphs),  Prev: Unweighted graph-processing utilities,  Up: Unweighted graph-processing utilities

Usage and interface (`ugraphs')
===============================

   * *Library usage:*

     `:- use_module(library(ugraphs)).'

   * *Exports:*
        - _Predicates:_

          `vertices_edges_to_ugraph/3', `neighbors/3', `edges/2',
          `del_vertices/3', `vertices/2', `add_vertices/3',
          `add_edges/3', `transpose/2', `point_to/3'.

        - _Regular Types:_

          `ugraph/1'.


   * *Other modules used:*
        - _System library modules:_

          `sets', `sort'.




File: ciao.info,  Node: Documentation on exports (ugraphs),  Prev: Usage and interface (ugraphs),  Up: Unweighted graph-processing utilities

Documentation on exports (`ugraphs')
====================================

 - PREDICATE: vertices_edges_to_ugraph/3:
     No further documentation available for this predicate.




 - PREDICATE: neighbors/3:
     *Usage:* `neighbors(+Vertex,+Graph,-Neighbors)'
        - _Description:_ Is true if `Vertex' is a vertex in `Graph'
          and `Neighbors' are its neighbors.



 - PREDICATE: edges/2:
     *Usage:* `edges(+Graph,-Edges)'
        - _Description:_ Unifies `Edges' with the edges in `Graph'.



 - PREDICATE: del_vertices/3:
     *Usage:* `del_vertices(+Graph1,+Vertices,-Graph2)'
        - _Description:_ Is true if `Graph2' is `Graph1' with
          `Vertices' and all edges to and from `Vertices' removed
          from it.



 - PREDICATE: vertices/2:
     *Usage:* `vertices(+Graph,-Vertices)'
        - _Description:_ Unifies `Vertices' with the vertices in
          `Graph'.



 - PREDICATE: add_vertices/3:
     *Usage:* `add_vertices(+Graph1,+Vertices,-Graph2)'
        - _Description:_ Is true if `Graph2' is `Graph1' with
          `Vertices' added to it.



 - PREDICATE: add_edges/3:
     *Usage:* `add_edges(+Graph1,+Edges,-Graph2)'
        - _Description:_ Is true if `Graph2' is `Graph1' with `Edges'
          and their 'to' and 'from' vertices added to it.



 - PREDICATE: transpose/2:
     *Usage:* `transpose(+Graph,-Transpose)'
        - _Description:_ Is true if `Transpose' is the graph computed
          by replacing each edge `(u,v)' in `Graph' by its symmetric
          edge `(v,u)'. It can only be used one way around. The cost
          is O(N^2).



 - PREDICATE: point_to/3:
     *Usage:* `point_to(+Vertex,+Graph,-Point_to)'
        - _Description:_ Is true if `Point_to' is the list of nodes
          which go directly to `Vertex' in `Graph'.



 - REGTYPE: ugraph/1:
     *Usage:* `ugraph(Graph)'
        - _Description:_ `Graph' is an ugraph.




File: ciao.info,  Node: wgraphs (library),  Next: Labeled graph-processing utilities,  Prev: Unweighted graph-processing utilities,  Up: Top

wgraphs (library)
*****************

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 0.4#5 (1998/2/24)

* Menu:

* Usage and interface (wgraphs)::
* Documentation on exports (wgraphs)::


File: ciao.info,  Node: Usage and interface (wgraphs),  Next: Documentation on exports (wgraphs),  Prev: wgraphs (library),  Up: wgraphs (library)

Usage and interface (`wgraphs')
===============================

   * *Library usage:*

     `:- use_module(library(wgraphs)).'

   * *Exports:*
        - _Predicates:_

          `vertices_edges_to_wgraph/3'.


   * *Other modules used:*
        - _System library modules:_

          `sets', `sort'.




File: ciao.info,  Node: Documentation on exports (wgraphs),  Prev: Usage and interface (wgraphs),  Up: wgraphs (library)

Documentation on exports (`wgraphs')
====================================

 - PREDICATE: vertices_edges_to_wgraph/3:
     No further documentation available for this predicate.





File: ciao.info,  Node: Labeled graph-processing utilities,  Next: queues (library),  Prev: wgraphs (library),  Up: Top

Labeled graph-processing utilities
**********************************

   *Author(s):* F. Bueno.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   See the comments for the `ugraphs' library.

* Menu:

* Usage and interface (lgraphs)::
* Documentation on exports (lgraphs)::


File: ciao.info,  Node: Usage and interface (lgraphs),  Next: Documentation on exports (lgraphs),  Prev: Labeled graph-processing utilities,  Up: Labeled graph-processing utilities

Usage and interface (`lgraphs')
===============================

   * *Library usage:*

     `:- use_module(library(lgraphs)).'

   * *Exports:*
        - _Predicates:_

          `vertices_edges_to_lgraph/3'.

        - _Regular Types:_

          `lgraph/2'.


   * *Other modules used:*
        - _System library modules:_

          `sort', `sets'.




File: ciao.info,  Node: Documentation on exports (lgraphs),  Prev: Usage and interface (lgraphs),  Up: Labeled graph-processing utilities

Documentation on exports (`lgraphs')
====================================

 - REGTYPE: lgraph/2:
     *Usage:* `lgraph(Graph,Type)'
        - _Description:_ `Graph' is a labeled graph of `Type' terms.



 - PREDICATE: vertices_edges_to_lgraph/3:
     No further documentation available for this predicate.





File: ciao.info,  Node: queues (library),  Next: Random numbers,  Prev: Labeled graph-processing utilities,  Up: Top

queues (library)
****************

   *Version:* 0.4#5 (1998/2/24)

* Menu:

* Usage and interface (queues)::
* Documentation on exports (queues)::


File: ciao.info,  Node: Usage and interface (queues),  Next: Documentation on exports (queues),  Prev: queues (library),  Up: queues (library)

Usage and interface (`queues')
==============================

   * *Library usage:*

     `:- use_module(library(queues)).'

   * *Exports:*
        - _Predicates:_

          `q_empty/1', `q_insert/3', `q_member/2', `q_delete/3'.




File: ciao.info,  Node: Documentation on exports (queues),  Prev: Usage and interface (queues),  Up: queues (library)

Documentation on exports (`queues')
===================================

 - PREDICATE: q_empty/1:
     No further documentation available for this predicate.




 - PREDICATE: q_insert/3:
     No further documentation available for this predicate.




 - PREDICATE: q_member/2:
     No further documentation available for this predicate.




 - PREDICATE: q_delete/3:
     No further documentation available for this predicate.





File: ciao.info,  Node: Random numbers,  Next: sets (library),  Prev: queues (library),  Up: Top

Random numbers
**************

   *Author(s):* Daniel Cabeza.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#150 (2000/5/24, 20:0:38 CEST)

   This module provides predicates for generating pseudo-random
numbers

* Menu:

* Usage and interface (random)::
* Documentation on exports (random)::


File: ciao.info,  Node: Usage and interface (random),  Next: Documentation on exports (random),  Prev: Random numbers,  Up: Random numbers

Usage and interface (`random')
==============================

   * *Library usage:*

     `:- use_module(library(random)).'

   * *Exports:*
        - _Predicates:_

          `random/1', `random/3', `srandom/1'.




File: ciao.info,  Node: Documentation on exports (random),  Prev: Usage and interface (random),  Up: Random numbers

Documentation on exports (`random')
===================================

 - PREDICATE: random/1:
     `random(Number)'

     `Number' is a (pseudo-) random number in the range [0.0,1.0]




 - PREDICATE: random/3:
     `random(Low,Up,Number)'

     `Number' is a (pseudo-) random number in the range [`Low', `Up']

     *Usage 1:* `random(+int,+int,-int)'
        - _Description:_ If `Low' and `Up' are integers, `Number' is
          an integer.



 - PREDICATE: srandom/1:
     `srandom(Seed)'

     Changes the sequence of pseudo-random numbers according to
     `Seed'. The stating sequence of numbers generated can be
     duplicated by calling the predicate with `Seed' unbound (the
     sequence depends on the OS).





File: ciao.info,  Node: sets (library),  Next: Variable name dictionaries,  Prev: Random numbers,  Up: Top

sets (library)
**************

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 0.9#17 (1999/3/23, 20:57:20 MET)

   This module implements set operations. Sets are just ordered lists.

* Menu:

* Usage and interface (sets)::
* Documentation on exports (sets)::


File: ciao.info,  Node: Usage and interface (sets),  Next: Documentation on exports (sets),  Prev: sets (library),  Up: sets (library)

Usage and interface (`sets')
============================

   * *Library usage:*

     `:- use_module(library(sets)).'

   * *Exports:*
        - _Predicates:_

          `insert/3', `ord_delete/3', `ord_member/2',
          `ord_test_member/3', `ord_subtract/3', `ord_intersection/3',
          `ord_intersection_diff/4', `ord_intersect/2',
          `ord_subset/2', `ord_subset_diff/3', `ord_union/3',
          `ord_union_diff/4', `ord_union_symdiff/4',
          `ord_union_change/3', `merge/3', `ord_disjoint/2',
          `setproduct/3'.


   * *Other modules used:*
        - _System library modules:_

          `sort'.




File: ciao.info,  Node: Documentation on exports (sets),  Prev: Usage and interface (sets),  Up: sets (library)

Documentation on exports (`sets')
=================================

 - PREDICATE: insert/3:
     *Usage:* `insert(+Set1,+Element,-Set2)'
        - _Description:_ It is true when `Set2' is `Set1' with
          `Element' inserted in it, preserving the order.



 - PREDICATE: ord_delete/3:
     *Usage:* `ord_delete(+Set0,+X,-Set)'
        - _Description:_ It succeeds if `Set' is `Set0' without
          element `X'.



 - PREDICATE: ord_member/2:
     *Usage:* `ord_member(+X,+Set)'
        - _Description:_ It succeeds if `X' is member of `Set'.



 - PREDICATE: ord_test_member/3:
     *Usage:* `ord_test_member(+Set,+X,-Result)'
        - _Description:_ If `X' is member of `Set' then
          `Result'=`yes'. Otherwise `Result'=`no'.



 - PREDICATE: ord_subtract/3:
     *Usage:* `ord_subtract(+Set1,+Set2,?(Difference))'
        - _Description:_ It is true when `Difference' contains all
          and only the elements of `Set1' which are not also in
          `Set2'.



 - PREDICATE: ord_intersection/3:
     *Usage:* `ord_intersection(+Set1,+Set2,?(Intersection))'
        - _Description:_ It is true when `Intersection' is the
          ordered representation of `Set1' and `Set2', provided that
          `Set1' and `Set2' are ordered lists.



 - PREDICATE: ord_intersection_diff/4:
     *Usage:*
     `ord_intersection_diff(+Set1,+Set2,-Intersect,-NotIntersect)'
        - _Description:_ `Intersect' contains those elements which
          are both in `Set1' and `Set2', and `NotIntersect' those
          which are in `Set1' but not in `Set2'.



 - PREDICATE: ord_intersect/2:
     *Usage:* `ord_intersect(+Xs,+Ys)'
        - _Description:_ Succeeds when the two ordered lists have at
          least one element in common.



 - PREDICATE: ord_subset/2:
     *Usage:* `ord_subset(+Xs,+Ys)'
        - _Description:_ Succeeds when every element of `Xs' appears
          in `Ys'.



 - PREDICATE: ord_subset_diff/3:
     *Usage:* `ord_subset_diff(+Set1,+Set2,-Difference)'
        - _Description:_ It succeeds when every element of `Set1'
          appears in `Set2' and `Difference' has the elements of
          `Set2' which are not in `Set1'.



 - PREDICATE: ord_union/3:
     *Usage:* `ord_union(+Set1,+Set2,?(Union))'
        - _Description:_ It is true when `Union' is the union of
          `Set1' and `Set2'. When some element occurs in both sets,
          `Union' retains only one copy.



 - PREDICATE: ord_union_diff/4:
     *Usage:* `ord_union_diff(+Set1,+Set2,-Union,-Difference)'
        - _Description:_ It succeeds when `Union' is the union of
          `Set1' and `Set2', and `Difference' is `Set2' set-minus
          `Set1'.



 - PREDICATE: ord_union_symdiff/4:
     *Usage:* `ord_union_symdiff(+Set1,+Set2,-Union,-Diff)'
        - _Description:_ It is true when Diff is the symmetric
          difference of Set1 and Set2, and Union is the union of Set1
          and Set2.



 - PREDICATE: ord_union_change/3:
     *Usage:* `ord_union_change(+Set1,+Set2,-Union)'
        - _Description:_ `Union' is the union of `Set1' and `Set2'
          and `Union' is different from `Set2'.



 - PREDICATE: merge/3:
     *Usage:* `merge(+Set1,+Set2,?(Union))'
        - _Description:_ See `ord_union/3'.



 - PREDICATE: ord_disjoint/2:
     *Usage:* `ord_disjoint(+Set1,+Set2)'
        - _Description:_ `Set1' and `Set2' have no element in common.



 - PREDICATE: setproduct/3:
     *Usage:* `setproduct(+Set1,+Set2,-Product)'
        - _Description:_ `Product' has all two element sets such that
          one element is in `Set1' and the other in `set2', except
          that if the same element belongs to both, then the
          corresponding one element set is in `Product'.




File: ciao.info,  Node: Variable name dictionaries,  Next: *** PART X - Miscellaneous standalone utilities,  Prev: sets (library),  Up: Top

Variable name dictionaries
**************************

   *Author(s):* Francisco Bueno.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 0.8#19 (1998/12/3, 12:53:16 MET)

* Menu:

* Usage and interface (vndict)::
* Documentation on exports (vndict)::


File: ciao.info,  Node: Usage and interface (vndict),  Next: Documentation on exports (vndict),  Prev: Variable name dictionaries,  Up: Variable name dictionaries

Usage and interface (`vndict')
==============================

   * *Library usage:*

     `:- use_module(library(vndict)).'

   * *Exports:*
        - _Predicates:_

          `create_dict/2', `complete_dict/3', `complete_vars_dict/3',
          `prune_dict/3', `dict2varnamesl/2', `varnamesl2dict/2',
          `find_name/4', `rename/2', `vars_names_dict/3'.

        - _Regular Types:_

          `null_dict/1', `varname/1', `varnamesl/1', `varnamedict/1'.


   * *Other modules used:*
        - _System library modules:_

          `idlists', `metaterms', `sets', `sort'.




File: ciao.info,  Node: Documentation on exports (vndict),  Prev: Usage and interface (vndict),  Up: Variable name dictionaries

Documentation on exports (`vndict')
===================================

 - REGTYPE: null_dict/1:
     *Usage:* `null_dict(D)'
        - _Description:_ `D' is an empty dictionary.



 - PREDICATE: create_dict/2:
     *Usage:* `create_dict(Term,Dict)'
        - _Description:_ `Dict' has names for all variables in `Term'.

        - _The following properties should hold at call time:_

          `Term' is any term.   (`basic_props:term/1')

        - _The following properties should hold upon exit:_

          `Dict' is a dictionary of variable names.
          (`vndict:varnamedict/1')



 - PREDICATE: complete_dict/3:
     *Usage:* `complete_dict(+Dict,+Term,-NewDict)'
        - _Description:_ `NewDict' is `Dict' augmented with the
          variables of `Term' not yet in `Dict'.



 - PREDICATE: complete_vars_dict/3:
     *Usage:* `complete_vars_dict(+Dict,+Vars,-NewDict)'
        - _Description:_ `NewDict' is `Dict' augmented with the
          variables of the list `Vars' not yet in `Dict'.



 - PREDICATE: prune_dict/3:
     *Usage:* `prune_dict(+Term,+Dict,-NewDict)'
        - _Description:_ `NewDict' is `Dict' reduced to just the
          variables of `Term'.



 - PREDICATE: dict2varnamesl/2:
     *Usage:* `dict2varnamesl(Dict,VNs)'
        - _Description:_ Translates `Dict' to `VNs'.

        - _The following properties should hold at call time:_

          `Dict' is a dictionary of variable names.
          (`vndict:varnamedict/1')

        - _The following properties should hold upon exit:_

          `VNs' is a list of `Name=Var', for a variable `Var' and its
          name `Name'.   (`vndict:varnamesl/1')



 - PREDICATE: varnamesl2dict/2:
     *Usage:* `varnamesl2dict(VNs,Dict)'
        - _Description:_ Translates `VNs' to `Dict'.

        - _The following properties should hold at call time:_

          `VNs' is a list of `Name=Var', for a variable `Var' and its
          name `Name'.   (`vndict:varnamesl/1')

        - _The following properties should hold upon exit:_

          `Dict' is a dictionary of variable names.
          (`vndict:varnamedict/1')



 - PREDICATE: find_name/4:
     `find_name(Vars,Names,V,Name)'

     Given that `vars_names_dict(Dict,Vars,Names)' holds, it acts as
     `rename(X,Dict)', but the name of `X' is given as `Name' instead
     of unified with it.




 - PREDICATE: rename/2:
     *Usage:* `rename(Term,Dict)'
        - _Description:_ Unifies each variable in `Term' with its
          name in `Dict'. If no name is found, a new name is created.

        - _The following properties should hold at call time:_

          `Dict' is a dictionary of variable names.
          (`vndict:varnamedict/1')



 - REGTYPE: varname/1:
     *Usage:* `varname(N)'
        - _Description:_ `N' is term representing a variable name.



 - REGTYPE: varnamesl/1:
     *Usage:* `varnamesl(D)'
        - _Description:_ `D' is a list of `Name=Var', for a variable
          `Var' and its name `Name'.



 - REGTYPE: varnamedict/1:
     *Usage:* `varnamedict(D)'
        - _Description:_ `D' is a dictionary of variable names.



 - PREDICATE: vars_names_dict/3:
     *Usage:* `vars_names_dict(Dict,Vars,Names)'
        - _Description:_ `Varss' is a sorted list of variables, and
          `Names' is a list of their names, which correspond in the
          same order.

        - _Call and exit should be _compatible_ with:_

          `Dict' is a dictionary of variable names.
          (`vndict:varnamedict/1')

          `Vars' is a list.   (`basic_props:list/1')

          `Names' is a list.   (`basic_props:list/1')




File: ciao.info,  Node: *** PART X - Miscellaneous standalone utilities,  Next: A Program to Help Cleaning your Directories,  Prev: Variable name dictionaries,  Up: Top

PART X - Miscellaneous standalone utilities
*******************************************

   *Author(s):* <clip@clip.dia.fi.upm.es>,
`http://www.clip.dia.fi.upm.es/', The CLIP Group, School of Computer
Science, Technical University of Madrid.

   This is the documentation for a set of miscellaneous standalone
utilities contained in the `etc' directory of the Ciao distribution.


File: ciao.info,  Node: A Program to Help Cleaning your Directories,  Next: Printing the declarations and code in a file,  Prev: *** PART X - Miscellaneous standalone utilities,  Up: Top

A Program to Help Cleaning your Directories
*******************************************

   *Author(s):* Manuel Carro.

   *Version:* 0.1#2 (2000/6/1, 17:57:19 CEST)

   A simple program for traversing a directory tree and deciding
which files may be deleted in order to save space and not to loose
information.

* Menu:

* Usage (cleandirs)::
* Known bugs and planned improvements (cleandirs)::


File: ciao.info,  Node: Usage (cleandirs),  Next: Known bugs and planned improvements (cleandirs),  Prev: A Program to Help Cleaning your Directories,  Up: A Program to Help Cleaning your Directories

Usage (cleandirs)
=================


     cleandirs: <initial_dir> <delete_options> <backup_options>
     cleandirs explores <initial_dir> (which should be an absolute path)
     and looks for backup files and files which can be generated from other
     files, using a plausible heuristic aimed at retaining the same amount
     of information while recovering some disk space.  The heuristic is
     based on the extension of the filename.
     
     Delete options is one of:
        --list: just list the files/directories which are amenable to be deleted,
                but do not delete them. SAFE.
         --ask: list the files/directories and ask for deletion. UNSAFE if you
                make a mistake.
      --delete: just delete the files/directories without asking.  I envy your
                brave soul if you choose this option.
     
     Backup options is one of:
      --includebackups: include backup files in the list of files to check.
      --excludebackups: do not include backup files in the list of files to check.
         --onlybackups: include only backup files in the list of files to check.
     
     Symbolic links are not traversed.  Special files are not checked.

   Invoking the program with no arguments will return an up-to-date
information on the options.


File: ciao.info,  Node: Known bugs and planned improvements (cleandirs),  Prev: Usage (cleandirs),  Up: A Program to Help Cleaning your Directories

Known bugs and planned improvements (`cleandirs')
=================================================

   * Recursive removal of subdirectories relies on the existence of a
     recursive /bin/rm command in your system.


File: ciao.info,  Node: Printing the declarations and code in a file,  Next: Printing the contents of a bytecode file,  Prev: A Program to Help Cleaning your Directories,  Up: Top

Printing the declarations and code in a file
********************************************

   *Author(s):* Manuel Hermenegildo.

   *Version:* 0.5#6 (1999/4/15, 20:33:6 MEST)

   A simple program for printing assertion information ( predicate
declarations, property declarations, type declarations, etc.) and
printing code-related information ( imports, exports, libraries used,
etc.) on a file. The file should be a single CIAO or Prolog source
file. It uses the CIAO compiler's pass one to do it. This program is
specially useful for example to check what the compiler is actually
seeing after syntactic expansions, as well as for checking what
assertions the assertion normalizer is producing from the original
assertions in the file.

* Menu:

* Usage (fileinfo)::
* More detailed explanation of options (fileinfo)::


File: ciao.info,  Node: Usage (fileinfo),  Next: More detailed explanation of options (fileinfo),  Prev: Printing the declarations and code in a file,  Up: Printing the declarations and code in a file

Usage (fileinfo)
================


         fileinfo -asr <filename.asr>
            : pretty prints the contents of <filename.asr>
     
         fileinfo [-v] [-m] <-a|-c|-e> <filename> [libdir1] ... [libdirN]
         -v : verbose output (e.g., lists all files read)
         -m : restrict info to current module
         -a : print assertions
         -c : print code and interface (imports/exports, etc.)
         -e : print only errors - useful to check syntax of assertions in file
     
         fileinfo -h
            : print this information


File: ciao.info,  Node: More detailed explanation of options (fileinfo),  Prev: Usage (fileinfo),  Up: Printing the declarations and code in a file

More detailed explanation of options (fileinfo)
===============================================

   * If the `-a' option is selected, `fileinfo' prints the assertions
     (only code-oriented assertions - not comment-oriented
     assertions) in the file _after normalization_. If the `-c'
     option is selected `fileinfo' prints the file interface, the
     declarations contained in the file, and the actual code. If the
     `-e' option is selected `fileinfo' prints only any sintactic and
     import-export errors found in the file, including the assertions.

   * `filename' must be the name of a Prolog or CIAO source file.

   * This filename can be followed by other arguments which will be
     taken to be library directory paths in which to look for files
     used by the file being analyzed.

   * If the `-m' option is selected, only the information related to
     the current module is printed.

   * The `-v' option produces verbose output. This is very useful for
     debugging, since all the files accessed during assertion
     normalization are listed.

   * In the `-asr' usage, `fileinfo' can be used to print the
     contents of a `.asr' file in human-readable form.



File: ciao.info,  Node: Printing the contents of a bytecode file,  Next: Crossed-references of a program,  Prev: Printing the declarations and code in a file,  Up: Top

Printing the contents of a bytecode file
****************************************

   *Author(s):* Daniel Cabeza.

   *Version:* 0.5#2 (1999/11/11, 19:20:50 MET)

   This simple program takes as an argument a bytecode (.po) file and
prints out in symbolic form the information contained in the file. It
uses compiler and engine builtins to do so, so that it keeps track
with changes in bytecode format.

* Menu:

* Usage (viewpo)::


File: ciao.info,  Node: Usage (viewpo),  Prev: Printing the contents of a bytecode file,  Up: Printing the contents of a bytecode file

Usage (viewpo)
==============


     	viewpo <file1>.po
     	   : print .po contents in symbolic form
     
     	viewpo -h
     	   : print this information


File: ciao.info,  Node: Crossed-references of a program,  Next: Gathering the dependent files for a file,  Prev: Printing the contents of a bytecode file,  Up: Top

Crossed-references of a program
*******************************

   *Author(s):* Francisco Bueno.

   The `xrefs' crossed-references Ciao library includes several
modules which allow displaying crossed-references of the code in a
program. Crossed-references identify modules which import code from
other modules, or files (be them modules or not) which use code in
other files. Crossed-references can be obtained as a term
representing a graph, displayed graphically (using daVinci, a graph
displayer developed by U. of Bremen, Germany), or printed as a list.

   The libraries involved are as follows:
   * `etc(xmrefs)' displays a graph of crossed-references between
     modules using daVinci,

   * `etc(xfrefs)' displays a graph of crossed-references between
     files using daVinci,

   * `library(xrefs)' obtains a graph of crossed-references between
     files,

   * `library('xrefs/mrefs')' obtains a graph of crossed-references
     between modules,

   * `library('xrefs/pxrefs')' prints a list of crossed-references
     between files.
   The first two are intended to be used by loading in `ciaosh'. The
other three are intended to be used as modules within an application.

   The following is an example graph of the library modules involved
in the crossed-references application. It has been obtained with:
     [ciao/etc]> ciaosh
     Ciao-Prolog 1.5 #24: Tue Dec 28 14:12:11 CET 1999
     ?- use_module(xmrefs).
     
     yes
     ?- set_flag(X).
     
     X = 3 ?
     
     yes
     ?- set_files([xfrefs, xmrefs,
                   library(xrefs),
                   library('xrefs/mrefs'),
                   library('xrefs/pxrefs'),
                   library('xrefs/xrefs2graph'),
                   library('xrefs/xrefsbuild'),
                   library('xrefs/xrefsread')
     	     ]).
     
     yes
     ?- xmrefs.

so that it is displayed by daVinci as:


[Image file: autofigxmgraph.eps]

   The following is an example graph of the same module files, where
crossed-references have been obtained with `xfrefs:xfrefs(whodefs)'
instead of `xmrefs:xmrefs':


[Image file: autofigxfgraph.eps]

   For more information refer to the xrefs documentation
(`xrefs_doc.dvi') in the source library of the Ciao distribution.


File: ciao.info,  Node: Gathering the dependent files for a file,  Next: Finding differences between two Prolog files,  Prev: Crossed-references of a program,  Up: Top

Gathering the dependent files for a file
****************************************

   *Author(s):* Daniel Cabeza, Manuel Hermenegildo.

   *Version:* 1.0#6 (1998/11/5, 13:56:58 MET)

   This simple program takes a single Ciao or Prolog source filename
(which is typically the main file of an application). It prints out
the list of all the dependent files, i.e., all files needed in order
to build the application, including those which reside in libraries.
This is particularly useful in Makefiles, for building standalone
distributions (e.g., .tar files) automatically.

   The filename should be followed by other arguments which will be
taken to be library directory paths in which to look for files used
by the file being analyzed.

* Menu:

* Usage (get_deps)::


File: ciao.info,  Node: Usage (get_deps),  Prev: Gathering the dependent files for a file,  Up: Gathering the dependent files for a file

Usage (get_deps)
================


     	get_deps [-u <filename>] <filename> [lib_dir1] ... [lib_dirN]
                : return dependent files for <filename>
                  found in [lib_dir1] ... [lib_dirN]
     
     	get_deps -h
                : print this information


File: ciao.info,  Node: Finding differences between two Prolog files,  Next: The Ciao lpmake scripting facility,  Prev: Gathering the dependent files for a file,  Up: Top

Finding differences between two Prolog files
********************************************

   *Author(s):* Francisco Bueno.

   This simple program works like the good old diff but for files
that contain Prolog code. It prints out the clauses that it finds are
different in the files. Its use avoids textual differences such as
different variable names and different formatting of the code in the
files.

* Menu:

* Usage (pldiff)::
* Known bugs and planned improvements (pldiff)::


File: ciao.info,  Node: Usage (pldiff),  Next: Known bugs and planned improvements (pldiff),  Prev: Finding differences between two Prolog files,  Up: Finding differences between two Prolog files

Usage (pldiff)
==============


     	pldiff <file1> <file2>
     	   : find differences
     
     	pldiff -h
     	   : print this information

   but you can also use the program as a library and invoke the
predicate:

        pldiff( <filename> , <filename> )


File: ciao.info,  Node: Known bugs and planned improvements (pldiff),  Prev: Usage (pldiff),  Up: Finding differences between two Prolog files

Known bugs and planned improvements (`pldiff')
==============================================

   * Currently uses variant/2 to compare clauses. This is useful, but
     there should be an option to select the way clauses are
     compared, e.g., some form of equivalence defined by the user.


File: ciao.info,  Node: The Ciao lpmake scripting facility,  Next: Find out which architecture we are running on,  Prev: Finding differences between two Prolog files,  Up: Top

The Ciao lpmake scripting facility
**********************************

   *Author(s):* Manuel Hermenegildo.

   *Note:* `lpmake' and the `make' library are still under active
development, and they may change substantially in future releases.

   `lpmake' is a Ciao application which uses the Ciao `make' library
to implement a dependency-driven scripts in a similar way to the Unix
`make' facility.

   The original purpose of the Unix `make' utility was to determine
automatically which pieces of a large program needed to be
recompiled, and issue the commands to recompile them. In fact, `make'
is often used for many other purposes: it can be used to describe any
task where some files must be updated automatically from others
whenever the others change.

   To prepare to use `lpmake', you must write a file (typically called
`Makefile.pl') that describes the relationships among files in your
program or application, and states the commands for updating each
file. In a program, typically the executable file is updated from
object files, which are in turn made by compiling source files.

   Once a suitable makefile exists, each time you change some source
files, simply typing `lpmake' suffices to perform all necessary
recompilations. The `make' program uses the makefile data base and
the last modification times of the files to decide which of the files
need to be updated. For each of those files, it issues the commands
recorded in the data base.

   `lpmake' executes commands in the `Makefile.pl' to update one or
more target _names_, where _name_ is typically a program, but can
also be a file to be generated or even a "virtual" target. If no `-l'
or `-m' options are present, `lpmake' will look for the makefile
`Makefile.pl'.

   `lpmake' updates a target if it depends on prerequisite files that
have been modified since the target was last modified, or if the
target does not exist.

   You can provide command line arguments to `lpmake' to control
which files should be regenerated, or how.

   *Note:* if you use `make' and `functions', then `make' should
appear before `functions' in the list of packages.


File: ciao.info,  Node: Find out which architecture we are running on,  Next: *** PART XI - Contributed libraries,  Prev: The Ciao lpmake scripting facility,  Up: Top

Find out which architecture we are running on
*********************************************

   *Author(s):* Manuel Carro, Robert Manchek.

   *Version:* 0.0#1 (2000/5/8, 20:27:7 CEST)

   The architecure and operating system the engine is compiled for
determines whether we can use or not certain libraries. This script,
taken from a PVM distribution, uses a heuristic (which may need to be
tuned from time to time) to find out the platform. It returns a
string which is used throughout the engine (in #ifdefs) to
enable/disable certain characteristics.

* Menu:

* Usage (ciao_get_arch)::
* More details::


File: ciao.info,  Node: Usage (ciao_get_arch),  Next: More details,  Prev: Find out which architecture we are running on,  Up: Find out which architecture we are running on

Usage (ciao_get_arch)
=====================

        Usage: ciao_get_arch


File: ciao.info,  Node: More details,  Prev: Usage (ciao_get_arch),  Up: Find out which architecture we are running on

More details
============

   Look at the script itself...


File: ciao.info,  Node: *** PART XI - Contributed libraries,  Next: Programming MYCIN rules,  Prev: Find out which architecture we are running on,  Up: Top

PART XI - Contributed libraries
*******************************

   This part includes a number of libraries which have contributed by
users of the Ciao system. Over time, some of these libraries are
moved to the main library directories of the system.


File: ciao.info,  Node: Programming MYCIN rules,  Next: A Chart Library,  Prev: *** PART XI - Contributed libraries,  Up: Top

Programming MYCIN rules
***********************

   *Author(s):* Angel Fernandez Pineda.

   *Version:* 1.5#172 (2000/7/12, 16:45:31 CEST)

   *Version of last change:* 1.5#59 (2000/2/29, 14:51:54 CET)

   MYCIN databases are declared as Prolog modules containing mycin
rules. Those rules are given a _certainty factor_ (_CF_) which
denotates an expert's credibility on that rule:
   * A value of -1 stands for _surely not_.

   * A value of 1 stands for _certainly_.

   * A value of 0 stands for _I don't know_.


   Intermediate values are allowed.

   Mycin rules work on a different way as Prolog clauses: a rule will
never fail (in the Prolog sense), it will return a certainty value
instead. As a consequence *all* mycin rules will be explored during
inference, so the order in which rules are written is not
significant. For this reason, the usage of the Prolog _cut_ (!) is
discouraged.

* Menu:

* Usage and interface (mycin)::
* Documentation on new declarations (mycin)::
* Known bugs and planned improvements (mycin)::


File: ciao.info,  Node: Usage and interface (mycin),  Next: Documentation on new declarations (mycin),  Prev: Programming MYCIN rules,  Up: Programming MYCIN rules

Usage and interface (`mycin')
=============================

   * *Library usage:*

     In order to declare a mycin database you must include the
     following declaration as the first one in your file:
                     :- mycin(MycinDataBaseName).

   * *New declarations defined:*

     `export/1'.



File: ciao.info,  Node: Documentation on new declarations (mycin),  Next: Known bugs and planned improvements (mycin),  Prev: Usage and interface (mycin),  Up: Programming MYCIN rules

Documentation on new declarations (`mycin')
===========================================

 - DECLARATION: export/1:
     This directive allows a given mycin predicate to be called from
     Prolog programs. The way in which mycin rules are called departs
     from Prolog ones. For instance, the followin mycin predicate:
          :- export p/1.

     must be called from Prolog Programs as: `mycin(p(X),CF)', where
     CF will be binded to the resulting certainty factor. Obviously,
     the variables on _P/1_ may be instantiated as you wish. Since
     the Prolog predicate _mycin/2_ may be imported from several
     mycin databases, it is recommended to fully qualify those
     predicate goals. For example : `mydatabase:mycin(p(X),CF)'.

     *Usage:* :- `export(Spec)'.
        - _Description:_ `Spec' will be a callable mycin predicate.




File: ciao.info,  Node: Known bugs and planned improvements (mycin),  Prev: Documentation on new declarations (mycin),  Up: Programming MYCIN rules

Known bugs and planned improvements (`mycin')
=============================================

   * Not fully implemented.

   * Dynamic mycin predicates not implemented: open question.

   * Importation of user-defined mycin predicates requires further
     design. This includes importation of mycin databases from
     another mycin database.


File: ciao.info,  Node: A Chart Library,  Next: Low level Interface between Prolog and blt,  Prev: Programming MYCIN rules,  Up: Top

A Chart Library
***************

   *Author(s):* Isabel Marti'n Garci'a.

   This library is intended to eaose the task of displaying some
graphical results. This library allows the programmer to visualize
different graphs and tables without knowing anything about specific
graphical packages.

   You need to install the BLT package in your computer. BLT is an
extension to the Tk toolkit and it does not require any patching of
the Tcl or Tk source files. You can find it in
`http://www.tcltk.com/blt/index.html'

   Basically, when the user invokes a predicate, the library
(internally) creates a bltwish interpreter and passes the information
through a socket to display the required widget. The interpreter
parses the received commands and executes them.

   The predicates exported by this library can be classified in four
main groups, according to the types of representation they provide.

   * bar charts

   * line graphs

   * scatter graphs

   * tables

   To represent graphs, the Cartesian coordinate system is used. I
have tried to show simple samples for every library exported
predicate in order to indicate how to call them.

* Menu:

* Bar charts::
* Line graphs::
* Scatter graphs::
* Tables::
* Overview of widgets::
* Usage and interface (chartlib)::
* Documentation on exports (chartlib)::


File: ciao.info,  Node: Bar charts,  Next: Line graphs,  Prev: A Chart Library,  Up: A Chart Library

Bar charts
==========

   In this section we shall introduce the general issues about the
set of barchart predicates. By calling the predicates that pertain to
this group a bar chart for plotting two-dimensional data (X-Y
coordinates) can be created. A bar chart is a graphic means of
comparing numbers by displaying bars of lengths proportional to the
y-coordinates they represented. The barchart widget has many
configurable options such as title, header text, legend and so on.
You can configure the appearance of the bars as well. The bar chart
widget has the following components:

Header text
     The text displayed at the top of the window. If it is `''' no
     text will be displayed.

Save button
     The button placed below the header text. Pops up a dialog box
     for the user to select a file to save the graphic in PostScript
     format.(1)

Bar chart title
     The title of the graph. It is displayed at the top of the bar
     chart graph. If text is `''' no title will be displayed.

X axis title
     X axis title. If text is `''' no x axis title will be displayed.

Y axis title
     Y axis title. If text is `''' no y axis title will be displayed.

X axis
     X coordinate axis. The x axis is drawn at the bottom margin of
     the bar chart graph. The x axis consists of the axis line, ticks
     and tick labels. Tick labels can be numbers or plain text. If
     the labels are numbers, they could be displayed at uniform
     intervals (the numbers are treated as normal text) or depending
     on its x-coodinate value. You can also set limits (maximum and
     minimum) for the x axis, but only if the tick labels are numeric.

Y axis
     Y coordinate axis. You can set limits (maximum and minimum) for
     the y axis. The y axis is drawn at the right margin of the bar
     chart graph.The y axis consists of the axis line, ticks and tick
     labels. The tick labels are numeric values determined from the
     data and are drawn at uniform intervals.

Bar chart graph
     This is the plotting area, placed in the center of the window
     and surrounded by the axes, the axis titles and the legend (if
     any). The range of the axes controls what region of the data is
     plotted. By default, the minimum and maximum limits are
     determined from the data, but you can set them (as mentioned
     before). Data points outside the minimum and maximum value of
     the axes are not plotted.

Legend
     The legend displays the name and symbol of each bar. The legend
     is placed in the right margin of the Bar chart graph.

Footer text
     Text displayed at the lower part of the window. If text is `'''
     no header text will be displayed.

Quit button
     Button placed below the footer text. Click it to close the
     window.

   All of them are arranged in a window. However you can, for
example, show a bar chart window without legend or header text. Other
configuration options will be explained later.

   In addition to the window appearance there is another important
issue about the bar chart window, namely its behaviour in response to
user actions. The association user actions to response is called
_bindings_. The main bindings currently specified are the following:

Default bindings
     Those are well known by most users. They are related to the
     frame displayed around the window. As you know, you can
     interactively move, resize, close, iconify, deiconify, send to
     another desktop etc. a window.

Bindings related to bar chart graph and its legend
     Clicking the left mouse key over a legend element, the
     corresponding bar turns out into red. After clicking again, the
     bar toggles to its original look. In addition, you can do
     zoom-in by pressing the left mouse key over the bar chart graph
     and dragging to select an area. To zoom out simply press the
     right mouse button.

     When the pointer passes over the plotting area the cross hairs
     are drawn. The cross hairs consists of two intersecting lines
     (one vertical and one horizontal). Besides, if the pointer is
     over a legend element, its background changes.

Bindings related to buttons
     There are two buttons in the main widget. Clicking the mouse on
     the Save button a "Save as" dialog box is popped up. The user
     can select a file to save the graph. If the user choose a file
     that already exists, the dialog box prompts the user for
     confirmation on whether the existing file should be overwritten
     or not. Furthermore, you can close the widget by clicking on the
     Quit button.

     When the pointer passes over a button the button color changes.

   The predicates that belong to this group are those whose names
begin with *barchart* and *genmultibar*. If you take a look at the
predicate names that pertain to this group, you will notice that they
are not self-explanatory. It would have been better to name the
predicates in a way that allows the user to identify the predicate
features by its name, but it would bring about very long names (i.e
barchart_WithoutLegend_BarsAtUniformIntervals_RandomBarsColors). For
this reason I decided to simply add a number after barchart to name
them.

   ---------- Footnotes ----------

   (1) Limitation: Some printers can have problems if the PostScript
file is too complex (i.e. too many points/lines appear in the
picture).


File: ciao.info,  Node: Line graphs,  Next: Scatter graphs,  Prev: Bar charts,  Up: A Chart Library

Line graphs
===========

   It is frequently the case that several datasets need to be
displayed on the same plot. If so, you may wish to distinguish the
points in different datasets by joining them by lines of different
color, or by plotting with symbols of different types. This set of
predicates allows the programmer to represent two-dimensional data
(X-Y coordinates). Each dataset contains x and y vectors containing
the coordinates of the data. You can configure the appearance of the
points and the lines which the points are connected with. The
configurable line graph components are:

line graph
     This is the plotting area, placed in the center of the window
     and surrounded by the axes, the axes titles and the legend (if
     any). The range of the axes controls what region of the data is
     plotted. By default, the minimum and maximum limits are
     determined from the data, but you can set them. Data points
     outside the minimum and maximum value of the axes are not
     plotted. You can specify how connecting line segments joining
     successive datapoints are drawn by setting the `Smooth'
     argument. Smooth can be either linear, step, natural and
     quadratic. Furthermore, you can select the appearance of the
     points and lines.

Legend
     The legend displays the name and symbol of each line. The legend
     is placed in the right margin of the graph.

   The elements header, footer, quit and save buttons, the titles and
the axes are quite similar to those in barchart graphs, except in
that the tick labels will be numbers. All of them are arranged in a
window by the geometry manager. However you can, as we mentioned in
the above paragraphs, show a line graph window without any titles or
footer text. Other configuration options will be explained later in
this section or in the corresponding modules.

   Related to the behaviour of the widgets in response to user
actions (bindings) we will remark the following features:

Bindings related to line graph and its legend
     Clicking the left mouse key over a legend element, the
     corresponding line turns out into blue. Repeating the action
     reverts the line to its original color. Moreover, you can do
     zoom-in by clicking the left mouse key over the bar chart graph
     and dragging a rectangle defining the area you want to zoom in.
     To zoom out simply press the right mouse button.

     When the pointer passes over the plotting area the cross hairs
     are drawn. The cross hairs consists of two intersecting lines
     (one vertical and one horizontal). Besides, if the pointer is
     over a legend element, its background changes.

Other bindings
     The default bindings and the bindings related to the save and
     quit buttons are similar to those in the bar chart graphs.

   The predicates that belong to this group are those whose names
begin with *graph_*.


File: ciao.info,  Node: Scatter graphs,  Next: Tables,  Prev: Line graphs,  Up: A Chart Library

Scatter graphs
==============

   The challenge of this section is to introduce some general aspects
about the scatter graph predicates group. By invoking the scatter
graph predicates the user can represent two-dimensional point
datasets. Often you need to display one or several point datasets on
the same plot. If so, you may wish to distinguish the points that
pertain to different datasets by using plotting symbols of different
types, or by displaying them in different colors. This set of
predicates allows you to represent two-dimensional data (X-Y
coordinates). Each dataset contains x and y vectors containing the
coordinates of the data. You can configure the appearance of the
points. The configurable scatter graph components are:

scatter graph
     This is the plotting area, placed in the center of the window
     and surrounded by the axes, the axes titles and the legend (if
     any). The range of the axes controls what region of the data is
     plotted. By default, the minimum and maximum limits are
     determined from the data, but you can set them (as we mentioned
     before). Data points outside the minimum and maximum value of
     the axes are not plotted. The user can select the appearance of
     the points.

Legend
     The legend displays the name and symbol of each point dataset.
     The legend is drawn in the right margin of the graph.

   The elements header, footer, quit and save buttons, the titles and
the axes are similar to those in barchart graphs except for that, as
in line graphs, the tick labels will be numbers. All of them are
arranged in a window by the geometry manager. However you can, for
example, show a scatter graph window without titles or footer text,
as we mentioned before. Other configuration options will be explained
later, in the corresponding modules.

   Related to the behaviour of the widgets in response to user
actions (bindings) the following features are:

Bindings related to scatter graph and its legend
     Clicking the left mouse key over a legend element, the points
     which belong to the corresponding dataset turn out into blue.
     Repeating the action toggles the point dataset to its original
     color. Moreover, you can do zoom-in by clicking the left mouse
     key over the bar chart graph and dragging a rectangle defining
     the area you want to zoom-in on. To do zoom-out simply press the
     right mouse button.

     When the pointer passes over the plotting area the cross hairs
     are drawn. The cross hairs consists of two intersecting lines
     (one vertical and one horizontal). Besides, if the pointer is
     over a legend element, its background changes.

Other bindings
     The default bindings and the bindings related to the save and
     quit buttons are similar to those in the bar chart graphs.

   The predicates that belong to this group are those whose names
began with *scattergraph_*.


File: ciao.info,  Node: Tables,  Next: Overview of widgets,  Prev: Scatter graphs,  Up: A Chart Library

Tables
======

   The purpose of this section is to allow the user to display
results in a table. A table is a regular structure in which:

   * Every row has the same number of columns, or

   * Every column has the same number of rows.


   The widget configurable components are as follows:

Title
     Title of the widget, it is displayed centered at the top of the
     canvas. If text is `''' no title will be displayed.

Header text
     Left centered text displayed bellow the title. If text is `'''
     no header text will be displayed.

Table
     Is placed in the center of the window. The table is composed by
     cells ordered in rows and columns. The cell values can be either
     any kind of text or numbers and they can be empty as well (see
     the type definition in the corresponding chapter module). A
     table is a list of lists. Each sublist is a row, so every
     sublist in the table must contain the same number of alements.

Footer text
     Left centered text displayed at the lower part of the window. If
     text is `''' no header text will be displayed.

Quit button
     Button placed below the footer text. You can click it to close
     the window.

   If the arguments are not in a correct format an exception will be
thrown. Moreover, these widgets have the default bindings and the
binding related to the quit button:

   The set of predicates that belongs to this group are those which
names begin with *table_widget*.


File: ciao.info,  Node: Overview of widgets,  Next: Usage and interface (chartlib),  Prev: Tables,  Up: A Chart Library

Overview of widgets
===================

   Although you don't have to worry about how to arrange the widgets,
here is an overview of how Tcl-tk, the underlying graphical system
currently used by chartlib, performs this task. Quoting from the book
_Tcl and Tk toolkit_, John K. Ousterhout.

   The X Window System provides many facilities for manipulating
windows in displays. The root window may have any number of child
windows, each of wich is called a top-level window. Top-level windows
may have children of their own, wich may have also children, and so
on. The descendants of top-level windows are called internal windows.
Internal windows are usedfor individual controls such as buttons,
text entries, and for grouping controls together. An X-application
tipically manages several top-level windows. Tk uses X to implement a
set of controls with the Motif look and feel. These controls are
called widgets. Each widget is implemented using one X window, and
the terms "window" and "widget" will be used interchangeably in this
document. As with windows, widgets are nested in hierarchical
structures. In this library top-level widgets (nonleaf or main) are
just containers for organizing and arranging the leaf widgets
(components). Thereby, the barchart widget is a top-level window wich
contains some widget components.

   Probably the most painstaking aspect of building a graphical
application is getting the placement and size of the widgets just
right. It usually takes many iterations to align widgets and adjust
their spacing. That's because managing the geometry of widgets is
simply not a packing problem, but also graphical design problem.
Attributes such as alignment, symmetry, and balance are more
important than minimizing the amount of space used for packing. Tk is
similar to other X toolkits in that it does not allow widgets to
determine their own geometries. A widget will not even appeared
unless it is managed by a geometry manager. This separation of
geometry management from internal widget behaviour allows multiple
geometry managers to exist simultaneously and permits any widget to
be used with any geometry manager. A geometry manager's job is to
arrange one or more _slave_ widgets relative to a _master_ widgets.
There are some geometry managers in Tk such as pack, place and canvas
widget. We will use another one call table.

   The table geometry manager arranges widgets in a table. It's easy
to align widgets (horizontally and vertically) or to create empty
space to balance the arrangement of the widgets. Widgets (called
slaves in the Tk parlance) are arranged inside a containing widget
(called the master). Widgets are positioned at row,column locations
and may span any number of rows or columns. More than one widget can
occupy a single location. The placement of widget windows determines
both the size and arrangement of the table. The table queries the
requested size of each widget. The requested size of a widget is the
natural size of the widget (before the widget is shrunk or expanded).
The height of each row and the width of each column is the largest
widget spanning that row or column. The size of the table is in turn
the sum of the row and column sizes. This is the table's normal size.
The total number of rows and columns in a table is determined from
the indices specified. The table grows dynamically as windows are
added at larger indices.


File: ciao.info,  Node: Usage and interface (chartlib),  Next: Documentation on exports (chartlib),  Prev: Overview of widgets,  Up: A Chart Library

Usage and interface (`chartlib')
================================

   * *Library usage:*

     `:- use_module(library(chartlib)).'

   * *Other modules used:*
        - _System library modules:_

          `chartlib/genbar1', `chartlib/genbar2', `chartlib/genbar3',
          `chartlib/genbar4', `chartlib/genmultibar',
          `chartlib/table_widget1', `chartlib/table_widget2',
          `chartlib/table_widget3', `chartlib/table_widget4',
          `chartlib/gengraph1', `chartlib/gengraph2',
          `chartlib/chartlib_errhandle'.




File: ciao.info,  Node: Documentation on exports (chartlib),  Prev: Usage and interface (chartlib),  Up: A Chart Library

Documentation on exports (`chartlib')
=====================================

 - (: UNDOC_REEXPORT) barchart1/7:
     Imported from `genbar1' (see the corresponding documentation for
     details).




 - (: UNDOC_REEXPORT) barchart1/9:
     Imported from `genbar1' (see the corresponding documentation for
     details).




 - (: UNDOC_REEXPORT) percentbarchart1/7:
     Imported from `genbar1' (see the corresponding documentation for
     details).




 - (: UNDOC_REEXPORT) barchart2/7:
     Imported from `genbar2' (see the corresponding documentation for
     details).




 - (: UNDOC_REEXPORT) barchart2/11:
     Imported from `genbar2' (see the corresponding documentation for
     details).




 - (: UNDOC_REEXPORT) percentbarchart2/7:
     Imported from `genbar2' (see the corresponding documentation for
     details).




 - (: UNDOC_REEXPORT) barchart3/7:
     Imported from `genbar3' (see the corresponding documentation for
     details).




 - (: UNDOC_REEXPORT) barchart3/9:
     Imported from `genbar3' (see the corresponding documentation for
     details).




 - (: UNDOC_REEXPORT) percentbarchart3/7:
     Imported from `genbar3' (see the corresponding documentation for
     details).




 - (: UNDOC_REEXPORT) barchart4/7:
     Imported from `genbar4' (see the corresponding documentation for
     details).




 - (: UNDOC_REEXPORT) barchart4/11:
     Imported from `genbar4' (see the corresponding documentation for
     details).




 - (: UNDOC_REEXPORT) percentbarchart4/7:
     Imported from `genbar4' (see the corresponding documentation for
     details).




 - (: UNDOC_REEXPORT) multibarchart/8:
     Imported from `genmultibar' (see the corresponding documentation
     for details).




 - (: UNDOC_REEXPORT) multibarchart/10:
     Imported from `genmultibar' (see the corresponding documentation
     for details).




 - (: UNDOC_REEXPORT) tablewidget1/4:
     Imported from `table_widget1' (see the corresponding
     documentation for details).




 - (: UNDOC_REEXPORT) tablewidget1/5:
     Imported from `table_widget1' (see the corresponding
     documentation for details).




 - (: UNDOC_REEXPORT) tablewidget2/4:
     Imported from `table_widget2' (see the corresponding
     documentation for details).




 - (: UNDOC_REEXPORT) tablewidget2/5:
     Imported from `table_widget2' (see the corresponding
     documentation for details).




 - (: UNDOC_REEXPORT) tablewidget3/4:
     Imported from `table_widget3' (see the corresponding
     documentation for details).




 - (: UNDOC_REEXPORT) tablewidget3/5:
     Imported from `table_widget3' (see the corresponding
     documentation for details).




 - (: UNDOC_REEXPORT) tablewidget4/4:
     Imported from `table_widget4' (see the corresponding
     documentation for details).




 - (: UNDOC_REEXPORT) tablewidget4/5:
     Imported from `table_widget4' (see the corresponding
     documentation for details).




 - (: UNDOC_REEXPORT) graph_b1/9:
     Imported from `gengraph1' (see the corresponding documentation
     for details).




 - (: UNDOC_REEXPORT) graph_b1/13:
     Imported from `gengraph1' (see the corresponding documentation
     for details).




 - (: UNDOC_REEXPORT) graph_w1/9:
     Imported from `gengraph1' (see the corresponding documentation
     for details).




 - (: UNDOC_REEXPORT) graph_w1/13:
     Imported from `gengraph1' (see the corresponding documentation
     for details).




 - (: UNDOC_REEXPORT) scattergraph_b1/8:
     Imported from `gengraph1' (see the corresponding documentation
     for details).




 - (: UNDOC_REEXPORT) scattergraph_b1/12:
     Imported from `gengraph1' (see the corresponding documentation
     for details).




 - (: UNDOC_REEXPORT) scattergraph_w1/8:
     Imported from `gengraph1' (see the corresponding documentation
     for details).




 - (: UNDOC_REEXPORT) scattergraph_w1/12:
     Imported from `gengraph1' (see the corresponding documentation
     for details).




 - (: UNDOC_REEXPORT) graph_b2/9:
     Imported from `gengraph2' (see the corresponding documentation
     for details).




 - (: UNDOC_REEXPORT) graph_b2/13:
     Imported from `gengraph2' (see the corresponding documentation
     for details).




 - (: UNDOC_REEXPORT) graph_w2/9:
     Imported from `gengraph2' (see the corresponding documentation
     for details).




 - (: UNDOC_REEXPORT) graph_w2/13:
     Imported from `gengraph2' (see the corresponding documentation
     for details).




 - (: UNDOC_REEXPORT) scattergraph_b2/8:
     Imported from `gengraph2' (see the corresponding documentation
     for details).




 - (: UNDOC_REEXPORT) scattergraph_b2/12:
     Imported from `gengraph2' (see the corresponding documentation
     for details).




 - (: UNDOC_REEXPORT) scattergraph_w2/8:
     Imported from `gengraph2' (see the corresponding documentation
     for details).




 - (: UNDOC_REEXPORT) scattergraph_w2/12:
     Imported from `gengraph2' (see the corresponding documentation
     for details).




 - (: UNDOC_REEXPORT) chartlib_text_error_protect/1:
     Imported from `chartlib_errhandle' (see the corresponding
     documentation for details).




 - (: UNDOC_REEXPORT) chartlib_visual_error_protect/1:
     Imported from `chartlib_errhandle' (see the corresponding
     documentation for details).





File: ciao.info,  Node: Low level Interface between Prolog and blt,  Next: chartlib_errhandle (library),  Prev: A Chart Library,  Up: Top

Low level Interface between Prolog and blt
******************************************

   This module exports some predicates to interact with Tcl-tk,
particularly with the bltwish program. Bltwish is a windowing shell
consisting of the Tcl command languaje, the Tk toolkit plus the
additional commands that comes with the BLT library and a main
program that reads commands. It creates a main window and then
processes Tcl commands.

* Menu:

* Usage and interface (bltclass)::
* Documentation on exports (bltclass)::


File: ciao.info,  Node: Usage and interface (bltclass),  Next: Documentation on exports (bltclass),  Prev: Low level Interface between Prolog and blt,  Up: Low level Interface between Prolog and blt

Usage and interface (`bltclass')
================================

   * *Library usage:*

     `:- use_module(library(bltclass)).'

   * *Exports:*
        - _Predicates:_

          `new_interp/1', `tcltk_raw_code/2', `interp_file/2'.

        - _Regular Types:_

          `bltwish_interp/1'.


   * *Other modules used:*
        - _System library modules:_

          `sockets/sockets', `system', `write', `read', `strings',
          `format', `terms'.




File: ciao.info,  Node: Documentation on exports (bltclass),  Prev: Usage and interface (bltclass),  Up: Low level Interface between Prolog and blt

Documentation on exports (`bltclass')
=====================================

 - PREDICATE: new_interp/1:
     `new_interp(Interp)'

     Creates a bltwish interprter and returns a socket. The socket
     allows the comunication between Prolog and Tcl-tk. Thus, bltwish
     receives the commands through the socket.




 - PREDICATE: tcltk_raw_code/2:
     `tcltk_raw_code(Command_Line,Interp)'

     Sends a command line to the interpreter. Tcl-tk parses and
     executes it.




 - REGTYPE: bltwish_interp/1:
     `bltwish_interp(Interp)'

     This type defines a bltwish interpreter. In fact, the bltwish
     interpreter receives the commands through the socket created.
          bltwish_interp(Interp) :-
                  stream(Interp).




 - PREDICATE: interp_file/2:
     `interp_file(File,Interp)'

     Sends the script file (File) to the interpreter through the
     socket. A script file is a file that contains commands that
     Tcl-tk can execute.





File: ciao.info,  Node: chartlib_errhandle (library),  Next: Color and Pattern Library,  Prev: Low level Interface between Prolog and blt,  Up: Top

chartlib_errhandle (library)
****************************

   This module is an error handler. If the format of the arguments is
not correct in a call to a chartlib predicate an exception will be
thrown . You can wrap the chartlib predicates with the predicates
exported by this module to handle automatically the errors if any.

* Menu:

* Usage and interface (chartlib_errhandle)::
* Documentation on exports (chartlib_errhandle)::
* Documentation on internals (chartlib_errhandle)::


File: ciao.info,  Node: Usage and interface (chartlib_errhandle),  Next: Documentation on exports (chartlib_errhandle),  Prev: chartlib_errhandle (library),  Up: chartlib_errhandle (library)

Usage and interface (`chartlib_errhandle')
==========================================

   * *Library usage:*

     `:- use_module(library(chartlib_errhandle)).'

   * *Exports:*
        - _Predicates:_

          `chartlib_text_error_protect/1',
          `chartlib_visual_error_protect/1'.


   * *Other modules used:*
        - _System library modules:_

          `chartlib/bltclass', `chartlib/install_utils'.




File: ciao.info,  Node: Documentation on exports (chartlib_errhandle),  Next: Documentation on internals (chartlib_errhandle),  Prev: Usage and interface (chartlib_errhandle),  Up: chartlib_errhandle (library)

Documentation on exports (`chartlib_errhandle')
===============================================

 - PREDICATE: chartlib_text_error_protect/1:
     `chartlib_text_error_protect(G)'

     This predicate catches the thrown exception and sends it to the
     appropiate handler. The handler will show the error message in
     the standard output.

     _Meta-predicate_ with arguments:
     `chartlib_text_error_protect(goal)'.




 - PREDICATE: chartlib_visual_error_protect/1:
     `chartlib_visual_error_protect(G)'

     This predicate catches the thrown exception and sends it to the
     appropiate handler. The handler will pop up a message box.

     _Meta-predicate_ with arguments:
     `chartlib_visual_error_protect(goal)'.





File: ciao.info,  Node: Documentation on internals (chartlib_errhandle),  Prev: Documentation on exports (chartlib_errhandle),  Up: chartlib_errhandle (library)

Documentation on internals (`chartlib_errhandle')
=================================================

 - REGTYPE: handler_type/1:
     `handler_type(X)'

     The library chartlib includes two error handlers already
     programmed.
          handler_type(text).
          handler_type(visual).




 - PREDICATE: error_message/2:
     `error_message(ErrorCode,ErrorMessage)'

     Binds the error code with its corresponding text message.




 - PREDICATE: error_file/2:
     `error_file(ErrorCode,ErrorFile)'

     Binds the error code with its corresponding script error file.





File: ciao.info,  Node: Color and Pattern Library,  Next: genbar1 (library),  Prev: chartlib_errhandle (library),  Up: Top

Color and Pattern Library
*************************

   This module contains predicates to access and check conformance to
the available colors and patterns.

* Menu:

* Usage and interface (color_pattern)::
* Documentation on exports (color_pattern)::


File: ciao.info,  Node: Usage and interface (color_pattern),  Next: Documentation on exports (color_pattern),  Prev: Color and Pattern Library,  Up: Color and Pattern Library

Usage and interface (`color_pattern')
=====================================

   * *Library usage:*

     `:- use_module(library(color_pattern)).'

   * *Exports:*
        - _Predicates:_

          `color/2', `pattern/2', `random_color/1',
          `random_lightcolor/1', `random_darkcolor/1',
          `random_pattern/1'.

        - _Regular Types:_

          `color/1', `pattern/1'.


   * *Other modules used:*
        - _System library modules:_

          `lists', `random/random'.




File: ciao.info,  Node: Documentation on exports (color_pattern),  Prev: Usage and interface (color_pattern),  Up: Color and Pattern Library

Documentation on exports (`color_pattern')
==========================================

 - REGTYPE: color/1:
     `color(Color)'

          color('GreenYellow').
          color('Yellow').
          color('White').
          color('Wheat').
          color('BlueViolet').
          color('Violet').
          color('MediumTurquoise').
          color('DarkTurquoise').
          color('Turquoise').
          color('Thistle').
          color('Tan').
          color('Sienna').
          color('Salmon').
          color('VioletRed').
          color('OrangeRed').
          color('MediumVioletRed').
          color('IndianRed').
          color('Red').
          color('Plum').
          color('Pink').
          color('MediumOrchid').
          color('DarkOrchid').
          color('Orchid').
          color('Orange').
          color('Maroon').
          color('Magenta').
          color('Khaki').
          color('Grey').
          color('LightGray').
          color('DimGray').
          color('DarkSlateGray').
          color('YellowGreen').
          color('SpringGreen').
          color('SeaGreen').
          color('PaleGreen').
          color('MediumSpringGreen').
          color('MediumSeaGreen').
          color('LimeGreen').
          color('ForestGreen').
          color('DarkOliveGreen').
          color('DarkGreen').
          color('Green').
          color('Goldenrod').
          color('Gold').
          color('Brown').
          color('Firebrick').
          color('Cyan').
          color('Coral').
          color('SteelBlue').
          color('SlateBlue').
          color('SkyBlue').
          color('Navy').
          color('MidnightBlue').
          color('MediumSlateBlue').
          color('MediumBlue').
          color('LightSteelBlue').
          color('LightBlue').
          color('DarkSlateBlue').
          color('CornflowerBlue').
          color('CadetBlue').
          color('Blue').
          color('Black').
          color('MediumAquamarine').
          color('Aquamarine').
     Defines available colors for elements such as points, lines or
     bars.




 - PREDICATE: color/2:
     *Usage:* `color(C1,C2)'
        - _Description:_ Test whether the color `C1' is a valid color
          or not. If `C1' is a variable the predicate will choose a
          valid color randomly. If `C1' is a ground term that is not
          a valid color an exception (error9) will be thrown

        - _The following properties should hold at call time:_

          `color_pattern:color(C1)'  (`color_pattern:color/1')

        - _The following properties should hold upon exit:_

          `color_pattern:color(C2)'  (`color_pattern:color/1')



 - REGTYPE: pattern/1:
     `pattern(Pattern)'

          pattern(pattern1).
          pattern(pattern2).
          pattern(pattern3).
          pattern(pattern4).
          pattern(pattern5).
          pattern(pattern6).
          pattern(pattern7).
          pattern(pattern8).
          pattern(pattern9).
     Defines valid patterns used in the stipple style bar attribute.




 - PREDICATE: pattern/2:
     *Usage:* `pattern(P1,P2)'
        - _Description:_ Test whether the pattern `P1' is a valid
          pattern or not. If `P1' is a variable the predicate will
          choose a valid pattern randomly. If `P1' is a ground term
          that is not a valid pattern an exception (error10) will be
          thrown.

        - _The following properties should hold at call time:_

          `color_pattern:pattern(P1)'  (`color_pattern:pattern/1')

        - _The following properties should hold upon exit:_

          `color_pattern:pattern(P2)'  (`color_pattern:pattern/1')



 - PREDICATE: random_color/1:
     `random_color(Color)'

     This predicate choose a valid color among the availables
     randomly.




 - PREDICATE: random_lightcolor/1:
     `random_lightcolor(Color)'

     This predicate choose a valid light color among the availables
     randomly.




 - PREDICATE: random_darkcolor/1:
     `random_darkcolor(Color)'

     This predicate choose a valid dark color among the availables
     randomly.




 - PREDICATE: random_pattern/1:
     `random_pattern(Pattern)'

     This predicate choose a valid pattern among the availables
     randomly.





File: ciao.info,  Node: genbar1 (library),  Next: genbar2 (library),  Prev: Color and Pattern Library,  Up: Top

genbar1 (library)
*****************

   This module defines predicates to show barchart widgets. The three
predicates exported by this module plot two-variable data as regular
bars in a window. They all share the following features:

   * No numeric values for the `x' axis are needed because they will
     be interpreted as labels. See `xbarelement1/1' definition type.

   * The bars will be displayed at uniform intervals.

   * The user can either select the appearance of the bars
     (background color, foreground color and stipple style) or not.
     See the `xbarelement1' type definition. Thus, the user can call
     each predicate in two ways.

   * The bar chart has a legend. One entry (symbol and label) per bar.

   * If you don't want to display text in the elements header,
     barchart title, x axis title, y axis title or footer, simply
     type `''' as the value of the argument.

   * The predicates test whether the format of the arguments is
     correct. If one or both vectors are empty, the exception
     `error2' will be thrown. If the vectors contains elements but
     are not correct, the exception `error1' or `error3' will be
     thrown, depending on the error type. `error1' means that
     `XVector' and `YVector' do not contain the same number of
     elements and `error3' indicates that not all the `XVector'
     elements contain a correct number of attributes .


Particular features will be pointed out in the corresponding
predicate.

* Menu:

* Usage and interface (genbar1)::
* Documentation on exports (genbar1)::
* Documentation on internals (genbar1)::


File: ciao.info,  Node: Usage and interface (genbar1),  Next: Documentation on exports (genbar1),  Prev: genbar1 (library),  Up: genbar1 (library)

Usage and interface (`genbar1')
===============================

   * *Library usage:*

     `:- use_module(library(genbar1)).'

   * *Exports:*
        - _Predicates:_

          `barchart1/7', `barchart1/9', `percentbarchart1/7'.

        - _Regular Types:_

          `yelement/1', `axis_limit/1', `header/1', `title/1',
          `footer/1'.


   * *Other modules used:*
        - _System library modules:_

          `chartlib/bltclass', `chartlib/test_format',
          `chartlib/color_pattern', `chartlib/install_utils', `lists',
          `random/random'.




File: ciao.info,  Node: Documentation on exports (genbar1),  Next: Documentation on internals (genbar1),  Prev: Usage and interface (genbar1),  Up: genbar1 (library)

Documentation on exports (`genbar1')
====================================

 - PREDICATE: barchart1/7:
     `barchart1(Header,BarchartTitle,XTitle,XVector,YTitle,YVector,Footer)'

     The `y' axis range is determined from the limits of the data.
     Two examples are given to demonstrate clearly how to call the
     predicates. In the first example the user sets the bar
     appearance, in the second one the appearance features will be
     chosen by the system and the colors that have been assigned to
     the variables Color1, Color2 and Pattern will be shown also.

     Example 1:

          barchart1('This is the header text',
            'Barchart title',
            'xaxistitle',
            [ ['bar1','legend_element1','Blue','Yellow','pattern1'],
                     ['bar2','legend_element2','Plum','SeaGreen','pattern2'],
                     ['bar3','legend_element3','Turquoise','Yellow','pattern5'] ],
            'yaxixtitle',
            [20,10,59],
            'footer').

     Example 2:

          barchart1('This is the header text',
            'Barchart title',
            'xaxistitle',
            [ ['element1','legend_element1',Color1,Color2,Pattern],
                      ['element2','legend_element2'],
                      ['element3','legend_element3'] ],
            'yaxixtitle',
            [20,10,59],
            'footer').




 - PREDICATE: barchart1/9:
     `barchart1(Header,BTitle,XTitle,XVector,YTitle,YVector,YMax,YMin,Footer)'

     You can set the minimum and maximum limits of the `y' axis. Data
     outside the limits will not be plotted. Each limit, as you can
     check by looking at the `axis_limit/1' definition, is a number.
     If the argument is a variable the limit will be calculated from
     the data (i.e., if `YMax' value is YValueMax the maximum y axis
     limit will calculated using the largest data value).

     Example:

          barchart1('This is the header text',
            'Barchart title',
            'xaxistitle',
            [ ['element1','e1','Blue','Yellow','pattern1'],
                ['element2','e2','Turquoise','Plum','pattern5'],
                ['element3','e3','Turquoise','Green','pattern5'] ],
            'yaxixtitle',
            [20,10,59],
            70,
            _,
            'footer').




 - PREDICATE: percentbarchart1/7:
     `percentbarchart1(Header,BTitle,XTitle,XVector,YTitle,YVector,Footer)'

     The y axis maximum coordinate value is 100. The `x' axis limits
     are automatically worked out.

     Example:

          percentbarchart1('This is a special barchart to represent percentages',
            'Barchart with legend',
            'My xaxistitle',
            [ [1,'bar1','Blue','Yellow','pattern1'],
                 [8,'bar2','MediumTurquoise','Plum','pattern5'] ],
            'My yaxixtitle',
            [80,10],
            'This is the footer text').




 - REGTYPE: yelement/1:
          yelement(Y) :-
                  number(Y).

     Y is the bar lenght, so it must be a numeric value.

     Both Prolog and Tcl-Tk support integers and floats. Integers are
     usually specified in decimal, but if the first character is 0
     the number is read in octal (base 8), and if the first two
     characters are 0x, the number is read in hexadecimal (base16).
     Float numbers may be specified using most of the forms defined
     for ANSI C, including the following examples:

        * 9.56

        * 5.88e-2

        * 5.1E2

     Note: Be careful when using floats. While 8. or 7.e4 is
     interpreted by Tcl-tk as 8.0 and 7.0e4, Prolog will not read
     them as float numbers. Example:
                  ?- number(8.e+5).
                  {SYNTAX ERROR: (lns 130-130) , or ) expected in arguments
                  number ( 8
                  ** here **
                  . e + 5 ) .
                  }
          
                  no
                  ?- number(8.).
                  {SYNTAX ERROR: (lns 138-138) , or ) expected in arguments
                  number ( 8
                  ** here **
                  . ) .
                  }
          
                  no
          
                  ?- number(8.0e+5).
          
                  yes
                  ?- number(8.0).
          
                  yes

     Precision: Tcl-tk internally represents integers with the C type
     `int', which provides at least 32 bits of precision on most
     machines. Since Prolog integers can (in some implementations)
     exceed 32 bits but the precision in Tcl-tk depends on the
     machine, it is up to the progammer to ensure that the values fit
     into the maximum precision of the machine for integers. Real
     numbers are represented with the C type `double', which is
     usually represented with 64-bit values (about 15 decimal digits
     of precision) using the IEEE Floating Point Standard.

     Conversion: If the list is composed by integers and floats,
     Tcl-tk will convert integers to floats.




 - REGTYPE: axis_limit/1:
          axis_limit(X) :-
                  number(X).
          axis_limit(_1).

     This type is defined in order to set the minimum and maximum
     limits of the axes. Data outside the limits will not be plotted.
     Each limit, is a number or a variable. If the argument is not a
     number the limit will be calculated from the data (i.e., if YMax
     value is `Var' the maximum y axis limit will be calculated using
     the largest data value).




 - REGTYPE: header/1:
     *Usage:* `header(X)'
        - _Description:_ `X' is a text (an atom) describing the
          header of the graph.



 - REGTYPE: title/1:
     *Usage:* `title(X)'
        - _Description:_ `X' is a text (an atom) to be used as label,
          usually not very long.



 - REGTYPE: footer/1:
     *Usage:* `footer(X)'
        - _Description:_ `X' is a text (an atom) describing the
          footer of the graph.




File: ciao.info,  Node: Documentation on internals (genbar1),  Prev: Documentation on exports (genbar1),  Up: genbar1 (library)

Documentation on internals (`genbar1')
======================================

 - REGTYPE: xbarelement1/1:
          xbarelement1([XValue,LegendElement]) :-
                  atomic(XValue),
                  atomic(LegendElement).
          xbarelement1([XValue,LegendElement,ForegColor,BackgColor,SPattern]) :-
                  atomic(XValue),
                  atomic(LegendElement),
                  color(ForegColor),
                  color(BackgColor),
                  pattern(SPattern).

     Defines the attributes of the bar.
    `XValue'
          bar label. Although `XValue' values may be numbers, the
          will be treated as labels. Different elements with the same
          label will produce different bars.

    `LegendElement'
          Legend element name. It may be a number or an atom and
          equal or different to the XValue. Every `LegendElement'
          value of the list must be unique.

    `ForegColor'
          It sets the Foreground color of the bar. Its value must be
          a valid color, otherwise the system will throw an
          exception. If the argument value is a variable, it gets
          instantiated to a color chosen by the library.

    `BackgColor'
          It sets the Background color of the bar. Its value must be
          a valid color, otherwise the system will throw an
          exception. If the argument value is a variable, it gets
          instantiated to a color chosen by the library.

    `SPattern'
          It sets the stipple of the bar. Its value must be a valid
          pattern, otherwise the system will throw an exception. If
          the argument value is a variable, it gets instantiated to a
          pattern chosen by the library.





File: ciao.info,  Node: genbar2 (library),  Next: genbar3 (library),  Prev: genbar1 (library),  Up: Top

genbar2 (library)
*****************

   This module defines predicates which show barchart widgets. The
three predicates exported by this module plot two-variable data as
regular bars in a window. They all share the following features:

   * Numeric values for the x axis are needed, otherwise it does not
     work properly. See `xbarelement2/1' definition type.

   * The bar position is proportional to the x-coordinate value.

   * The user can either select the appearance of the bars
     (background color, foreground color and stipple style) or not.
     See the `xbarelement2/1' type definition. Thus, the user can
     call each predicate in two ways.

   * The bar chart has a legend and one entry (symbol and label) per
     bar.

   * If you do not want to display text in the elements header,
     barchart title, x axis title, y axis title or footer, simply
     type `''' as the value of the argument.

   * The predicates test whether the format of the arguments is
     correct. If one or both vectors are empty, the exception
     `error2' will be thrown. If the vectors contain elements but are
     not correct, the exception `error1' or `error3' will be thrown,
     depending on the error type. `error1' means that `XVector' and
     `YVector' does not contain the same number of elements and
     `error3' indicates that not all the `XVector' elements contain a
     correct number of attributes .


   Particular features will be pointed out in the corresponding
predicate.

* Menu:

* Usage and interface (genbar2)::
* Documentation on exports (genbar2)::


File: ciao.info,  Node: Usage and interface (genbar2),  Next: Documentation on exports (genbar2),  Prev: genbar2 (library),  Up: genbar2 (library)

Usage and interface (`genbar2')
===============================

   * *Library usage:*

     `:- use_module(library(genbar2)).'

   * *Exports:*
        - _Predicates:_

          `barchart2/7', `barchart2/11', `percentbarchart2/7'.

        - _Regular Types:_

          `xbarelement2/1'.


   * *Other modules used:*
        - _System library modules:_

          `chartlib/genbar1', `chartlib/bltclass',
          `chartlib/color_pattern', `chartlib/test_format',
          `chartlib/install_utils', `lists', `random/random'.




File: ciao.info,  Node: Documentation on exports (genbar2),  Prev: Usage and interface (genbar2),  Up: genbar2 (library)

Documentation on exports (`genbar2')
====================================

 - PREDICATE: barchart2/7:
     `barchart2(Header,BarchartTitle,XTitle,XVector,YTitle,YVector,Footer)'

     The maximum and minimum limits for axes are determined from the
     data.

     Example:

          barchart2('This is the header text',
            'Barchart with legend',
            'My xaxistitle',
            [ [1,'bar1','Blue','Yellow','pattern1'],
                 [2,'bar2','MediumTurquoise','Plum','pattern5'] ],
            'My yaxixtitle',
            [20,10],
            'This is the footer text').




 - PREDICATE: barchart2/11:
     `barchart2(Header,BT,XT,XVector,XMax,XMin,YT,YVector,YMax,YMin,Footer)'

     You can set the minimum and maximum limits of the axes. Data
     outside the limits will not be plotted. Each limit, as you can
     check looking at the `axis_limit/1' definition, is a number. If
     the argument is a variable the limit will be calculated from the
     data (i.e., if `YMax' value is YValueMax the maximum y axis
     limit will calculated using the largest data value).

     Example:

          barchart2('This is the header text',
            'Barchart with legend',
            'My xaxistitle',
            [ [1,'bar1',Color1,Color2,Pattern1],
                   [2,'bar2',Color3,Color4,Pattern2] ],
            10,
            -10,
            'My yaxixtitle',
            [20,10],
            100,
            -10,
            'The limits for the axes are set by the user').




 - PREDICATE: percentbarchart2/7:
     `percentbarchart2(Header,BTitle,XTitle,XVector,YTitle,YVector,Footer)'

     The y axis maximum coordinate value is 100. The x axis limits
     are autoarrange.

     Example:

          percentbarchart2('This is a special barchart to represent percentages',
            'Barchart with legend',
            'My xaxistitle',
            [ [1,'bar1','Blue','Yellow','pattern1'],
                    [2,'bar2','MediumTurquoise','Plum','pattern5'] ],
            'My yaxixtitle',
            [80,10],
            'This is the footer text').




 - REGTYPE: xbarelement2/1:
          xbarelement2([XValue,LegendElement]) :-
                  number(XValue),
                  atomic(LegendElement).
          xbarelement2([XValue,LegendElement,ForegColor,BackgColor,SPattern]) :-
                  number(XValue),
                  atomic(LegendElement),
                  color(ForegColor),
                  color(BackgColor),
                  pattern(SPattern).
     Defines the attributes of the bar.

    `XValue'
          x-coordinate position of the bar. Different elements with
          the same abscissas will produce overlapped bars.

    `LegendElement'
          Element legend name. It may be a number or an atom and
          equal or different to the XValue. Every `LegendElement'
          value of the list must be unique.

    `ForegColor'
          Is the Foreground color of the bar. Its value must be a
          valid color, otherwise the system will throw an exception.
          If the argument value is a variable, it gets instantiated
          to a color chosen by the library.

    `BackgColor'
          Is the Background color of the bar. Its value must be a
          valid color, otherwise the system will throw an exception.
          If the argument value is a variable, it gets instantiated
          to a color chosen by the library.

    `SPattern'
          Is the stipple of the bar. Its value must be a valid
          pattern, otherwise the system will throw an exception. If
          the argument value is a variable, it gets instantiated to a
          pattern chosen by the library.





File: ciao.info,  Node: genbar3 (library),  Next: genbar4 (library),  Prev: genbar2 (library),  Up: Top

genbar3 (library)
*****************

   This module defines predicates which depict barchart widgets. The
three predicates exported by this module plot two-variable data as
regular bars in a window and are similar to those exported in the
genbar1 module except in that these defined in this module do not
display a legend. Thus, not all the argument types are equal.

   The predicates test whether the format of the arguments is
correct. If one or both vectors are empty, the exception `error2'
will be thrown. If the vectors contain elements but are not correct,
the exception `error1' or `error3' will be thrown, depending on the
error type. `error1' means that `XVector' and `YVector' do not
contain the same number of elements and `error3' indicates that not
all the `XVector' elements contain a correct number of attributes .

* Menu:

* Usage and interface (genbar3)::
* Documentation on exports (genbar3)::
* Documentation on internals (genbar3)::


File: ciao.info,  Node: Usage and interface (genbar3),  Next: Documentation on exports (genbar3),  Prev: genbar3 (library),  Up: genbar3 (library)

Usage and interface (`genbar3')
===============================

   * *Library usage:*

     `:- use_module(library(genbar3)).'

   * *Exports:*
        - _Predicates:_

          `barchart3/7', `barchart3/9', `percentbarchart3/7'.


   * *Other modules used:*
        - _System library modules:_

          `chartlib/genbar1', `chartlib/bltclass',
          `chartlib/color_pattern', `chartlib/test_format',
          `chartlib/install_utils', `lists', `random/random'.




File: ciao.info,  Node: Documentation on exports (genbar3),  Next: Documentation on internals (genbar3),  Prev: Usage and interface (genbar3),  Up: genbar3 (library)

Documentation on exports (`genbar3')
====================================

 - PREDICATE: barchart3/7:
     `barchart3(Header,BarchartTitle,XTitle,XVector,YTitle,YVector,Footer)'

     As we mentioned in the above paragraph, this predicate is
     comparable to `barchart1/8' except in the `XVector' argument
     type.

     Example:
          barchart3('This is the header text',
            'Barchart without legend',
            'My xaxistitle',
            [['bar1'],['bar2']],
            'My yaxixtitle',
            [20,10],
            'This is the footer text').




 - PREDICATE: barchart3/9:
     `barchart3(Header,BTitle,XTitle,XVector,YTitle,YVector,YMax,YMin,Footer)'

     As we mentioned, this predicate is quite similar to the
     `barchart1/10' except in the `XVector' argument type, because
     the yielded bar chart lacks of legend.

     Example:
          barchart3('This is the header text',
            'Barchart without legend',
            'My xaxistitle',
            [['bar1'],['bar2']],
            'My yaxixtitle',
            30,
            5,
            [20,10],
            'This is the footer text').




 - PREDICATE: percentbarchart3/7:
     `percentbarchart3(Header,BTitle,XTitle,XVector,YTitle,YVector,Footer)'

     The `y' axis maximum coordinate value is 100. The x axis limits
     are autoarrange.

     Example:

          percentbarchart3('This is a special barchart to represent percentages',
                    'Barchart without legend',
                    'My xaxistitle',
                    [ ['pr1','Blue','Yellow','pattern1'],
                      ['pr2','MediumTurquoise','Plum','pattern5'] ],
                    'My yaxixtitle',
                    [80,10],
                    'This is the footer text').





File: ciao.info,  Node: Documentation on internals (genbar3),  Prev: Documentation on exports (genbar3),  Up: genbar3 (library)

Documentation on internals (`genbar3')
======================================

 - REGTYPE: xbarelement3/1:
          xbarelement3([XValue]) :-
                  atomic(XValue).
          xbarelement3([XValue,ForegColor,BackgColor,StipplePattern]) :-
                  atomic(XValue),
                  color(ForegColor),
                  color(BackgColor),
                  pattern(StipplePattern).

     Defines the attributes of the bar.
    `XValue'
          bar label. Although `XValue' values may be numbers, the
          will be treated as labels. Different elements with the same
          label will produce different bars.

    `ForegColor'
          It sets the Foreground color of the bar. Its value must be
          a valid color, otherwise the system will throw an
          exception. If the argument value is a variable, it gets
          instantiated to a color chosen by the library.

    `BackgColor'
          It sets the Background color of the bar. Its value must be
          a valid color, otherwise the system will throw an
          exception. If the argument value is a variable, it gets
          instantiated to a color chosen by the library.

    `SPattern'
          It sets the stipple of the bar. Its value must be a valid
          pattern, otherwise the system will throw an exception. If
          the argument value is a variable, it gets instantiated to a
          pattern chosen by the library.





File: ciao.info,  Node: genbar4 (library),  Next: gengraph1 (library),  Prev: genbar3 (library),  Up: Top

genbar4 (library)
*****************

   This module defines predicates which depict barchart widgets. The
three predicates exported by this module plot two-variable data as
regular bars in a window and are similar to those exported in genbar2
module except in that those defined in this module doesn't display a
legend. Thus, the user does not have to define legend element names.

   The predicates test whether the format of the arguments is
correct. If one or both vectors are empty, the exception `error2'
will be thrown. If the vectors contains elements but are not correct,
the exception `error1' or `error3' will be thrown, depending on the
error type. `error1' means that `XVector' and `YVector' do not
contain the same number of elements and `error3' indicates that not
all the `XVector' elements contain a correct number of attributes .

* Menu:

* Usage and interface (genbar4)::
* Documentation on exports (genbar4)::
* Documentation on internals (genbar4)::


File: ciao.info,  Node: Usage and interface (genbar4),  Next: Documentation on exports (genbar4),  Prev: genbar4 (library),  Up: genbar4 (library)

Usage and interface (`genbar4')
===============================

   * *Library usage:*

     `:- use_module(library(genbar4)).'

   * *Exports:*
        - _Predicates:_

          `barchart4/7', `barchart4/11', `percentbarchart4/7'.


   * *Other modules used:*
        - _System library modules:_

          `chartlib/genbar1', `chartlib/bltclass',
          `chartlib/color_pattern', `chartlib/test_format',
          `chartlib/install_utils', `lists', `random/random'.




File: ciao.info,  Node: Documentation on exports (genbar4),  Next: Documentation on internals (genbar4),  Prev: Usage and interface (genbar4),  Up: genbar4 (library)

Documentation on exports (`genbar4')
====================================

 - PREDICATE: barchart4/7:
     `barchart4(Header,BarchartTitle,XTitle,XVector,YTitle,YVector,Footer)'

     As we mentioned in the above paragraph, this predicate is
     comparable to `barchart2/8' except in the `XVector' argument
     type.

     Example:
          barchart4('This is the header text',
            'Barchart without legend',
            'My xaxistitle',
            [[2],[5],[6]],
            'My yaxixtitle',
            [20,10,59],
            'Numeric values in the xaxis').




 - PREDICATE: barchart4/11:
     `barchart4(Hder,BT,XT,XVector,XMax,XMin,YT,YVector,YMax,YMin,Fter)'

     As we stated before, this predicate is quite similar to
     `barchart2/10' except in the following aspects:

        * The `XVector' argument type, because the yielded bar chart
          lacks the legend.

        * The user can set limits for both `x' axis and `y' axis.


     Example:
          barchart4('This is the header text, you can write a graph description',
            'Barchart without legend',
            'My xaxistitle',
            [[2,'Blue','Yellow','pattern1'],
                 [20,'MediumTurquoise','Plum','pattern5'],
                 [30,'MediumTurquoise','Green','pattern5']],
            50,
            -10,
            'My yaxixtitle',
            [20,10,59],
            100,
            -10,
            'Numeric values in the xaxis').




 - PREDICATE: percentbarchart4/7:
     `percentbarchart4(Header,BTitle,XTitle,XVector,YTitle,YVector,Footer)'

     The y axis maximum coordinate value is 100. The x axis limits
     are automatically worked out. This predicate is useful when the
     bar height represents percentages.

     Example:

          percentbarchart4('This is the header text',
            'Barchart without legend',
            'My xaxistitle',
            [[2,'Blue','Yellow','pattern1'],[5,'Yellow','Plum','pattern5'],
                 [6,'MediumTurquoise','Green','pattern5']],
            'My yaxixtitle',
            [20,10,59],
            'Numeric values in the xaxis').





File: ciao.info,  Node: Documentation on internals (genbar4),  Prev: Documentation on exports (genbar4),  Up: genbar4 (library)

Documentation on internals (`genbar4')
======================================

 - REGTYPE: xbarelement4/1:
     Defines the attributes of the bar.
    `XValue'
          x-coordinate position of the bar. Different elements with
          the same abscissas will produce overlapped bars.

    `ForegColor'
          It sets the Foreground color of the bar. Its value must be
          a valid color, otherwise the system will throw an
          exception. If the argument value is a variable, it gets
          instantiated to a color chosen by the library.

    `BackgColor'
          It sets the Background color of the bar. Its value must be
          a valid color, otherwise the system will throw an
          exception. If the argument value is a variable, it gets
          instantiated to a color chosen by the library.

    `SPattern'
          It sets the stipple of the bar. Its value must be a valid
          pattern, otherwise the system will throw an exception. If
          the argument value is a variable, it gets instantiated to a
          pattern chosen by the library.





File: ciao.info,  Node: gengraph1 (library),  Next: gengraph2 (library),  Prev: genbar4 (library),  Up: Top

gengraph1 (library)
*******************

   This module defines predicates which depict line graph and scatter
graph widgets. All eigth predicates exported by this module plot
two-variable data. Each point is defined by its X-Y coordinate
values. A dataset is defined by two lists xvector and yvector, which
contain the points coordinates. As you might guess, the values placed
in the the same position in both lists are the coordinates of a
point. They both share the following features:

   * Numeric values for vector elements are needed. We'll use two
     vectors to represent the X-Y coordinates of each set of plotted
     data, but in this case every dataset shares the X-vector, i.e.,
     x-coordinate of points with the same index (1) in different
     datasets is the same. Thus, the numbers of points in each
     yvector must be equal to the number of points in the xvector.

   * The active element color is navyblue, which means that when you
     select a legend element, the corresponding line or point dataset
     turns into navyblue.

   * The user can either select the appearance of the lines and/or
     points of each dataset or not. If not, the system will choose
     the colors for the lines and the points among the available ones
     in accordance with the plot background color and it will also
     set the points size and symbol to the default. If the plot
     background color is black, the system will choose a lighter
     color, and the system will select a darker color when the plot
     background color is white. Thus, the user can define the
     appearanse attributes of each dataset in four different ways.
     Take a look at the `attributes/1' type definition and see the
     examples to understand it clearly.

   * The graph has a legend and one entry (symbol and label) per
     dataset.

   * If you do not want to display text in the element header,
     barchart title, xaxis title, yaxis title or footer, simply give
     `''' as the value of the argument.

   * The predicates check whether the format of the arguments is
     correct as well. The testing process involves some
     verifications. If one or both vectors are empty, the exception
     `error2' will be thrown. If the vectors contains elements but
     are not correct, the exception `error4' will be thrown.


   The names of the line graph predicates begin with *graph_* and
those corresponding to the scatter graph group begin with
*scattergraph_*.

* Menu:

* Usage and interface (gengraph1)::
* Documentation on exports (gengraph1)::

   ---------- Footnotes ----------

   (1) It should be pointed out that I am refering to an index as the
position of an element in a list.


File: ciao.info,  Node: Usage and interface (gengraph1),  Next: Documentation on exports (gengraph1),  Prev: gengraph1 (library),  Up: gengraph1 (library)

Usage and interface (`gengraph1')
=================================

   * *Library usage:*

     `:- use_module(library(gengraph1)).'

   * *Exports:*
        - _Predicates:_

          `graph_b1/9', `graph_b1/13', `graph_w1/9', `graph_w1/13',
          `scattergraph_b1/8', `scattergraph_b1/12',
          `scattergraph_w1/8', `scattergraph_w1/12'.

        - _Regular Types:_

          `vector/1', `smooth/1', `attributes/1', `symbol/1',
          `size/1'.


   * *Other modules used:*
        - _System library modules:_

          `chartlib/bltclass', `chartlib/genbar1',
          `chartlib/color_pattern', `chartlib/test_format',
          `chartlib/install_utils', `lists', `random/random'.




File: ciao.info,  Node: Documentation on exports (gengraph1),  Prev: Usage and interface (gengraph1),  Up: gengraph1 (library)

Documentation on exports (`gengraph1')
======================================

 - PREDICATE: graph_b1/9:
     `graph_b1(Header,GTitle,XTitle,XVector,YTitle,YVectors,LAtts,Footer,Smooth)'

     Besides the features mentioned at the begining of the chapter,
     the displayed graph generated when calling this predicate has
     the following distinguishing characteristics:

        * The plotting area background color is black.

        * The cross hairs color is white.

        * The axes limits are determined from the data.


     Example:

          graph_b1('This is the header text',
            'Graph_title',
            'xaxistitle',
            [20,10,59],
            'yaxixtitle',
            [ [10,35,40],[25,50,60] ],
            [ ['element1','Blue','Yellow','plus',6],['element2',Outline,Color] ],
            'footer',
            'linear').




 - PREDICATE: graph_b1/13:
     `graph_b1(Header,GT,XT,XV,XMax,XMin,YT,YVs,YMax,YMin,LAtts,Footer,Smooth)'

     The particular features related to this predicate are described
     below:

        * The plotting area background color is black.

        * The cross hairs color is white.

        * You can set the minimum and maximum limits of the axes.
          Data outside the limits will not be plotted.


     Example:
          graph_b1('This is the header text',
            'Graph_title',
            'xaxistitle',
            [20,10,59],
            50,
            _,
            'yaxixtitle',
            [[10,35,40],[25,50,60]],
            50,
            _,
            [['line1','circle',4],['line2',OutlineColor,Color]],
            'footer',
            'step').




 - PREDICATE: graph_w1/9:
     `graph_w1(Header,GTitle,XTitle,XVector,YTitle,YVectors,LAtts,Footer,Smooth)'

     This predicate is quite similar to `graph_b1/9'. The differences
     lies in the plot background color and in the cross hairs color,
     which are white and black respectively.

     Example:
          graph_w1('This is the header text',
            'Graph_title',
            'xaxistitle',
            [20,10,40,50],
            'yaxixtitle',
            [ [10,35,40,50],[25,20,60,40] ],
            [['line1','Blue','DarkOrchid'],['line2','circle',3]],
            'footer',
            'quadratic').




 - PREDICATE: graph_w1/13:
     `graph_w1(Header,GT,XT,XV,XMax,XMin,YT,YVs,YMax,YMin,LAtts,Footer,Smooth)'

     This predicate is quite similar to `graph_b1/13', the
     differences between them are listed below:

        * The plotting area background color is white.

        * The cross hairs color is black.


     Example:
          graph_w1('This is the header text',
            'Graph_title',
            'xaxistitle',
            [20,10,59],
            100,
            10,
            'yaxixtitle',
            [[10,35,40],[25,20,60]],
            _,
            _,
            [['element1','Blue','Yellow'],['element2','Turquoise','Plum']],
            'footer',
            'quadratic').




 - PREDICATE: scattergraph_b1/8:
     `scattergraph_b1(Header,GTitle,XTitle,XVector,YTitle,YVectors,PAtts,Footer)'

     Apart from the features brought up at the beginning of the
     chapter, the scatter graph displayed invoking this predicate has
     the following characteristics:

        * The plotting area background color is black.

        * The cross hairs color is white.

        * The axes limits are determined from the data.


     Example:
          scattergraph_b1('This is the header text',
            'Graph_title',
            'xaxistitle',
            [10,15,20],
            'yaxixtitle',
            [[10,35,20],[15,11,21]],
            [['element1','Blue','Yellow'],['element2','Turquoise','Plum']],
            'footer').




 - PREDICATE: scattergraph_b1/12:
     `scattergraph_b1(Header,GT,XT,XV,XMax,XMin,YT,YVs,YMax,YMin,PAtts,Footer)'

     The particular features related to this predicate are described
     below:

        * The plotting area background color is black.

        * The cross hairs color is white.

        * You can set the minimum and maximum limits of the axes.
          Data outside the limits will not be plotted.


     Example:
          scattergraph_b1('This is the header text',
            'Graph_title',
            'xaxistitle',
            [20,10,59],
            50,
            _,
            'yaxixtitle',
            [[10,35,40],[25,50,60]],
            50,
            _,
            [['point dataset1','Blue','Yellow'],['point dataset2']],
            'footer').




 - PREDICATE: scattergraph_w1/8:
     `scattergraph_w1(Header,GT,XT,XVector,YT,YVectors,PAtts,Footer)'

     This predicate is quite similar to `scattergraph_b1/8' except in
     the following:

        * The plotting area background color is black.

        * The cross hairs color is white.

        * If the user does not fix the points colors, they will be
          chosen among the lighter ones.


     Example:
          scattergraph_w1('This is the header text',
            'Graph_title',
            'xaxistitle',
            [20,10,59],
            'yaxixtitle',
            [[10,35,40],[25,20,60]],
            [['e1','Blue','Green'],['e2','MediumVioletRed','Plum']],
            'footer').




 - PREDICATE: scattergraph_w1/12:
     `scattergraph_w1(Header,GT,XT,XV,XMax,XMin,YT,YVs,YMax,YMin,PAtts,Footer)'

     This predicate is quite similar to `scattergraph1_b1/13', the
     differences between them are listed below:

        * The plotting area background color is white.

        * The cross hairs color is black.


     Example:
          scattergraph_w1('This is the header text',
            'Graph_title',
            'xaxistitle',
            [20,10,59],
            150,
            5,
            'yaxixtitle',
            [[10,35,40],[25,20,60]],
            _,
            -10,
            [['e1','Blue','Yellow'],['e2','MediumTurquoise','Plum']],
            'footer').




 - REGTYPE: vector/1:
          vector(X) :-
                  list(X,number).
     The type vector defines a list of numbers (integers or floats).




 - REGTYPE: smooth/1:
     `smooth(Smooth)'

          smooth(linear).
          smooth(cubic).
          smooth(quadratic).
          smooth(step).

     Specifies how connecting segments are drawn between data points.
     If `Smooth' is `linear', a single line segment is drawn,
     connecting both data points. When `Smooth' is `step', two line
     segments will be drawn, the first line is a horizontal line
     segment that steps the next X-coordinate and the second one is a
     vertical line, moving to the next Y-coordinate. Both `cubic' and
     `quadratic' generate multiple segments between data points. If
     `cubic'is used, the segments are generated using a cubic spline.
     If `quadratic', a quadratic spline is used. The default is
     linear.




 - REGTYPE: attributes/1:
          attributes([ElementName]) :-
                  atomic(ElementName).
          attributes([ElementName,OutLine,Color]) :-
                  atomic(ElementName),
                  color(OutLine),
                  color(Color).
          attributes([ElementName,Symbol,Size]) :-
                  atomic(ElementName),
                  symbol(Symbol),
                  size(Size).
          attributes([ElementName,OutLine,Color,Symbol,Size]) :-
                  atomic(ElementName),
                  color(OutLine),
                  color(Color),
                  symbol(Symbol),
                  size(Size).

     Each line or point dataset in the graph has its own attributes,
     which are defined by this type. The name of the dataset,
     specified in the `ElementName' argument, may be either a number
     or an atom. The second argument is the color of a thin line
     around each point in the dataset and the Color argument is the
     points and lines color. Both `OutLine' and `Color' must be a
     valid color (see available values in `color/1'), otherwise a
     random color according to the plot background color will be
     selected. The `Symbol' must be a valid symbol and the `Size'
     must be a number. Be careful if you want to especify the
     `Symbol' and the `Size', otherwise the predicate will not work
     as you expect. If you don't select a symbol and a size for a
     dataset the default values will be square and 1 pixel.




 - REGTYPE: symbol/1:
     `symbol(Symbol)'

          symbol(square).
          symbol(circle).
          symbol(diamond).
          symbol(plus).
          symbol(cross).
          symbol(splus).
          symbol(scross).
          symbol(triangle).
     `Symbol' stands for the shape of the points whether in scatter
     graphs or in line graphs.




 - REGTYPE: size/1:
     `size(Size)'

          size(Size) :-
                  number(Size).
     `Size' stands for the size in pixels of the points whether in
     scatter graphs or in line graphs.





File: ciao.info,  Node: gengraph2 (library),  Next: genmultibar (library),  Prev: gengraph1 (library),  Up: Top

gengraph2 (library)
*******************

   This module defines predicates which show line graph widgets. All
eight predicates exported by this module plot two-variable data. Each
point is defined by its X-Y coordinate values. Every predicate share
the following features:

   * A dataset is defined by three lists xvector, yvector and
     attributes. The arguments named `XVectors' (or `XVs'),
     `YVectors' (or `YVs') and `LAtts'(1) contain this information.
     Those arguments must be lists whose elements are also lists. The
     first dataset is defined by the firts element of the three
     lists, the second dataset is defined by the second element of
     the three lists and so on.

   * Numeric values for the vector elements are needed. We will use
     two vectors to represent the X-Y coordinates of each set of data
     plotted. In these predicates the vectors can have different
     number of points. However, the number of elements in xvector and
     yvector that pertain to a certain dataset must be, obviously,
     equal.

   * The active line color is blue, which means that when you select
     a legend element, the corresponding line turns into navyblue.

   * The user can either select the appearance for the lines and the
     points or not. See the `attributes/1' type definition. Thus, the
     user can call each predicate in different ways ways.

   * The graph has a legend and one entry (symbol and label) per
     dataset.

   * If you do not want to display text in the elements header,
     barchart title, xaxis title, yaxis title or footer, simply give
     `''' as the value of the argument.

   * The predicates check whether the format of the arguments is
     correct as well. The testing process involves some
     verifications. If one or both vectors are empty, the exception
     `error2' will be thrown. If the vectors contains elements but
     are not correct, the exception `error4' will be thrown.


* Menu:

* Usage and interface (gengraph2)::
* Documentation on exports (gengraph2)::

   ---------- Footnotes ----------

   (1) In scatter graphs the attibute that contains the features of a
point dataset is `PAtts'.


File: ciao.info,  Node: Usage and interface (gengraph2),  Next: Documentation on exports (gengraph2),  Prev: gengraph2 (library),  Up: gengraph2 (library)

Usage and interface (`gengraph2')
=================================

   * *Library usage:*

     `:- use_module(library(gengraph2)).'

   * *Exports:*
        - _Predicates:_

          `graph_b2/9', `graph_b2/13', `graph_w2/9', `graph_w2/13',
          `scattergraph_b2/8', `scattergraph_b2/12',
          `scattergraph_w2/8', `scattergraph_w2/12'.


   * *Other modules used:*
        - _System library modules:_

          `chartlib/gengraph1', `chartlib/genbar1',
          `chartlib/bltclass', `chartlib/color_pattern',
          `chartlib/test_format', `lists', `random/random'.




File: ciao.info,  Node: Documentation on exports (gengraph2),  Prev: Usage and interface (gengraph2),  Up: gengraph2 (library)

Documentation on exports (`gengraph2')
======================================

 - PREDICATE: graph_b2/9:
     `graph_b2(Header,GTitle,XTitle,XVectors,YTitle,YVectors,LAtts,Footer,Sm)'

     Besides the features mentioned at the begining of the module
     chapter, the displayed graph generated calling this predicate
     has the following distinguish characteristics:

        * The plotting area background color is black.

        * The cross hairs color is white.

        * The axis limits are determined from the data.


     Example:

          graph_b2('This is the header text',
            'Graph_title',
            'xaxistitle',
            [[20,30,59],[25,50]],
            'yaxixtitle',
            [[10,35,40],[25,50]],
            [['line1','Blue','Yellow'],['line2']],
            'footer',
            'natural').




 - PREDICATE: graph_b2/13:
     `graph_b2(Header,GT,XT,XVs,XMax,XMin,YT,YVs,YMax,YMin,LAtts,Footer,Smooth)'

     In addition to the features brought up at the begining of the
     module chapter, this graph has the following:

        * The plotting area background color is black.

        * The cross hairs color is white.

        * You can set the maximum and minimum values for the graph
          axes.


     Example:

          graph_b2('This is the header text',
            'Graph_title',
            'xaxistitle',
            [[20,10,59],[15,30,35]],
            50,
            _,
            'yaxixtitle',
            [[10,35,40],[25,50,60]],
            50.5,
            _,
            [['line1','Blue','Yellow'],['line','MediumTurquoise','Plum']],
            'footer',
            'step').




 - PREDICATE: graph_w2/9:
     `graph_w2(Header,GT,XT,XVectors,YTitle,YVectors,LAtts,Footer,Smooth)'

     This predicate is quite similar to `graph_b2/9'. The difference
     lies in the graph appearance, as you can see below.

        * The plotting area background color is white.

        * The cross hairs color is black.


     Example:

          graph_w2('This is the header text',
            'Graph_title',
            'xaxistitle',
            [[10,30,59],[25,50]],
            'yaxixtitle',
            [[10,35,40],[25,40]],
            [['element1','Blue','DarkOrchid'],['element2','DarkOliveGreen',
              'Firebrick']],
            'footer',
            'natural').




 - PREDICATE: graph_w2/13:
     `graph_w2(Header,GT,XT,XV,XMax,XMin,YT,YVs,YMax,YMin,LAtts,Footer,Smooth)'

     This predicate is comparable to `graph_b2/13'. The differences
     lie in the plot background color and in the cross hairs color,
     wich are white and black respectively.

     Example:
          graph_w2('This is the header text',
            'Graph_title',
            'xaxistitle',
            [[10,30,59],[10,35,40]],
            80,
            _,
            'yaxixtitle',
            [[10,35,40],[25,50,60]],
            50,
            _,
            [['element1','Blue','Green'],['element2','Turquoise','Black']],
            'footer',
            'linear').




 - PREDICATE: scattergraph_b2/8:
     `scattergraph_b2(Header,GT,XT,XVectors,YT,YVectors,PAtts,Footer)'

     Apart from the features brought up at the beginning of the
     chapter, the scatter graph displayed when invoking this
     predicate has the following features:

        * The plotting area background color is black.

        * The cross hairs color is white.

        * The axis limits are determined from the data.


     Example:
          scattergraph_b2('This is the header text',
            'Graph_title',
            'xaxistitle',
            [[10,15,20],[8,30,40]],
            'yaxixtitle',
            [[10,35,20],[15,11,21]],
            [['element1','Blue','Yellow'],['element2','MediumTurquoise','Plum']],
            'footer').




 - PREDICATE: scattergraph_b2/12:
     `scattergraph_b2(Header,GT,XT,XVs,XMax,XMin,YT,YVs,YMax,YMin,PAtts,Footer)'

     The particular features related to this predicate are described
     below:

        * The plotting area background color is black.

        * The cross hairs color is white.

        * You can set the minimum and maximum limits of the axes.
          Data outside the limits will not be plotted.


     Example:
          scattergraph_b2('This is the header text',
            'Graph_title',
            'xaxistitle',
            [[20,30,50],[18,40,59]],
            50,
            _,
            'yaxixtitle',
            [[10,35,40],[25,50,60]],
            50,
            _,
            [['point dataset1'],['point dataset2']],
            'footer').




 - PREDICATE: scattergraph_w2/8:
     `scattergraph_w2(Header,GTitle,XTitle,XVs,YTitle,YVs,PAtts,Footer)'

     This predicate is quite similar to `scattergraph_w1/8' except in
     the following:

        * The plotting area background color is black.

        * The cross hairs color is white.

        * If the user do not provide the colors of the points, they
          will be chosen among the lighter ones.


     Example:
          scattergraph_w2('This is the header text',
            'Graph_title',
            'xaxistitle',
            [[20,30,40,15,30,35,20,30]],
            'yaxixtitle',
            [[10,30,40,25,20,25,20,25]],
            [['set1','cross',4]],
            'footer').




 - PREDICATE: scattergraph_w2/12:
     `scattergraph_w2(Header,GT,XT,XVs,XMax,XMin,YT,YVs,YMax,YMin,PAtts,Footer)'

     This predicate is comparable to `scattergraph_w2/13', the
     differences between them are listed below:

        * The plotting area background color is white.

        * The cross hairs color is black.


     Example:
          scattergraph_w2('This is the header text',
            'Graph_title',
            'xaxistitle',
            [[20,10,59],[15,30,50]],
            150,
            5,
            'yaxixtitle',
            [[10,35,40],[25,20,60]],
            _,
            -10,
            [['e1','Blue','Yellow'],['e2','MediumTurquoise','Plum']],
            'footer').





File: ciao.info,  Node: genmultibar (library),  Next: table_widget1 (library),  Prev: gengraph2 (library),  Up: Top

genmultibar (library)
*********************

   This module defines predicates which show barchart widgets. These
bar charts are somewhat different from the bar charts generated by
the predicates in modules genbar1, genbar2, genbar3 and genbar4.
Predicates in the present module show different features of each
dataset element in one chart at the same time. Each bar chart element
is a group of bars, and the element features involve three vectors
defined as follows:

   * xvector is a list containing the names (atoms) of the bars (n
     elements). Each bar group will be displayed at uniform intervals.

   * yvector is a list that contains m sublists, each one is composed
     of n elements. The i-sublist contains the y-values of the
     i-BarAttribute element for all of the XVector elements.

   * bar_attributtes is a list containing the appearance features of
     the bars (m elements). Each element of the list can be partial
     or complete, which means that you can define as bar attributes
     only the element name or by setting the element name, its
     background and foreground color and its stipple pattern.


   Other relevant aspects about this widgets are:

   * If you don't want to display text in the elements header,
     barchart title, xaxis title, yaxis title or footer, simply type
     `''' as the value of the argument.

   * The bar chart has a legend, and one entry (symbol and label) per
     feature group bar.

   * The user can either select the appearance of the bars
     (background color, foreground color and stipple style) or not.
     See the multibar_attribute type definition.

   * Data points can have their bar segments displayed in one of the
     following modes: stacked, aligned, overlapped or overlayed. They
     user can change the mode clicking in the checkboxes associated
     to each mode.

   * The predicates test whether the format of the arguments is
     correct. If one or both vectors are empty, the exception
     `error2' will be thrown. If the vectors contains elements but
     are not correct, the exception `error5' or `error6' will be
     thrown, depending on what is incorrect. `error5' means that
     `XVector' and each element of `YVector' do not contain the same
     number of elements or that `YVector' and `BarsAtt' do not
     contain the same number of elements, while `error6' indicates
     that not all the `BarsAtt' elements contain a correct number of
     attributes.


   The examples will help you to understand how these predicates
should be called.

* Menu:

* Usage and interface (genmultibar)::
* Documentation on exports (genmultibar)::
* Documentation on internals (genmultibar)::


File: ciao.info,  Node: Usage and interface (genmultibar),  Next: Documentation on exports (genmultibar),  Prev: genmultibar (library),  Up: genmultibar (library)

Usage and interface (`genmultibar')
===================================

   * *Library usage:*

     `:- use_module(library(genmultibar)).'

   * *Exports:*
        - _Predicates:_

          `multibarchart/8', `multibarchart/10'.


   * *Other modules used:*
        - _System library modules:_

          `chartlib/genbar1', `chartlib/bltclass',
          `chartlib/color_pattern', `chartlib/test_format',
          `chartlib/install_utils', `lists', `random/random'.




File: ciao.info,  Node: Documentation on exports (genmultibar),  Next: Documentation on internals (genmultibar),  Prev: Usage and interface (genmultibar),  Up: genmultibar (library)

Documentation on exports (`genmultibar')
========================================

 - PREDICATE: multibarchart/8:
     `multibarchart(Header,BTitle,XTitle,XVector,YTitle,BarsAtts,YVector,Footer)'

     The x axis limits are autoarrange. The user can call the
     predicate in two ways. In the first example the user sets the
     appearance of the bars, in the second one the appearance
     features will be chosen by the library.

     Example1:
          multibarchart('This is the Header text',
          	'My BarchartTitle',
          	'Processors',
          	['processor1','processor2','processor3','processor4'],
          	'Time (seconds)',
          	[['setup time','MediumTurquoise','Plum','pattern2'],
          	    ['sleep time','Blue','Green','pattern5'],
          	    ['running time','Yellow','Plum','pattern1']],
          	[[20,30,40,50],[10,8,5,35],[60,100,20,50]],
          	'This is the Footer text').
     Example2:
          multibarchart('This is the Header text',
          	'My BarchartTitle',
          	'Processors',
          	['processor1','processor2','processor3','processor4'],
          	'Time (seconds)',
          	[['setup time'],['sleep time'],['running time']],
          	[[20,30,40,50],[10,8,5,35],[60,100,20,50]],
          	'This is the Footer text').




 - PREDICATE: multibarchart/10:
     `multibarchart(Header,BT,XT,XVector,YT,BAtts,YVector,YMax,YMin,Footer)'

     This predicate is quite similar to `multibarchart/8', except in
     that you can choose limits in the y axis. The part of the bars
     placed outside the limits will not be plotted.

     Example2:
          multibarchart('This is the Header text',
          	'My BarchartTitle',
          	'Processors',
          	['processor1','processor2','processor3','processor4'],
          	'Time (seconds)',
          	[['setup time'],['sleep time'],['running time']],
          	[[20,30,40,50],[10,8,5,35],[60,100,20,50]],
          	[80],
          	[0],
          	'This is the Footer text').





File: ciao.info,  Node: Documentation on internals (genmultibar),  Prev: Documentation on exports (genmultibar),  Up: genmultibar (library)

Documentation on internals (`genmultibar')
==========================================

 - REGTYPE: multibar_attribute/1:
          multibar_attribute([LegendElement]) :-
                  atomic(LegendElement).
          multibar_attribute([LegendElement,ForegroundColor,BackgroundColor,StipplePattern]) :-
                  atom(LegendElement),
                  color(ForegroundColor),
                  color(BackgroundColor),
                  pattern(StipplePattern).

     Defines the attributes of each feature bar along the different
     datasets.

    LegendElement
          Legend element name. It may be a number or an atom. Every
          `LegendElement' value of the list must be unique.

    `ForegColor'
          It sets the Foreground color of the bar. Its value must be
          a valid color, otherwise the system will throw an
          exception. If the argument value is a variable, it gets
          instantiated to a color chosen by the library.

    `BackgColor'
          It sets the Background color of the bar. Its value must be
          a valid color, otherwise the system will throw an
          exception. If the argument value is a variable, it gets
          instantiated to a color chosen by the library.

    `SPattern'
          It sets the stipple of the bar. Its value must be a valid
          pattern, otherwise the system will throw an exception. If
          the argument value is a variable, it gets instantiated to a
          pattern chosen by the library.




 - REGTYPE: xelement/1:
          xelement(Label) :-
                  atomic(Label).
     This type defines a dataset label. Although `Label' values may
     be numbers, the will be treated as atoms, So it will be
     displayed at uniform intervals along the x axis.





File: ciao.info,  Node: table_widget1 (library),  Next: table_widget2 (library),  Prev: genmultibar (library),  Up: Top

table_widget1 (library)
***********************

   In addition to the features explained in the introduction, the
predicates exported by this module depict tables in which the font
weight for the table elements is bold.

   If the arguments are not in a correct format the exception
`error8' will be thrown.

* Menu:

* Usage and interface (table_widget1)::
* Documentation on exports (table_widget1)::
* Documentation on internals (table_widget1)::


File: ciao.info,  Node: Usage and interface (table_widget1),  Next: Documentation on exports (table_widget1),  Prev: table_widget1 (library),  Up: table_widget1 (library)

Usage and interface (`table_widget1')
=====================================

   * *Library usage:*

     `:- use_module(library(table_widget1)).'

   * *Exports:*
        - _Predicates:_

          `tablewidget1/4', `tablewidget1/5'.

        - _Regular Types:_

          `table/1', `image/1'.


   * *Other modules used:*
        - _System library modules:_

          `chartlib/genbar1', `chartlib/bltclass',
          `chartlib/test_format', `chartlib/install_utils', `lists'.




File: ciao.info,  Node: Documentation on exports (table_widget1),  Next: Documentation on internals (table_widget1),  Prev: Usage and interface (table_widget1),  Up: table_widget1 (library)

Documentation on exports (`table_widget1')
==========================================

 - PREDICATE: tablewidget1/4:
     `tablewidget1(Title,Header,ElementTable,Footer)'

     Shows a regular table in a window. The user does not choose a
     background image.

     Example:
          tablewidget1('This is the title',
          	     'Header text',
          	     [['Number of processors','8'],['Average processors','95'],
          	         ['Average Tasks per fork','7.5']],
          	     'Footer text').




 - PREDICATE: tablewidget1/5:
     `tablewidget1(Title,Header,ElementTable,Footer,BackgroundImage)'

     Shows a regular table in a window. The user must set a
     background image. See the `image/1' type definition.

     Example:
          tablewidget1('This is the title',
          	     'Header text',
          	     [['Number of processors','8'],['Average processors','95'],
          	         ['Average Tasks per fork','7.5']],
          	     'Footer text',
          	     './images/rain.gif')




 - REGTYPE: table/1:
     A table is a list of rows, each row must contain the same number
     of elements, otherwise the table wouldn't be regular and an
     exception will be thrown by the library. The rows list may not
     be empty.
          table([X]) :-
                  row(X).
          table([X|Xs]) :-
                  row(X),
                  table(Xs).




 - REGTYPE: image/1:
     Some predicates allow the user to set the widget background
     image, whose is what this type is intended for. The user has to
     take into account the following restrictions:

        * The image must be in gif format.

        * The file path must be absolute.






File: ciao.info,  Node: Documentation on internals (table_widget1),  Prev: Documentation on exports (table_widget1),  Up: table_widget1 (library)

Documentation on internals (`table_widget1')
============================================

 - REGTYPE: row/1:
          row([X]) :-
                  cell_value(X).
          row([X|Xs]) :-
                  cell_value(X),
                  row(Xs).
     Each row is a list of elements whose type is `cell_value/1'. A
     row cannot be an empty list, as you can see in the definition
     type.




 - REGTYPE: row/1:
          row([X]) :-
                  cell_value(X).
          row([X|Xs]) :-
                  cell_value(X),
                  row(Xs).
     Each row is a list of elements whose type is `cell_value/1'. A
     row cannot be an empty list, as you can see in the definition
     type.




 - REGTYPE: cell_value/1:
     This type defines the possible values that a table element have.
     If any cell value is `''', the cell will be displayed empty.
          cell_value(X) :-
                  atomic(X).





File: ciao.info,  Node: table_widget2 (library),  Next: table_widget3 (library),  Prev: table_widget1 (library),  Up: Top

table_widget2 (library)
***********************

   In addition to the features explained in the introduction,
predicates exported by this module display tables in which the font
weight for the elements placed in the first row is bold. The
remaining elements are in medium weight font.

   If the arguments are not in a correct format the exception
`error8' will be thrown.

* Menu:

* Usage and interface (table_widget2)::
* Documentation on exports (table_widget2)::


File: ciao.info,  Node: Usage and interface (table_widget2),  Next: Documentation on exports (table_widget2),  Prev: table_widget2 (library),  Up: table_widget2 (library)

Usage and interface (`table_widget2')
=====================================

   * *Library usage:*

     `:- use_module(library(table_widget2)).'

   * *Exports:*
        - _Predicates:_

          `tablewidget2/4', `tablewidget2/5'.


   * *Other modules used:*
        - _System library modules:_

          `chartlib/genbar1', `chartlib/bltclass',
          `chartlib/table_widget1', `chartlib/test_format',
          `chartlib/install_utils', `lists'.




File: ciao.info,  Node: Documentation on exports (table_widget2),  Prev: Usage and interface (table_widget2),  Up: table_widget2 (library)

Documentation on exports (`table_widget2')
==========================================

 - PREDICATE: tablewidget2/4:
     `tablewidget2(Title,Header,ElementTable,Footer)'

     Shows a regular table in a window. The system sets a default
     background image for the widget.

     Example:
          tablewidget2('COM Features',
          	     'Extracted from "Inside COM" book ',
          	     [['Feature','Rich people','Bean Plants','C++','COM'],
          	       ['Edible','Yes','Yes','No','No'],
          	       ['Supports inheritance','Yes','Yes','Yes','Yes and No'],
          	       ['Can run for President','Yes','No','No','No']],
          	     'What do you think about COM?').




 - PREDICATE: tablewidget2/5:
     `tablewidget2(Title,Header,ElementTable,Footer,BackgroundImage)'

     This predicate and `tablewidget2/4' are quite similar, except
     that in the already one defined you must set the background
     image.

     Example:
          tablewidget2('COM Features',
          	     'Extracted from "Inside COM" book ',
          	     [['Feature','Rich people','Bean Plants','C++','COM'],
          	       ['Edible','Yes','Yes','No','No'],
          	       ['Supports inheritance','Yes','Yes','Yes','Yes and No'],
          	       ['Can run for President','Yes','No','No','No']],
          	     'What do you think about COM?',
          	     './images/rain.gif').





File: ciao.info,  Node: table_widget3 (library),  Next: table_widget4 (library),  Prev: table_widget2 (library),  Up: Top

table_widget3 (library)
***********************

   The predicates exported by this module display data in a regular
table, as we brought up in the introduction. Both predicates have in
common that the font weight for the elements placed in the first
column is bold and the remaining elements are in medium font weight.

   If the arguments are not in a correct format the exception
`error8' will be thrown.

* Menu:

* Usage and interface (table_widget3)::
* Documentation on exports (table_widget3)::


File: ciao.info,  Node: Usage and interface (table_widget3),  Next: Documentation on exports (table_widget3),  Prev: table_widget3 (library),  Up: table_widget3 (library)

Usage and interface (`table_widget3')
=====================================

   * *Library usage:*

     `:- use_module(library(table_widget3)).'

   * *Exports:*
        - _Predicates:_

          `tablewidget3/4', `tablewidget3/5'.


   * *Other modules used:*
        - _System library modules:_

          `chartlib/genbar1', `chartlib/bltclass',
          `chartlib/table_widget1', `chartlib/test_format',
          `chartlib/install_utils', `lists'.




File: ciao.info,  Node: Documentation on exports (table_widget3),  Prev: Usage and interface (table_widget3),  Up: table_widget3 (library)

Documentation on exports (`table_widget3')
==========================================

 - PREDICATE: tablewidget3/4:
     `tablewidget3(Title,Header,ElementTable,Footer)'

     Shows a regular table in a window. The user does not choose a
     background image.

     Example:
          tablewidget3('This is the title',
          	     'Header text',
          	     [['Number of processors','8'],['Average processors','95'],
          	       ['Tasks per fork','7.5']],
          	     'Footer text').




 - PREDICATE: tablewidget3/5:
     `tablewidget3(Title,Header,ElementTable,Footer,BackgroundImage)'

     Shows a regular table in a window. The user must set a
     background image.

     Example:
          tablewidget3('This is the title',
          	     'Header text',
          	     [['Number of processors','8'],['Average processors','95'],
          	         ['Average Tasks per fork','7.5']],
          	     'Footer text',
          	     './images/rain.gif')





File: ciao.info,  Node: table_widget4 (library),  Next: test_format (library),  Prev: table_widget3 (library),  Up: Top

table_widget4 (library)
***********************

   In addition to the features explained in the introduction,
predicates exported by this module display tables in which the font
weight for the elements placed in the first row and column is bold.
The remaining elements are in medium weight font.

   If the arguments are not in a correct format the exception
`error8' will be thrown.

* Menu:

* Usage and interface (table_widget4)::
* Documentation on exports (table_widget4)::


File: ciao.info,  Node: Usage and interface (table_widget4),  Next: Documentation on exports (table_widget4),  Prev: table_widget4 (library),  Up: table_widget4 (library)

Usage and interface (`table_widget4')
=====================================

   * *Library usage:*

     `:- use_module(library(table_widget4)).'

   * *Exports:*
        - _Predicates:_

          `tablewidget4/4', `tablewidget4/5'.


   * *Other modules used:*
        - _System library modules:_

          `chartlib/genbar1', `chartlib/bltclass',
          `chartlib/table_widget1', `chartlib/test_format',
          `chartlib/install_utils', `lists'.




File: ciao.info,  Node: Documentation on exports (table_widget4),  Prev: Usage and interface (table_widget4),  Up: table_widget4 (library)

Documentation on exports (`table_widget4')
==========================================

 - PREDICATE: tablewidget4/4:
     `tablewidget4(Title,Header,ElementTable,Footer)'

     Shows a regular table in a window. The system sets a default
     background image for the widget.

     Example:
          tablewidget4('Some sterEUtypes',
            'Source: Eurostat yearbook, 1999',
            [['Country','Adult alcohol intake per year (litres)',
                 'Cigarettes smoked per day per adult',
                       'Suicides per 100000 people'],
                ['Finland','8.4','2.2','26.3'],['Spain','11.4','5.3','7.5'],
                ['Austria','11.9','4.6','20.7'],['Britain','9.4','4.2','7.1'],
                ['USA','4.7','4.9','13'],['European Union','11.1','4.5','11.9']],
            'This is part of the published table').




 - PREDICATE: tablewidget4/5:
     `tablewidget4(Title,Header,ElementTable,Footer,BackgroundImage)'

     This predicate and `tablewidget4/4' are comparable, except that
     in the already defined you must set the background image.

     Example:
          tablewidget4('Some sterEUtypes',
            'Source: Eurostat yearbook, 1999',
            [['Country','Adult alcohol intake per year (litres)',
                 'Cigarettes smoked per day per adult',
                     'Suicides per 100000 people'],
                ['Finland','8.4','2.2','26.3'],['Spain','11.4','5.3','7.5'],
                ['Austria','11.9','4.6','20.7'],['Britain','9.4','4.2','7.1'],
                ['USA','4.7','4.9','13'],['European Union','11.1','4.5','11.9']],
            'This is part of the published table',
            './images/rain.gif').





File: ciao.info,  Node: test_format (library),  Next: *** PART XII - Appendices,  Prev: table_widget4 (library),  Up: Top

test_format (library)
*********************

   Most of the predicates exported by this module perform some checks
to determine whether the arguments attain some conditions or not. In
the second case an exception will be thrown. To catch the exceptions
you can use the following metapredicates when invoking chartlib
exported predicates:

   * `chartlib_text_error_protect/1'

   * `chartlib_text_error_protect/1'


   Both metapredicates are defined in the chartlib_errhandle module
that comes with this library. Some of the predicates have a
`Predicate' argument which will be used in case of error to show
which chartlib predicate causes the error.

* Menu:

* Usage and interface (test_format)::
* Documentation on exports (test_format)::


File: ciao.info,  Node: Usage and interface (test_format),  Next: Documentation on exports (test_format),  Prev: test_format (library),  Up: test_format (library)

Usage and interface (`test_format')
===================================

   * *Library usage:*

     `:- use_module(library(test_format)).'

   * *Exports:*
        - _Predicates:_

          `equalnumber/3', `not_empty/4', `not_empty/3',
          `check_sublist/4', `valid_format/4', `vectors_format/4',
          `valid_vectors/4', `valid_attributes/2', `valid_table/2'.


   * *Other modules used:*
        - _System library modules:_

          `chartlib/bltclass', `lists'.




File: ciao.info,  Node: Documentation on exports (test_format),  Prev: Usage and interface (test_format),  Up: test_format (library)

Documentation on exports (`test_format')
========================================

 - PREDICATE: equalnumber/3:
     `equalnumber(X,Y,Predicate)'

     Test whether the list `X' and the list `Y' contain the same
     number of elements.




 - PREDICATE: not_empty/4:
     `not_empty(X,Y,Z,Predicate)'

     Tests whether at least one the lists `X', `Y' or `Z' are empty.




 - PREDICATE: not_empty/3:
     `not_empty(X,Y,Predicate)'

     Tests whether the lists `X' or `Y' are empty.




 - PREDICATE: check_sublist/4:
     `check_sublist(List,Number,Number,Predicate)'

     Tests if the number of elements in each sublist of `List' is
     `Number1' or `Number2'.




 - PREDICATE: valid_format/4:
     `valid_format(XVector,YVector,BarsAttributes,Predicate)'

     Tests the following restrictions:

        * The `XVector' number of elements is the same as each
          `YVector' sublist number of elements.

        * The `YVector' length is equal to `BarsAttributes' length.





 - PREDICATE: vectors_format/4:
     `vectors_format(XVector,YVectors,LinesAttributes,Predicate)'

     Tests the following conditions:

        * `YVectors' list and `LinesAttributes' list have the same
          number of elements.

        * `XVector' list and each `YVectors' element have the same
          number of elements.

        * Each sublist of `LinesAttributes' is composed of 5, 3 or 1
          elements.





 - PREDICATE: valid_vectors/4:
     `valid_vectors(XVector,YVectors,LinesAttributes,Predicate)'

     Tests the following conditions:

        * `XVector' list, `YVectors' list and `LinesAttributes' list
          have the same number of elements.

        * Each sublist of `LinesAttributes' is composed of 5, 3 or 1
          element.





 - PREDICATE: valid_attributes/2:
     `valid_attributes(BarsAttibuttes,Predicate)'

     Check if each `BarsAttibuttes' element is a list composed of one
     or four elements.




 - PREDICATE: valid_table/2:
     `valid_table(ElementTable,Predicate)'

     All of the `ElementTable' sublists have the same number of
     elements and are not empty.





File: ciao.info,  Node: *** PART XII - Appendices,  Next: Installing Ciao from the source distribution,  Prev: test_format (library),  Up: Top

PART XII - Appendices
*********************

   These appendices describe the installation of the Ciao environment
on different systems and some other issues such as reporting bugs,
signing up on the Ciao user's mailing list, downloading new versions,
limitations, etc.


File: ciao.info,  Node: Installing Ciao from the source distribution,  Next: Installing Ciao from a Win32 binary distribution,  Prev: *** PART XII - Appendices,  Up: Top

Installing Ciao from the source distribution
********************************************

   *Author(s):* Manuel Carro, Daniel Cabeza, Manuel Hermenegildo.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#104 (2000/4/3, 10:41:2 CEST)

   To correctly install PiLLoW, first, make sure you downloaded the
right version of PiLLoW (there are different versions for different
LP/CLP systems; the version that comes with Ciao is of course the
right one for Ciao). Then, please follow these steps:

  1. Copy the files in the `images' directory to a WWW accessible
     directory in your server.

  2. Edit the file `icon_address.pl' and change the fact to point to
     the URL to be used to access the images above.

  3. In the Ciao system the files are in the correct place, in other
     systems copy the files `pillow.pl' and `icon_address.pl' to a
     suitable directory so that your Prolog system will find them.



File: ciao.info,  Node: Installing Ciao from a Win32 binary distribution,  Next: Beyond installation,  Prev: Installing Ciao from the source distribution,  Up: Top

Installing Ciao from a Win32 binary distribution
************************************************

   *Author(s):* Daniel Cabeza, Manuel Carro, Manuel Hermenegildo.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

   *Version of last change:* 1.5#92 (2000/3/28, 17:41:25 CEST)

   This describes the installation of Ciao after downloading the
Windows _binary_ (i.e., _precompiled_) distribution. It includes the
installation of libraries and manuals and applies to Windows NT/95/98
systems. This is the simplest Windows installation, since it requires
no compilation and is highly recommended. However, it is also
possible to compile Ciao from the source distribution on these
systems (please refer to *Note Installing Ciao from the source
distribution:: for details).

   If you find any problems during installation, please refer to
*Note Troubleshooting (nasty messages and nifty workarounds)::.  See
also *Note Downloading new versions:: and *Note Reporting bugs::.

* Menu:

* Win32 binary installation summary::
* Checking for correct installation on Win32::
* Compiling the miscellaneous utilities under Windows::
* Server installation under Windows::
* Uninstallation under Windows::


File: ciao.info,  Node: Win32 binary installation summary,  Next: Checking for correct installation on Win32,  Prev: Installing Ciao from a Win32 binary distribution,  Up: Installing Ciao from a Win32 binary distribution

Win32 binary installation summary
=================================

Please follow these steps (below we use the terms _folder_ and
_directory_ interchangeably):

  1. Download the precompiled distribution and unpack it into any
     suitable folder, such as, e.g., `C:\Program Files'.

     This will create there a folder whose name reflects the Ciao
     version. Due to limitations of Windows related to file
     associations, do not put Ciao too deep in the folder hierarchy.
     For unpacking you will need a recent version of a zip archive
     manager - there are many freely available such as `WinZip',
     `unzip', `pkunzip', etc. (see for example `www.winzip.com').
     Some users have reported some problems with version 6.2 of
     WinZip, but no problems with, e.g., version 7. With WinZip,
     simply click on "Extract" and select the extraction folder as
     indicated above.

  2. Stop any Ciao-related applications.

     If you have a previous version of Ciao installed, make sure you
     do not have any Ciao applications (including, e.g., a toplevel
     shell) running, or the extraction process may not be able to
     complete. You may also want to delete the entire folder of the
     previous installation to save space.

  3. Open the Ciao source directory created during extraction and run
     (e.g. by double-clicking on it) the `install'(`.bat') script.
     Answer "yes" to the dialog that pops up and type any type any
     character in the installation window to finish the process. You
     may need to reboot for the changes in the registry to take
     effect.

     This will update the windows registry (the file `ciao'(`.reg')
     lists the additions) and also create some `.bat' files which may
     be useful for running Ciao executables from the command line. It
     also creates initialization scripts for the `emacs' editor. The
     actions performed by the installation script are reported in the
     installation window.

  4. You may want to add a _windows shortcut_ in a convenient place,
     such as the desktop, to `ciaosh.cpx', the standard interactive
     toplevel shell. It is located inside the `shell' folder (e.g.,
     click on the file `ciaosh.cpx' with the right mouse button and
     select the appropriate option, `Send to->Desktop as shortcut').

  5. You may also want to add another shortcut to the file
     `ciao'(`.html') located inside `doc\reference\ciao_html' so that
     you can open the Ciao manual by simply double-clicking on this
     shortcut.

  6. Finally, if the (freely available) `emacs' editor/environment is
     not installed in your system, we _highly recommend_ that you
     also install it at this point. While it is easy to use Ciao with
     any editor of your choice, the Ciao distribution includes a very
     powerful _application development environment_ which is based on
     `emacs' and which enables, e.g., source-level debugging, syntax
     coloring, context-sensitive on-line help, etc. If you are not
     convinced, consider that many programmers inside Micros*ft use
     `emacs' for developing their programs.

     The emacs editor (in all its versions: Un*x, Windows, etc.) can
     be downloaded from, for example, `http://www.emacs.org/', and
     also from the many GNU mirror sites worldwide (See
     `http://www.gnu.org/' for a list), in the `gnu/emacs' and
     `gnu/windows/emacs' directories. For example, at UPM it can be
     found at `ftp://ftp.fi.upm.es/pub/mirrors/gnu/emacs' and
     `ftp://ftp.fi.upm.es/pub/mirrors/gnu/windows/emacs'. You can
     find answers to frequently asked questions (FAQ) about `emacs'
     in general at `http://www.gnu.org/software/emacs/emacs-faq.text'
     and about the Windows version at
     `http://www.gnu.org/software/emacs/windows/ntemacs.html'
     (despite the `ntemacs' name it runs fine also as is on Win9X and
     Win2000 machines).

     You need to tell `emacs' how to load the Ciao mode automatically
     when editing and how to access the on-line documentation:

        * Start `emacs' (double click on the icon or from the `Start'
          menu). Open (menu `Files->Open File' or simply <^X><^F>)
          the file `ForEmacs.txt' that the installation script has
          created in directory where you installed the Ciao
          distribution.

        * Copy the lines in the file (select with the mouse and then
          menu `Edit->Copy'). Open/Create using `emacs' (menu
          `Files->Open File' or simply <^X><^F>) the file `~/.emacs'
          (or, if this fails, `c:/.emacs').

        * Paste the two lines (menu `Edit->Paste' or simply <^X><^Y>)
          into the file and save (menu `Files->Save Buffer' or simply
          <^X><^S>).

        * Exit `emacs' and start it again.


     `emacs' should not report any errors (at least related to Ciao)
     on startup. At this point the `emacs' checks in the following
     section should work.



File: ciao.info,  Node: Checking for correct installation on Win32,  Next: Compiling the miscellaneous utilities under Windows,  Prev: Win32 binary installation summary,  Up: Installing Ciao from a Win32 binary distribution

Checking for correct installation on Win32
==========================================

   After the actions and registry changes performed by the
installation procedure, you should check that the following should
work correctly:

   * Ciao-related file types (`.pl' source files, `.cpx' executables,
     `.itf,.po,.asr' interface files, `.pls' scripts, etc.) should
     have specific icons associated with them (you can look at the
     files in the folders in the Ciao distribution to check).

   * Double-clicking on the shortcut to `ciaosh'(`.cpx') on the
     desktop should start the typical Prolog top-level shell in a
     window. If this shortcut has not been created on the desktop,
     then double-clicking on the `ciaosh'(`.cpx') icon inside the
     `shell' folder within the Ciao source folder should have the
     same effect.

   * In the top-level shell, Prolog library modules should load
     correctly. Type for example `use_module(library(dec10_io))' at
     the Ciao top-level prompt -you should get back a prompt with no
     errors reported.

   * To exit the top level shell, type `halt.' as usual, or <^Z>.


Also, the following documentation-related actions should work:

   * Double-clicking on the shortcut to `ciao'(`.html') which appears
     on the desktop should show the Ciao manual in your default WWW
     browser. If this shortcut has not been created you can
     double-click on the `ciao'(`.html') file in the
     `doc\reference\ciao_html' folder inside the Ciao source folder.
     Make sure you configure your browser to use _style sheets_ for
     correct formatting of the manual (note, however, that some older
     versions of Explorer did not support style sheets well and will
     give better results turning them off).

   * The `doc\reference' folder contains the manual also in the other
     formats present in the distribution, such as `info' (very
     convenient for users of the `emacs' editor/program development
     system) and `postscript' or `pdf', which are specially useful
     for printing. See *Note Printing manuals (Win32):: for
     instructions.


Finally, if `emacs' is installed, after starting it (double-clicking
on the `emacs' icon or from the `Start' menu) the following should
work:

   * Typing <^H> <i> (or in the menus `Help->Manuals->Browse Manuals
     with Info') should open a list of manuals in info format in
     which the Ciao manual(s) should appear.

   * When opening a Prolog file, i.e., a file with `.pl' or `.pls'
     ending, using <^X><^F>`filename' (or using the menus) the code
     should appear highlighted according to syntax (e.g., comments in
     red), and `Ciao/Prolog' menus should appear in the menu bar on
     top of the `emacs' window.

   * Loading the file using the `Ciao/Prolog' menu (or typing <^C>
     <l>) should start in another emacs buffer the Ciao toplevel
     shell and load the file. You should now be able to switch the
     the toplevel shell and make queries from within `emacs'.


*Note:* when using `emacs' it is _very convenient_ to swap the
locations of the (normally not very useful) <Caps Lock> key and the
(very useful in `emacs') <Ctrl> key on the keyboard. How to do this
is explained in the `emacs' frequently asked questions FAQs (see the
`emacs' download instructions for their location).


File: ciao.info,  Node: Compiling the miscellaneous utilities under Windows,  Next: Server installation under Windows,  Prev: Checking for correct installation on Win32,  Up: Installing Ciao from a Win32 binary distribution

Compiling the miscellaneous utilities under Windows
===================================================

   The `etc' folder contains a number of utilities, documented in the
manual in _PART V - Miscellaneous Standalone Utilities_. In the Win32
distribution these utilities are not compiled by the installation
process. You can create the executable for each of them when needed
by compiling the corresponding `.pl' file.


File: ciao.info,  Node: Server installation under Windows,  Next: Uninstallation under Windows,  Prev: Compiling the miscellaneous utilities under Windows,  Up: Installing Ciao from a Win32 binary distribution

Server installation under Windows
=================================

   If you would like to install Ciao on a server machine, used by
several clients, the following steps are recommended:

   * Follow the standard installation procedure on the server. When
     selecting the folder in which Ciao is installed make sure you
     select a folder that is visible by the client machines. Also
     make sure that the functionality specified in the previous
     sections is now available on the server.

   * Perform a _client installation_ on each client, by running
     (e.g., double-click on it) the `client.bat' script. This should
     update the registry of each client. At this point all the
     functionality should also be available on the clients.



File: ciao.info,  Node: Uninstallation under Windows,  Prev: Server installation under Windows,  Up: Installing Ciao from a Win32 binary distribution

Uninstallation under Windows
============================

   To uninstall Ciao under Windows, simply delete the directory in
which you put the Ciao distribution. If you also want to delete the
registry entries created by the Ciao installation (not strictly
needed) this must currently be done by hand. The installation leaves
a list of these entries in the file `ciao.reg' to aid in this task.
Also, all the register entries contain the word _ciao_. Thus, to
delete all Ciao entries, run the application `regedit' (for example,
by selecting `Run' from the Windows `Start' menu), search (<^F>) for
_ciao_ in all registry entries (i.e., select all of `Keys', `Values',
and `Data' in the `Edit->Find' dialog), and delete each matching key
(click on the left window to find the matching key for each entry
found).


File: ciao.info,  Node: Beyond installation,  Next: References,  Prev: Installing Ciao from a Win32 binary distribution,  Up: Top

Beyond installation
*******************

   *Author(s):* Manuel Carro, Daniel Cabeza, Manuel Hermenegildo.

   *Version:* 1.5#171 (2000/7/7, 16:10:17 CEST)

* Menu:

* Architecture-specific notes and limitations::
* Keeping up to date with the Ciao users mailing list::
* Downloading new versions::
* Reporting bugs::


File: ciao.info,  Node: Architecture-specific notes and limitations,  Next: Keeping up to date with the Ciao users mailing list,  Prev: Beyond installation,  Up: Beyond installation

Architecture-specific notes and limitations
===========================================

   Ciao makes use of advanced characteristics of modern architectures
and operating systems such as multithreading, shared memory, sockets,
locks, dynamic load libraries, etc., some of which are sometimes not
present in a given system and others may be implemented in very
different ways across the different systems. As a result, currently
not all Ciao features are available in all supported operating
systems. Sometimes this is because not all the required features are
present in all the OS flavors supported and sometimes because we
simply have not had the time to port them yet.

   The current state of matters is as follows:

LINUX:
     multithreading, shared DB access, and locking working.

Solaris:
     multithreading, shared DB access, and locking working.

IRIX:
     multithreading, shared DB access, and locking working.

SunOS 4:
     multithreading, shared DB access, and locking NOT working.

Win 95/98/NT/2000:
     multithreading, shared DB access, and locking working. Dynamic
     linking of object code (C) libraries NOT working.

   The features that do not work are disabled at compile time.


File: ciao.info,  Node: Keeping up to date with the Ciao users mailing list,  Next: Downloading new versions,  Prev: Architecture-specific notes and limitations,  Up: Beyond installation

Keeping up to date with the Ciao users mailing list
===================================================

   We recommend that you join the Ciao _users mailing list_
(`ciao-users@clip.dia.fi.upm.es'), in order to receive information on
new versions and solutions to problems. Simply send a message to
<ciao-users-request@clip.dia.fi.upm.es>, containing in the body only
the word:

   `subscribe'

alone in one line. Messages in the list are strictly limited to
issues directly related to Ciao Prolog and your email address will of
course be kept strictly confidential. You mail also want to subscribe
to the `comp.lang.prolog' newsgroup.

   There is additional info available on the Ciao system, other CLIP
group software, publications on the technology underlying these
systems, etc. in the CLIP group's WWW site
`http://clip.dia.fi.upm.es'.


File: ciao.info,  Node: Downloading new versions,  Next: Reporting bugs,  Prev: Keeping up to date with the Ciao users mailing list,  Up: Beyond installation

Downloading new versions
========================

   Ciao and its related libraries and utilities are under constant
improvement, so you should make sure that you have the latest
versions of the different components, which can be dowloaded from:

   `http://clip.dia.fi.upm.es/Software'


File: ciao.info,  Node: Reporting bugs,  Prev: Downloading new versions,  Up: Beyond installation

Reporting bugs
==============

   If you still have problems after downloading the latest version
and reading the installation instructions you can send a message to
<ciao-bug@clip.dia.fi.upm.es>. Please be as informative as possible
in your messages, so that we can reproduce the bug.

   * For _installation problems_ we typically need to have the
     version and patch number of the Ciao package (e.g., the name of
     the file downloaded), the output produced by the installation
     process (you can capture it by redirecting the output into a
     file or cutting and pasting with the mouse), and the exact
     version of the Operating System you are using (as well as the C
     compiler, if you took a source distribution).

   * For _problems during use_ we also need the Ciao and OS versions
     and a small example of code which we can run to reproduce the
     bug.



File: ciao.info,  Node: References,  Next: Library/Module Definition Index,  Prev: Beyond installation,  Up: Top

References
**********

*[AAF91]*
     J. Almgren, S. Andersson, L. Flood, C. Frisk, H. Nilsson, and J.
     Sundberg.
     _Sicstus Prolog Library Manual_.
     Po Box 1263, S-16313 Spanga, Sweden, October 1991.

*[AKNL86]*
     Hassan Ait-Kaci, Roger Nasr, and Pat Lincoln.
     E An Overview.
     Technical Report AI-420-86-P, Microelectronics and Computer
     Technology   Corporation, 9430 Research Boulevard, Austin, TX
     78759, December 1986.

*[Apt97]*
     K. Apt, editor.
     _From Logic Programming to Prolog_.
     Prentice-Hall, Hemel Hempstead, Hertfordshire, England, 1997.

*[BA82]*
     M. Ben-Ari.
     _Principles of Concurrent Programming_.
     Prentice Hall International, 1982.

*[BBP81]*
     D.L. Bowen, L. Byrd, L.M. Pereira, F.C.N. Pereira, and D.H.D.
     Warren.
     Decsystem-10 prolog user's manual.
     Technical report, Department of Artificial Intelligence,
     University of   Edinburgh, October 1981.

*[BCC97]*
     F. Bueno, D. Cabeza, M. Carro, M. Hermenegildo, P.
     L\'opez-Garc\'\ia, and   G. Puebla.
     The Ciao Prolog System. Reference Manual.
     The Ciao System Documentation Series-TR CLIP3/97.1, School of
     Computer   Science, Technical University of Madrid (UPM), August
     1997.

*[BdlBH99]*
     F. Bueno, M.~Garc\'\ia de~la Banda, and M. Hermenegildo.
     Effectiveness of Abstract Interpretation in Automatic
     Parallelization: A Case Study in Logic Programming.
     _ACM Transactions on Programming Languages and Systems_,
     21(2):189-238, March 1999.

*[BLGPH99]*
     F. Bueno, P. L\'opez-Garc\'\ia, G. Puebla, and M. Hermenegildo.
     The Ciao Prolog Preprocessor.
     Technical Report CLIP8/95.0.7.20, Technical University of Madrid
     (UPM),   Facultad de Inform\'atica, 28660 Boadilla del Monte,
     Madrid, Spain, November   1999.

*[Bue95]*
     F. Bueno.
     The CIAO Multiparadigm Compiler: A User's Manual.
     Technical Report CLIP8/95.0, Facultad de Inform\'atica, UPM, June
      1995.

*[Byr80]*
     L. Byrd.
     Understanding the Control Flow of Prolog Programs.
     In S.-A. T\"arnlund, editor, _Workshop on Logic Programming_,
     Debrecen, 1980.

*[Car87]*
     M. Carlsson.
     Freeze, Indexing, and Other Implementation Issues in the Wam.
     In _Fourth International Conference on Logic Programming_, pages
      40-58. University of Melbourne, MIT Press, May 1987.

*[Car88]*
     M. Carlsson.
     _Sicstus Prolog User's Manual_.
     Po Box 1263, S-16313 Spanga, Sweden, February 1988.

*[CCG98]*
     I. Caballero, D. Cabeza, S. Genaim, J.M. Gomez, and M.
     Hermenegildo.
     persdb\_sql: SQL Persistent Database Interface.
     Technical Report D3.1.M2-A2 CLIP10/98.0, RADIOWEB Project,
     December   1998.

*[CGH93]*
     M. Carro, L. G\'omez, and M. Hermenegildo.
     Some Paradigms for Visualizing Parallel Execution of Logic
     Programs.
     In _1993 International Conference on Logic Programming_, pages
     184-201. MIT Press, June 1993.

*[CH95]*
     D. Cabeza and M. Hermenegildo.
     Distributed Concurrent Constraint Execution in the CIAO System.
     In _Proc. of the 1995 COMPULOG-NET Workshop on Parallelism and
     Implementation Technologies_, Utrecht, NL, September 1995. U.
     Utrecht / T.U.    Madrid.
     Available from \htmladdnormallink\tt
     http://www.clip.dia.fi.upm.es/   http://www.clip.dia.fi.upm.es/.

*[CH97]*
     D. Cabeza and M. Hermenegildo.
     WWW Programming using Computational Logic Systems (and the
     PILLOW/CIAO Library).
     In _Proceedings of the Workshop on Logic Programming and the WWW
     at   WWW6_, San Francisco, CA, April 1997.

*[CH99]*
     D. Cabeza and M. Hermenegildo.
     The Ciao Modular Compiler and Its Generic Program Processing
     Library.
     In _ICLP'99 WS on Parallelism and Implementation of (C)LP
     Systems_,   pages 147-164. N.M. State U., December 1999.

*[CH00a]*
     D. Cabeza and M. Hermenegildo.
     A New Module System for Prolog.
     In _International Conference on Computational Logic, CL2000_,
     number   1861 in LNAI, pages 131-148. Springer-Verlag, July 2000.

*[CH00b]*
     D. Cabeza and M. Hermenegildo.
     The Ciao Modular, Standalone Compiler and Its Generic   Program
     Processing Library.
     In _Special Issue on Parallelism and Implementation of (C)LP
     Systems_,   volume 30 of _Electronic Notes in Theoretical
     Computer Science_.    Elsevier - North Holland, March 2000.

*[CH00c]*
     M. Carro and M. Hermenegildo.
     Tools for Constraint Visualization: The VIFID/TRIFID Tool.
     In P. Deransart, M. Hermenegildo, and J. Maluszynski, editors,
     _Analysis and Visualization Tools for Constraint Programming_,
     number 1870 in LNCS, pages 253-272. Springer-Verlag, September
     2000.

*[CH00d]*
     M. Carro and M. Hermenegildo.
     Tools for Search Tree Visualization: The APT Tool.
     In P. Deransart, M. Hermenegildo, and J. Maluszynski, editors,
     _Analysis and Visualization Tools for Constraint Programming_,
     number 1870 in LNCS, pages 237-252. Springer-Verlag, September
     2000.

*[CHGT98]*
     D. Cabeza, M. Hermenegildo, S. Genaim, and C. Taboch.
     Design of a Generic, Homogeneous Interface to Relational
     Databases.
     Technical Report D3.1.M1-A1, CLIP7/98.0, RADIOWEB Project,
     September   1998.

*[CHV96a]*
     D. Cabeza, M. Hermenegildo, and S. Varma.
     The PiLLoW/CIAO Library for INTERNET/WWW Programming using
     Computational Logic Systems.
     In _Proceedings of the 1st Workshop on Logic Programming Tools
     for   INTERNET Applications_, pages 72-90, JICSLP'96, Bonn,
     September 1996.

*[CHV96b]*
     D. Cabeza, M. Hermenegildo, and S. Varma.
     The \sf P\em i\sf LL\em o\sf W/CIAO Library for   INTERNET/WWW
     Programming using Computational Logic Systems.
     In _Proceedings of the 1st Workshop on Logic Programming Tools
     for   INTERNET Applications_, JICSLP'96, Bonn, September 1996.
     Available from \htmladdnormallink\tt
     http://clement.info.umoncton.ca/\~lpnet
     http://clement.info.umoncton.ca/\~lpnet.

*[CLI95]*
     The CLIP Group.
     CIAO Compiler: Distributed Execution and Low Level Support
     Subsystem.
     Public Software, ACCLAIM Deliverable D4.3/2-A3, Facultad de
     Inform\'atica, UPM, June 1995.

*[CM81]*
     W.F. Clocksin and C.S. Mellish.
     _Programming in Prolog_.
     Springer-Verlag, 1981.

*[Col78]*
     A. Colmerauer.
     Metamorphosis grammars.
     In _Natural language communication with computers_, pages
     133-189.    Springer LNCS 63, 1978.

*[Col82]*
     A. Colmerauer et al.
     _Prolog II: Reference Manual and Theoretical Model_.
     Groupe D'intelligence Artificielle, Facult\'e Des Sciences De
     Luminy,   Marseille, 1982.

*[DEDC96]*
     P. Deransart, A. Ed-Dbali, and L. Cervoni.
     _Prolog: The Standard_.
     Springer-Verlag, 1996.

*[Dij65]*
     E.W. Dijkstra.
     Co-operating sequential processes.
     In F. Genuys, editor, _Programming Languages_. Academic Press,
     London,   1965.

*[DL93]*
     S.K. Debray and N.W. Lin.
     Cost analysis of logic programs.
     _ACM Transactions on Programming Languages and Systems_,
     15(5):826-875, November 1993.

*[DLGH97]*
     S.K. Debray, P. L\'opez-Garc\'\ia, and M. Hermenegildo.
     Non-Failure Analysis for Logic Programs.
     In _1997 International Conference on Logic Programming_, pages
     48-62,   Cambridge, MA, June 1997. MIT Press, Cambridge, MA.

*[DLGHL97]*
     S.K. Debray, P. L\'opez-Garc\'\ia, M. Hermenegildo, and N.-W.
     Lin.
     Lower Bound Cost Estimation for Logic Programs.
     In _1997 International Logic Programming Symposium_, pages
     291-305.    MIT Press, Cambridge, MA, October 1997.

*[GCH98]*
     J.M. Gomez, D. Cabeza, and M. Hermenegildo.
     WebDB: A Database WWW Interface.
     Technical Report D3.1.M2-A3 CLIP11/98.0, RADIOWEB Project,
     December   1998.

*[GdW94]*
     J.P. Gallagher and D.A. de Waal.
     Fast and precise regular approximations of logic programs.
     In Pascal Van~Hentenryck, editor, _Proc.~of the 11th
     International   Conference on Logic Programming_, pages 599-613.
     MIT Press, 1994.

*[HBC96]*
     M. Hermenegildo, F. Bueno, D. Cabeza, M. Carro, M. Garc\'\ia de
     la Banda,   P. L\'opez-Garc\'\ia, and G. Puebla.
     The CIAO Multi-Dialect Compiler and System: A Demo and   Status
     Report.
     In _Proceedings of the JICSLP'96 Workshop on Parallelism and
     Implementation Technology_. Computer Science Department,
     Technical University   of Madrid, September 1996.
     Available from \htmladdnormallink\tt
     http://www.clip.dia.fi.upm.es/Projects/COMPULOG/meeting96/papers/PS/clip.ps.%
     gz
     http://www.clip.dia.fi.upm.es/Projects/COMPULOG/meeting96/papers/PS/clip.ps%
     .gz.

*[HBC99]*
     M. Hermenegildo, F. Bueno, D. Cabeza, M. Carro, M.~Garc\'\ia de
     la Banda,   P. L\'opez-Garc\'\ia, and G. Puebla.
     The CIAO Multi-Dialect Compiler and System: An   Experimentation
     Workbench for Future (C)LP Systems.
     In _Parallelism and Implementation of Logic and Constraint
     Logic Programming_, pages 65-85. Nova Science, Commack, NY, USA,
     April   1999.

*[HBGP95]*
     M. Hermenegildo, F. Bueno, M. Garc\'\ia de la Banda, and G.
     Puebla.
     The CIAO Multi-Dialect Compiler and System: An   Experimentation
     Workbench for Future (C)LP Systems.
     In _Proceedings of the ILPS'95 Workshop on Visions for the
     Future of   Logic Programming_, Portland, Oregon, USA, December
     1995.
     Available from \htmladdnormallink\tt
     http://www.clip.dia.fi.upm.es/   http://www.clip.dia.fi.upm.es/.

*[HBPLG99]*
     M. Hermenegildo, F. Bueno, G. Puebla, and P. L\'opez-Garc\'\ia.
     Program Analysis, Debugging and Optimization Using the Ciao
     System Preprocessor.
     In _1999 International Conference on Logic Programming_, pages
     52-66,   Cambridge, MA, November 1999. MIT Press.

*[HC93]*
     M. Hermenegildo and The CLIP Group.
     Towards CIAO-Prolog - A Parallel Concurrent Constraint   System.
     In _Proc. of the Compulog Net Area Workshop on Parallelism and
     Implementation Technologies_. FIM/UPM, Madrid, Spain, June 1993.

*[HC94]*
     M. Hermenegildo and The CLIP Group.
     Some Methodological Issues in the Design of CIAO - A Generic,
     Parallel, Concurrent Constraint System.
     In _Principles and Practice of Constraint Programming_, number
     874 in   LNCS, pages 123-133. Springer-Verlag, May 1994.

*[HC97]*
     M. Hermenegildo and The CLIP Group.
     An Automatic Documentation Generator for (C)LP - Reference
     Manual.
     The Ciao System Documentation Series-TR CLIP5/97.3, Facultad de
     Inform\'atica, UPM, August 1997.

*[HCC95]*
     M. Hermenegildo, D. Cabeza, and M. Carro.
     Using Attributed Variables in the Implementation of Concurrent
     and   Parallel Logic Programming Systems.
     In _Proc. of the Twelfth International Conference on Logic
     Programming_, pages 631-645. MIT Press, June 1995.

*[Her86]*
     M. Hermenegildo.
     An Abstract Machine for Restricted AND-parallel Execution of
     Logic Programs.
     In _Third International Conference on Logic Programming_, number
     225 in   Lecture Notes in Computer Science, pages 25-40.
     Imperial College,   Springer-Verlag, July 1986.

*[Her96]*
     M. Hermenegildo.
     Writing "Shell Scripts" in SICStus Prolog, April 1996.
     Posting in \tt comp.lang.prolog. Available from
     \htmladdnormallink\tt   http://www.clip.dia.fi.upm.es/
     http://www.clip.dia.fi.upm.es/.

*[Her99]*
     M. Hermenegildo.
     A Documentation Generator for Logic Programming Systems.
     Technical Report CLIP10/99.0, Facultad de Inform\'atica, UPM,
     September 1999.

*[Her00]*
     M. Hermenegildo.
     A Documentation Generator for (C)LP Systems.
     In _International Conference on Computational Logic, CL2000_,
     number   1861 in LNAI, pages 1345-1361. Springer-Verlag, July
     2000.

*[HG90]*
     M. Hermenegildo and K. Greene.
     \&-Prolog and its Performance: Exploiting Independent
     And-Parallelism.
     In _1990 International Conference on Logic Programming_, pages
     253-268. MIT Press, June 1990.

*[HG91]*
     M. Hermenegildo and K. Greene.
     The \&-Prolog System: Exploiting Independent And-Parallelism.
     _New Generation Computing_, 9(3,4):233-257, 1991.

*[Hog84]*
     C.~J. Hogger.
     _Introduction to Logic Programming_.
     Academic Press, London, 1984.

*[Hol90]*
     C. Holzbaur.
     _Specification of Constraint Based Inference Mechanisms
     through Extended Unification_.
     PhD thesis, University of Vienna, 1990.

*[Hol92]*
     C. Holzbaur.
     Metastructures vs. Attributed Variables in the Context of
     Extensible Unification.
     In _1992 International Symposium on Programming Language
     Implementation   and Logic Programming_, pages 260-268. LNCS631,
     Springer Verlag, August   1992.

*[Hol94]*
     C. Holzbaur.
     _SICStus 2.1/DMCAI Clp 2.1.1 User's Manual_.
     University of Vienna, 1994.

*[JL88]*
     D. Jacobs and A. Langen.
     Compilation of Logic Programs for Restricted And-Parallelism.
     In _European Symposium on Programming_, pages 284-297, 1988.

*[Knu84]*
     D. Knuth.
     Literate programming.
     _Computer Journal_, 27:97-111, 1984.

*[LGHD96]*
     P. L\'opez-Garc\'\ia, M. Hermenegildo, and S.K. Debray.
     A Methodology for Granularity Based Control of Parallelism in
     Logic Programs.
     _Journal of Symbolic Computation, Special Issue on Parallel
     Symbolic   Computation_, 22:715-734, 1996.

*[MH89]*
     K. Muthukumar and M. Hermenegildo.
     Determination of Variable Dependence Information at Compile-Time
      Through Abstract Interpretation.
     In _1989 North American Conference on Logic Programming_, pages
     166-189. MIT Press, October 1989.

*[Nai85]*
     L. Naish.
     _The MU-Prolog 3.2 Reference Manual_.
     TR 85/11, Dept. of Computer Science, U. of Melbourne, October
     1985.

*[Nai91]*
     L. Naish.
     Adding equations to NU-Prolog.
     In _Symp. on Progr. Language Impl. and Logic Progr (PLILP'91)_,
     LNCS   528, pages 15-26. Springer Verlag, 1991.

*[Par97]*
     The RADIOWEB~Project Partners.
     RADIOWEB EP25562: Automatic Generation of Web Sites for the
     Radio Brodcasting Industry - Project Description / Technical
     Annex.
     Technical Report, RADIOWEB Project, July 1997.

*[PBH97]*
     G. Puebla, F. Bueno, and M. Hermenegildo.
     An Assertion Language for Debugging of Constraint Logic
     Programs.
     In _Proceedings of the ILPS'97 Workshop on Tools and
     Environments for   (Constraint) Logic Programming_, October 1997.
     Available from \htmladdnormallink\tt
     ftp://clip.dia.fi.upm.es/pub/papers/assert\_lang\_tr\_discipldeliv.ps.gz
     ftp://clip.dia.fi.upm.es/pub/papers/assert\_lang\_tr\_discipldeliv.ps.gz
     as   technical report CLIP2/97.1.

*[PBH00]*
     G. Puebla, F. Bueno, and M. Hermenegildo.
     An Assertion Language for Constraint Logic Programs.
     In P. Deransart, M. Hermenegildo, and J. Maluszynski, editors,
     _Analysis and Visualization Tools for Constraint Programming_,
     number 1870 in LNCS, pages 23-61. Springer-Verlag, September
     2000.

*[PH99]*
     G. Puebla and M. Hermenegildo.
     Some Issues in Analysis and Specialization of Modular
     Ciao-Prolog Programs.
     In _ICLP'99 Workshop on Optimization and Implementation of
     Declarative   Languages_, pages 45-61. U. of Southampton, U.K,
     November 1999.

*[PW80]*
     F.C.N. Pereira and D.H.D. Warren.
     Definite clause grammars for language analysis - a survey of the
     formalism   and a comparison with augmented transition networks.
     _Artificial Intelligence_, 13:231-278, 1980.

*[SS86]*
     L. Sterling and E. Shapiro.
     _The Art of Prolog_.
     MIT Press, 1986.

*[Swe95]*
     Swedish Institute of Computer Science, P.O. Box 1263, S-16313
     Spanga, Sweden.
     _Sicstus Prolog V3.0 User's Manual_, 1995.


File: ciao.info,  Node: Library/Module Definition Index,  Next: Predicate/Method Definition Index,  Prev: References,  Up: Top

Library/Module Definition Index
*******************************

* Menu:

* actmods:                               Active modules (high-level distributed execution).
* aggregates:                            All solutions predicates.
* andprolog:                             Independent and-parallel execution.
* argnames:                              argnames (library).
* arithmetic:                            Arithmetic.
* assertions:                            The Ciao assertion package.
* assertions_props:                      Types and properties related to assertions.
* assrt_write:                           Pretty-printing assertions.
* atom2term:                             Atom to Term Conversion.
* atomic_basic:                          Basic predicates handling names of constants.
* attributes:                            Attributed variables.
* basic_props:                           Basic data types and properties.
* basiccontrol:                          Control constructs/predicates.
* basicmodes:                            Classical Prolog modes.
* bf:                                    Breadth-first execution.
* bltclass:                              Low level Interface between Prolog and blt.
* builtin_directives:                    Basic builtin directives.
* chartlib:                              A Chart Library.
* chartlib_errhandle:                    chartlib_errhandle (library).
* ciaosh:                                The interactive top-level shell.
* class:                                 Declaring classes and interfaces.
* classic:                               Classic Prolog package.
* clpq:                                  Constraint programming over rationals.
* clpr:                                  Constraint programming over reals.
* color_pattern:                         Color and Pattern Library.
* conc_aggregates:                       conc_aggregates (library).
* concurrency:                           Low-level concurrency/multithreading primitives.
* counters:                              counters (library).
* ctrlcclean:                            ctrlcclean (library).
* data_facts:                            Fast/concurrent update of facts.
* davinci:                               davinci (library).
* db_client:                             Low-level socket interface to SQL/ODBC databases.
* dcg:                                   Definite clause grammars.
* dcg_expansion:                         Definite clause grammars (expansion).
* debugger:                              Predicates controlling the interactive debugger.
* dec10_io:                              DEC-10 Prolog file IO.
* dict:                                  Dictionaries.
* dynamic:                               Dynamic predicates.
* dynmods:                               dynmods (library).
* emacs:                                 Calling emacs from Prolog.
* errhandle:                             errhandle (library).
* exceptions:                            Exception handling.
* expansion_tools:                       Code translation utilities.
* fastrw:                                Fast Reading and Writing of Terms.
* file_utils:                            file_utils (library).
* filenames:                             File name manipulation.
* foreign_compilation:                   Utilities for on-demand compilation of foreign files.
* foreign_interface:                     foreign_interface (library).
* format:                                Formatted output.
* freeze:                                Delaying predicates (freeze).
* functions:                             functions (library).
* genbar1:                               genbar1 (library).
* genbar2:                               genbar2 (library).
* genbar3:                               genbar3 (library).
* genbar4:                               genbar4 (library).
* gengraph1:                             gengraph1 (library).
* gengraph2:                             gengraph2 (library).
* genmultibar:                           genmultibar (library).
* global:                                global (library).
* graphs:                                Graphs.
* hiord:                                 Some Higher-Order Predicates.
* html:                                  HTML/XML/CGI programming.
* http:                                  HTTP conectivity.
* id:                                    Iterative-deepening execution.
* idlists:                               Identity lists.
* io_aux:                                Message printing primitives.
* io_basic:                              Basic input/output.
* iso:                                   ISO-Prolog package.
* iso_byte_char:                         iso_byte_char (library).
* iso_incomplete:                        iso_incomplete (library).
* iso_misc:                              iso_misc (library).
* isomodes:                              ISO-Prolog modes.
* javart:                                Low-level Prolog to Java interface.
* javasock:                              Low-level Prolog to Java socket connection.
* jtopl:                                 Low-level Java to Prolog interface.
* lgraphs:                               Labeled graph-processing utilities.
* libpaths:                              Customizing library paths and path aliases.
* librowser:                             The Ciao library browser.
* linda:                                 linda (library).
* lists:                                 List processing.
* loading_code:                          Directives for using code in other files.
* messages:                              Printing status and error messages.
* meta_props:                            Meta-properties.
* metaterms:                             Term manipulation.
* modules:                               The module system.
* mycin:                                 Programming MYCIN rules.
* native_props:                          Properties which are native to analyzers.
* numlists:                              Lists of numbers.
* objects:                               Compile-time usage of objects.
* objects_rt:                            Run time usage of objects.
* odd:                                   Miscellaneous predicates.
* old_database:                          Quintus-like internal database.
* operators:                             Defining operators.
* patterns:                              Pattern (regular expression) matching.
* persdbrt:                              Persistent predicate database.
* persdbrtsql:                           SQL persistent database interface.
* pillow:                                The PiLLoW Web Programming Library.
* pillow_types:                          PiLLoW types.
* pl2sql:                                Prolog to SQL translator.
* pretty_print:                          A simple pretty-printer for Ciao programs.
* prolog_flags:                          Changing system behaviour and various flags.
* prolog_sys:                            Prolog system internal predicates.
* pure:                                  Pure Prolog package.
* queues:                                queues (library).
* random:                                Random numbers.
* read:                                  Term input.
* regtypes:                              Declaring regular types.
* rtchecks:                              Run-time checking of assertions.
* runtime_ops:                           runtime_ops (library).
* sets:                                  sets (library).
* sockets:                               The socket interface.
* sort:                                  Sorting lists.
* streams:                               Structured stream handling.
* streams_basic:                         Basic file/stream handling.
* strings:                               String processing.
* syntax_extensions:                     Extending the syntax.
* system:                                Operating system utilities.
* system_info:                           Gathering some basic internal info.
* table_widget1:                         table_widget1 (library).
* table_widget2:                         table_widget2 (library).
* table_widget3:                         table_widget3 (library).
* table_widget4:                         table_widget4 (library).
* tcltk:                                 The Tcl/Tk interface.
* term_basic:                            Basic term manipulation.
* term_compare:                          Comparing terms.
* term_typing:                           Extra-logical properties for typing.
* terms:                                 terms (library).
* test_format:                           test_format (library).
* ttyout:                                ttyout (library).
* ugraphs:                               Unweighted graph-processing utilities.
* vndict:                                Variable name dictionaries.
* wgraphs:                               wgraphs (library).
* when:                                  Delaying predicates (when).
* write:                                 Term output.


File: ciao.info,  Node: Predicate/Method Definition Index,  Next: Property Definition Index,  Prev: Library/Module Definition Index,  Up: Top

Predicate/Method Definition Index
*********************************

* Menu:

* !/0:                                   Documentation on exports (basiccontrol).
* $is_persistent/2:                      Documentation on multifiles (persdbrt).
* &/2:                                   Documentation on exports (andprolog).
* ,/2:                                   Documentation on exports (basiccontrol).
* ->/2:                                  Documentation on exports (basiccontrol).
* ./2:                                   Documentation on exports (ciaosh).
* ;/2:                                   Documentation on exports (basiccontrol).
* </2:                                   Documentation on exports (arithmetic).
* =../2:                                 Documentation on exports (term_basic).
* =:=/2:                                 Documentation on exports (arithmetic).
* =</2:                                  Documentation on exports (arithmetic).
* =>/2:                                  Documentation on exports (andprolog).
* =\=/2:                                 Documentation on exports (arithmetic).
* >/2:                                   Documentation on exports (arithmetic).
* >=/2:                                  Documentation on exports (arithmetic).
* \+/1:                                  Documentation on exports (basiccontrol).
* \=/2:                                  Documentation on exports (iso_misc).
* ^/2:                                   Documentation on exports (aggregates).
* abolish/1:                             Documentation on exports (dynamic).
* abort/0:                               Documentation on exports (exceptions).
* absolute_file_name/2:                  Documentation on exports (streams_basic).
* absolute_file_name/7:                  Documentation on exports (streams_basic).
* active_agents/1:                       Documentation on exports (andprolog).
* add_after/4 <1>:                       Documentation on exports (idlists).
* add_after/4:                           Documentation on exports (lists).
* add_before/4 <1>:                      Documentation on exports (idlists).
* add_before/4:                          Documentation on exports (lists).
* add_edges/3:                           Documentation on exports (ugraphs).
* add_vertices/3:                        Documentation on exports (ugraphs).
* aggregate_function/3:                  Documentation on internals (pl2sql).
* aggregate_functor/2:                   Documentation on internals (pl2sql).
* append/3:                              Documentation on exports (lists).
* apropos/1:                             Documentation on exports (librowser).
* arg/2:                                 Documentation on exports (terms).
* arg/3:                                 Documentation on exports (term_basic).
* arg_expander/6:                        Documentation on exports (expansion_tools).
* arithmetic_functor/2:                  Documentation on internals (pl2sql).
* ask/2:                                 Documentation on exports (metaterms).
* assert/1:                              Documentation on exports (dynamic).
* assert/2:                              Documentation on exports (dynamic).
* asserta/1:                             Documentation on exports (dynamic).
* asserta/2:                             Documentation on exports (dynamic).
* asserta_fact/1:                        Documentation on exports (data_facts).
* asserta_fact/2:                        Documentation on exports (data_facts).
* assertz/1:                             Documentation on exports (dynamic).
* assertz/2:                             Documentation on exports (dynamic).
* assertz_fact/1:                        Documentation on exports (data_facts).
* assertz_fact/2:                        Documentation on exports (data_facts).
* atom2term/2:                           Documentation on exports (atom2term).
* atom_chars/2:                          Documentation on exports (iso_byte_char).
* atom_codes/2:                          Documentation on exports (atomic_basic).
* atom_concat/2:                         Documentation on exports (terms).
* atom_concat/3:                         Documentation on exports (atomic_basic).
* atom_length/2:                         Documentation on exports (atomic_basic).
* atom_lock_state/2:                     Documentation on exports (concurrency).
* attach_attribute/2:                    Documentation on exports (attributes).
* attribute/4:                           Documentation on multifiles (pl2sql).
* bagof/3:                               Documentation on exports (aggregates).
* barchart1/7:                           Documentation on exports (genbar1).
* barchart1/9:                           Documentation on exports (genbar1).
* barchart2/11:                          Documentation on exports (genbar2).
* barchart2/7:                           Documentation on exports (genbar2).
* barchart3/7:                           Documentation on exports (genbar3).
* barchart3/9:                           Documentation on exports (genbar3).
* barchart4/11:                          Documentation on exports (genbar4).
* barchart4/7:                           Documentation on exports (genbar4).
* basename/2:                            Documentation on exports (filenames).
* bind_socket/3:                         Documentation on exports (sockets).
* body_expander/6:                       Documentation on exports (expansion_tools).
* breakpt/6:                             Documentation on exports (debugger).
* browse/2:                              Documentation on exports (librowser).
* C/3:                                   Documentation on exports (term_basic).
* call/1:                                Documentation on exports (basiccontrol).
* call/2:                                Documentation on internals (basiccontrol).
* call_in_module/2:                      Documentation on exports (debugger).
* callme/1:                              Documentation on multifiles (rtchecks).
* callme/2 <1>:                          Documentation on multifiles (messages).
* callme/2 <2>:                          Documentation on multifiles (rtchecks).
* callme/2:                              Documentation on multifiles (meta_props).
* case_insensitive_match/2:              Documentation on exports (patterns).
* catch/3:                               Documentation on exports (exceptions).
* cd/1:                                  Documentation on exports (system).
* char_code/2:                           Documentation on exports (iso_byte_char).
* character_count/2:                     Documentation on exports (streams_basic).
* chartlib_text_error_protect/1:         Documentation on exports (chartlib_errhandle).
* chartlib_visual_error_protect/1:       Documentation on exports (chartlib_errhandle).
* check/1:                               Documentation on exports (assertions).
* check_sublist/4:                       Documentation on exports (test_format).
* chmod/2:                               Documentation on exports (system).
* chmod/3:                               Documentation on exports (system).
* ciaolibdir/1:                          Documentation on exports (system_info).
* clause/2:                              Documentation on exports (dynamic).
* clause/3:                              Documentation on exports (dynamic).
* clearerr/1:                            Documentation on exports (streams_basic).
* close/1:                               Documentation on exports (streams_basic).
* close/2:                               Documentation on exports (iso_incomplete).
* close_client/0:                        Documentation on exports (linda).
* close_file/1:                          Documentation on exports (dec10_io).
* close_input/1:                         Documentation on exports (streams).
* close_output/1:                        Documentation on exports (streams).
* close_predicate/1:                     Documentation on exports (data_facts).
* code_class/2:                          Documentation on exports (io_basic).
* color/2:                               Documentation on exports (color_pattern).
* combine_attributes/2 <1>:              Documentation on multifiles (when).
* combine_attributes/2 <2>:              Documentation on multifiles (freeze).
* combine_attributes/2:                  Documentation on multifiles (attributes).
* compare/3:                             Documentation on exports (term_compare).
* comparison/2:                          Documentation on internals (pl2sql).
* compile/1:                             Documentation on exports (ciaosh).
* compiler_and_opts/2:                   Documentation on exports (foreign_compilation).
* complete_dict/3:                       Documentation on exports (vndict).
* complete_vars_dict/3:                  Documentation on exports (vndict).
* compound/1:                            Documentation on exports (iso_misc).
* connect_to_socket/3:                   Documentation on exports (sockets).
* connect_to_socket_type/4:              Documentation on exports (sockets).
* constructor/0:                         Documentation on exports (class).
* consult/1:                             Documentation on exports (ciaosh).
* contains1/2:                           Documentation on exports (lists).
* contains_ro/2:                         Documentation on exports (lists).
* copy_args/3:                           Documentation on exports (terms).
* copy_stdout/1:                         Documentation on exports (file_utils).
* copy_term/2:                           Documentation on exports (term_basic).
* create_dict/2:                         Documentation on exports (vndict).
* ctrlc_clean/1:                         Documentation on exports (ctrlcclean).
* ctrlcclean/0:                          Documentation on exports (ctrlcclean).
* current_atom/1:                        Documentation on exports (prolog_sys).
* current_executable/1:                  Documentation on exports (system).
* current_fact/1:                        Documentation on exports (data_facts).
* current_fact/2:                        Documentation on exports (data_facts).
* current_fact_nb/1:                     Documentation on exports (data_facts).
* current_host/1:                        Documentation on exports (system).
* current_infixop/4:                     Documentation on exports (operators).
* current_input/1:                       Documentation on exports (streams_basic).
* current_key/2:                         Documentation on exports (old_database).
* current_module/1:                      Documentation on exports (system_info).
* current_op/3:                          Documentation on exports (operators).
* current_output/1:                      Documentation on exports (streams_basic).
* current_postfixop/3:                   Documentation on exports (operators).
* current_predicate/1:                   Documentation on exports (dynamic).
* current_predicate/2 <1>:               Documentation on exports (prolog_sys).
* current_predicate/2:                   Documentation on exports (dynamic).
* current_prefixop/3:                    Documentation on exports (operators).
* current_prolog_flag/2:                 Documentation on exports (prolog_flags).
* current_stream/3:                      Documentation on exports (streams_basic).
* data/1:                                Documentation on exports (dynamic).
* datime/1:                              Documentation on exports (system).
* datime/9:                              Documentation on exports (system).
* davinci/0:                             Documentation on exports (davinci).
* davinci_get/1:                         Documentation on exports (davinci).
* davinci_get_all/1:                     Documentation on exports (davinci).
* davinci_lgraph/1:                      Documentation on exports (davinci).
* davinci_put/1:                         Documentation on exports (davinci).
* davinci_quit/0:                        Documentation on exports (davinci).
* davinci_ugraph/1:                      Documentation on exports (davinci).
* db_eval_sql/3:                         Documentation on exports (db_client).
* db_get_tables/2:                       Documentation on exports (db_client).
* db_login/5:                            Documentation on exports (db_client).
* db_logoff/1:                           Documentation on exports (db_client).
* db_one_tuple/2:                        Documentation on exports (db_client).
* db_query/4:                            Documentation on internals (persdbrtsql).
* db_query_one_tuple/4:                  Documentation on internals (persdbrtsql).
* db_stmt_handle/3:                      Documentation on exports (db_client).
* db_table_types/3:                      Documentation on exports (db_client).
* dbassertz_fact/1:                      Documentation on exports (persdbrtsql).
* dbcall/2:                              Documentation on exports (persdbrtsql).
* dbcurrent_fact/1:                      Documentation on exports (persdbrtsql).
* dbfindall/4:                           Documentation on exports (persdbrtsql).
* dbretract_fact/1:                      Documentation on exports (persdbrtsql).
* dbretractall_fact/1:                   Documentation on exports (persdbrtsql).
* dcg_translation/2:                     Documentation on exports (dcg_expansion).
* debug/0:                               Documentation on exports (debugger).
* debug/1:                               Documentation on exports (io_aux).
* debug_goal/2:                          Documentation on exports (messages).
* debug_goal/3:                          Documentation on exports (messages).
* debug_message/1:                       Documentation on exports (messages).
* debug_message/2:                       Documentation on exports (messages).
* debug_module/1:                        Documentation on exports (debugger).
* debug_module_source/1:                 Documentation on exports (debugger).
* debugging/0:                           Documentation on exports (debugger).
* define_flag/3 <1>:                     Documentation on multifiles (write).
* define_flag/3:                         Documentation on multifiles (prolog_flags).
* del_global/1:                          Documentation on exports (global).
* del_vertices/3:                        Documentation on exports (ugraphs).
* delete/3 <1>:                          Documentation on exports (idlists).
* delete/3:                              Documentation on exports (lists).
* delete_file/1:                         Documentation on exports (system).
* delete_on_ctrlc/2:                     Documentation on exports (ctrlcclean).
* derived_from/2:                        Documentation on exports (objects_rt).
* describe/1:                            Documentation on exports (librowser).
* destroy/1:                             Documentation on exports (objects_rt).
* destructor/0:                          Documentation on exports (class).
* detach_attribute/1:                    Documentation on exports (attributes).
* dgraph_to_ugraph/2:                    Documentation on exports (graphs).
* dic_get/3:                             Documentation on exports (dict).
* dic_lookup/3:                          Documentation on exports (dict).
* dic_lookup/4:                          Documentation on exports (dict).
* dic_node/2:                            Documentation on exports (dict).
* dic_replace/4:                         Documentation on exports (dict).
* dict2varnamesl/2:                      Documentation on exports (vndict).
* difference/3:                          Documentation on exports (lists).
* directory_files/2:                     Documentation on exports (system).
* display/1:                             Documentation on exports (io_basic).
* display/2:                             Documentation on exports (io_basic).
* display_list/1:                        Documentation on exports (io_aux).
* display_string/1:                      Documentation on exports (io_aux).
* display_term/1:                        Documentation on exports (io_aux).
* displayq/1:                            Documentation on exports (io_basic).
* displayq/2:                            Documentation on exports (io_basic).
* disproves/2:                           Documentation on multifiles (rtchecks).
* dlgraph_to_lgraph/2:                   Documentation on exports (graphs).
* dlist/3:                               Documentation on exports (lists).
* do_on_abolish/1:                       Documentation on multifiles (dynamic).
* dynamic/1:                             Documentation on exports (dynamic).
* dynamic_search_path/1:                 Documentation on exports (ciaosh).
* edges/2:                               Documentation on exports (ugraphs).
* edges_to_lgraph/2:                     Documentation on exports (graphs).
* edges_to_ugraph/2:                     Documentation on exports (graphs).
* emacs_edit/1:                          Documentation on exports (emacs).
* emacs_edit_nowait/1:                   Documentation on exports (emacs).
* emacs_eval/1:                          Documentation on exports (emacs).
* emacs_eval_nowait/1:                   Documentation on exports (emacs).
* eng_backtrack/2:                       Documentation on exports (concurrency).
* eng_call/3:                            Documentation on exports (concurrency).
* eng_call/4:                            Documentation on exports (concurrency).
* eng_cut/1:                             Documentation on exports (concurrency).
* eng_kill/1:                            Documentation on exports (concurrency).
* eng_killothers/0:                      Documentation on exports (concurrency).
* eng_release/1:                         Documentation on exports (concurrency).
* eng_self/1:                            Documentation on exports (concurrency).
* eng_status/0:                          Documentation on exports (concurrency).
* eng_wait/1:                            Documentation on exports (concurrency).
* ensure_loaded/1:                       Documentation on exports (ciaosh).
* equal_lists/2:                         Documentation on exports (lists).
* equalnumber/3:                         Documentation on exports (test_format).
* erase/1:                               Documentation on exports (data_facts).
* error/1:                               Documentation on exports (io_aux).
* error_file/2:                          Documentation on internals (chartlib_errhandle).
* error_message/1:                       Documentation on exports (messages).
* error_message/2 <1>:                   Documentation on internals (chartlib_errhandle).
* error_message/2:                       Documentation on exports (messages).
* error_message/3:                       Documentation on exports (messages).
* error_protect/1:                       Documentation on exports (errhandle).
* exec/3:                                Documentation on exports (system).
* exec/4:                                Documentation on exports (system).
* extension/2:                           Documentation on exports (filenames).
* extract_paths/2:                       Documentation on exports (system).
* fail/0:                                Documentation on exports (basiccontrol).
* false/1:                               Documentation on exports (assertions).
* fast_read/1:                           Documentation on exports (fastrw).
* fast_write/1:                          Documentation on exports (fastrw).
* fast_write_to_string/3:                Documentation on exports (fastrw).
* fetch_url/3:                           Documentation on exports (http).
* file_exists/1:                         Documentation on exports (system).
* file_exists/2:                         Documentation on exports (system).
* file_name_extension/3:                 Documentation on exports (filenames).
* file_properties/6:                     Documentation on exports (system).
* file_property/2:                       Documentation on exports (system).
* file_search_path/2 <1>:                Documentation on multifiles (streams_basic).
* file_search_path/2:                    Documentation on multifiles (libpaths).
* file_terms/2:                          Documentation on exports (file_utils).
* file_to_string/2:                      Documentation on exports (file_utils).
* fileerrors/0:                          Documentation on exports (prolog_flags).
* find_name/4:                           Documentation on exports (vndict).
* findall/3 <1>:                         Documentation on exports (conc_aggregates).
* findall/3:                             Documentation on exports (aggregates).
* findall/4:                             Documentation on exports (aggregates).
* findnsols/4:                           Documentation on exports (aggregates).
* findnsols/5:                           Documentation on exports (aggregates).
* flush_output/0:                        Documentation on exports (streams_basic).
* flush_output/1:                        Documentation on exports (streams_basic).
* fmode/2:                               Documentation on exports (system).
* foldl/4:                               Documentation on exports (hiord).
* force_lazy/1:                          Documentation on exports (ciaosh).
* form_default/3:                        Documentation on exports (html).
* form_empty_value/1:                    Documentation on exports (html).
* form_request_method/1:                 Documentation on exports (html).
* format/2:                              Documentation on exports (format).
* format/3:                              Documentation on exports (format).
* formatting/2:                          Documentation on exports (davinci).
* freeze/2:                              Documentation on exports (freeze).
* frozen/2:                              Documentation on exports (freeze).
* functor/3:                             Documentation on exports (term_basic).
* garbage_collect/0:                     Documentation on exports (prolog_sys).
* gc/0:                                  Documentation on exports (prolog_flags).
* get1_code/1:                           Documentation on exports (io_basic).
* get1_code/2:                           Documentation on exports (io_basic).
* get_alias_path/0:                      Documentation on exports (libpaths).
* get_arch/1:                            Documentation on exports (system_info).
* get_attribute/2:                       Documentation on exports (attributes).
* get_byte/1:                            Documentation on exports (iso_byte_char).
* get_byte/2:                            Documentation on exports (iso_byte_char).
* get_char/1:                            Documentation on exports (iso_byte_char).
* get_char/2:                            Documentation on exports (iso_byte_char).
* get_code/1:                            Documentation on exports (io_basic).
* get_code/2:                            Documentation on exports (io_basic).
* get_cookies/1:                         Documentation on exports (html).
* get_form_input/1:                      Documentation on exports (html).
* get_form_value/3:                      Documentation on exports (html).
* get_global/2:                          Documentation on exports (global).
* get_line/1:                            Documentation on exports (strings).
* get_line/2:                            Documentation on exports (strings).
* get_os/1:                              Documentation on exports (system_info).
* get_pid/1:                             Documentation on exports (system).
* get_primes/2:                          Documentation on exports (numlists).
* get_query_id/1:                        Documentation on internals (jtopl).
* getcounter/2:                          Documentation on exports (counters).
* getct/2:                               Documentation on exports (io_basic).
* getct1/2:                              Documentation on exports (io_basic).
* getenvstr/2:                           Documentation on exports (system).
* graph_b1/13:                           Documentation on exports (gengraph1).
* graph_b1/9:                            Documentation on exports (gengraph1).
* graph_b2/13:                           Documentation on exports (gengraph2).
* graph_b2/9:                            Documentation on exports (gengraph2).
* graph_w1/13:                           Documentation on exports (gengraph1).
* graph_w1/9:                            Documentation on exports (gengraph1).
* graph_w2/13:                           Documentation on exports (gengraph2).
* graph_w2/9:                            Documentation on exports (gengraph2).
* halt/0:                                Documentation on exports (exceptions).
* halt/1:                                Documentation on exports (exceptions).
* halt_server/0:                         Documentation on exports (linda).
* handle_error/2:                        Documentation on exports (errhandle).
* hostname_address/2:                    Documentation on exports (sockets).
* html2terms/2:                          Documentation on exports (html).
* html_expansion/2:                      Documentation on multifiles (html).
* html_protect/1:                        Documentation on exports (html).
* html_report_error/1:                   Documentation on exports (html).
* html_template/3:                       Documentation on exports (html).
* http_lines/3:                          Documentation on exports (html).
* icon_address/2:                        Documentation on exports (html).
* if/3:                                  Documentation on exports (basiccontrol).
* imports_meta_pred/3:                   Documentation on exports (expansion_tools).
* in/1:                                  Documentation on exports (linda).
* in/2:                                  Documentation on exports (linda).
* in_noblock/1:                          Documentation on exports (linda).
* in_stream/2:                           Documentation on exports (linda).
* inccounter/2:                          Documentation on exports (counters).
* include/1:                             Documentation on exports (ciaosh).
* inform_user/1:                         Documentation on exports (io_aux).
* inherited/1:                           Documentation on exports (class).
* init_persdb/0:                         Documentation on exports (persdbrt).
* init_sql_persdb/0:                     Documentation on exports (persdbrtsql).
* initialize_db/0:                       Documentation on exports (persdbrt).
* insert/3:                              Documentation on exports (sets).
* insert_last/3:                         Documentation on exports (lists).
* instance/2:                            Documentation on exports (metaterms).
* instance_codes/2:                      Documentation on exports (objects_rt).
* instance_of/2:                         Documentation on exports (objects_rt).
* intercept/3:                           Documentation on exports (exceptions).
* interface/2:                           Documentation on exports (objects_rt).
* interp_file/2:                         Documentation on exports (bltclass).
* intersection/3:                        Documentation on exports (lists).
* intset_delete/3:                       Documentation on exports (lists).
* intset_in/2:                           Documentation on exports (lists).
* intset_insert/3:                       Documentation on exports (lists).
* intset_sequence/3:                     Documentation on exports (lists).
* is/2:                                  Documentation on exports (arithmetic).
* issue_debug_messages/1:                Documentation on multifiles (messages).
* java_add_listener/3:                   Documentation on exports (javart).
* java_connection/0:                     Documentation on exports (javart).
* java_create_object/2:                  Documentation on exports (javart).
* java_delete_object/1:                  Documentation on exports (javart).
* java_disconnection/0:                  Documentation on exports (javart).
* java_fast_read/2:                      Documentation on exports (javasock).
* java_fast_write/2:                     Documentation on exports (javasock).
* java_get_value/2:                      Documentation on exports (javart).
* java_invoke_method/2:                  Documentation on exports (javart).
* java_remote_connection/1:              Documentation on exports (javart).
* java_remove_listener/3:                Documentation on exports (javart).
* java_set_value/2:                      Documentation on exports (javart).
* java_stream/3:                         Documentation on exports (javasock).
* keysort/2:                             Documentation on exports (sort).
* last/2:                                Documentation on exports (lists).
* leash/1:                               Documentation on exports (debugger).
* length/2:                              Documentation on exports (lists).
* letter_match/2:                        Documentation on exports (patterns).
* library_directory/1 <1>:               Documentation on multifiles (streams_basic).
* library_directory/1:                   Documentation on multifiles (libpaths).
* linda_client/1:                        Documentation on exports (linda).
* linda_timeout/2:                       Documentation on exports (linda).
* line_count/2:                          Documentation on exports (streams_basic).
* line_position/2:                       Documentation on exports (streams_basic).
* linker_and_opts/2:                     Documentation on exports (foreign_compilation).
* list_breakpt/0:                        Documentation on exports (debugger).
* list_concat/2:                         Documentation on exports (lists).
* list_insert/2 <1>:                     Documentation on exports (idlists).
* list_insert/2:                         Documentation on exports (lists).
* list_lookup/3:                         Documentation on exports (lists).
* list_lookup/4:                         Documentation on exports (lists).
* list_to_list_of_lists/2:               Documentation on exports (lists).
* lock_atom/1:                           Documentation on exports (concurrency).
* make_actmod/2:                         Documentation on exports (ciaosh).
* make_exec/2:                           Documentation on exports (ciaosh).
* make_persistent/2:                     Documentation on exports (persdbrt).
* make_po/1:                             Documentation on exports (ciaosh).
* make_sql_persistent/3:                 Documentation on exports (persdbrtsql).
* map/3:                                 Documentation on exports (hiord).
* match_pattern/2:                       Documentation on exports (patterns).
* match_pattern/3:                       Documentation on exports (patterns).
* match_pattern_pred/2:                  Documentation on exports (patterns).
* match_string/3:                        Documentation on exports (db_client).
* maxdepth/1:                            Documentation on exports (debugger).
* member_0/2:                            Documentation on exports (idlists).
* memberchk/2:                           Documentation on exports (idlists).
* merge/3:                               Documentation on exports (sets).
* message/1:                             Documentation on exports (io_aux).
* message/2:                             Documentation on exports (io_aux).
* message_lns/4:                         Documentation on exports (io_aux).
* mktemp/2:                              Documentation on exports (system).
* modif_time/2:                          Documentation on exports (system).
* modif_time0/2:                         Documentation on exports (system).
* multibarchart/10:                      Documentation on exports (genmultibar).
* multibarchart/8:                       Documentation on exports (genmultibar).
* multifile/1:                           Documentation on exports (ciaosh).
* my_url/1:                              Documentation on exports (html).
* name/2:                                Documentation on exports (atomic_basic).
* negated_comparison/2:                  Documentation on internals (pl2sql).
* neighbors/3:                           Documentation on exports (ugraphs).
* new/2:                                 Documentation on exports (objects_rt).
* new_atom/1:                            Documentation on exports (prolog_sys).
* new_interp/1:                          Documentation on exports (bltclass).
* nl/0:                                  Documentation on exports (io_basic).
* nl/1:                                  Documentation on exports (io_basic).
* no_path_file_name/2:                   Documentation on exports (filenames).
* nobreakall/0:                          Documentation on exports (debugger).
* nobreakpt/6:                           Documentation on exports (debugger).
* nocontainsx/2:                         Documentation on exports (lists).
* nodebug/0:                             Documentation on exports (debugger).
* nodebug_module/1:                      Documentation on exports (debugger).
* nofileerrors/0:                        Documentation on exports (prolog_flags).
* nogc/0:                                Documentation on exports (prolog_flags).
* nonsingle/1:                           Documentation on exports (lists).
* nospy/1:                               Documentation on exports (debugger).
* nospyall/0:                            Documentation on exports (debugger).
* not_empty/3:                           Documentation on exports (test_format).
* not_empty/4:                           Documentation on exports (test_format).
* note/1:                                Documentation on exports (io_aux).
* note_message/1:                        Documentation on exports (messages).
* note_message/2:                        Documentation on exports (messages).
* note_message/3:                        Documentation on exports (messages).
* notrace/0:                             Documentation on exports (debugger).
* nth/3:                                 Documentation on exports (lists).
* number_chars/2:                        Documentation on exports (iso_byte_char).
* number_codes/2:                        Documentation on exports (atomic_basic).
* number_codes/3:                        Documentation on exports (atomic_basic).
* numbervars/3:                          Documentation on exports (write).
* odbc_connect/2:                        Documentation on exports (db_client).
* odbc_disconnect/1:                     Documentation on exports (db_client).
* once/1:                                Documentation on exports (iso_misc).
* op/3:                                  Documentation on exports (operators).
* open/3:                                Documentation on exports (streams_basic).
* open/4:                                Documentation on exports (iso_incomplete).
* open_client/2:                         Documentation on exports (linda).
* open_input/2:                          Documentation on exports (streams).
* open_null_stream/1:                    Documentation on exports (streams).
* open_output/2:                         Documentation on exports (streams).
* open_predicate/1:                      Documentation on exports (data_facts).
* optional_message/2:                    Documentation on exports (messages).
* optional_message/3:                    Documentation on exports (messages).
* ord_delete/3:                          Documentation on exports (sets).
* ord_disjoint/2:                        Documentation on exports (sets).
* ord_intersect/2:                       Documentation on exports (sets).
* ord_intersection/3:                    Documentation on exports (sets).
* ord_intersection_diff/4:               Documentation on exports (sets).
* ord_member/2:                          Documentation on exports (sets).
* ord_subset/2:                          Documentation on exports (sets).
* ord_subset_diff/3:                     Documentation on exports (sets).
* ord_subtract/3:                        Documentation on exports (sets).
* ord_test_member/3:                     Documentation on exports (sets).
* ord_union/3:                           Documentation on exports (sets).
* ord_union_change/3:                    Documentation on exports (sets).
* ord_union_diff/4:                      Documentation on exports (sets).
* ord_union_symdiff/4:                   Documentation on exports (sets).
* out/1:                                 Documentation on exports (linda).
* out_stream/2:                          Documentation on exports (linda).
* output_html/1:                         Documentation on exports (html).
* parse_term/3:                          Documentation on exports (atom2term).
* passertz_fact/1:                       Documentation on exports (persdbrt).
* pattern/2:                             Documentation on exports (color_pattern).
* pause/1:                               Documentation on exports (system).
* pcurrent_fact/1:                       Documentation on exports (persdbrt).
* peek_byte/1:                           Documentation on exports (iso_byte_char).
* peek_byte/2:                           Documentation on exports (iso_byte_char).
* peek_char/1:                           Documentation on exports (iso_byte_char).
* peek_char/2:                           Documentation on exports (iso_byte_char).
* peek_code/1:                           Documentation on exports (io_basic).
* peek_code/2:                           Documentation on exports (io_basic).
* percentbarchart1/7:                    Documentation on exports (genbar1).
* percentbarchart2/7:                    Documentation on exports (genbar2).
* percentbarchart3/7:                    Documentation on exports (genbar3).
* percentbarchart4/7:                    Documentation on exports (genbar4).
* persistent_dir/2:                      Documentation on multifiles (persdbrt).
* phrase/2:                              Documentation on exports (dcg_expansion).
* phrase/3:                              Documentation on exports (dcg_expansion).
* pl2sqlstring/3:                        Documentation on exports (pl2sql).
* pl2sqlterm/3:                          Documentation on exports (pl2sql).
* point_to/3:                            Documentation on exports (ugraphs).
* pop_global/2:                          Documentation on exports (global).
* pop_prolog_flag/1:                     Documentation on exports (prolog_flags).
* popen/3:                               Documentation on exports (system).
* portray/1:                             Documentation on multifiles (write).
* portray_attribute/2:                   Documentation on multifiles (write).
* portray_clause/1:                      Documentation on exports (write).
* portray_clause/2:                      Documentation on exports (write).
* powerset/2:                            Documentation on exports (lists).
* predicate_property/2:                  Documentation on exports (prolog_sys).
* pretract_fact/1:                       Documentation on exports (persdbrt).
* pretty_print/2:                        Documentation on exports (pretty_print).
* pretty_print/3:                        Documentation on exports (pretty_print).
* prettyvars/1:                          Documentation on exports (write).
* print/1:                               Documentation on exports (write).
* print/2:                               Documentation on exports (write).
* printable_char/1:                      Documentation on exports (write).
* printqueries/1:                        Documentation on exports (pl2sql).
* process_first_command/1:               Documentation on internals (jtopl).
* process_next_command/2:                Documentation on internals (jtopl).
* prolog_flag/3:                         Documentation on exports (prolog_flags).
* prolog_parse/2:                        Documentation on internals (jtopl).
* prolog_server/0:                       Documentation on exports (jtopl).
* prompt/2:                              Documentation on exports (prolog_flags).
* proves/2:                              Documentation on multifiles (rtchecks).
* prune_dict/3:                          Documentation on exports (vndict).
* push_global/2:                         Documentation on exports (global).
* push_prolog_flag/2:                    Documentation on exports (prolog_flags).
* put_byte/1:                            Documentation on exports (iso_byte_char).
* put_byte/2:                            Documentation on exports (iso_byte_char).
* put_char/1:                            Documentation on exports (iso_byte_char).
* put_char/2:                            Documentation on exports (iso_byte_char).
* put_code/1:                            Documentation on exports (io_basic).
* put_code/2:                            Documentation on exports (io_basic).
* q_delete/3:                            Documentation on exports (queues).
* q_empty/1:                             Documentation on exports (queues).
* q_insert/3:                            Documentation on exports (queues).
* q_member/2:                            Documentation on exports (queues).
* query_generation/3:                    Documentation on internals (pl2sql).
* random/1:                              Documentation on exports (random).
* random/3:                              Documentation on exports (random).
* random_color/1:                        Documentation on exports (color_pattern).
* random_darkcolor/1:                    Documentation on exports (color_pattern).
* random_lightcolor/1:                   Documentation on exports (color_pattern).
* random_pattern/1:                      Documentation on exports (color_pattern).
* rd/1:                                  Documentation on exports (linda).
* rd/2:                                  Documentation on exports (linda).
* rd_findall/3:                          Documentation on exports (linda).
* rd_noblock/1:                          Documentation on exports (linda).
* read/1:                                Documentation on exports (read).
* read/2:                                Documentation on exports (read).
* read_command/1:                        Documentation on internals (jtopl).
* read_term/2:                           Documentation on exports (read).
* read_term/3:                           Documentation on exports (read).
* read_top_level/3:                      Documentation on exports (read).
* recorda/3:                             Documentation on exports (old_database).
* recorded/3:                            Documentation on exports (old_database).
* recordz/3:                             Documentation on exports (old_database).
* relation/3:                            Documentation on multifiles (pl2sql).
* rename/2:                              Documentation on exports (vndict).
* repeat/0:                              Documentation on exports (basiccontrol).
* retract/1:                             Documentation on exports (dynamic).
* retract_fact/1:                        Documentation on exports (data_facts).
* retract_fact_nb/1:                     Documentation on exports (data_facts).
* retractall/1:                          Documentation on exports (dynamic).
* retractall_fact/1:                     Documentation on exports (data_facts).
* reverse/2:                             Documentation on exports (lists).
* reverse/3:                             Documentation on exports (lists).
* scattergraph_b1/12:                    Documentation on exports (gengraph1).
* scattergraph_b1/8:                     Documentation on exports (gengraph1).
* scattergraph_b2/12:                    Documentation on exports (gengraph2).
* scattergraph_b2/8:                     Documentation on exports (gengraph2).
* scattergraph_w1/12:                    Documentation on exports (gengraph1).
* scattergraph_w1/8:                     Documentation on exports (gengraph1).
* scattergraph_w2/12:                    Documentation on exports (gengraph2).
* scattergraph_w2/8:                     Documentation on exports (gengraph2).
* second_prompt/2:                       Documentation on exports (read).
* see/1:                                 Documentation on exports (dec10_io).
* seeing/1:                              Documentation on exports (dec10_io).
* seen/0:                                Documentation on exports (dec10_io).
* select/3:                              Documentation on exports (lists).
* select_socket/5:                       Documentation on exports (sockets).
* self/1:                                Documentation on exports (class).
* set_cookie/2:                          Documentation on exports (html).
* set_debug_mode/1:                      Documentation on exports (ciaosh).
* set_fact/1:                            Documentation on exports (data_facts).
* set_global/2:                          Documentation on exports (global).
* set_input/1:                           Documentation on exports (streams_basic).
* set_nodebug_mode/1:                    Documentation on exports (ciaosh).
* set_output/1:                          Documentation on exports (streams_basic).
* set_prolog_flag/2:                     Documentation on exports (prolog_flags).
* setarg/3:                              Documentation on exports (odd).
* setcounter/2:                          Documentation on exports (counters).
* setof/3:                               Documentation on exports (aggregates).
* setproduct/3:                          Documentation on exports (sets).
* shell/0:                               Documentation on exports (system).
* shell/1:                               Documentation on exports (system).
* shell/2:                               Documentation on exports (system).
* shell_s/0:                             Documentation on internals (jtopl).
* simple_message/1:                      Documentation on exports (messages).
* simple_message/2:                      Documentation on exports (messages).
* skip_code/1:                           Documentation on exports (io_basic).
* skip_code/2:                           Documentation on exports (io_basic).
* socket_accept/2:                       Documentation on exports (sockets).
* socket_connection/2:                   Documentation on exports (javasock).
* socket_disconnection/0:                Documentation on exports (javasock).
* socket_recv/2:                         Documentation on exports (sockets).
* socket_recv_code/3:                    Documentation on exports (sockets).
* socket_send/2:                         Documentation on exports (sockets).
* solve/1:                               Documentation on internals (jtopl).
* solve_on_thread/1:                     Documentation on internals (jtopl).
* sort/2:                                Documentation on exports (sort).
* spy/1:                                 Documentation on exports (debugger).
* sql_get_tables/2:                      Documentation on exports (persdbrtsql).
* sql_persistent/3:                      Documentation on exports (persdbrtsql).
* sql_persistent_location/2:             Documentation on multifiles (persdbrtsql).
* sql_query/3:                           Documentation on exports (persdbrtsql).
* sql_query_one_tuple/3:                 Documentation on internals (persdbrtsql).
* sql_table_types/3:                     Documentation on exports (persdbrtsql).
* sqlterm2string/2:                      Documentation on exports (pl2sql).
* srandom/1:                             Documentation on exports (random).
* statistics/0:                          Documentation on exports (prolog_sys).
* statistics/2:                          Documentation on exports (prolog_sys).
* stream_code/2:                         Documentation on exports (streams_basic).
* stream_property/2:                     Documentation on exports (iso_incomplete).
* stream_to_string/2:                    Documentation on exports (file_utils).
* string/3:                              Documentation on exports (strings).
* string2term/2:                         Documentation on exports (atom2term).
* sub_atom/4:                            Documentation on exports (atomic_basic).
* sub_atom/5:                            Documentation on exports (iso_misc).
* subtract/3:                            Documentation on exports (idlists).
* sum_list/2:                            Documentation on exports (numlists).
* sum_list/3:                            Documentation on exports (numlists).
* sum_list_of_lists/2:                   Documentation on exports (numlists).
* sum_list_of_lists/3:                   Documentation on exports (numlists).
* system/1:                              Documentation on exports (system).
* system/2:                              Documentation on exports (system).
* system_lib/1:                          Documentation on exports (librowser).
* tab/1:                                 Documentation on exports (io_basic).
* tab/2:                                 Documentation on exports (io_basic).
* tablewidget1/4:                        Documentation on exports (table_widget1).
* tablewidget1/5:                        Documentation on exports (table_widget1).
* tablewidget2/4:                        Documentation on exports (table_widget2).
* tablewidget2/5:                        Documentation on exports (table_widget2).
* tablewidget3/4:                        Documentation on exports (table_widget3).
* tablewidget3/5:                        Documentation on exports (table_widget3).
* tablewidget4/4:                        Documentation on exports (table_widget4).
* tablewidget4/5:                        Documentation on exports (table_widget4).
* tcl_delete/1:                          Documentation on exports (tcltk).
* tcl_eval/3:                            Documentation on exports (tcltk).
* tcl_event/3:                           Documentation on exports (tcltk).
* tcl_new/1:                             Documentation on exports (tcltk).
* tcltk_raw_code/2:                      Documentation on exports (bltclass).
* tell/1:                                Documentation on exports (dec10_io).
* telling/1:                             Documentation on exports (dec10_io).
* this_module/1:                         Documentation on exports (system_info).
* throw/1:                               Documentation on exports (exceptions).
* time/1:                                Documentation on exports (system).
* tk_event_loop/1:                       Documentation on exports (tcltk).
* tk_loop/1:                             Documentation on exports (tcltk).
* tk_new/2:                              Documentation on exports (tcltk).
* tk_new/4:                              Documentation on exports (tcltk).
* tk_next_event/2:                       Documentation on exports (tcltk).
* told/0:                                Documentation on exports (dec10_io).
* topd/0:                                Documentation on exports (davinci).
* trace/0:                               Documentation on exports (debugger).
* translate_arithmetic_function/5:       Documentation on internals (pl2sql).
* translate_comparison/5:                Documentation on internals (pl2sql).
* translate_conjunction/5:               Documentation on internals (pl2sql).
* translate_goal/5:                      Documentation on internals (pl2sql).
* transpose/2:                           Documentation on exports (ugraphs).
* true/0:                                Documentation on exports (basiccontrol).
* true/1:                                Documentation on exports (assertions).
* trust/1:                               Documentation on exports (assertions).
* ttydisplay/1:                          Documentation on exports (ttyout).
* ttydisplay_string/1:                   Documentation on exports (ttyout).
* ttydisplayq/1:                         Documentation on exports (ttyout).
* ttyflush/0:                            Documentation on exports (ttyout).
* ttyget/1:                              Documentation on exports (ttyout).
* ttyget1/1:                             Documentation on exports (ttyout).
* ttynl/0:                               Documentation on exports (ttyout).
* ttyput/1:                              Documentation on exports (ttyout).
* ttyskip/1:                             Documentation on exports (ttyout).
* ttyskipeol/0:                          Documentation on exports (ttyout).
* ttytab/1:                              Documentation on exports (ttyout).
* ugraph2term/2:                         Documentation on exports (davinci).
* umask/2:                               Documentation on exports (system).
* undo/1:                                Documentation on exports (odd).
* undo_force_lazy/1:                     Documentation on exports (ciaosh).
* unify_with_occurs_check/2:             Documentation on exports (iso_misc).
* union/3:                               Documentation on exports (lists).
* union_idlists/3:                       Documentation on exports (idlists).
* unload/1:                              Documentation on exports (ciaosh).
* unlock_atom/1:                         Documentation on exports (concurrency).
* update/0:                              Documentation on exports (librowser).
* update_attribute/2:                    Documentation on exports (attributes).
* update_files/2:                        Documentation on exports (persdbrt).
* url_info/2:                            Documentation on exports (html).
* url_info_relative/3:                   Documentation on exports (html).
* url_query/2:                           Documentation on exports (html).
* use_class/1:                           Documentation on exports (objects_rt).
* use_module/1 <1>:                      Documentation on exports (dynmods).
* use_module/1:                          Documentation on exports (ciaosh).
* use_module/2:                          Documentation on exports (ciaosh).
* use_package/1:                         Documentation on exports (ciaosh).
* valid_attributes/2:                    Documentation on exports (test_format).
* valid_format/4:                        Documentation on exports (test_format).
* valid_table/2:                         Documentation on exports (test_format).
* valid_vectors/4:                       Documentation on exports (test_format).
* variant/2:                             Documentation on exports (metaterms).
* varnamesl2dict/2:                      Documentation on exports (vndict).
* vars_names_dict/3:                     Documentation on exports (vndict).
* varsbag/3:                             Documentation on exports (metaterms).
* varset/2:                              Documentation on exports (metaterms).
* vectors_format/4:                      Documentation on exports (test_format).
* verify_attribute/2 <1>:                Documentation on multifiles (when).
* verify_attribute/2 <2>:                Documentation on multifiles (freeze).
* verify_attribute/2:                    Documentation on multifiles (attributes).
* vertices/2:                            Documentation on exports (ugraphs).
* vertices_edges_to_lgraph/3:            Documentation on exports (lgraphs).
* vertices_edges_to_ugraph/3:            Documentation on exports (ugraphs).
* vertices_edges_to_wgraph/3:            Documentation on exports (wgraphs).
* warning/1:                             Documentation on exports (io_aux).
* warning_message/1:                     Documentation on exports (messages).
* warning_message/2:                     Documentation on exports (messages).
* warning_message/3:                     Documentation on exports (messages).
* wellformed_body/3:                     Documentation on exports (dynamic).
* when/2:                                Documentation on exports (when).
* where/1:                               Documentation on exports (librowser).
* whitespace/2:                          Documentation on exports (strings).
* whitespace0/2:                         Documentation on exports (strings).
* working_directory/2:                   Documentation on exports (system).
* write/1:                               Documentation on exports (write).
* write/2:                               Documentation on exports (write).
* write_answer/1:                        Documentation on internals (jtopl).
* write_assertion/6:                     Documentation on exports (assrt_write).
* write_assertion_as_comment/6:          Documentation on exports (assrt_write).
* write_canonical/1:                     Documentation on exports (write).
* write_canonical/2:                     Documentation on exports (write).
* write_list1/1:                         Documentation on exports (write).
* write_string/1:                        Documentation on exports (strings).
* write_string/2:                        Documentation on exports (strings).
* write_term/2:                          Documentation on exports (write).
* write_term/3:                          Documentation on exports (write).
* writeq/1:                              Documentation on exports (write).
* writeq/2:                              Documentation on exports (write).
* xml2terms/2:                           Documentation on exports (html).
* |/2:                                   Documentation on internals (basiccontrol).


File: ciao.info,  Node: Property Definition Index,  Next: Regular Type Definition Index,  Prev: Predicate/Method Definition Index,  Up: Top

Property Definition Index
*************************

* Menu:

* =/2:                                   Documentation on exports (term_basic).
* ==/2:                                  Documentation on exports (term_compare).
* @</2:                                  Documentation on exports (term_compare).
* @=</2:                                 Documentation on exports (term_compare).
* @>/2:                                  Documentation on exports (term_compare).
* @>=/2:                                 Documentation on exports (term_compare).
* \==/2:                                 Documentation on exports (term_compare).
* atom/1:                                Documentation on exports (term_typing).
* atomic/1:                              Documentation on exports (term_typing).
* call/2:                                Documentation on exports (meta_props).
* class_name/1:                          Documentation on exports (objects_rt).
* class_source/1:                        Documentation on exports (objects_rt).
* compat/2:                              Documentation on exports (basic_props).
* constructor/1:                         Documentation on exports (objects_rt).
* covered/1:                             Documentation on exports (native_props).
* do_not_free/2:                         Documentation on exports (foreign_interface).
* docstring/1:                           Documentation on exports (assertions_props).
* expander_pred/1:                       Documentation on internals (expansion_tools).
* fails/1:                               Documentation on exports (native_props).
* float/1:                               Documentation on exports (term_typing).
* foreign/1:                             Documentation on exports (foreign_interface).
* foreign/2:                             Documentation on exports (foreign_interface).
* ground/1:                              Documentation on exports (term_typing).
* head_pattern/1:                        Documentation on exports (assertions_props).
* indep/1 <1>:                           Documentation on exports (andprolog).
* indep/1:                               Documentation on exports (native_props).
* indep/2 <1>:                           Documentation on exports (andprolog).
* indep/2:                               Documentation on exports (native_props).
* instance_id/1:                         Documentation on exports (objects_rt).
* integer/1:                             Documentation on exports (term_typing).
* interface_name/1:                      Documentation on exports (objects_rt).
* interface_source/1:                    Documentation on exports (objects_rt).
* internal_module_id/1:                  Documentation on internals (system_info).
* is_det/1:                              Documentation on exports (native_props).
* iso/1:                                 Documentation on exports (basic_props).
* line/1:                                Documentation on internals (strings).
* linear/1:                              Documentation on exports (native_props).
* list1/2:                               Documentation on exports (lists).
* member/2:                              Documentation on exports (basic_props).
* method_spec/1:                         Documentation on exports (objects_rt).
* mshare/1:                              Documentation on exports (native_props).
* multpredspec/1:                        Documentation on internals (debugger).
* mut_exclusive/1:                       Documentation on exports (native_props).
* nabody/1:                              Documentation on exports (assertions_props).
* native/1:                              Documentation on exports (foreign_interface).
* native/2:                              Documentation on exports (foreign_interface).
* nonvar/1:                              Documentation on exports (term_typing).
* not_covered/1:                         Documentation on exports (native_props).
* not_fails/1:                           Documentation on exports (native_props).
* not_further_inst/2:                    Documentation on exports (basic_props).
* not_mut_exclusive/1:                   Documentation on exports (native_props).
* number/1:                              Documentation on exports (term_typing).
* possibly_fails/1:                      Documentation on exports (native_props).
* possibly_nondet/1:                     Documentation on exports (native_props).
* prop/2:                                Documentation on exports (meta_props).
* prop_abs/1:                            Documentation on internals (meta_props).
* regtype/1:                             Documentation on exports (basic_props).
* regtype/2:                             Documentation on exports (meta_props).
* returns/2:                             Documentation on exports (foreign_interface).
* sideff_hard/1:                         Documentation on exports (native_props).
* sideff_pure/1:                         Documentation on exports (native_props).
* sideff_soft/1:                         Documentation on exports (native_props).
* size_lb/2:                             Documentation on exports (native_props).
* size_of/3:                             Documentation on exports (foreign_interface).
* size_ub/2:                             Documentation on exports (native_props).
* sourcenames/1:                         Documentation on internals (ciaosh).
* steps_lb/2:                            Documentation on exports (native_props).
* steps_ub/2:                            Documentation on exports (native_props).
* sublist/2:                             Documentation on exports (lists).
* subordlist/2:                          Documentation on exports (lists).
* type/2:                                Documentation on exports (term_typing).
* var/1:                                 Documentation on exports (term_typing).
* virtual_method_spec/1:                 Documentation on exports (objects_rt).
* write_option/1:                        Documentation on exports (write).


File: ciao.info,  Node: Regular Type Definition Index,  Next: Declaration Definition Index,  Prev: Property Definition Index,  Up: Top

Regular Type Definition Index
*****************************

* Menu:

* address/1:                             Documentation on exports (foreign_interface).
* answer/1:                              Documentation on internals (jtopl).
* answertableterm/1:                     Documentation on exports (db_client).
* answertupleterm/1:                     Documentation on exports (db_client).
* apropos_spec/1:                        Documentation on internals (librowser).
* arithexpression/1:                     Documentation on exports (arithmetic).
* assrt_body/1:                          Documentation on exports (assertions_props).
* assrt_status/1:                        Documentation on exports (assertions_props).
* assrt_type/1:                          Documentation on exports (assertions_props).
* atm/1:                                 Documentation on exports (basic_props).
* atm_or_atm_list/1:                     Documentation on exports (basic_props).
* attributes/1:                          Documentation on exports (gengraph1).
* axis_limit/1:                          Documentation on exports (genbar1).
* bltwish_interp/1:                      Documentation on exports (bltclass).
* body/1:                                Documentation on internals (pretty_print).
* byte/1:                                Documentation on exports (foreign_interface).
* byte_list/1:                           Documentation on exports (foreign_interface).
* c_assrt_body/1:                        Documentation on exports (assertions_props).
* callable/1:                            Documentation on exports (basic_props).
* canonic_html_term/1:                   Documentation on exports (pillow_types).
* canonic_xml_term/1:                    Documentation on exports (pillow_types).
* cell_value/1:                          Documentation on internals (table_widget1).
* character_code/1:                      Documentation on exports (basic_props).
* clause/1:                              Documentation on internals (pretty_print).
* clauses/1:                             Documentation on internals (pretty_print).
* clterm/1:                              Documentation on internals (pretty_print).
* color/1:                               Documentation on exports (color_pattern).
* command/1:                             Documentation on internals (jtopl).
* complex_arg_property/1:                Documentation on exports (assertions_props).
* complex_goal_property/1:               Documentation on exports (assertions_props).
* constant/1:                            Documentation on exports (basic_props).
* datime_struct/1:                       Documentation on exports (system).
* dbconnection/1 <1>:                    Documentation on exports (db_client).
* dbconnection/1:                        Documentation on internals (persdbrtsql).
* dbhandle/1:                            Documentation on internals (db_client).
* dbname/1 <1>:                          Documentation on exports (db_client).
* dbname/1:                              Documentation on exports (persdbrtsql).
* dbqueryconnection/1:                   Documentation on exports (db_client).
* dgraph/1:                              Documentation on exports (graphs).
* dictionary/1:                          Documentation on exports (assertions_props).
* directoryname/1:                       Documentation on internals (persdbrt).
* dlgraph/1:                             Documentation on exports (graphs).
* elisp_string/1:                        Documentation on exports (emacs).
* flag/1:                                Documentation on internals (pretty_print).
* flt/1:                                 Documentation on exports (basic_props).
* footer/1:                              Documentation on exports (genbar1).
* form_assignment/1:                     Documentation on exports (pillow_types).
* form_dict/1:                           Documentation on exports (pillow_types).
* form_value/1:                          Documentation on exports (pillow_types).
* format_control/1:                      Documentation on exports (format).
* g_assrt_body/1:                        Documentation on exports (assertions_props).
* garbage_collection_option/1:           Documentation on internals (prolog_sys).
* gc_result/1:                           Documentation on internals (prolog_sys).
* gnd/1:                                 Documentation on exports (basic_props).
* handler_type/1:                        Documentation on internals (chartlib_errhandle).
* header/1:                              Documentation on exports (genbar1).
* hms_time/1:                            Documentation on exports (pillow_types).
* html_term/1:                           Documentation on exports (pillow_types).
* http_date/1:                           Documentation on exports (pillow_types).
* http_request_param/1:                  Documentation on exports (pillow_types).
* http_response_param/1:                 Documentation on exports (pillow_types).
* image/1:                               Documentation on exports (table_widget1).
* int/1:                                 Documentation on exports (basic_props).
* int_list/1:                            Documentation on exports (foreign_interface).
* intlist/1:                             Documentation on exports (numlists).
* io_mode/1:                             Documentation on exports (streams_basic).
* java_constructor/1:                    Documentation on exports (javart).
* java_event/1:                          Documentation on exports (javart).
* java_field/1:                          Documentation on exports (javart).
* java_method/1:                         Documentation on exports (javart).
* java_object/1:                         Documentation on exports (javart).
* keypair/1:                             Documentation on internals (sort).
* keyword/1:                             Documentation on internals (persdbrt).
* lgraph/2:                              Documentation on exports (lgraphs).
* list/1:                                Documentation on exports (basic_props).
* list/2:                                Documentation on exports (basic_props).
* machine_name/1:                        Documentation on exports (javart).
* memory_option/1:                       Documentation on internals (prolog_sys).
* memory_result/1:                       Documentation on internals (prolog_sys).
* metaspec/1:                            Documentation on internals (modules).
* modulename/1:                          Documentation on internals (modules).
* month/1:                               Documentation on exports (pillow_types).
* multibar_attribute/1:                  Documentation on internals (genmultibar).
* nnegint/1:                             Documentation on exports (basic_props).
* null_dict/1:                           Documentation on exports (vndict).
* num/1:                                 Documentation on exports (basic_props).
* numlist/1:                             Documentation on exports (numlists).
* operator_specifier/1:                  Documentation on exports (basic_props).
* pair/1:                                Documentation on internals (graphs).
* passwd/1 <1>:                          Documentation on exports (db_client).
* passwd/1:                              Documentation on exports (persdbrtsql).
* pattern/1 <1>:                         Documentation on exports (color_pattern).
* pattern/1:                             Documentation on exports (patterns).
* popen_mode/1:                          Documentation on exports (system).
* predfunctor/1:                         Documentation on exports (assertions_props).
* predname/1:                            Documentation on exports (basic_props).
* projterm/1 <1>:                        Documentation on exports (pl2sql).
* projterm/1:                            Documentation on exports (persdbrtsql).
* prolog_goal/1:                         Documentation on exports (javart).
* prolog_query/1:                        Documentation on internals (jtopl).
* property_conjunction/1:                Documentation on exports (assertions_props).
* property_starterm/1:                   Documentation on exports (assertions_props).
* propfunctor/1:                         Documentation on exports (assertions_props).
* querybody/1 <1>:                       Documentation on exports (pl2sql).
* querybody/1:                           Documentation on exports (persdbrtsql).
* reference/1:                           Documentation on internals (data_facts).
* row/1:                                 Documentation on internals (table_widget1).
* s_assrt_body/1:                        Documentation on exports (assertions_props).
* sequence/2:                            Documentation on exports (basic_props).
* sequence_or_list/2:                    Documentation on exports (basic_props).
* size/1:                                Documentation on exports (gengraph1).
* smooth/1:                              Documentation on exports (gengraph1).
* socket_type/1:                         Documentation on exports (sockets).
* socketname/1 <1>:                      Documentation on exports (db_client).
* socketname/1:                          Documentation on exports (persdbrtsql).
* sourcename/1:                          Documentation on exports (streams_basic).
* sqlstring/1:                           Documentation on exports (pl2sql).
* stmthandle/1:                          Documentation on internals (db_client).
* stream/1:                              Documentation on exports (streams_basic).
* string/1:                              Documentation on exports (basic_props).
* struct/1:                              Documentation on exports (basic_props).
* symbol/1:                              Documentation on exports (gengraph1).
* symbol_option/1:                       Documentation on internals (prolog_sys).
* symbol_result/1:                       Documentation on internals (prolog_sys).
* table/1:                               Documentation on exports (table_widget1).
* tclCommand/1:                          Documentation on exports (tcltk).
* tclInterpreter/1:                      Documentation on exports (tcltk).
* term/1:                                Documentation on exports (basic_props).
* time_option/1:                         Documentation on internals (prolog_sys).
* time_result/1:                         Documentation on internals (prolog_sys).
* title/1:                               Documentation on exports (genbar1).
* translation_predname/1:                Documentation on internals (syntax_extensions).
* triple/1:                              Documentation on internals (graphs).
* tuple/1 <1>:                           Documentation on exports (db_client).
* tuple/1:                               Documentation on internals (persdbrtsql).
* ugraph/1:                              Documentation on exports (ugraphs).
* url_term/1:                            Documentation on exports (pillow_types).
* user/1 <1>:                            Documentation on exports (db_client).
* user/1:                                Documentation on exports (persdbrtsql).
* value_dict/1:                          Documentation on exports (pillow_types).
* varname/1:                             Documentation on exports (vndict).
* varnamedict/1:                         Documentation on exports (vndict).
* varnamesl/1:                           Documentation on exports (vndict).
* vector/1:                              Documentation on exports (gengraph1).
* wakeup_exp/1:                          Documentation on exports (when).
* weekday/1:                             Documentation on exports (pillow_types).
* xbarelement1/1:                        Documentation on internals (genbar1).
* xbarelement2/1:                        Documentation on exports (genbar2).
* xbarelement3/1:                        Documentation on internals (genbar3).
* xbarelement4/1:                        Documentation on internals (genbar4).
* xelement/1:                            Documentation on internals (genmultibar).
* yelement/1:                            Documentation on exports (genbar1).


File: ciao.info,  Node: Declaration Definition Index,  Next: Concept Definition Index,  Prev: Regular Type Definition Index,  Up: Top

Declaration Definition Index
****************************

* Menu:

* add_clause_trans/1:                    Documentation on internals (syntax_extensions).
* add_goal_trans/1:                      Documentation on internals (syntax_extensions).
* add_sentence_trans/1:                  Documentation on internals (syntax_extensions).
* add_term_trans/1:                      Documentation on internals (syntax_extensions).
* calls/1:                               Documentation on new declarations (assertions).
* calls/2:                               Documentation on new declarations (assertions).
* comment/2:                             Documentation on new declarations (assertions).
* comp/1:                                Documentation on new declarations (assertions).
* comp/2:                                Documentation on new declarations (assertions).
* concurrent/1:                          Documentation on new declarations (class).
* data/1:                                Documentation on new declarations (class).
* decl/1:                                Documentation on new declarations (assertions).
* decl/2:                                Documentation on new declarations (assertions).
* discontiguous/1:                       Documentation on internals (builtin_directives).
* dynamic/1:                             Documentation on new declarations (class).
* ensure_loaded/1:                       Documentation on internals (loading_code).
* entry/1:                               Documentation on new declarations (assertions).
* export/1 <1>:                          Documentation on new declarations (mycin).
* export/1 <2>:                          Documentation on new declarations (class).
* export/1:                              Documentation on internals (modules).
* impl_defined/1:                        Documentation on internals (builtin_directives).
* implements/1:                          Documentation on new declarations (class).
* import/2:                              Documentation on internals (modules).
* include/1:                             Documentation on internals (loading_code).
* inherit_class/1:                       Documentation on new declarations (class).
* inheritable/1:                         Documentation on new declarations (class).
* initialization/1:                      Documentation on internals (builtin_directives).
* instance_of/2:                         Documentation on new declarations (objects).
* load_compilation_module/1:             Documentation on internals (syntax_extensions).
* meta_predicate/1:                      Documentation on internals (modules).
* modedef/1:                             Documentation on new declarations (assertions).
* module/2:                              Documentation on internals (modules).
* module/3:                              Documentation on internals (modules).
* multifile/1:                           Documentation on internals (builtin_directives).
* new/2:                                 Documentation on new declarations (objects).
* new_declaration/1:                     Documentation on internals (syntax_extensions).
* new_declaration/2:                     Documentation on internals (syntax_extensions).
* on_abort/1:                            Documentation on internals (builtin_directives).
* op/3:                                  Documentation on internals (syntax_extensions).
* pred/1:                                Documentation on new declarations (assertions).
* pred/2:                                Documentation on new declarations (assertions).
* prop/1:                                Documentation on new declarations (assertions).
* prop/2:                                Documentation on new declarations (assertions).
* public/1:                              Documentation on new declarations (class).
* redefining/1:                          Documentation on internals (builtin_directives).
* reexport/1:                            Documentation on internals (modules).
* reexport/2:                            Documentation on internals (modules).
* regtype/1:                             Documentation on new declarations (regtypes).
* regtype/2:                             Documentation on new declarations (regtypes).
* success/1:                             Documentation on new declarations (assertions).
* success/2:                             Documentation on new declarations (assertions).
* use_active_module/2:                   Documentation on new declarations (actmods).
* use_class/1:                           Documentation on new declarations (objects).
* use_module/1:                          Documentation on internals (modules).
* use_module/2:                          Documentation on internals (modules).
* use_package/1:                         Documentation on internals (loading_code).
* virtual/1:                             Documentation on new declarations (class).


File: ciao.info,  Node: Concept Definition Index,  Next: Global Index,  Prev: Declaration Definition Index,  Up: Top

Concept Definition Index
************************

* Menu:

* &-Prolog:                              Acknowledgments.
* .ciaorc <1>:                           The Ciao initialization file (Win32).
* .ciaorc:                               The Ciao initialization file (Un*x).
* abort:                                 Options available during debugging.
* abstract methods:                      Documentation on new declarations (class).
* acceptable modes:                      Documentation on exports (assertions_props).
* acknowledgments:                       Acknowledgments.
* active module <1>:                     Active modules (high-level distributed execution).
* active module:                         Types of executables generated.
* active object:                         Active modules (high-level distributed execution).
* addmodule and pred(N) meta-arguments:  Usage and interface (class).
* ancestors:                             Options available during debugging.
* Anne Mulkers:                          Acknowledgments.
* answer variable:                       Shell interaction.
* assertion body syntax:                 Documentation on exports (assertions_props).
* assertion language:                    Preprocessing programs.
* assertions:                            Using Ciao inside GNU emacs.
* attribute:                             Documentation on new declarations (class).
* Austrian Research Institute for AI:    Acknowledgments.
* auto-documenter command args, setting: Setting the top-level.
* auto-documenter command, setting:      Setting the top-level.
* auto-documenter default format, setting: Generating program documentation.
* auto-documenter lib path, setting:     Setting the top-level.
* auto-documenter working dir, setting:  Generating program documentation.
* auto-fill:                             Using Ciao inside GNU emacs.
* auto-indentation:                      Using Ciao inside GNU emacs.
* box-type debugger:                     The interactive debugger.
* breakpoint:                            Documentation on exports (debugger).
* breakpoints:                           Debugging programs.
* Bristol University:                    Acknowledgments.
* bugs, reporting:                       Reporting bugs.
* calls assertion:                       Documentation on new declarations (assertions).
* certainty factor:                      Programming MYCIN rules.
* CGI:                                   The PiLLoW Web Programming Library.
* CGI executables:                       The script interpreter.
* change, author:                        Version control.
* change, comment:                       Version control.
* changelog:                             Using Ciao inside GNU emacs.
* changing the executables used:         Setting the top-level.
* check assertion:                       Documentation on exports (assertions).
* checking the assertions:               Preprocessing programs.
* Christian Holzbauer:                   Acknowledgments.
* Ciao basic builtins <1>:               *** PART II - The Ciao basic language (engine).
* Ciao basic builtins:                   PART II - The Ciao basic language (engine).
* Ciao engine:                           Acknowledgments.
* Ciao preprocessor <1>:                 Preprocessing programs.
* Ciao preprocessor <2>:                 Using Ciao inside GNU emacs.
* Ciao preprocessor:                     Acknowledgments.
* Ciao top-level:                        Using Ciao inside GNU emacs.
* ciao, global description:              About the Ciao Prolog development system.
* Ciao, why this name:                   About the name of the System.
* ciao-users:                            Keeping up to date with the Ciao users mailing list.
* Ciao/Prolog mode version:              Getting the Ciao/Prolog mode version.
* client installation:                   Server installation under Windows.
* CLIP group:                            Acknowledgments.
* closed:                                Documentation on exports (data_facts).
* coloring, syntax:                      Using Ciao inside GNU emacs.
* command:                               Options available during debugging.
* comment assertion:                     Documentation on new declarations (assertions).
* comments, machine readable:            The Ciao assertion package.
* comp assertion:                        Documentation on new declarations (assertions).
* compatibility properties:              Defining properties.
* compiler, standalone:                  The stand-alone command-line compiler.
* compiling:                             Loading and compiling programs.
* compiling programs <1>:                Running Ciao scripts (Win32).
* compiling programs <2>:                Generating executables (Win32).
* compiling programs <3>:                Compiling and running programs (Win32).
* compiling programs <4>:                Running Ciao scripts (Un*x).
* compiling programs <5>:                Generating executables (Un*x).
* compiling programs:                    Compiling and running programs (Un*x).
* compiling, from command line:          The stand-alone command-line compiler.
* computational cost:                    Preprocessing programs.
* concurrency:                           Low-level concurrency/multithreading primitives.
* concurrent attribute:                  Documentation on new declarations (class).
* concurrent predicate:                  Fast/concurrent update of facts.
* constructor:                           Documentation on exports (class).
* contributed libraries <1>:             *** PART XI - Contributed libraries.
* contributed libraries:                 PART XI - Contributed libraries.
* creating executables:                  Loading and compiling programs.
* creep:                                 Options available during debugging.
* csh-compatible shell:                  Un*x user setup.
* current input stream:                  Documentation on exports (streams_basic).
* current output stream:                 Documentation on exports (streams_basic).
* customize:                             Setting the top-level.
* D.H.D. Warren:                         Acknowledgments.
* D.L. Bowen:                            Acknowledgments.
* Daniel Cabeza:                         Acknowledgments.
* data predicate:                        Fast/concurrent update of facts.
* database initialization:               Documentation on exports (persdbrt).
* debug options:                         Options available during debugging.
* debugger:                              The interactive debugger.
* debugging <1>:                         Debugging programs.
* debugging:                             Options available during debugging.
* debugging, source-level <1>:           Debugging programs.
* debugging, source-level:               Using Ciao inside GNU emacs.
* decl assertion:                        Documentation on new declarations (assertions).
* declarations, user defined:            Basic builtin directives.
* DECsystem-10 Prolog User's Manual:     Acknowledgments.
* depth first iterative deepening:       Iterative-deepening execution.
* depth limit:                           Iterative-deepening execution.
* destructor:                            Documentation on exports (class).
* determinacy:                           Preprocessing programs.
* development environment <1>:           Win32 binary installation summary.
* development environment <2>:           An introduction to the Ciao emacs environment (Win32).
* development environment:               An introduction to the Ciao emacs environment (Un*x).
* display:                               Options available during debugging.
* downloading emacs:                     Win32 binary installation summary.
* downloading, latest versions:          Downloading new versions.
* emacs interface <1>:                   *** PART I - The program development environment.
* emacs interface:                       PART I - The program development environment.
* emacs lisp:                            Calling emacs from Prolog.
* emacs mode:                            Using Ciao inside GNU emacs.
* emacs mode, loading several:           Coexistence with other Prolog interfaces.
* emacs mode, setting up, Win32:         Win32 binary installation summary.
* emacs server:                          Calling emacs from Prolog.
* emacs, download:                       Win32 binary installation summary.
* emacs, intro <1>:                      An introduction to the Ciao emacs environment (Win32).
* emacs, intro:                          An introduction to the Ciao emacs environment (Un*x).
* engine directory <1>:                  *** PART II - The Ciao basic language (engine).
* engine directory:                      PART II - The Ciao basic language (engine).
* engine module:                         Pure Prolog package.
* Enrico Pontelli:                       Acknowledgments.
* entry assertion:                       Documentation on new declarations (assertions).
* environment variables:                 Installation of the Ciao/Prolog emacs interface.
* environment variables, setup:          Un*x user setup.
* equi join in the WHERE-clause:         Documentation on internals (pl2sql).
* executable:                            Introduction to building executables.
* executables, compressed:               Types of executables generated.
* executables, dynamic:                  Types of executables generated.
* executables, generating <1>:           Generating executables (Win32).
* executables, generating:               Generating executables (Un*x).
* executables, how to run:               Running executables from the command line.
* executables, lazy load:                Types of executables generated.
* executables, self-contained:           Types of executables generated.
* executables, static:                   Types of executables generated.
* executables, types:                    Types of executables generated.
* existential quantification:            Documentation on exports (pl2sql).
* extensibility:                         ISO-Prolog compliance versus extensibility.
* F.C.N. Pereira:                        Acknowledgments.
* fail:                                  Options available during debugging.
* false assertion:                       Documentation on exports (assertions).
* formatting commands:                   Some attention points.
* formatting conventions, for emacs:     Conventions for writing Ciao programs under Emacs.
* Francisco Bueno:                       Acknowledgments.
* Gerda Janssens:                        Acknowledgments.
* German Puebla:                         Acknowledgments.
* Gopal Gupta:                           Acknowledgments.
* granularity control:                   Preprocessing programs.
* H. Ait-Kaci:                           Entering recursive (conjunctive) shell levels.
* hard side-effects:                     Documentation on exports (native_props).
* help <1>:                              Checking for correct installation on Win32.
* help <2>:                              Options available during debugging.
* help <3>:                              Printing manuals (Win32).
* help <4>:                              Testing your Ciao Win32 installation.
* help:                                  Printing manuals (Un*x).
* help, unix:                            Getting help (Un*x).
* help, windows:                         Getting help (Win32).
* HTML:                                  The PiLLoW Web Programming Library.
* HTTP:                                  The PiLLoW Web Programming Library.
* independent:                           Documentation on exports (andprolog).
* Inference of properties:               Preprocessing programs.
* inheritable interface:                 Documentation on new declarations (class).
* inheritance relationship:              Documentation on new declarations (class).
* initialization clauses:                Documentation on new declarations (class).
* initialization file <1>:               The Ciao initialization file (Win32).
* initialization file:                   The Ciao initialization file (Un*x).
* INRIA:                                 Acknowledgments.
* installation, Windows clients:         Server installation under Windows.
* installation, Windows server:          Server installation under Windows.
* installation, Windows, from binaries:  Installing Ciao from a Win32 binary distribution.
* instantiation properties:              Defining properties.
* interface inheritance:                 Documentation on new declarations (class).
* interfaces:                            Declaring classes and interfaces.
* interpreted mode:                      Marking modules and files for debugging in the top-level debugger.
* interpreting:                          Loading and compiling programs.
* iso <1>:                               *** PART III - ISO-Prolog library (iso).
* iso:                                   PART III - ISO-Prolog library (iso).
* ISO-Prolog <1>:                        Documentation on exports (arithmetic).
* ISO-Prolog <2>:                        About the name of the System.
* ISO-Prolog:                            ISO-Prolog compliance versus extensibility.
* ISO-Prolog builtins <1>:               *** PART III - ISO-Prolog library (iso).
* ISO-Prolog builtins:                   PART III - ISO-Prolog library (iso).
* iso-prolog, compliance:                ISO-Prolog compliance versus extensibility.
* iterative-deepening:                   Iterative-deepening execution.
* Jan Maluzynski:                        Acknowledgments.
* Java commands:                         Documentation on internals (jtopl).
* Java event handling from Prolog:       Java event handling from Prolog.
* Java exception handling from Prolog:   Java exception handling from Prolog.
* Johan Andersson:                       Acknowledgments (ciao.el).
* Johan Bevemyr:                         Acknowledgments (ciao.el).
* Johan Widen:                           Acknowledgments.
* John Gallagher:                        Acknowledgments.
* K.U. Leuven:                           Acknowledgments.
* Kalyan Muthukumar:                     Acknowledgments.
* Kevin Greene:                          Acknowledgments.
* key sequences:                         Functionality and associated key sequences (bindings).
* keyboard:                              Characters and character strings.
* Kim Marriott:                          Acknowledgments.
* L. Byrd:                               Acknowledgments.
* L.M. Pereira:                          Acknowledgments.
* leap:                                  Options available during debugging.
* lib library <1>:                       *** PART II - The Ciao basic language (engine).
* lib library:                           PART II - The Ciao basic language (engine).
* limitations, architecture-specific:    Architecture-specific notes and limitations.
* Linkoping U.:                          Acknowledgments.
* loading mode:                          Marking modules and files for debugging in the top-level debugger.
* loading programs <1>:                  Loading and compiling programs.
* loading programs <2>:                  Compiling and running programs (Win32).
* loading programs:                      Compiling and running programs (Un*x).
* locating errors:                       Locating errors and checking the syntax of assertions.
* LogIn:                                 Entering recursive (conjunctive) shell levels.
* Low level Java to Prolog interface:    Low-level Java to Prolog interface.
* Low-Level Prolog to Java Interface Structure: Low-Level Prolog to Java Interface Structure.
* Low-Level Prolog to Java Interface Structure. Java side: Java side.
* Low-Level Prolog to Java Interface Structure. Prolog side: Prolog side.
* LPdoc:                                 About this manual.
* lpdoc command args, setting:           Setting the top-level.
* lpdoc command, setting:                Setting the top-level.
* lpdoc default format, setting:         Generating program documentation.
* lpdoc lib path, setting:               Setting the top-level.
* lpdoc working dir, setting:            Generating program documentation.
* mailing list:                          Keeping up to date with the Ciao users mailing list.
* main module:                           Loading and compiling programs.
* manual, printing <1>:                  Checking for correct installation on Win32.
* manual, printing <2>:                  Printing manuals (Win32).
* manual, printing <3>:                  Testing your Ciao Win32 installation.
* manual, printing:                      Printing manuals (Un*x).
* manual, tour:                          A tour of the manual.
* manuals, printing <1>:                 Printing manuals (Win32).
* manuals, printing:                     Printing manuals (Un*x).
* Manuel Carro:                          Acknowledgments.
* Manuel Hermenegildo:                   Acknowledgments.
* Maria Jose Garcia de la Banda:         Acknowledgments.
* Masanobu Umeda:                        Acknowledgments (ciao.el).
* Mats Carlsson <1>:                     Acknowledgments (ciao.el).
* Mats Carlsson:                         Acknowledgments.
* Maurice Bruynooghe:                    Acknowledgments.
* MCC:                                   Acknowledgments.
* Melbourne U.:                          Acknowledgments.
* modes:                                 Preprocessing programs.
* modular interface:                     Intermediate files in the compilation process.
* module qualification:                  The module system.
* modules, active:                       Types of executables generated.
* Monash U.:                             Acknowledgments.
* moving changelog entries:              Version control.
* multi-evaluated:                       Documentation on new declarations (class).
* New Mexico State University:           Acknowledgments.
* nodebug:                               Options available during debugging.
* non-failure:                           Preprocessing programs.
* nospy:                                 Options available during debugging.
* notation:                              Syntax terminology and notational conventions.
* overriden:                             Documentation on new declarations (class).
* P. Lincoln:                            Entering recursive (conjunctive) shell levels.
* parallel Prolog:                       Acknowledgments.
* parallelizing compiler:                Acknowledgments.
* parametric property:                   Documentation on internals (meta_props).
* parametric regular type abstractions:  Documentation on internals (meta_props).
* path alias:                            Documentation on exports (streams_basic).
* patterns:                              Pattern (regular expression) matching.
* Pawel Pietrzak:                        Acknowledgments.
* Pedro Lopez:                           Acknowledgments.
* Peter Olin:                            Acknowledgments (ciao.el).
* Peter Stuckey:                         Acknowledgments.
* Pierre Deransart:                      Acknowledgments.
* PiLLoW on-line tutorial:               The PiLLoW Web Programming Library.
* Polymorphism:                          Object oriented programming.
* pred assertion:                        Documentation on new declarations (assertions).
* preprocessing programs:                Preprocessing programs.
* preprocessor command args, setting:    Setting the top-level.
* preprocessor command, setting:         Setting the top-level.
* print:                                 Options available during debugging.
* printdepth:                            Options available during debugging.
* printing, manual <1>:                  Checking for correct installation on Win32.
* printing, manual <2>:                  Printing manuals (Win32).
* printing, manual <3>:                  Testing your Ciao Win32 installation.
* printing, manual:                      Printing manuals (Un*x).
* program development environment:       Using Ciao inside GNU emacs.
* program parallelization:               Preprocessing programs.
* program specialization:                Preprocessing programs.
* program transformations <1>:           Preprocessing programs.
* program transformations:               Using Ciao inside GNU emacs.
* programming environment <1>:           *** PART I - The program development environment.
* programming environment:               PART I - The program development environment.
* Prolog answers:                        Documentation on internals (jtopl).
* prolog flag <1>:                       Documentation on exports (io_aux).
* prolog flag:                           Changing system behaviour and various flags.
* Prolog server:                         Documentation on exports (jtopl).
* Prolog shell scripts:                  The script interpreter.
* prolog-emacs interface:                Calling emacs from Prolog.
* prop assertion:                        Documentation on new declarations (assertions).
* properties of computations:            Defining properties.
* properties of execution states:        Defining properties.
* properties, basic:                     Basic data types and properties.
* properties, native:                    Properties which are native to analyzers.
* property abstraction:                  Documentation on internals (meta_props).
* protected:                             Documentation on new declarations (class).
* public domain <1>:                     Summary.
* public domain:                         (outside of any node).
* public interface:                      Documentation on new declarations (class).
* pure Prolog:                           Pure Prolog package.
* query:                                 Shell interaction.
* records <1>:                           *** PART VII - Ciao Prolog extensions.
* records:                               PART VII - Ciao Prolog extensions.
* recursive level:                       Entering recursive (conjunctive) shell levels.
* references, to Ciao:                   Referring to Ciao.
* referring to Ciao:                     Referring to Ciao.
* regtype assertion:                     Documentation on new declarations (regtypes).
* regular expressions:                   Pattern (regular expression) matching.
* reporting bugs:                        Reporting bugs.
* retry:                                 Options available during debugging.
* Roger Nasr <1>:                        Entering recursive (conjunctive) shell levels.
* Roger Nasr:                            Acknowledgments.
* run-time checks:                       Run-time checking of assertions.
* run-time tests:                        Preprocessing programs.
* running programs <1>:                  Running Ciao scripts (Win32).
* running programs <2>:                  Compiling and running programs (Win32).
* running programs <3>:                  Running Ciao scripts (Un*x).
* running programs:                      Compiling and running programs (Un*x).
* Saumya Debray:                         Acknowledgments.
* scripts <1>:                           Running Ciao scripts (Win32).
* scripts:                               Running Ciao scripts (Un*x).
* Seif Haridi:                           Acknowledgments.
* sh-compatible shell:                   Un*x user setup.
* sharing sets:                          Documentation on exports (native_props).
* shortcut, windows:                     Win32 binary installation summary.
* SICS <1>:                              Acknowledgments (ciao.el).
* SICS:                                  Acknowledgments.
* SICStus Prolog:                        Acknowledgments.
* sizes of terms:                        Preprocessing programs.
* skip:                                  Options available during debugging.
* Socket implementation:                 Low-level Prolog to Java socket connection.
* soft side-effects:                     Documentation on exports (native_props).
* source-level debugging <1>:            Debugging programs.
* source-level debugging:                Using Ciao inside GNU emacs.
* specifications:                        Preprocessing programs.
* spy:                                   Options available during debugging.
* standard total ordering:               Comparing terms.
* static checks:                         Using Ciao inside GNU emacs.
* static debugging:                      Preprocessing programs.
* status, this manual:                   About this manual.
* style sheets <1>:                      Checking for correct installation on Win32.
* style sheets <2>:                      Testing your Ciao Win32 installation.
* style sheets:                          Testing your Ciao Un*x installation.
* subterm:                               Options available during debugging.
* success assertion:                     Documentation on new declarations (assertions).
* super class:                           Documentation on new declarations (class).
* Swedish Institute of Computer Science: Acknowledgments.
* Syntax highlighting:                   Using Ciao inside GNU emacs.
* Technical University of Madrid:        Acknowledgments.
* top-level shell, starting, unix:       Starting/exiting the top-level shell (Un*x).
* top-level shell, starting, windows:    Starting/exiting the top-level shell (Win32).
* toplevel command args, setting:        Setting the top-level.
* toplevel command, setting:             Setting the top-level.
* tour, of the manual:                   A tour of the manual.
* tracing the source code:               Using Ciao inside GNU emacs.
* troubleshooting:                       Installing Ciao from a Win32 binary distribution.
* true assertion:                        Documentation on exports (assertions).
* trust assertion:                       Documentation on exports (assertions).
* types:                                 Preprocessing programs.
* U. of Arizona:                         Acknowledgments.
* unify:                                 Options available during debugging.
* UPM:                                   Acknowledgments.
* user module:                           The module system.
* user modules, debugging:               Marking modules and files for debugging in the top-level debugger.
* user setup:                            Un*x user setup.
* users mailing list:                    Keeping up to date with the Ciao users mailing list.
* variable instantiation:                Preprocessing programs.
* Veroniek Dumortier:                    Acknowledgments.
* version control:                       Using Ciao inside GNU emacs.
* version maintenance mode for packages: Version control.
* version number:                        Version control.
* virtual:                               Documentation on new declarations (class).
* WAM:                                   Acknowledgments.
* why the name Ciao:                     About the name of the System.
* windows shortcut:                      Win32 binary installation summary.
* Wlodek Drabent:                        Acknowledgments.
* write:                                 Options available during debugging.
* writing programs:                      Commands which help in typing in programs.
* WWW, interfacing with:                 The PiLLoW Web Programming Library.
* XML:                                   The PiLLoW Web Programming Library.


File: ciao.info,  Node: Global Index,  Prev: Concept Definition Index,  Up: Top

Global Index
************

   This is a global index containing pointers to places where
concepts,  predicates, modes, properties, types, applications, etc.,
are referred to  in the text of the document. Note that due to
limitations of the  `info' format unfortunately only the first
reference will appear in  online versions of the document.

* Menu:

* !/0 <1>:                               Documentation on exports (basiccontrol).
* !/0:                                   Usage and interface (basiccontrol).
* # /2:                                  Documentation on exports (arithmetic).
* $/1:                                   Usage and interface (pillow).
* $/2 <1>:                               Usage and interface (pillow).
* $/2:                                   Usage and interface (argnames).
* $is_persistent/2 <1>:                  Documentation on multifiles (persdbrt).
* $is_persistent/2:                      Usage and interface (persdbrt).
* &-Prolog <1>:                          Acknowledgments (ciao.el).
* &-Prolog:                              Acknowledgments.
* &/2 <1>:                               Documentation on exports (andprolog).
* &/2:                                   Usage and interface (andprolog).
* ','/2:                                 Documentation on exports (basic_props).
* '<-'/1:                                Breadth-first execution.
* '<-'/2:                                Breadth-first execution.
* * /2:                                  Documentation on exports (arithmetic).
* * projection:                          Documentation on internals (pl2sql).
* ** /2:                                 Documentation on exports (arithmetic).
* */1 <1>:                               Documentation on new modes (isomodes).
* */1:                                   Usage and interface (isomodes).
* */2 <1>:                               Documentation on new modes (isomodes).
* */2 <2>:                               Usage and interface (isomodes).
* */2:                                   Documentation on exports (assertions_props).
* + /1:                                  Documentation on exports (arithmetic).
* + /2:                                  Documentation on exports (arithmetic).
* ++ /1:                                 Documentation on exports (arithmetic).
* +/1 <1>:                               Documentation on new modes (basicmodes).
* +/1 <2>:                               Usage and interface (basicmodes).
* +/1 <3>:                               Documentation on new modes (isomodes).
* +/1 <4>:                               Usage and interface (isomodes).
* +/1:                                   Documentation on exports (assertions_props).
* +/2 <1>:                               Documentation on new modes (basicmodes).
* +/2 <2>:                               Usage and interface (basicmodes).
* +/2 <3>:                               Documentation on new modes (isomodes).
* +/2:                                   Usage and interface (isomodes).
* ,/2 <1>:                               Documentation on exports (basiccontrol).
* ,/2:                                   Usage and interface (basiccontrol).
* - /1:                                  Documentation on exports (arithmetic).
* - /2:                                  Documentation on exports (arithmetic).
* -- /1:                                 Documentation on exports (arithmetic).
* -->/2:                                 Usage and interface (classic).
* -/1 <1>:                               Documentation on new modes (basicmodes).
* -/1 <2>:                               Usage and interface (basicmodes).
* -/1 <3>:                               Documentation on new modes (isomodes).
* -/1:                                   Usage and interface (isomodes).
* -/2 <1>:                               Documentation on new modes (basicmodes).
* -/2 <2>:                               Usage and interface (basicmodes).
* -/2 <3>:                               Documentation on new modes (isomodes).
* -/2:                                   Usage and interface (isomodes).
* ->/2 <1>:                              Documentation on exports (basiccontrol).
* ->/2:                                  Usage and interface (basiccontrol).
* ./2 <1>:                               Documentation on exports (ciaosh).
* ./2:                                   Usage and interface (ciaosh).
* .ciaorc <1>:                           Shell invocation and startup.
* .ciaorc <2>:                           The Ciao initialization file (Win32).
* .ciaorc <3>:                           Compiling and running programs (Win32).
* .ciaorc <4>:                           The Ciao initialization file (Un*x).
* .ciaorc:                               Compiling and running programs (Un*x).
* .emacs <1>:                            Calling emacs from Prolog.
* .emacs <2>:                            Installation of the Ciao/Prolog emacs interface.
* .emacs <3>:                            The Ciao initialization file (Win32).
* .emacs:                                The Ciao initialization file (Un*x).
* .tar files:                            Gathering the dependent files for a file.
* / /2:                                  Documentation on exports (arithmetic).
* // /2:                                 Documentation on exports (arithmetic).
* /\ /2:                                 Documentation on exports (arithmetic).
* /bin/sh:                               Documentation on exports (system).
* /bin/sh.exe:                           Running executables from the command line.
* ::/2:                                  Usage and interface (assertions).
* :=/2:                                  Usage and interface (functions).
* ;/2 <1>:                               Documentation on exports (basiccontrol).
* ;/2:                                   Usage and interface (basiccontrol).
* <-/1:                                  Usage and interface (bf).
* <-/2:                                  Usage and interface (bf).
* </2 <1>:                               Documentation on exports (arithmetic).
* </2:                                   Usage and interface (arithmetic).
* << /2:                                 Documentation on exports (arithmetic).
* =../2 <1>:                             Documentation on exports (term_basic).
* =../2:                                 Usage and interface (term_basic).
* =/2 <1>:                               Documentation on exports (term_basic).
* =/2:                                   Usage and interface (term_basic).
* =:=/2 <1>:                             Documentation on exports (arithmetic).
* =:=/2:                                 Usage and interface (arithmetic).
* =</2 <1>:                              Documentation on exports (arithmetic).
* =</2:                                  Usage and interface (arithmetic).
* ==/2 <1>:                              Unweighted graph-processing utilities.
* ==/2 <2>:                              Documentation on exports (term_compare).
* ==/2:                                  Usage and interface (term_compare).
* =>/2 <1>:                              Documentation on exports (andprolog).
* =>/2 <2>:                              Usage and interface (andprolog).
* =>/2 <3>:                              Usage and interface (argnames).
* =>/2:                                  Usage and interface (assertions).
* =\=/2 <1>:                             Documentation on exports (arithmetic).
* =\=/2:                                 Usage and interface (arithmetic).
* >/2 <1>:                               Documentation on exports (arithmetic).
* >/2:                                   Usage and interface (arithmetic).
* >=/2 <1>:                              Documentation on exports (arithmetic).
* >=/2:                                  Usage and interface (arithmetic).
* >> /2:                                 Documentation on exports (arithmetic).
* ?/1 <1>:                               Documentation on new modes (basicmodes).
* ?/1 <2>:                               Usage and interface (basicmodes).
* ?/1 <3>:                               Documentation on new modes (isomodes).
* ?/1:                                   Usage and interface (isomodes).
* ?/2 <1>:                               Documentation on new modes (basicmodes).
* ?/2 <2>:                               Usage and interface (basicmodes).
* ?/2 <3>:                               Documentation on new modes (isomodes).
* ?/2:                                   Usage and interface (isomodes).
* @/1 <1>:                               Documentation on new modes (basicmodes).
* @/1 <2>:                               Usage and interface (basicmodes).
* @/1 <3>:                               Documentation on new modes (isomodes).
* @/1:                                   Usage and interface (isomodes).
* @/2 <1>:                               Documentation on new modes (basicmodes).
* @/2 <2>:                               Usage and interface (basicmodes).
* @/2 <3>:                               Documentation on new modes (isomodes).
* @/2:                                   Usage and interface (isomodes).
* @</2 <1>:                              Documentation on exports (term_compare).
* @</2:                                  Usage and interface (term_compare).
* @=</2 <1>:                             Documentation on exports (term_compare).
* @=</2:                                 Usage and interface (term_compare).
* @>/2 <1>:                              Documentation on exports (term_compare).
* @>/2:                                  Usage and interface (term_compare).
* @>=/2 <1>:                             Documentation on exports (term_compare).
* @>=/2:                                 Usage and interface (term_compare).
* \ /1:                                  Documentation on exports (arithmetic).
* \+/1 <1>:                              Documentation on exports (basiccontrol).
* \+/1:                                  Usage and interface (basiccontrol).
* \/ /2:                                 Documentation on exports (arithmetic).
* \=/2 <1>:                              Documentation on exports (iso_misc).
* \=/2:                                  Usage and interface (iso_misc).
* \==/2 <1>:                             Documentation on exports (term_compare).
* \==/2:                                 Usage and interface (term_compare).
* ^/2 <1>:                               Documentation on exports (pl2sql).
* ^/2 <2>:                               Documentation on exports (aggregates).
* ^/2:                                   Usage and interface (aggregates).
* _assertion language_:                  Modes.
* _mode_:                                Modes.
* _predicate spec_:                      Predicate specs.
* abolish/1 <1>:                         Documentation on exports (dynamic).
* abolish/1:                             Usage and interface (dynamic).
* abort:                                 Options available during debugging.
* abort/0:                               Documentation on exports (exceptions).
* abs/1:                                 Documentation on exports (arithmetic).
* absolute_file_name/2 <1>:              Operating system utilities.
* absolute_file_name/2 <2>:              Documentation on exports (streams_basic).
* absolute_file_name/2:                  Usage and interface (streams_basic).
* absolute_file_name/7 <1>:              Documentation on exports (streams_basic).
* absolute_file_name/7:                  Usage and interface (streams_basic).
* abstract methods:                      Documentation on new declarations (class).
* acceptable modes:                      Documentation on exports (assertions_props).
* ACCLAIM:                               Acknowledgments.
* acknowledgments:                       Acknowledgments.
* acrobat reader <1>:                    Printing manuals (Win32).
* acrobat reader:                        Printing manuals (Un*x).
* active module <1>:                     Active modules (high-level distributed execution).
* active module <2>:                     Documentation on exports (ciaosh).
* active module:                         Types of executables generated.
* active modules <1>:                    *** PART VII - Ciao Prolog extensions.
* active modules:                        PART VII - Ciao Prolog extensions.
* active object:                         Active modules (high-level distributed execution).
* active_agents/1 <1>:                   Documentation on exports (andprolog).
* active_agents/1:                       Usage and interface (andprolog).
* activemod:                             Loading and compiling programs.
* add_after/4 <1>:                       Documentation on exports (idlists).
* add_after/4 <2>:                       Usage and interface (idlists).
* add_after/4 <3>:                       Documentation on exports (lists).
* add_after/4:                           Usage and interface (lists).
* add_before/4 <1>:                      Documentation on exports (idlists).
* add_before/4 <2>:                      Usage and interface (idlists).
* add_before/4 <3>:                      Documentation on exports (lists).
* add_before/4:                          Usage and interface (lists).
* add_clause_trans/1:                    Documentation on internals (syntax_extensions).
* add_edges/3 <1>:                       Documentation on exports (ugraphs).
* add_edges/3:                           Usage and interface (ugraphs).
* add_goal_trans/1:                      Documentation on internals (syntax_extensions).
* add_sentence_trans/1:                  Documentation on internals (syntax_extensions).
* add_term_trans/1:                      Documentation on internals (syntax_extensions).
* add_vertices/3 <1>:                    Documentation on exports (ugraphs).
* add_vertices/3:                        Usage and interface (ugraphs).
* addmodule and pred(N) meta-arguments:  Usage and interface (class).
* address/1 <1>:                         Documentation on exports (foreign_interface).
* address/1:                             Usage and interface (foreign_interface).
* aggregate function (sub)queries:       Documentation on internals (pl2sql).
* aggregate function terms:              Documentation on internals (pl2sql).
* aggregate_function/3:                  Documentation on internals (pl2sql).
* aggregate_functor/2 <1>:               Documentation on internals (pl2sql).
* aggregate_functor/2:                   Documentation on exports (pl2sql).
* aggregates <1>:                        Usage and interface (pl2sql).
* aggregates <2>:                        Usage and interface (persdbrtsql).
* aggregates <3>:                        Usage and interface (davinci).
* aggregates <4>:                        Usage and interface (objects_rt).
* aggregates <5>:                        Usage and interface (functions).
* aggregates <6>:                        Usage and interface (argnames).
* aggregates <7>:                        conc_aggregates (library).
* aggregates <8>:                        Usage and interface (runtime_ops).
* aggregates <9>:                        Usage and interface (dynmods).
* aggregates <10>:                       Usage and interface (iso).
* aggregates:                            Usage and interface (debugger).
* aggregation operations:                SQL persistent database interface.
* aggregation predicates:                Documentation on exports (aggregates).
* analyzer output:                       Documentation on exports (assertions).
* ancestors:                             Options available during debugging.
* andprolog/andprolog:                   Usage and interface (native_props).
* Anne Mulkers:                          Acknowledgments.
* answer variable:                       Shell interaction.
* answer/1:                              Documentation on internals (jtopl).
* answertableterm:                       Documentation on exports (db_client).
* answertableterm/1 <1>:                 Documentation on exports (db_client).
* answertableterm/1 <2>:                 Usage and interface (db_client).
* answertableterm/1:                     Documentation on exports (persdbrtsql).
* answertupleterm/1 <1>:                 Documentation on exports (db_client).
* answertupleterm/1:                     Usage and interface (db_client).
* append/3 <1>:                          Documentation on exports (lists).
* append/3:                              Usage and interface (lists).
* apropos/1 <1>:                         Documentation on exports (librowser).
* apropos/1:                             Usage and interface (librowser).
* apropos_spec/1:                        Documentation on internals (librowser).
* arg/2 <1>:                             Documentation on exports (terms).
* arg/2:                                 Usage and interface (terms).
* arg/3 <1>:                             Documentation on exports (term_basic).
* arg/3:                                 Usage and interface (term_basic).
* arg_expander/6 <1>:                    Documentation on exports (expansion_tools).
* arg_expander/6:                        Usage and interface (expansion_tools).
* argnames/1:                            Usage and interface (argnames).
* arithexpression/1 <1>:                 Documentation on exports (arithmetic).
* arithexpression/1 <2>:                 Usage and interface (arithmetic).
* arithexpression/1:                     Arithmetic.
* arithmetic:                            Documentation on new declarations (assertions).
* arithmetic goal:                       Documentation on internals (pl2sql).
* arithmetic_functor/2 <1>:              Documentation on internals (pl2sql).
* arithmetic_functor/2:                  Documentation on exports (pl2sql).
* ASCII code:                            Documentation on exports (arithmetic).
* ask/2 <1>:                             Documentation on exports (metaterms).
* ask/2:                                 Usage and interface (metaterms).
* assert/1 <1>:                          Documentation on exports (dynamic).
* assert/1:                              Usage and interface (dynamic).
* assert/2 <1>:                          Documentation on exports (dynamic).
* assert/2:                              Usage and interface (dynamic).
* asserta/1 <1>:                         Documentation on exports (dynamic).
* asserta/1:                             Usage and interface (dynamic).
* asserta/2 <1>:                         Documentation on exports (dynamic).
* asserta/2:                             Usage and interface (dynamic).
* asserta_fact/1 <1>:                    Documentation on exports (data_facts).
* asserta_fact/1:                        Usage and interface (data_facts).
* asserta_fact/2 <1>:                    Documentation on exports (data_facts).
* asserta_fact/2:                        Usage and interface (data_facts).
* assertion body syntax:                 Documentation on exports (assertions_props).
* assertion language <1>:                Preprocessing programs.
* assertion language:                    About this manual.
* assertion normalizer:                  Printing the declarations and code in a file.
* assertions <1>:                        Types and properties related to assertions.
* assertions <2>:                        Usage and interface (assertions).
* assertions <3>:                        The Ciao assertion package.
* assertions <4>:                        Version control.
* assertions:                            Using Ciao inside GNU emacs.
* assertions/assertions_props <1>:       Usage and interface (assrt_write).
* assertions/assertions_props <2>:       Usage and interface (regtypes).
* assertions/assertions_props:           Usage and interface (assertions).
* assertions/assrt_lib:                  Usage and interface (assrt_write).
* assertions/doc_props <1>:              Usage and interface (andprolog).
* assertions/doc_props <2>:              Usage and interface (format).
* assertions/doc_props:                  Usage and interface (dcg_expansion).
* assertions/meta_props <1>:             Usage and interface (messages).
* assertions/meta_props <2>:             Usage and interface (rtchecks).
* assertions/meta_props <3>:             Usage and interface (basicmodes).
* assertions/meta_props:                 Usage and interface (isomodes).
* assertz/1 <1>:                         Documentation on exports (dynamic).
* assertz/1:                             Usage and interface (dynamic).
* assertz/2 <1>:                         Documentation on exports (dynamic).
* assertz/2:                             Usage and interface (dynamic).
* assertz_fact/1 <1>:                    Documentation on exports (persdbrtsql).
* assertz_fact/1 <2>:                    SQL persistent database interface.
* assertz_fact/1 <3>:                    Documentation on exports (persdbrt).
* assertz_fact/1 <4>:                    Introduction to persistent predicates.
* assertz_fact/1 <5>:                    Documentation on exports (data_facts).
* assertz_fact/1:                        Usage and interface (data_facts).
* assertz_fact/2 <1>:                    Documentation on exports (data_facts).
* assertz_fact/2:                        Usage and interface (data_facts).
* assrt_body/1 <1>:                      Documentation on exports (assertions_props).
* assrt_body/1 <2>:                      Usage and interface (assertions_props).
* assrt_body/1:                          Documentation on new declarations (assertions).
* assrt_status/1 <1>:                    Documentation on exports (assertions_props).
* assrt_status/1:                        Usage and interface (assertions_props).
* assrt_type/1 <1>:                      Documentation on exports (assertions_props).
* assrt_type/1:                          Usage and interface (assertions_props).
* atan/1:                                Documentation on exports (arithmetic).
* atm/1 <1>:                             Documentation on exports (basic_props).
* atm/1:                                 Usage and interface (basic_props).
* atm_or_atm_list/1 <1>:                 Documentation on exports (basic_props).
* atm_or_atm_list/1:                     Usage and interface (basic_props).
* atom/1 <1>:                            Documentation on exports (term_typing).
* atom/1:                                Usage and interface (term_typing).
* atom2term:                             Usage and interface (jtopl).
* atom2term/2 <1>:                       Documentation on exports (atom2term).
* atom2term/2:                           Usage and interface (atom2term).
* atom_chars/2 <1>:                      Documentation on exports (iso_byte_char).
* atom_chars/2:                          Usage and interface (iso_byte_char).
* atom_codes/2 <1>:                      Documentation on exports (atomic_basic).
* atom_codes/2:                          Usage and interface (atomic_basic).
* atom_concat/2 <1>:                     Documentation on exports (terms).
* atom_concat/2:                         Usage and interface (terms).
* atom_concat/3 <1>:                     Documentation on exports (atomic_basic).
* atom_concat/3:                         Usage and interface (atomic_basic).
* atom_length/2 <1>:                     Documentation on exports (atomic_basic).
* atom_length/2:                         Usage and interface (atomic_basic).
* atom_lock_state/2 <1>:                 Documentation on exports (concurrency).
* atom_lock_state/2:                     Usage and interface (concurrency).
* Atomic goals:                          Documentation on exports (pl2sql).
* atomic/1 <1>:                          Documentation on exports (term_typing).
* atomic/1:                              Usage and interface (term_typing).
* attach_attribute/2 <1>:                Documentation on exports (attributes).
* attach_attribute/2:                    Usage and interface (attributes).
* attribute:                             Documentation on new declarations (class).
* attribute/4 <1>:                       Documentation on multifiles (pl2sql).
* attribute/4 <2>:                       Documentation on exports (pl2sql).
* attribute/4 <3>:                       Usage and interface (pl2sql).
* attribute/4:                           Prolog to SQL translator.
* attributes:                            Documentation on exports (term_basic).
* attributes/1 <1>:                      gengraph2 (library).
* attributes/1 <2>:                      Documentation on exports (gengraph1).
* attributes/1 <3>:                      Usage and interface (gengraph1).
* attributes/1:                          gengraph1 (library).
* Austrian Research Institute for AI:    Acknowledgments.
* auto-documenter command args, setting: Setting the top-level.
* auto-documenter command, setting:      Setting the top-level.
* auto-documenter default format, setting: Generating program documentation.
* auto-documenter lib path, setting:     Setting the top-level.
* auto-documenter working dir, setting:  Generating program documentation.
* auto-fill:                             Using Ciao inside GNU emacs.
* auto-indentation:                      Using Ciao inside GNU emacs.
* axis_limit/1 <1>:                      Documentation on exports (genbar2).
* axis_limit/1 <2>:                      Documentation on exports (genbar1).
* axis_limit/1:                          Usage and interface (genbar1).
* backup file:                           Implementation Issues.
* bagof/3 <1>:                           Known bugs and planned improvements (conc_aggregates).
* bagof/3 <2>:                           Documentation on exports (aggregates).
* bagof/3:                               Usage and interface (aggregates).
* barchart1/10:                          Documentation on exports (genbar3).
* barchart1/7 <1>:                       Documentation on exports (genbar1).
* barchart1/7 <2>:                       Usage and interface (genbar1).
* barchart1/7:                           Documentation on exports (chartlib).
* barchart1/8:                           Documentation on exports (genbar3).
* barchart1/9 <1>:                       Documentation on exports (genbar1).
* barchart1/9 <2>:                       Usage and interface (genbar1).
* barchart1/9:                           Documentation on exports (chartlib).
* barchart2/10:                          Documentation on exports (genbar4).
* barchart2/11 <1>:                      Documentation on exports (genbar2).
* barchart2/11 <2>:                      Usage and interface (genbar2).
* barchart2/11:                          Documentation on exports (chartlib).
* barchart2/7 <1>:                       Documentation on exports (genbar2).
* barchart2/7 <2>:                       Usage and interface (genbar2).
* barchart2/7:                           Documentation on exports (chartlib).
* barchart2/8:                           Documentation on exports (genbar4).
* barchart3/7 <1>:                       Documentation on exports (genbar3).
* barchart3/7 <2>:                       Usage and interface (genbar3).
* barchart3/7:                           Documentation on exports (chartlib).
* barchart3/9 <1>:                       Documentation on exports (genbar3).
* barchart3/9 <2>:                       Usage and interface (genbar3).
* barchart3/9:                           Documentation on exports (chartlib).
* barchart4/11 <1>:                      Documentation on exports (genbar4).
* barchart4/11 <2>:                      Usage and interface (genbar4).
* barchart4/11:                          Documentation on exports (chartlib).
* barchart4/7 <1>:                       Documentation on exports (genbar4).
* barchart4/7 <2>:                       Usage and interface (genbar4).
* barchart4/7:                           Documentation on exports (chartlib).
* basename/2 <1>:                        Documentation on exports (filenames).
* basename/2:                            Usage and interface (filenames).
* bash <1>:                              Installation of the Ciao/Prolog emacs interface.
* bash <2>:                              Running executables from the command line.
* bash:                                  Un*x user setup.
* basic_props:regtype/1:                 Declaring regular types.
* between:                               Usage and interface (iso_misc).
* bf:                                    Iterative-deepening execution.
* bf/af:                                 Breadth-first execution.
* bind_socket/3 <1>:                     Documentation on exports (sockets).
* bind_socket/3:                         Usage and interface (sockets).
* bltwish_interp/1 <1>:                  Documentation on exports (bltclass).
* bltwish_interp/1:                      Usage and interface (bltclass).
* body/1:                                Documentation on internals (pretty_print).
* body_expander/6 <1>:                   Documentation on exports (expansion_tools).
* body_expander/6:                       Usage and interface (expansion_tools).
* box-type debugger:                     The interactive debugger.
* breadth first execution:               Iterative-deepening execution.
* breadth-first execution <1>:           *** PART VII - Ciao Prolog extensions.
* breadth-first execution:               PART VII - Ciao Prolog extensions.
* breakpoins:                            Marking modules and files for debugging with the embedded debugger.
* breakpoint:                            Documentation on exports (debugger).
* breakpoints <1>:                       Debugging programs.
* breakpoints:                           The interactive debugger.
* breakpt/6 <1>:                         Documentation on exports (debugger).
* breakpt/6 <2>:                         Usage and interface (debugger).
* breakpt/6 <3>:                         Marking modules and files for debugging with the embedded debugger.
* breakpt/6:                             The debugging process.
* Bristol University:                    Acknowledgments.
* browse/2 <1>:                          Documentation on exports (librowser).
* browse/2:                              Usage and interface (librowser).
* buffer:                                Checking the installation.
* bugs, reporting:                       Reporting bugs.
* building standalone distributions:     Gathering the dependent files for a file.
* builtin directives <1>:                Extending the syntax.
* builtin directives:                    Basic builtin directives.
* builtin modules:                       The module system.
* byrd-box model:                        Debugging programs.
* byte/1 <1>:                            Documentation on exports (foreign_interface).
* byte/1:                                Usage and interface (foreign_interface).
* byte_list/1 <1>:                       Documentation on exports (foreign_interface).
* byte_list/1:                           Usage and interface (foreign_interface).
* C/3 <1>:                               Documentation on exports (term_basic).
* C/3:                                   Usage and interface (term_basic).
* c:/.emacs:                             Win32 binary installation summary.
* c_assrt_body/1 <1>:                    Documentation on exports (assertions_props).
* c_assrt_body/1:                        Usage and interface (assertions_props).
* c_itf:                                 Code translation utilities.
* call/1 <1>:                            Documentation on exports (assertions_props).
* call/1 <2>:                            Documentation on exports (basiccontrol).
* call/1:                                Usage and interface (basiccontrol).
* call/2 <1>:                            Documentation on exports (meta_props).
* call/2 <2>:                            Usage and interface (meta_props).
* call/2 <3>:                            Documentation on internals (basiccontrol).
* call/2:                                Documentation on internals (modules).
* call/N:                                Documentation on internals (basiccontrol).
* call_in_module/2 <1>:                  Documentation on exports (debugger).
* call_in_module/2 <2>:                  Usage and interface (debugger).
* call_in_module/2:                      Calling predicates that are not exported by a module.
* callable/1 <1>:                        Documentation on exports (basic_props).
* callable/1:                            Usage and interface (basic_props).
* Calling emacs <1>:                     *** PART VIII - Interfaces to other languages and systems.
* Calling emacs:                         PART VIII - Interfaces to other languages and systems.
* callme/1:                              Documentation on multifiles (rtchecks).
* callme/2 <1>:                          Documentation on multifiles (messages).
* callme/2 <2>:                          Usage and interface (messages).
* callme/2 <3>:                          Documentation on multifiles (rtchecks).
* callme/2 <4>:                          Documentation on multifiles (meta_props).
* callme/2:                              Usage and interface (meta_props).
* calls assertion:                       Documentation on new declarations (assertions).
* calls/1 <1>:                           Documentation on new declarations (assertions).
* calls/1:                               Usage and interface (assertions).
* calls/2 <1>:                           Documentation on new declarations (assertions).
* calls/2:                               Usage and interface (assertions).
* canonic_html_term/1 <1>:               Documentation on exports (pillow_types).
* canonic_html_term/1:                   Usage and interface (pillow_types).
* canonic_xml_term/1 <1>:                Documentation on exports (pillow_types).
* canonic_xml_term/1:                    Usage and interface (pillow_types).
* case_insensitive_match/2 <1>:          Documentation on exports (patterns).
* case_insensitive_match/2:              Usage and interface (patterns).
* catch/3 <1>:                           Documentation on exports (exceptions).
* catch/3:                               Usage and interface (exceptions).
* cd/1 <1>:                              Documentation on exports (system).
* cd/1 <2>:                              Usage and interface (system).
* cd/1 <3>:                              Compiling and running programs (Win32).
* cd/1:                                  Compiling and running programs (Un*x).
* ceiling/1:                             Documentation on exports (arithmetic).
* cell_value/1:                          Documentation on internals (table_widget1).
* certainty factor <1>:                  Documentation on new declarations (mycin).
* certainty factor:                      Programming MYCIN rules.
* CGI <1>:                               HTML/XML/CGI programming.
* CGI:                                   The PiLLoW Web Programming Library.
* CGI executables:                       The script interpreter.
* change, author:                        Version control.
* change, comment:                       Version control.
* changelog:                             Using Ciao inside GNU emacs.
* changelog entry:                       Version control.
* changing the executables used:         Setting the top-level.
* char_code/2 <1>:                       Documentation on exports (iso_byte_char).
* char_code/2:                           Usage and interface (iso_byte_char).
* char_conversion/2:                     Extending the syntax.
* character string:                      Some attention points.
* character_code/1 <1>:                  Documentation on exports (basic_props).
* character_code/1:                      Usage and interface (basic_props).
* character_count/2 <1>:                 Documentation on exports (streams_basic).
* character_count/2:                     Usage and interface (streams_basic).
* chartlib/bltclass <1>:                 Usage and interface (test_format).
* chartlib/bltclass <2>:                 Usage and interface (table_widget4).
* chartlib/bltclass <3>:                 Usage and interface (table_widget3).
* chartlib/bltclass <4>:                 Usage and interface (table_widget2).
* chartlib/bltclass <5>:                 Usage and interface (table_widget1).
* chartlib/bltclass <6>:                 Usage and interface (genmultibar).
* chartlib/bltclass <7>:                 Usage and interface (gengraph2).
* chartlib/bltclass <8>:                 Usage and interface (gengraph1).
* chartlib/bltclass <9>:                 Usage and interface (genbar4).
* chartlib/bltclass <10>:                Usage and interface (genbar3).
* chartlib/bltclass <11>:                Usage and interface (genbar2).
* chartlib/bltclass <12>:                Usage and interface (genbar1).
* chartlib/bltclass:                     Usage and interface (chartlib_errhandle).
* chartlib/chartlib_errhandle:           Usage and interface (chartlib).
* chartlib/color_pattern <1>:            Usage and interface (genmultibar).
* chartlib/color_pattern <2>:            Usage and interface (gengraph2).
* chartlib/color_pattern <3>:            Usage and interface (gengraph1).
* chartlib/color_pattern <4>:            Usage and interface (genbar4).
* chartlib/color_pattern <5>:            Usage and interface (genbar3).
* chartlib/color_pattern <6>:            Usage and interface (genbar2).
* chartlib/color_pattern:                Usage and interface (genbar1).
* chartlib/genbar1 <1>:                  Usage and interface (table_widget4).
* chartlib/genbar1 <2>:                  Usage and interface (table_widget3).
* chartlib/genbar1 <3>:                  Usage and interface (table_widget2).
* chartlib/genbar1 <4>:                  Usage and interface (table_widget1).
* chartlib/genbar1 <5>:                  Usage and interface (genmultibar).
* chartlib/genbar1 <6>:                  Usage and interface (gengraph2).
* chartlib/genbar1 <7>:                  Usage and interface (gengraph1).
* chartlib/genbar1 <8>:                  Usage and interface (genbar4).
* chartlib/genbar1 <9>:                  Usage and interface (genbar3).
* chartlib/genbar1 <10>:                 Usage and interface (genbar2).
* chartlib/genbar1:                      Usage and interface (chartlib).
* chartlib/genbar2:                      Usage and interface (chartlib).
* chartlib/genbar3:                      Usage and interface (chartlib).
* chartlib/genbar4:                      Usage and interface (chartlib).
* chartlib/gengraph1 <1>:                Usage and interface (gengraph2).
* chartlib/gengraph1:                    Usage and interface (chartlib).
* chartlib/gengraph2:                    Usage and interface (chartlib).
* chartlib/genmultibar:                  Usage and interface (chartlib).
* chartlib/install_utils <1>:            Usage and interface (table_widget4).
* chartlib/install_utils <2>:            Usage and interface (table_widget3).
* chartlib/install_utils <3>:            Usage and interface (table_widget2).
* chartlib/install_utils <4>:            Usage and interface (table_widget1).
* chartlib/install_utils <5>:            Usage and interface (genmultibar).
* chartlib/install_utils <6>:            Usage and interface (gengraph1).
* chartlib/install_utils <7>:            Usage and interface (genbar4).
* chartlib/install_utils <8>:            Usage and interface (genbar3).
* chartlib/install_utils <9>:            Usage and interface (genbar2).
* chartlib/install_utils <10>:           Usage and interface (genbar1).
* chartlib/install_utils:                Usage and interface (chartlib_errhandle).
* chartlib/table_widget1 <1>:            Usage and interface (table_widget4).
* chartlib/table_widget1 <2>:            Usage and interface (table_widget3).
* chartlib/table_widget1 <3>:            Usage and interface (table_widget2).
* chartlib/table_widget1:                Usage and interface (chartlib).
* chartlib/table_widget2:                Usage and interface (chartlib).
* chartlib/table_widget3:                Usage and interface (chartlib).
* chartlib/table_widget4:                Usage and interface (chartlib).
* chartlib/test_format <1>:              Usage and interface (table_widget4).
* chartlib/test_format <2>:              Usage and interface (table_widget3).
* chartlib/test_format <3>:              Usage and interface (table_widget2).
* chartlib/test_format <4>:              Usage and interface (table_widget1).
* chartlib/test_format <5>:              Usage and interface (genmultibar).
* chartlib/test_format <6>:              Usage and interface (gengraph2).
* chartlib/test_format <7>:              Usage and interface (gengraph1).
* chartlib/test_format <8>:              Usage and interface (genbar4).
* chartlib/test_format <9>:              Usage and interface (genbar3).
* chartlib/test_format <10>:             Usage and interface (genbar2).
* chartlib/test_format:                  Usage and interface (genbar1).
* chartlib_errhandle:                    Documentation on exports (chartlib).
* chartlib_text_error_protect/1 <1>:     test_format (library).
* chartlib_text_error_protect/1 <2>:     Documentation on exports (chartlib_errhandle).
* chartlib_text_error_protect/1 <3>:     Usage and interface (chartlib_errhandle).
* chartlib_text_error_protect/1:         Documentation on exports (chartlib).
* chartlib_visual_error_protect/1 <1>:   Documentation on exports (chartlib_errhandle).
* chartlib_visual_error_protect/1 <2>:   Usage and interface (chartlib_errhandle).
* chartlib_visual_error_protect/1:       Documentation on exports (chartlib).
* check assertion:                       Documentation on exports (assertions).
* check/1 <1>:                           Documentation on exports (assertions).
* check/1:                               Usage and interface (assertions).
* check_sublist/4 <1>:                   Documentation on exports (test_format).
* check_sublist/4:                       Usage and interface (test_format).
* checking the assertions:               Preprocessing programs.
* chmod/2 <1>:                           Documentation on exports (system).
* chmod/2:                               Usage and interface (system).
* chmod/3 <1>:                           Documentation on exports (system).
* chmod/3:                               Usage and interface (system).
* Christian Holzbauer:                   Acknowledgments.
* ciao <1>:                              Win32 binary installation summary.
* ciao <2>:                              Installation of the Ciao/Prolog emacs interface.
* ciao <3>:                              Customization.
* ciao <4>:                              An introduction to the Ciao emacs environment (Win32).
* ciao <5>:                              An introduction to the Ciao emacs environment (Un*x).
* ciao:                                  Testing your Ciao Un*x installation.
* Ciao basic builtins <1>:               *** PART II - The Ciao basic language (engine).
* Ciao basic builtins:                   PART II - The Ciao basic language (engine).
* Ciao engine <1>:                       Types of executables generated.
* Ciao engine <2>:                       Running executables from the command line.
* Ciao engine:                           Acknowledgments.
* Ciao engine builtins:                  Documentation on multifiles (streams_basic).
* Ciao preprocessor <1>:                 Preprocessing programs.
* Ciao preprocessor <2>:                 Using Ciao inside GNU emacs.
* Ciao preprocessor:                     Acknowledgments.
* Ciao top-level:                        Using Ciao inside GNU emacs.
* ciao, global description:              About the Ciao Prolog development system.
* Ciao, why this name:                   About the name of the System.
* ciao-shell <1>:                        Customizing library paths and path aliases.
* ciao-shell <2>:                        How it works.
* ciao-shell <3>:                        The script interpreter.
* ciao-shell:                            Testing your Ciao Un*x installation.
* ciao-users:                            Keeping up to date with the Ciao users mailing list.
* ciao.reg:                              Uninstallation under Windows.
* Ciao/Prolog mode version:              Getting the Ciao/Prolog mode version.
* ciaoc <1>:                             Basic builtin directives.
* ciaoc <2>:                             Customizing library paths and path aliases.
* ciaoc <3>:                             Usage (ciaoc).
* ciaoc <4>:                             Types of executables generated.
* ciaoc <5>:                             Introduction to building executables.
* ciaoc <6>:                             The stand-alone command-line compiler.
* ciaoc <7>:                             Generating executables (Win32).
* ciaoc <8>:                             Generating executables (Un*x).
* ciaoc:                                 Testing your Ciao Un*x installation.
* ciaoc.bat:                             Introduction to building executables.
* ciaolibdir/1 <1>:                      Documentation on exports (system_info).
* ciaolibdir/1:                          Usage and interface (system_info).
* ciaopp <1>:                            Properties which are native to analyzers.
* ciaopp <2>:                            Customization.
* ciaopp <3>:                            Preprocessing programs.
* ciaopp <4>:                            Using Ciao inside GNU emacs.
* ciaopp <5>:                            The interactive debugger.
* ciaopp <6>:                            Types of executables generated.
* ciaopp <7>:                            *** PART I - The program development environment.
* ciaopp <8>:                            Acknowledgments.
* ciaopp <9>:                            PART I - The program development environment.
* ciaopp <10>:                           Summary.
* ciaopp:                                (outside of any node).
* ciaosh <1>:                            Checking for correct installation on Win32.
* ciaosh <2>:                            Crossed-references of a program.
* ciaosh <3>:                            Usage and interface (librowser).
* ciaosh <4>:                            Using Ciao inside GNU emacs.
* ciaosh <5>:                            Customizing library paths and path aliases.
* ciaosh <6>:                            The interactive top-level shell.
* ciaosh <7>:                            *** PART I - The program development environment.
* ciaosh <8>:                            Testing your Ciao Win32 installation.
* ciaosh <9>:                            Testing your Ciao Un*x installation.
* ciaosh:                                PART I - The program development environment.
* ciaosh.cpx:                            Win32 binary installation summary.
* CICYT/MEC:                             Acknowledgments.
* class constructor:                     Documentation on exports (objects_rt).
* class instances:                       Run time usage of objects.
* class_name/1 <1>:                      Documentation on exports (objects_rt).
* class_name/1:                          Usage and interface (objects_rt).
* class_source/1 <1>:                    Documentation on exports (objects_rt).
* class_source/1:                        Usage and interface (objects_rt).
* clause/1:                              Documentation on internals (pretty_print).
* clause/2 <1>:                          Documentation on exports (dynamic).
* clause/2:                              Usage and interface (dynamic).
* clause/3 <1>:                          Documentation on exports (dynamic).
* clause/3:                              Usage and interface (dynamic).
* clauses/1:                             Documentation on internals (pretty_print).
* clearerr/1 <1>:                        Documentation on exports (streams_basic).
* clearerr/1:                            Usage and interface (streams_basic).
* client installation:                   Server installation under Windows.
* client.bat:                            Server installation under Windows.
* CLIP group:                            Acknowledgments.
* close/1 <1>:                           Documentation on exports (db_client).
* close/1 <2>:                           Documentation on exports (system).
* close/1 <3>:                           Documentation on exports (streams_basic).
* close/1:                               Usage and interface (streams_basic).
* close/2 <1>:                           Documentation on exports (iso_incomplete).
* close/2:                               Usage and interface (iso_incomplete).
* close_client/0 <1>:                    Documentation on exports (linda).
* close_client/0:                        Usage and interface (linda).
* close_file/1 <1>:                      Documentation on exports (dec10_io).
* close_file/1:                          Usage and interface (dec10_io).
* close_input/1 <1>:                     Documentation on exports (streams).
* close_input/1:                         Usage and interface (streams).
* close_output/1 <1>:                    Documentation on exports (streams).
* close_output/1:                        Usage and interface (streams).
* close_predicate/1 <1>:                 Documentation on exports (data_facts).
* close_predicate/1:                     Usage and interface (data_facts).
* closed:                                Documentation on exports (data_facts).
* clterm/1:                              Documentation on internals (pretty_print).
* code_class/2 <1>:                      Documentation on exports (io_basic).
* code_class/2:                          Usage and interface (io_basic).
* color/1 <1>:                           Documentation on exports (gengraph1).
* color/1 <2>:                           Documentation on exports (color_pattern).
* color/1:                               Usage and interface (color_pattern).
* color/2 <1>:                           Documentation on exports (color_pattern).
* color/2:                               Usage and interface (color_pattern).
* coloring, syntax:                      Using Ciao inside GNU emacs.
* combine_attributes/2 <1>:              Documentation on multifiles (when).
* combine_attributes/2 <2>:              Usage and interface (when).
* combine_attributes/2 <3>:              Documentation on multifiles (freeze).
* combine_attributes/2 <4>:              Usage and interface (freeze).
* combine_attributes/2 <5>:              Documentation on multifiles (attributes).
* combine_attributes/2:                  Usage and interface (attributes).
* command:                               Options available during debugging.
* command/1:                             Documentation on internals (jtopl).
* comment assertion:                     Documentation on new declarations (assertions).
* comment string:                        Documentation on exports (assertions_props).
* comment/2 <1>:                         Documentation on new declarations (assertions).
* comment/2 <2>:                         Usage and interface (assertions).
* comment/2:                             Version control.
* comments, machine readable:            The Ciao assertion package.
* comp assertion:                        Documentation on new declarations (assertions).
* comp/1 <1>:                            Documentation on exports (assertions_props).
* comp/1 <2>:                            Documentation on new declarations (assertions).
* comp/1:                                Usage and interface (assertions).
* comp/2 <1>:                            Documentation on new declarations (assertions).
* comp/2:                                Usage and interface (assertions).
* compare/3 <1>:                         Documentation on exports (term_compare).
* compare/3:                             Usage and interface (term_compare).
* comparison goal:                       Documentation on internals (pl2sql).
* comparison operations:                 Documentation on internals (pl2sql).
* comparison/2 <1>:                      Documentation on internals (pl2sql).
* comparison/2:                          Documentation on exports (pl2sql).
* compat/2 <1>:                          Documentation on exports (basic_props).
* compat/2:                              Usage and interface (basic_props).
* compatibility properties:              Defining properties.
* compatible:                            Documentation on exports (assertions_props).
* compile/1 <1>:                         Traditional Prolog Mode Commands.
* compile/1 <2>:                         Documentation on exports (ciaosh).
* compile/1 <3>:                         Usage and interface (ciaosh).
* compile/1 <4>:                         Compiling and running programs (Win32).
* compile/1:                             Compiling and running programs (Un*x).
* compiler, standalone:                  The stand-alone command-line compiler.
* compiler/c_itf <1>:                    Usage and interface (expansion_tools).
* compiler/c_itf:                        Usage and interface (ciaosh).
* compiler/compiler <1>:                 Usage and interface (dynmods).
* compiler/compiler:                     Usage and interface (ciaosh).
* compiler/exemaker:                     Usage and interface (ciaosh).
* compiler_and_opts/2 <1>:               Documentation on exports (foreign_compilation).
* compiler_and_opts/2:                   Usage and interface (foreign_compilation).
* compiling:                             Loading and compiling programs.
* compiling programs <1>:                Running Ciao scripts (Win32).
* compiling programs <2>:                Generating executables (Win32).
* compiling programs <3>:                Compiling and running programs (Win32).
* compiling programs <4>:                Running Ciao scripts (Un*x).
* compiling programs <5>:                Generating executables (Un*x).
* compiling programs:                    Compiling and running programs (Un*x).
* compiling, from command line:          The stand-alone command-line compiler.
* complete proof procedure <1>:          Iterative-deepening execution.
* complete proof procedure:              Breadth-first execution.
* complete_dict/3 <1>:                   Documentation on exports (vndict).
* complete_dict/3:                       Usage and interface (vndict).
* complete_vars_dict/3 <1>:              Documentation on exports (vndict).
* complete_vars_dict/3:                  Usage and interface (vndict).
* complex argument property:             Documentation on exports (assertions_props).
* complex goal property:                 Documentation on exports (assertions_props).
* complex_arg_property/1 <1>:            Documentation on exports (assertions_props).
* complex_arg_property/1:                Usage and interface (assertions_props).
* complex_goal_property/1 <1>:           Documentation on exports (assertions_props).
* complex_goal_property/1:               Usage and interface (assertions_props).
* compound/1 <1>:                        Documentation on exports (iso_misc).
* compound/1:                            Usage and interface (iso_misc).
* computational cost:                    Preprocessing programs.
* concurrency:                           Low-level concurrency/multithreading primitives.
* concurrency/concurrency <1>:           Usage and interface (jtopl).
* concurrency/concurrency <2>:           Usage and interface (javart).
* concurrency/concurrency:               Usage and interface (andprolog).
* concurrent:                            Documentation on exports (data_facts).
* concurrent attribute:                  Documentation on new declarations (class).
* concurrent predicate <1>:              Documentation on exports (data_facts).
* concurrent predicate:                  Fast/concurrent update of facts.
* concurrent predicates:                 Low-level concurrency/multithreading primitives.
* concurrent updates <1>:                SQL persistent database interface.
* concurrent updates:                    Introduction to persistent predicates.
* concurrent/1 <1>:                      Documentation on new declarations (class).
* concurrent/1:                          Usage and interface (class).
* conjunctions:                          Documentation on exports (pl2sql).
* connect_to_socket/3 <1>:               Documentation on exports (db_client).
* connect_to_socket/3 <2>:               Documentation on exports (sockets).
* connect_to_socket/3:                   Usage and interface (sockets).
* connect_to_socket_type/4 <1>:          Documentation on exports (sockets).
* connect_to_socket_type/4:              Usage and interface (sockets).
* constant arguments:                    Documentation on internals (pl2sql).
* constant/1 <1>:                        Documentation on exports (basic_props).
* constant/1:                            Usage and interface (basic_props).
* constraint logic programming <1>:      *** PART VII - Ciao Prolog extensions.
* constraint logic programming:          PART VII - Ciao Prolog extensions.
* constructor:                           Documentation on exports (class).
* constructor/0 <1>:                     Documentation on exports (class).
* constructor/0:                         Usage and interface (class).
* constructor/1 <1>:                     Documentation on exports (objects_rt).
* constructor/1:                         Usage and interface (objects_rt).
* consult/1 <1>:                         Traditional Prolog Mode Commands.
* consult/1 <2>:                         Documentation on exports (ciaosh).
* consult/1 <3>:                         Usage and interface (ciaosh).
* consult/1 <4>:                         Compiling and running programs (Win32).
* consult/1:                             Compiling and running programs (Un*x).
* contains1/2 <1>:                       Documentation on exports (lists).
* contains1/2:                           Usage and interface (lists).
* contains_ro/2 <1>:                     Documentation on exports (lists).
* contains_ro/2:                         Usage and interface (lists).
* Context-sensitive <1>:                 Getting help (Win32).
* Context-sensitive:                     Getting help (Un*x).
* contributed libraries <1>:             *** PART XI - Contributed libraries.
* contributed libraries:                 PART XI - Contributed libraries.
* control:                               Documentation on exports (odd).
* copy_args/3 <1>:                       Documentation on exports (terms).
* copy_args/3:                           Usage and interface (terms).
* copy_stdout/1 <1>:                     Documentation on exports (file_utils).
* copy_stdout/1:                         Usage and interface (file_utils).
* copy_term/2 <1>:                       Documentation on exports (term_basic).
* copy_term/2:                           Usage and interface (term_basic).
* cos/1:                                 Documentation on exports (arithmetic).
* covered/1 <1>:                         Documentation on exports (native_props).
* covered/1:                             Usage and interface (native_props).
* create_dict/2 <1>:                     Documentation on exports (vndict).
* create_dict/2:                         Usage and interface (vndict).
* creating executables:                  Loading and compiling programs.
* creep:                                 Options available during debugging.
* csh <1>:                               Installation of the Ciao/Prolog emacs interface.
* csh:                                   Un*x user setup.
* csh-compatible shell:                  Un*x user setup.
* ctrlc_clean/1 <1>:                     Documentation on exports (ctrlcclean).
* ctrlc_clean/1:                         Usage and interface (ctrlcclean).
* ctrlcclean/0 <1>:                      Documentation on exports (ctrlcclean).
* ctrlcclean/0:                          Usage and interface (ctrlcclean).
* current input stream:                  Documentation on exports (streams_basic).
* current output stream:                 Documentation on exports (streams_basic).
* current_atom/1 <1>:                    Documentation on exports (prolog_sys).
* current_atom/1:                        Usage and interface (prolog_sys).
* current_executable/1 <1>:              Documentation on exports (system).
* current_executable/1:                  Usage and interface (system).
* current_fact/1 <1>:                    Documentation on exports (persdbrtsql).
* current_fact/1 <2>:                    Documentation on exports (persdbrt).
* current_fact/1 <3>:                    Documentation on exports (data_facts).
* current_fact/1:                        Usage and interface (data_facts).
* current_fact/2 <1>:                    Documentation on exports (data_facts).
* current_fact/2:                        Usage and interface (data_facts).
* current_fact_nb/1 <1>:                 Documentation on exports (data_facts).
* current_fact_nb/1:                     Usage and interface (data_facts).
* current_host/1 <1>:                    Documentation on exports (system).
* current_host/1:                        Usage and interface (system).
* current_infixop/4 <1>:                 Documentation on exports (operators).
* current_infixop/4:                     Usage and interface (operators).
* current_input/1 <1>:                   Documentation on exports (streams_basic).
* current_input/1:                       Usage and interface (streams_basic).
* current_key/2 <1>:                     Documentation on exports (old_database).
* current_key/2:                         Usage and interface (old_database).
* current_module/1 <1>:                  Documentation on exports (system_info).
* current_module/1:                      Usage and interface (system_info).
* current_op/3 <1>:                      Documentation on exports (operators).
* current_op/3:                          Usage and interface (operators).
* current_output/1 <1>:                  Documentation on exports (streams_basic).
* current_output/1:                      Usage and interface (streams_basic).
* current_postfixop/3 <1>:               Documentation on exports (operators).
* current_postfixop/3:                   Usage and interface (operators).
* current_predicate/1 <1>:               Documentation on exports (dynamic).
* current_predicate/1:                   Usage and interface (dynamic).
* current_predicate/2 <1>:               Documentation on exports (prolog_sys).
* current_predicate/2 <2>:               Usage and interface (prolog_sys).
* current_predicate/2 <3>:               Documentation on exports (dynamic).
* current_predicate/2:                   Usage and interface (dynamic).
* current_prefixop/3 <1>:                Documentation on exports (operators).
* current_prefixop/3:                    Usage and interface (operators).
* current_prolog_flag/2 <1>:             Documentation on exports (prolog_flags).
* current_prolog_flag/2:                 Usage and interface (prolog_flags).
* current_stream/3 <1>:                  Documentation on exports (streams_basic).
* current_stream/3:                      Usage and interface (streams_basic).
* customize:                             Setting the top-level.
* D.H.D. Warren:                         Acknowledgments.
* D.L. Bowen:                            Acknowledgments.
* Daniel Cabeza:                         Acknowledgments.
* data file:                             Implementation Issues.
* data predicate <1>:                    Documentation on exports (data_facts).
* data predicate:                        Fast/concurrent update of facts.
* data/1 <1>:                            Using file-based persistent predicates.
* data/1 <2>:                            Class and Interface error reporting at compile time.
* data/1 <3>:                            Documentation on new declarations (class).
* data/1 <4>:                            Usage and interface (class).
* data/1 <5>:                            Declaring classes and interfaces.
* data/1 <6>:                            Documentation on exports (dynamic).
* data/1:                                Usage and interface (dynamic).
* Database aggregation functions:        Documentation on exports (pl2sql).
* Database arithmetic expressions:       Documentation on exports (pl2sql).
* Database arithmetic functions:         Documentation on exports (pl2sql).
* Database calls to is/2:                Documentation on exports (pl2sql).
* Database comparison goals:             Documentation on exports (pl2sql).
* database comparison operator:          Documentation on exports (pl2sql).
* database initialization:               Documentation on exports (persdbrt).
* database mediator server <1>:          Documentation on exports (db_client).
* database mediator server:              Low-level socket interface to SQL/ODBC databases.
* datime/1 <1>:                          Documentation on exports (system).
* datime/1:                              Usage and interface (system).
* datime/9 <1>:                          Documentation on exports (system).
* datime/9:                              Usage and interface (system).
* datime_struct/1 <1>:                   Documentation on exports (system).
* datime_struct/1:                       Usage and interface (system).
* davinci/0 <1>:                         Documentation on exports (davinci).
* davinci/0:                             Usage and interface (davinci).
* davinci_get/1 <1>:                     Documentation on exports (davinci).
* davinci_get/1:                         Usage and interface (davinci).
* davinci_get_all/1 <1>:                 Documentation on exports (davinci).
* davinci_get_all/1:                     Usage and interface (davinci).
* davinci_lgraph/1 <1>:                  Documentation on exports (davinci).
* davinci_lgraph/1:                      Usage and interface (davinci).
* davinci_put/1 <1>:                     Documentation on exports (davinci).
* davinci_put/1:                         Usage and interface (davinci).
* davinci_quit/0 <1>:                    Documentation on exports (davinci).
* davinci_quit/0:                        Usage and interface (davinci).
* davinci_ugraph/1 <1>:                  Documentation on exports (davinci).
* davinci_ugraph/1:                      Usage and interface (davinci).
* db_client:                             SQL persistent database interface.
* db_eval_sql/3 <1>:                     Documentation on exports (db_client).
* db_eval_sql/3:                         Usage and interface (db_client).
* db_get_tables/2 <1>:                   Documentation on exports (db_client).
* db_get_tables/2:                       Usage and interface (db_client).
* db_login/5 <1>:                        Documentation on exports (db_client).
* db_login/5:                            Usage and interface (db_client).
* db_logoff/1 <1>:                       Documentation on exports (db_client).
* db_logoff/1 <2>:                       Usage and interface (db_client).
* db_logoff/1:                           Documentation on internals (persdbrtsql).
* db_one_tuple/2 <1>:                    Documentation on exports (db_client).
* db_one_tuple/2:                        Usage and interface (db_client).
* db_query/4:                            Documentation on internals (persdbrtsql).
* db_query_one_tuple/4:                  Documentation on internals (persdbrtsql).
* db_stmt_handle/3 <1>:                  Documentation on exports (db_client).
* db_stmt_handle/3:                      Usage and interface (db_client).
* db_table_types/3 <1>:                  Documentation on exports (db_client).
* db_table_types/3:                      Usage and interface (db_client).
* dbassertz_fact/1 <1>:                  Documentation on exports (persdbrtsql).
* dbassertz_fact/1:                      Usage and interface (persdbrtsql).
* dbcall/2 <1>:                          Documentation on exports (persdbrtsql).
* dbcall/2:                              Usage and interface (persdbrtsql).
* dbconnection/1 <1>:                    Documentation on exports (db_client).
* dbconnection/1 <2>:                    Usage and interface (db_client).
* dbconnection/1:                        Documentation on internals (persdbrtsql).
* dbcurrent_fact/1 <1>:                  Documentation on exports (persdbrtsql).
* dbcurrent_fact/1:                      Usage and interface (persdbrtsql).
* dbfindall/4 <1>:                       Documentation on exports (persdbrtsql).
* dbfindall/4:                           Usage and interface (persdbrtsql).
* dbhandle/1:                            Documentation on internals (db_client).
* dbname/1 <1>:                          Documentation on exports (db_client).
* dbname/1 <2>:                          Usage and interface (db_client).
* dbname/1:                              Documentation on exports (persdbrtsql).
* dbqueryconnection/1 <1>:               Documentation on exports (db_client).
* dbqueryconnection/1:                   Usage and interface (db_client).
* dbretract_fact/1 <1>:                  Documentation on exports (persdbrtsql).
* dbretract_fact/1:                      Usage and interface (persdbrtsql).
* dbretractall_fact/1 <1>:               Documentation on exports (persdbrtsql).
* dbretractall_fact/1:                   Usage and interface (persdbrtsql).
* dcg_expansion:                         Usage and interface (assertions_props).
* dcg_translation/2 <1>:                 Documentation on exports (dcg_expansion).
* dcg_translation/2:                     Usage and interface (dcg_expansion).
* debug:                                 The debugging process.
* debug options:                         Options available during debugging.
* debug/0 <1>:                           Documentation on exports (debugger).
* debug/0 <2>:                           Usage and interface (debugger).
* debug/0:                               The debugging process.
* debug/1:                               Documentation on exports (io_aux).
* debug_goal/2 <1>:                      Documentation on exports (messages).
* debug_goal/2:                          Usage and interface (messages).
* debug_goal/3 <1>:                      Documentation on exports (messages).
* debug_goal/3:                          Usage and interface (messages).
* debug_message/1 <1>:                   Documentation on exports (messages).
* debug_message/1:                       Usage and interface (messages).
* debug_message/2 <1>:                   Documentation on exports (messages).
* debug_message/2:                       Usage and interface (messages).
* debug_module/1 <1>:                    Documentation on exports (debugger).
* debug_module/1 <2>:                    Usage and interface (debugger).
* debug_module/1:                        Marking modules and files for debugging in the top-level debugger.
* debug_module_source/1 <1>:             Documentation on exports (debugger).
* debug_module_source/1 <2>:             Usage and interface (debugger).
* debug_module_source/1 <3>:             The debugging process.
* debug_module_source/1:                 Marking modules and files for debugging in the top-level debugger.
* debugger <1>:                          The debugging process.
* debugger:                              The interactive debugger.
* debugger/debugger:                     Usage and interface (ciaosh).
* debugger/debugger_lib:                 Usage and interface (debugger).
* debugging <1>:                         Debugging programs.
* debugging:                             Options available during debugging.
* debugging tools:                       The interactive debugger.
* debugging, source-level <1>:           Debugging programs.
* debugging, source-level:               Using Ciao inside GNU emacs.
* debugging/0 <1>:                       Documentation on exports (debugger).
* debugging/0:                           Usage and interface (debugger).
* dec10_io <1>:                          Usage and interface (pl2sql).
* dec10_io:                              Usage and interface (classic).
* decl assertion:                        Documentation on new declarations (assertions).
* decl/1 <1>:                            Documentation on exports (assertions_props).
* decl/1 <2>:                            Documentation on new declarations (assertions).
* decl/1:                                Usage and interface (assertions).
* decl/2 <1>:                            Documentation on new declarations (assertions).
* decl/2:                                Usage and interface (assertions).
* declarations, user defined:            Basic builtin directives.
* DECsystem-10 Prolog User's Manual:     Acknowledgments.
* deductive database:                    Persistent predicates.
* default constructor <1>:               Documentation on exports (objects_rt).
* default constructor:                   Error reporting at compile time (objects).
* define_flag/3 <1>:                     Documentation on multifiles (write).
* define_flag/3 <2>:                     Usage and interface (write).
* define_flag/3 <3>:                     Documentation on multifiles (prolog_flags).
* define_flag/3:                         Usage and interface (prolog_flags).
* del_global/1 <1>:                      Documentation on exports (global).
* del_global/1:                          Usage and interface (global).
* del_vertices/3 <1>:                    Documentation on exports (ugraphs).
* del_vertices/3:                        Usage and interface (ugraphs).
* delaying predicate execution <1>:      *** PART VII - Ciao Prolog extensions.
* delaying predicate execution:          PART VII - Ciao Prolog extensions.
* delete/3 <1>:                          Documentation on exports (idlists).
* delete/3 <2>:                          Usage and interface (idlists).
* delete/3 <3>:                          Documentation on exports (lists).
* delete/3:                              Usage and interface (lists).
* delete_file/1 <1>:                     Documentation on exports (system).
* delete_file/1:                         Usage and interface (system).
* delete_on_ctrlc/2 <1>:                 Documentation on exports (ctrlcclean).
* delete_on_ctrlc/2:                     Usage and interface (ctrlcclean).
* dependent files:                       Gathering the dependent files for a file.
* depth first iterative deepening:       Iterative-deepening execution.
* depth limit:                           Iterative-deepening execution.
* derived_from/2 <1>:                    Documentation on exports (objects_rt).
* derived_from/2:                        Usage and interface (objects_rt).
* describe/1 <1>:                        Documentation on exports (librowser).
* describe/1:                            Usage and interface (librowser).
* destroy/1 <1>:                         Documentation on exports (objects_rt).
* destroy/1:                             Usage and interface (objects_rt).
* destructor:                            Documentation on exports (class).
* destructor/0 <1>:                      Documentation on exports (class).
* destructor/0:                          Usage and interface (class).
* detach_attribute/1 <1>:                Documentation on exports (attributes).
* detach_attribute/1:                    Usage and interface (attributes).
* determinacy:                           Preprocessing programs.
* development environment <1>:           Win32 binary installation summary.
* development environment <2>:           An introduction to the Ciao emacs environment (Win32).
* development environment:               An introduction to the Ciao emacs environment (Un*x).
* dgraph/1 <1>:                          Documentation on exports (graphs).
* dgraph/1:                              Usage and interface (graphs).
* dgraph_to_ugraph/2 <1>:                Documentation on exports (graphs).
* dgraph_to_ugraph/2:                    Usage and interface (graphs).
* dic_get/3 <1>:                         Documentation on exports (dict).
* dic_get/3:                             Usage and interface (dict).
* dic_lookup/3 <1>:                      Documentation on exports (dict).
* dic_lookup/3:                          Usage and interface (dict).
* dic_lookup/4 <1>:                      Documentation on exports (dict).
* dic_lookup/4:                          Usage and interface (dict).
* dic_node/2 <1>:                        Documentation on exports (dict).
* dic_node/2:                            Usage and interface (dict).
* dic_replace/4 <1>:                     Documentation on exports (dict).
* dic_replace/4:                         Usage and interface (dict).
* dict <1>:                              Usage and interface (fastrw).
* dict:                                  Usage and interface (classic).
* dict2varnamesl/2 <1>:                  Documentation on exports (vndict).
* dict2varnamesl/2:                      Usage and interface (vndict).
* dictionary/1 <1>:                      Documentation on exports (assertions_props).
* dictionary/1:                          Usage and interface (assertions_props).
* difference/3 <1>:                      Documentation on exports (lists).
* difference/3:                          Usage and interface (lists).
* directives:                            Basic builtin directives.
* directory_files/2 <1>:                 Documentation on exports (system).
* directory_files/2:                     Usage and interface (system).
* directoryname/1:                       Documentation on internals (persdbrt).
* DISCIPL:                               Acknowledgments.
* discontiguous/1 <1>:                   Usage and interface (class).
* discontiguous/1:                       Documentation on internals (builtin_directives).
* disjunctions:                          Documentation on exports (pl2sql).
* display:                               Options available during debugging.
* display/1 <1>:                         Term output.
* display/1 <2>:                         Documentation on exports (io_aux).
* display/1 <3>:                         Documentation on exports (io_basic).
* display/1:                             Usage and interface (io_basic).
* display/2 <1>:                         Term output.
* display/2 <2>:                         Documentation on exports (io_basic).
* display/2:                             Usage and interface (io_basic).
* display_list/1:                        Documentation on exports (io_aux).
* display_string/1 <1>:                  Documentation on exports (io_aux).
* display_string/1:                      Usage and interface (io_aux).
* display_term/1:                        Documentation on exports (io_aux).
* displayq/1 <1>:                        Documentation on exports (io_aux).
* displayq/1 <2>:                        Documentation on exports (io_basic).
* displayq/1:                            Usage and interface (io_basic).
* displayq/2 <1>:                        Documentation on exports (io_basic).
* displayq/2:                            Usage and interface (io_basic).
* disproves/2:                           Documentation on multifiles (rtchecks).
* distributed execution:                 Active modules (high-level distributed execution).
* dlgraph/1 <1>:                         Documentation on exports (graphs).
* dlgraph/1:                             Usage and interface (graphs).
* dlgraph_to_lgraph/2 <1>:               Documentation on exports (graphs).
* dlgraph_to_lgraph/2:                   Usage and interface (graphs).
* dlist/3 <1>:                           Documentation on exports (lists).
* dlist/3:                               Usage and interface (lists).
* do_not_free/2 <1>:                     Documentation on exports (foreign_interface).
* do_not_free/2:                         Usage and interface (foreign_interface).
* do_on_abolish/1 <1>:                   Documentation on multifiles (dynamic).
* do_on_abolish/1:                       Usage and interface (dynamic).
* docstring/1 <1>:                       Documentation on exports (assertions_props).
* docstring/1 <2>:                       Usage and interface (assertions_props).
* docstring/1:                           Some attention points.
* documentation generator <1>:           *** PART I - The program development environment.
* documentation generator:               PART I - The program development environment.
* downloading emacs:                     Win32 binary installation summary.
* downloading new versions <1>:          *** PART XII - Appendices.
* downloading new versions:              PART XII - Appendices.
* downloading, latest versions:          Downloading new versions.
* dynamic <1>:                           Usage and interface (javasock).
* dynamic <2>:                           Usage and interface (jtopl).
* dynamic <3>:                           Usage and interface (persdbrtsql).
* dynamic <4>:                           Usage and interface (objects_rt).
* dynamic <5>:                           Usage and interface (functions).
* dynamic <6>:                           Usage and interface (argnames).
* dynamic <7>:                           Usage and interface (runtime_ops).
* dynamic <8>:                           Usage and interface (dynmods).
* dynamic:                               Usage and interface (iso).
* dynamic predicate:                     Fast/concurrent update of facts.
* dynamic/1 <1>:                         Documentation on new declarations (class).
* dynamic/1 <2>:                         Usage and interface (class).
* dynamic/1:                             Documentation on exports (dynamic).
* dynamic_search_path/1 <1>:             Documentation on exports (ciaosh).
* dynamic_search_path/1:                 Usage and interface (ciaosh).
* dynmods <1>:                           Usage and interface (jtopl).
* dynmods <2>:                           Usage and interface (objects_rt).
* dynmods:                               Usage and interface (classic).
* edges/2 <1>:                           Documentation on exports (ugraphs).
* edges/2:                               Usage and interface (ugraphs).
* edges_to_lgraph/2 <1>:                 Documentation on exports (graphs).
* edges_to_lgraph/2:                     Usage and interface (graphs).
* edges_to_ugraph/2 <1>:                 Documentation on exports (graphs).
* edges_to_ugraph/2:                     Usage and interface (graphs).
* EDIPIA:                                Acknowledgments.
* elisp_string/1 <1>:                    Documentation on exports (emacs).
* elisp_string/1:                        Usage and interface (emacs).
* ELLA:                                  Acknowledgments.
* emacs <1>:                             Checking for correct installation on Win32.
* emacs <2>:                             Win32 binary installation summary.
* emacs <3>:                             Documentation on exports (emacs).
* emacs <4>:                             Calling emacs from Prolog.
* emacs <5>:                             Installation of the Ciao/Prolog emacs interface.
* emacs <6>:                             Customization.
* emacs <7>:                             Coexistence with other Prolog interfaces.
* emacs <8>:                             Version control.
* emacs <9>:                             Debugging programs.
* emacs <10>:                            Getting on-line help.
* emacs <11>:                            Checking the installation.
* emacs <12>:                            Using Ciao inside GNU emacs.
* emacs <13>:                            How it works.
* emacs <14>:                            Documentation on exports (debugger).
* emacs <15>:                            Format of debugging messages.
* emacs <16>:                            The procedure box control flow model.
* emacs <17>:                            Marking modules and files for debugging in the top-level debugger.
* emacs <18>:                            The interactive debugger.
* emacs <19>:                            An introduction to the Ciao emacs environment (Win32).
* emacs <20>:                            Getting help (Win32).
* emacs <21>:                            Testing your Ciao Win32 installation.
* emacs <22>:                            Getting started on Windows machines.
* emacs <23>:                            An introduction to the Ciao emacs environment (Un*x).
* emacs <24>:                            Getting help (Un*x).
* emacs <25>:                            Un*x user setup.
* emacs <26>:                            Getting started on Un*x-like machines.
* emacs:                                 About this manual.
* emacs Ciao/Prolog mode:                Version control.
* emacs interface <1>:                   Using Ciao inside GNU emacs.
* emacs interface <2>:                   The interactive top-level shell.
* emacs interface <3>:                   *** PART I - The program development environment.
* emacs interface:                       PART I - The program development environment.
* emacs lisp:                            Calling emacs from Prolog.
* emacs menu bar:                        Checking the installation.
* emacs mode <1>:                        Calling emacs from Prolog.
* emacs mode <2>:                        Using Ciao inside GNU emacs.
* emacs mode <3>:                        How it works.
* emacs mode:                            Marking modules and files for debugging in the top-level debugger.
* emacs mode, loading several:           Coexistence with other Prolog interfaces.
* emacs mode, setting up, Win32:         Win32 binary installation summary.
* emacs server:                          Calling emacs from Prolog.
* emacs, download:                       Win32 binary installation summary.
* emacs, intro <1>:                      An introduction to the Ciao emacs environment (Win32).
* emacs, intro:                          An introduction to the Ciao emacs environment (Un*x).
* emacs_edit/1 <1>:                      Documentation on exports (emacs).
* emacs_edit/1:                          Usage and interface (emacs).
* emacs_edit_nowait/1 <1>:               Documentation on exports (emacs).
* emacs_edit_nowait/1:                   Usage and interface (emacs).
* emacs_eval/1 <1>:                      Documentation on exports (emacs).
* emacs_eval/1:                          Usage and interface (emacs).
* emacs_eval_nowait/1 <1>:               Documentation on exports (emacs).
* emacs_eval_nowait/1:                   Usage and interface (emacs).
* embedded debugger <1>:                 Marking modules and files for debugging with the embedded debugger.
* embedded debugger:                     The interactive debugger.
* eng_backtrack/2 <1>:                   Documentation on exports (concurrency).
* eng_backtrack/2:                       Usage and interface (concurrency).
* eng_call/3 <1>:                        Documentation on exports (concurrency).
* eng_call/3:                            Usage and interface (concurrency).
* eng_call/4 <1>:                        Documentation on exports (concurrency).
* eng_call/4:                            Usage and interface (concurrency).
* eng_cut/1 <1>:                         Documentation on exports (concurrency).
* eng_cut/1:                             Usage and interface (concurrency).
* eng_kill/1 <1>:                        Documentation on exports (concurrency).
* eng_kill/1:                            Usage and interface (concurrency).
* eng_killothers:                        Documentation on exports (concurrency).
* eng_killothers/0 <1>:                  Documentation on exports (concurrency).
* eng_killothers/0:                      Usage and interface (concurrency).
* eng_release/1 <1>:                     Documentation on exports (concurrency).
* eng_release/1:                         Usage and interface (concurrency).
* eng_self/1 <1>:                        Documentation on exports (concurrency).
* eng_self/1:                            Usage and interface (concurrency).
* eng_status/0 <1>:                      Documentation on exports (concurrency).
* eng_status/0:                          Usage and interface (concurrency).
* eng_wait/1 <1>:                        Documentation on exports (concurrency).
* eng_wait/1:                            Usage and interface (concurrency).
* engine directory <1>:                  *** PART II - The Ciao basic language (engine).
* engine directory:                      PART II - The Ciao basic language (engine).
* engine module:                         Pure Prolog package.
* engine(basic_props):                   Documentation on new declarations (regtypes).
* Enrico Pontelli:                       Acknowledgments.
* ensure_loaded/1 <1>:                   Documentation on internals (loading_code).
* ensure_loaded/1 <2>:                   Documentation on exports (ciaosh).
* ensure_loaded/1 <3>:                   Usage and interface (ciaosh).
* ensure_loaded/1 <4>:                   Types of executables generated.
* ensure_loaded/1:                       Paths used by the compiler during compilation.
* entry assertion:                       Documentation on new declarations (assertions).
* entry/1 <1>:                           Documentation on exports (assertions_props).
* entry/1 <2>:                           Documentation on new declarations (assertions).
* entry/1:                               Usage and interface (assertions).
* environment variables:                 Installation of the Ciao/Prolog emacs interface.
* environment variables, setup:          Un*x user setup.
* equal_lists/2 <1>:                     Documentation on exports (lists).
* equal_lists/2:                         Usage and interface (lists).
* equality comparisons in the WHERE-clause: Documentation on internals (pl2sql).
* equalnumber/3 <1>:                     Documentation on exports (test_format).
* equalnumber/3:                         Usage and interface (test_format).
* equi join in the WHERE-clause:         Documentation on internals (pl2sql).
* erase/1 <1>:                           Documentation on exports (data_facts).
* erase/1:                               Usage and interface (data_facts).
* errhandle:                             Usage and interface (davinci).
* error term:                            Changing system behaviour and various flags.
* error/1:                               Documentation on exports (io_aux).
* error_file/2:                          Documentation on internals (chartlib_errhandle).
* error_message/1 <1>:                   Documentation on exports (messages).
* error_message/1:                       Usage and interface (messages).
* error_message/2 <1>:                   Documentation on internals (chartlib_errhandle).
* error_message/2 <2>:                   Documentation on exports (messages).
* error_message/2:                       Usage and interface (messages).
* error_message/3 <1>:                   Documentation on exports (messages).
* error_message/3:                       Usage and interface (messages).
* error_protect/1 <1>:                   Documentation on exports (errhandle).
* error_protect/1:                       Usage and interface (errhandle).
* etc:                                   Compiling the miscellaneous utilities under Windows.
* etc(xfrefs):                           Crossed-references of a program.
* etc(xmrefs):                           Crossed-references of a program.
* evaluable functors:                    Documentation on exports (arithmetic).
* examples <1>:                          Running Ciao scripts (Win32).
* examples <2>:                          Generating executables (Win32).
* examples <3>:                          Running Ciao scripts (Un*x).
* examples:                              Generating executables (Un*x).
* exec/3 <1>:                            Documentation on exports (system).
* exec/3:                                Usage and interface (system).
* exec/4 <1>:                            Documentation on exports (system).
* exec/4:                                Usage and interface (system).
* executable:                            Introduction to building executables.
* executables, compressed:               Types of executables generated.
* executables, dynamic:                  Types of executables generated.
* executables, generating <1>:           Generating executables (Win32).
* executables, generating:               Generating executables (Un*x).
* executables, how to run:               Running executables from the command line.
* executables, lazy load:                Types of executables generated.
* executables, self-contained:           Types of executables generated.
* executables, static:                   Types of executables generated.
* executables, types:                    Types of executables generated.
* execution visualizers:                 The interactive debugger.
* existential quantification:            Documentation on exports (pl2sql).
* exp/1:                                 Documentation on exports (arithmetic).
* expander_pred/1:                       Documentation on internals (expansion_tools).
* expansion:                             Documentation on internals (syntax_extensions).
* expansions:                            Declarations.
* Explorer <1>:                          Checking for correct installation on Win32.
* Explorer:                              Testing your Ciao Win32 installation.
* export/1 <1>:                          Documentation on new declarations (mycin).
* export/1 <2>:                          Usage and interface (mycin).
* export/1 <3>:                          Documentation on new declarations (class).
* export/1 <4>:                          Usage and interface (class).
* export/1 <5>:                          Declaring classes and interfaces.
* export/1:                              Documentation on internals (modules).
* exports:                               Printing the declarations and code in a file.
* extensibility:                         ISO-Prolog compliance versus extensibility.
* extension/2 <1>:                       Documentation on exports (filenames).
* extension/2:                           Usage and interface (filenames).
* External interface <1>:                *** PART VIII - Interfaces to other languages and systems.
* External interface:                    PART VIII - Interfaces to other languages and systems.
* extract_paths/2 <1>:                   Documentation on exports (system).
* extract_paths/2:                       Usage and interface (system).
* F.C.N. Pereira:                        Acknowledgments.
* fail:                                  Options available during debugging.
* fail/0 <1>:                            Documentation on exports (basiccontrol).
* fail/0:                                Usage and interface (basiccontrol).
* fails/1 <1>:                           Documentation on exports (native_props).
* fails/1:                               Usage and interface (native_props).
* false assertion:                       Documentation on exports (assertions).
* false/1 <1>:                           Documentation on exports (assertions).
* false/1:                               Usage and interface (assertions).
* fast_read/1 <1>:                       Documentation on exports (fastrw).
* fast_read/1:                           Usage and interface (fastrw).
* fast_write/1 <1>:                      Documentation on exports (fastrw).
* fast_write/1:                          Usage and interface (fastrw).
* fast_write_to_string/3 <1>:            Documentation on exports (fastrw).
* fast_write_to_string/3:                Usage and interface (fastrw).
* fastrw <1>:                            Usage and interface (linda).
* fastrw:                                Usage and interface (javasock).
* feature terms <1>:                     *** PART VII - Ciao Prolog extensions.
* feature terms:                         PART VII - Ciao Prolog extensions.
* fetch_url/3 <1>:                       Documentation on exports (http).
* fetch_url/3:                           Usage and interface (http).
* file_exists/1 <1>:                     Documentation on exports (system).
* file_exists/1:                         Usage and interface (system).
* file_exists/2 <1>:                     Documentation on exports (system).
* file_exists/2:                         Usage and interface (system).
* file_locks/file_locks:                 Usage and interface (persdbrt).
* file_name_extension/3 <1>:             Documentation on exports (filenames).
* file_name_extension/3:                 Usage and interface (filenames).
* file_properties/6 <1>:                 Documentation on exports (system).
* file_properties/6:                     Usage and interface (system).
* file_property/2 <1>:                   Documentation on exports (system).
* file_property/2:                       Usage and interface (system).
* file_search_path/2 <1>:                Documentation on multifiles (streams_basic).
* file_search_path/2 <2>:                Documentation on exports (streams_basic).
* file_search_path/2 <3>:                Usage and interface (streams_basic).
* file_search_path/2 <4>:                Documentation on multifiles (libpaths).
* file_search_path/2 <5>:                Documentation on exports (libpaths).
* file_search_path/2 <6>:                Usage and interface (libpaths).
* file_search_path/2 <7>:                Types of executables generated.
* file_search_path/2:                    Paths used by the compiler during compilation.
* file_terms/2 <1>:                      Documentation on exports (file_utils).
* file_terms/2:                          Usage and interface (file_utils).
* file_to_string/2 <1>:                  Documentation on exports (file_utils).
* file_to_string/2:                      Usage and interface (file_utils).
* fileerrors/0 <1>:                      Documentation on exports (prolog_flags).
* fileerrors/0:                          Usage and interface (prolog_flags).
* fileinfo:                              More detailed explanation of options (fileinfo).
* filenames <1>:                         Usage and interface (librowser).
* filenames:                             Usage and interface (messages).
* find_name/4 <1>:                       Documentation on exports (vndict).
* find_name/4:                           Usage and interface (vndict).
* findall/3 <1>:                         Documentation on exports (persdbrtsql).
* findall/3 <2>:                         Documentation on exports (conc_aggregates).
* findall/3 <3>:                         Usage and interface (conc_aggregates).
* findall/3 <4>:                         Documentation on exports (aggregates).
* findall/3:                             Usage and interface (aggregates).
* findall/4 <1>:                         Documentation on exports (aggregates).
* findall/4:                             Usage and interface (aggregates).
* findnsols/4 <1>:                       Documentation on exports (aggregates).
* findnsols/4:                           Usage and interface (aggregates).
* findnsols/5 <1>:                       Documentation on exports (aggregates).
* findnsols/5:                           Usage and interface (aggregates).
* flag/1:                                Documentation on internals (pretty_print).
* float/1 <1>:                           Documentation on exports (arithmetic).
* float/1 <2>:                           Documentation on exports (term_typing).
* float/1:                               Usage and interface (term_typing).
* float_fractional_part/1:               Documentation on exports (arithmetic).
* float_integer_part/1:                  Documentation on exports (arithmetic).
* floor/1:                               Documentation on exports (arithmetic).
* flt/1 <1>:                             Documentation on exports (arithmetic).
* flt/1 <2>:                             Documentation on exports (basic_props).
* flt/1:                                 Usage and interface (basic_props).
* flush_output/0 <1>:                    Documentation on exports (streams_basic).
* flush_output/0:                        Usage and interface (streams_basic).
* flush_output/1 <1>:                    Documentation on exports (streams_basic).
* flush_output/1:                        Usage and interface (streams_basic).
* fmode/2 <1>:                           Documentation on exports (system).
* fmode/2:                               Usage and interface (system).
* foldl/4 <1>:                           Documentation on exports (hiord).
* foldl/4:                               Usage and interface (hiord).
* footer/1 <1>:                          Documentation on exports (genbar1).
* footer/1:                              Usage and interface (genbar1).
* force_lazy/1 <1>:                      Documentation on exports (ciaosh).
* force_lazy/1:                          Usage and interface (ciaosh).
* foreign/1 <1>:                         Documentation on exports (foreign_interface).
* foreign/1:                             Usage and interface (foreign_interface).
* foreign/2 <1>:                         Documentation on exports (foreign_interface).
* foreign/2:                             Usage and interface (foreign_interface).
* ForEmacs.txt:                          Win32 binary installation summary.
* form_assignment/1 <1>:                 Documentation on exports (pillow_types).
* form_assignment/1:                     Usage and interface (pillow_types).
* form_default/3 <1>:                    Documentation on exports (html).
* form_default/3:                        Usage and interface (html).
* form_dict/1 <1>:                       Documentation on exports (pillow_types).
* form_dict/1:                           Usage and interface (pillow_types).
* form_empty_value/1 <1>:                Documentation on exports (html).
* form_empty_value/1:                    Usage and interface (html).
* form_request_method/1 <1>:             Documentation on exports (html).
* form_request_method/1:                 Usage and interface (html).
* form_value/1 <1>:                      Documentation on exports (pillow_types).
* form_value/1:                          Usage and interface (pillow_types).
* format <1>:                            Usage and interface (bltclass).
* format <2>:                            Usage and interface (javasock).
* format <3>:                            Usage and interface (jtopl).
* format <4>:                            Usage and interface (javart).
* format <5>:                            Usage and interface (davinci).
* format <6>:                            Usage and interface (assrt_write).
* format <7>:                            Usage and interface (messages).
* format <8>:                            Usage and interface (classic).
* format:                                Usage and interface (debugger).
* format/2 <1>:                          Documentation on exports (format).
* format/2:                              Usage and interface (format).
* format/3 <1>:                          Documentation on exports (format).
* format/3:                              Usage and interface (format).
* format_control/1 <1>:                  Documentation on exports (format).
* format_control/1:                      Usage and interface (format).
* formatting commands:                   Some attention points.
* formatting conventions, for emacs:     Conventions for writing Ciao programs under Emacs.
* formatting/2 <1>:                      Documentation on exports (davinci).
* formatting/2:                          Usage and interface (davinci).
* Francisco Bueno:                       Acknowledgments.
* freeze/2 <1>:                          Documentation on exports (freeze).
* freeze/2 <2>:                          Usage and interface (freeze).
* freeze/2 <3>:                          Delaying predicates (freeze).
* freeze/2:                              Usage and interface (attributes).
* FROM-clauses:                          Documentation on internals (pl2sql).
* frozen/2 <1>:                          Documentation on exports (freeze).
* frozen/2 <2>:                          Usage and interface (freeze).
* frozen/2:                              Delaying predicates (freeze).
* func/1:                                Documentation on exports (assertions_props).
* function/1:                            Usage and interface (functions).
* functional syntax <1>:                 *** PART VII - Ciao Prolog extensions.
* functional syntax:                     PART VII - Ciao Prolog extensions.
* functions <1>:                         The Ciao lpmake scripting facility.
* functions:                             Declarations.
* functor of a goal:                     Documentation on internals (pl2sql).
* functor/3 <1>:                         Documentation on exports (term_basic).
* functor/3:                             Usage and interface (term_basic).
* g_assrt_body/1 <1>:                    Documentation on exports (assertions_props).
* g_assrt_body/1:                        Usage and interface (assertions_props).
* garbage collection <1>:                Documentation on internals (prolog_sys).
* garbage collection:                    Documentation on exports (prolog_sys).
* garbage_collect/0 <1>:                 Documentation on exports (prolog_sys).
* garbage_collect/0:                     Usage and interface (prolog_sys).
* garbage_collection_option/1:           Documentation on internals (prolog_sys).
* gc/0 <1>:                              Documentation on exports (prolog_flags).
* gc/0:                                  Usage and interface (prolog_flags).
* gc_result/1:                           Documentation on internals (prolog_sys).
* gcd/2:                                 Documentation on exports (arithmetic).
* genbar1:                               Documentation on exports (chartlib).
* genbar2:                               Documentation on exports (chartlib).
* genbar3:                               Documentation on exports (chartlib).
* genbar4:                               Documentation on exports (chartlib).
* gengraph1:                             Documentation on exports (chartlib).
* gengraph2:                             Documentation on exports (chartlib).
* genmultibar:                           Documentation on exports (chartlib).
* Gerda Janssens:                        Acknowledgments.
* German Puebla:                         Acknowledgments.
* get1_code/1 <1>:                       Documentation on exports (io_basic).
* get1_code/1:                           Usage and interface (io_basic).
* get1_code/2 <1>:                       Documentation on exports (io_basic).
* get1_code/2:                           Usage and interface (io_basic).
* get_alias_path/0 <1>:                  Documentation on exports (libpaths).
* get_alias_path/0:                      Usage and interface (libpaths).
* get_arch/1 <1>:                        Documentation on exports (system_info).
* get_arch/1:                            Usage and interface (system_info).
* get_attribute/2 <1>:                   Documentation on exports (attributes).
* get_attribute/2:                       Usage and interface (attributes).
* get_byte/1 <1>:                        Documentation on exports (iso_byte_char).
* get_byte/1:                            Usage and interface (iso_byte_char).
* get_byte/2 <1>:                        Documentation on exports (iso_byte_char).
* get_byte/2:                            Usage and interface (iso_byte_char).
* get_char/1 <1>:                        Documentation on exports (iso_byte_char).
* get_char/1:                            Usage and interface (iso_byte_char).
* get_char/2 <1>:                        Documentation on exports (iso_byte_char).
* get_char/2:                            Usage and interface (iso_byte_char).
* get_code/1 <1>:                        Documentation on exports (io_basic).
* get_code/1:                            Usage and interface (io_basic).
* get_code/2 <1>:                        Documentation on exports (io_basic).
* get_code/2:                            Usage and interface (io_basic).
* get_cookies/1 <1>:                     Documentation on exports (html).
* get_cookies/1:                         Usage and interface (html).
* get_form_input/1 <1>:                  Documentation on exports (html).
* get_form_input/1:                      Usage and interface (html).
* get_form_value/3 <1>:                  Documentation on exports (html).
* get_form_value/3:                      Usage and interface (html).
* get_global/2 <1>:                      Documentation on exports (global).
* get_global/2:                          Usage and interface (global).
* get_line/1 <1>:                        Documentation on exports (strings).
* get_line/1:                            Usage and interface (strings).
* get_line/2 <1>:                        Documentation on exports (strings).
* get_line/2:                            Usage and interface (strings).
* get_os/1 <1>:                          Documentation on exports (system_info).
* get_os/1:                              Usage and interface (system_info).
* get_pid/1 <1>:                         Documentation on exports (system).
* get_pid/1:                             Usage and interface (system).
* get_primes/2 <1>:                      Documentation on exports (numlists).
* get_primes/2:                          Usage and interface (numlists).
* get_query_id/1:                        Documentation on internals (jtopl).
* getcounter/2 <1>:                      Documentation on exports (counters).
* getcounter/2:                          Usage and interface (counters).
* getct/2 <1>:                           Documentation on exports (io_basic).
* getct/2:                               Usage and interface (io_basic).
* getct1/2 <1>:                          Documentation on exports (io_basic).
* getct1/2:                              Usage and interface (io_basic).
* getenvstr/2 <1>:                       Documentation on exports (system).
* getenvstr/2:                           Usage and interface (system).
* ghostview <1>:                         Printing manuals (Win32).
* ghostview:                             Printing manuals (Un*x).
* global variables <1>:                  *** PART VII - Ciao Prolog extensions.
* global variables:                      PART VII - Ciao Prolog extensions.
* GlobalChangeLog:                       Version control.
* gmax/3:                                Delaying predicates (when).
* gnd/1 <1>:                             Documentation on exports (basic_props).
* gnd/1:                                 Usage and interface (basic_props).
* GNU emacs <1>:                         Emacs version compatibility.
* GNU emacs <2>:                         *** PART I - The program development environment.
* GNU emacs:                             PART I - The program development environment.
* GNU general public license:            Preprocessing programs.
* GNU General Public License <1>:        Summary.
* GNU General Public License:            (outside of any node).
* go/1 <1>:                              Documentation on new modes (basicmodes).
* go/1:                                  Usage and interface (basicmodes).
* go/2 <1>:                              Documentation on new modes (basicmodes).
* go/2:                                  Usage and interface (basicmodes).
* Goal:                                  Documentation on exports (when).
* Gopal Gupta:                           Acknowledgments.
* grammar rule:                          Documentation on exports (strings).
* granularity control:                   Preprocessing programs.
* graph_b1/13 <1>:                       Documentation on exports (gengraph1).
* graph_b1/13 <2>:                       Usage and interface (gengraph1).
* graph_b1/13:                           Documentation on exports (chartlib).
* graph_b1/9 <1>:                        Documentation on exports (gengraph1).
* graph_b1/9 <2>:                        Usage and interface (gengraph1).
* graph_b1/9:                            Documentation on exports (chartlib).
* graph_b2/13 <1>:                       Documentation on exports (gengraph2).
* graph_b2/13 <2>:                       Usage and interface (gengraph2).
* graph_b2/13:                           Documentation on exports (chartlib).
* graph_b2/9 <1>:                        Documentation on exports (gengraph2).
* graph_b2/9 <2>:                        Usage and interface (gengraph2).
* graph_b2/9:                            Documentation on exports (chartlib).
* graph_w1/13 <1>:                       Documentation on exports (gengraph1).
* graph_w1/13 <2>:                       Usage and interface (gengraph1).
* graph_w1/13:                           Documentation on exports (chartlib).
* graph_w1/9 <1>:                        Documentation on exports (gengraph1).
* graph_w1/9 <2>:                        Usage and interface (gengraph1).
* graph_w1/9:                            Documentation on exports (chartlib).
* graph_w2/13 <1>:                       Documentation on exports (gengraph2).
* graph_w2/13 <2>:                       Usage and interface (gengraph2).
* graph_w2/13:                           Documentation on exports (chartlib).
* graph_w2/9 <1>:                        Documentation on exports (gengraph2).
* graph_w2/9 <2>:                        Usage and interface (gengraph2).
* graph_w2/9:                            Documentation on exports (chartlib).
* graphs/lgraphs:                        Usage and interface (graphs).
* graphs/ugraphs <1>:                    Usage and interface (graphs).
* graphs/ugraphs:                        Usage and interface (davinci).
* ground/1 <1>:                          Known bugs and planned improvements (andprolog).
* ground/1 <2>:                          Documentation on exports (native_props).
* ground/1 <3>:                          Documentation on exports (term_typing).
* ground/1:                              Usage and interface (term_typing).
* H. Ait-Kaci:                           Entering recursive (conjunctive) shell levels.
* halt/0 <1>:                            Documentation on exports (exceptions).
* halt/0:                                Usage and interface (exceptions).
* halt/1 <1>:                            Documentation on exports (exceptions).
* halt/1:                                Usage and interface (exceptions).
* halt_server/0 <1>:                     Documentation on exports (linda).
* halt_server/0:                         Usage and interface (linda).
* handle_error/2 <1>:                    Documentation on exports (errhandle).
* handle_error/2:                        Usage and interface (errhandle).
* handler_type/1:                        Documentation on internals (chartlib_errhandle).
* hard side-effects:                     Documentation on exports (native_props).
* head pattern:                          Documentation on exports (assertions_props).
* head_pattern/1 <1>:                    Documentation on exports (assertions_props).
* head_pattern/1:                        Usage and interface (assertions_props).
* header/1 <1>:                          Documentation on exports (genbar1).
* header/1:                              Usage and interface (genbar1).
* hello:                                 How it works.
* help <1>:                              Checking for correct installation on Win32.
* help <2>:                              Options available during debugging.
* help <3>:                              Printing manuals (Win32).
* help <4>:                              Testing your Ciao Win32 installation.
* help:                                  Printing manuals (Un*x).
* help, unix:                            Getting help (Un*x).
* help, windows:                         Getting help (Win32).
* higher-order library <1>:              *** PART VII - Ciao Prolog extensions.
* higher-order library:                  PART VII - Ciao Prolog extensions.
* hms_time/1 <1>:                        Documentation on exports (pillow_types).
* hms_time/1:                            Usage and interface (pillow_types).
* hostname_address/2 <1>:                Documentation on exports (sockets).
* hostname_address/2:                    Usage and interface (sockets).
* HTML <1>:                              HTML/XML/CGI programming.
* HTML:                                  The PiLLoW Web Programming Library.
* html2terms/2 <1>:                      Documentation on exports (html).
* html2terms/2:                          Usage and interface (html).
* html_expansion/2 <1>:                  Documentation on multifiles (html).
* html_expansion/2:                      Usage and interface (html).
* html_protect/1 <1>:                    Documentation on exports (html).
* html_protect/1:                        Usage and interface (html).
* html_report_error/1 <1>:               Documentation on exports (html).
* html_report_error/1:                   Usage and interface (html).
* html_template/3 <1>:                   Documentation on exports (html).
* html_template/3:                       Usage and interface (html).
* html_term/1 <1>:                       Documentation on exports (pillow_types).
* html_term/1 <2>:                       Usage and interface (pillow_types).
* html_term/1:                           Documentation on exports (html).
* HTTP <1>:                              HTTP conectivity.
* HTTP:                                  The PiLLoW Web Programming Library.
* http_date/1 <1>:                       Documentation on exports (pillow_types).
* http_date/1:                           Usage and interface (pillow_types).
* http_lines/3 <1>:                      Documentation on exports (html).
* http_lines/3:                          Usage and interface (html).
* http_request_param/1 <1>:              Documentation on exports (pillow_types).
* http_request_param/1:                  Usage and interface (pillow_types).
* http_response_param/1 <1>:             Documentation on exports (pillow_types).
* http_response_param/1:                 Usage and interface (pillow_types).
* hw:                                    Running Ciao scripts (Un*x).
* hw.pls <1>:                            Running Ciao scripts (Win32).
* hw.pls:                                Running Ciao scripts (Un*x).
* icon_address.pl <1>:                   Installing Ciao from the source distribution.
* icon_address.pl:                       Installing PiLLoW.
* icon_address/2 <1>:                    Documentation on exports (pillow_types).
* icon_address/2 <2>:                    Documentation on exports (html).
* icon_address/2:                        Usage and interface (html).
* idlists <1>:                           Usage and interface (vndict).
* idlists:                               Usage and interface (metaterms).
* if/3 <1>:                              Documentation on exports (basiccontrol).
* if/3:                                  Usage and interface (basiccontrol).
* image/1 <1>:                           Documentation on exports (table_widget1).
* image/1:                               Usage and interface (table_widget1).
* impl_defined/1:                        Documentation on internals (builtin_directives).
* implements/1 <1>:                      Class and Interface error reporting at compile time.
* implements/1 <2>:                      Documentation on new declarations (class).
* implements/1 <3>:                      Usage and interface (class).
* implements/1:                          Declaring classes and interfaces.
* import/2:                              Documentation on internals (modules).
* imports:                               Printing the declarations and code in a file.
* imports_meta_pred/3 <1>:               Documentation on exports (expansion_tools).
* imports_meta_pred/3:                   Usage and interface (expansion_tools).
* in/1 <1>:                              Documentation on exports (linda).
* in/1 <2>:                              Usage and interface (linda).
* in/1 <3>:                              Documentation on new modes (basicmodes).
* in/1:                                  Usage and interface (basicmodes).
* in/2 <1>:                              Documentation on exports (linda).
* in/2 <2>:                              Usage and interface (linda).
* in/2 <3>:                              Documentation on new modes (basicmodes).
* in/2:                                  Usage and interface (basicmodes).
* in_noblock/1 <1>:                      Documentation on exports (linda).
* in_noblock/1:                          Usage and interface (linda).
* in_stream/2 <1>:                       Documentation on exports (linda).
* in_stream/2:                           Usage and interface (linda).
* inccounter/2 <1>:                      Documentation on exports (counters).
* inccounter/2:                          Usage and interface (counters).
* include/1 <1>:                         Documentation on internals (loading_code).
* include/1 <2>:                         Documentation on internals (modules).
* include/1 <3>:                         Documentation on exports (ciaosh).
* include/1:                             Usage and interface (ciaosh).
* indep/1 <1>:                           Known bugs and planned improvements (andprolog).
* indep/1 <2>:                           Documentation on exports (andprolog).
* indep/1 <3>:                           Usage and interface (andprolog).
* indep/1:                               Documentation on exports (native_props).
* indep/2 <1>:                           Known bugs and planned improvements (andprolog).
* indep/2 <2>:                           Documentation on exports (andprolog).
* indep/2 <3>:                           Usage and interface (andprolog).
* indep/2:                               Documentation on exports (native_props).
* independent:                           Documentation on exports (andprolog).
* Inference of properties:               Preprocessing programs.
* info <1>:                              Getting on-line help.
* info <2>:                              Using Ciao inside GNU emacs.
* info <3>:                              Un*x user setup.
* info:                                  Testing your Ciao Un*x installation.
* inform_user/1:                         Documentation on exports (io_aux).
* inherit_class/1 <1>:                   Documentation on new declarations (class).
* inherit_class/1:                       Usage and interface (class).
* inheritable interface:                 Documentation on new declarations (class).
* inheritable/1 <1>:                     Documentation on new declarations (class).
* inheritable/1:                         Usage and interface (class).
* inheritance relationship:              Documentation on new declarations (class).
* inherited/1 <1>:                       Documentation on exports (class).
* inherited/1:                           Usage and interface (class).
* init_persdb/0 <1>:                     Documentation on exports (persdbrt).
* init_persdb/0:                         Usage and interface (persdbrt).
* init_sql_persdb/0 <1>:                 Documentation on exports (persdbrtsql).
* init_sql_persdb/0:                     Usage and interface (persdbrtsql).
* initialization clauses:                Documentation on new declarations (class).
* initialization file <1>:               The Ciao initialization file (Win32).
* initialization file:                   The Ciao initialization file (Un*x).
* initialization/1:                      Documentation on internals (builtin_directives).
* initialize_db/0 <1>:                   Documentation on exports (persdbrt).
* initialize_db/0:                       Usage and interface (persdbrt).
* INRIA:                                 Acknowledgments.
* insert/3 <1>:                          Documentation on exports (sets).
* insert/3:                              Usage and interface (sets).
* insert_last/3 <1>:                     Documentation on exports (lists).
* insert_last/3:                         Usage and interface (lists).
* installation <1>:                      *** PART XII - Appendices.
* installation:                          PART XII - Appendices.
* installation, Windows clients:         Server installation under Windows.
* installation, Windows server:          Server installation under Windows.
* installation, Windows, from binaries:  Installing Ciao from a Win32 binary distribution.
* instance/2 <1>:                        Documentation on exports (metaterms).
* instance/2:                            Usage and interface (metaterms).
* instance_codes/2 <1>:                  Documentation on exports (objects_rt).
* instance_codes/2:                      Usage and interface (objects_rt).
* instance_id/1 <1>:                     Documentation on exports (objects_rt).
* instance_id/1:                         Usage and interface (objects_rt).
* instance_of/2 <1>:                     Documentation on exports (objects_rt).
* instance_of/2 <2>:                     Usage and interface (objects_rt).
* instance_of/2 <3>:                     Error reporting at compile time (objects).
* instance_of/2 <4>:                     Documentation on new declarations (objects).
* instance_of/2:                         Usage and interface (objects).
* instances:                             Run time usage of objects.
* instantiation mode <1>:                *** PART V - Annotated Prolog library (assertions).
* instantiation mode:                    PART V - Annotated Prolog library (assertions).
* instantiation properties:              Defining properties.
* instantiation state:                   Modes.
* int/1 <1>:                             Changing system behaviour and various flags.
* int/1 <2>:                             Documentation on exports (arithmetic).
* int/1 <3>:                             Documentation on exports (basic_props).
* int/1:                                 Usage and interface (basic_props).
* int_list/1 <1>:                        Documentation on exports (foreign_interface).
* int_list/1:                            Usage and interface (foreign_interface).
* integer/1 <1>:                         Documentation on exports (assertions_props).
* integer/1 <2>:                         Documentation on exports (arithmetic).
* integer/1 <3>:                         Documentation on exports (term_typing).
* integer/1:                             Usage and interface (term_typing).
* inter-process communication:           Active modules (high-level distributed execution).
* intercept/3 <1>:                       Documentation on exports (exceptions).
* intercept/3:                           Usage and interface (exceptions).
* interface file:                        Documentation on internals (syntax_extensions).
* interface inheritance:                 Documentation on new declarations (class).
* interface/2 <1>:                       Documentation on exports (objects_rt).
* interface/2:                           Usage and interface (objects_rt).
* interface_name/1 <1>:                  Documentation on exports (objects_rt).
* interface_name/1:                      Usage and interface (objects_rt).
* interface_source/1 <1>:                Documentation on exports (objects_rt).
* interface_source/1:                    Usage and interface (objects_rt).
* interfaces <1>:                        Usage and interface (class).
* interfaces:                            Declaring classes and interfaces.
* internal_module_id/1:                  Documentation on internals (system_info).
* interp_file/2 <1>:                     Documentation on exports (bltclass).
* interp_file/2:                         Usage and interface (bltclass).
* interpreted mode:                      Marking modules and files for debugging in the top-level debugger.
* interpreting:                          Loading and compiling programs.
* intersection/3 <1>:                    Documentation on exports (lists).
* intersection/3:                        Usage and interface (lists).
* intlist/1 <1>:                         Documentation on exports (numlists).
* intlist/1:                             Usage and interface (numlists).
* intset_delete/3 <1>:                   Documentation on exports (lists).
* intset_delete/3:                       Usage and interface (lists).
* intset_in/2 <1>:                       Documentation on exports (lists).
* intset_in/2:                           Usage and interface (lists).
* intset_insert/3 <1>:                   Documentation on exports (lists).
* intset_insert/3:                       Usage and interface (lists).
* intset_sequence/3 <1>:                 Documentation on exports (lists).
* intset_sequence/3:                     Usage and interface (lists).
* io_aux:                                Changing system behaviour and various flags.
* io_mode/1 <1>:                         Documentation on exports (streams_basic).
* io_mode/1:                             Usage and interface (streams_basic).
* is/2 <1>:                              Documentation on exports (pl2sql).
* is/2 <2>:                              Documentation on exports (arithmetic).
* is/2:                                  Usage and interface (arithmetic).
* is_det/1 <1>:                          Documentation on exports (native_props).
* is_det/1:                              Usage and interface (native_props).
* iso <1>:                               *** PART III - ISO-Prolog library (iso).
* iso <2>:                               Shell invocation and startup.
* iso:                                   PART III - ISO-Prolog library (iso).
* ISO-Prolog <1>:                        Documentation on exports (operators).
* ISO-Prolog <2>:                        Extending the syntax.
* ISO-Prolog <3>:                        Documentation on exports (io_basic).
* ISO-Prolog <4>:                        Basic input/output.
* ISO-Prolog <5>:                        Documentation on exports (arithmetic).
* ISO-Prolog <6>:                        Documentation on internals (loading_code).
* ISO-Prolog <7>:                        Documentation on internals (modules).
* ISO-Prolog <8>:                        Shell invocation and startup.
* ISO-Prolog <9>:                        Modes.
* ISO-Prolog <10>:                       About the name of the System.
* ISO-Prolog:                            ISO-Prolog compliance versus extensibility.
* ISO-Prolog builtins <1>:               *** PART III - ISO-Prolog library (iso).
* ISO-Prolog builtins <2>:               *** PART II - The Ciao basic language (engine).
* ISO-Prolog builtins <3>:               PART III - ISO-Prolog library (iso).
* ISO-Prolog builtins:                   PART II - The Ciao basic language (engine).
* iso-prolog, compliance:                ISO-Prolog compliance versus extensibility.
* iso/1 <1>:                             Documentation on exports (basic_props).
* iso/1:                                 Usage and interface (basic_props).
* iso_byte_char <1>:                     Usage and interface (objects_rt).
* iso_byte_char <2>:                     Usage and interface (functions).
* iso_byte_char <3>:                     Usage and interface (argnames).
* iso_byte_char <4>:                     Usage and interface (runtime_ops).
* iso_byte_char <5>:                     Usage and interface (dynmods).
* iso_byte_char:                         Usage and interface (iso).
* iso_incomplete <1>:                    Usage and interface (objects_rt).
* iso_incomplete <2>:                    Usage and interface (functions).
* iso_incomplete <3>:                    Usage and interface (argnames).
* iso_incomplete <4>:                    Usage and interface (runtime_ops).
* iso_incomplete <5>:                    Usage and interface (dynmods).
* iso_incomplete:                        Usage and interface (iso).
* iso_misc <1>:                          Usage and interface (pl2sql).
* iso_misc <2>:                          Usage and interface (objects_rt).
* iso_misc <3>:                          Usage and interface (functions).
* iso_misc <4>:                          Usage and interface (argnames).
* iso_misc <5>:                          Usage and interface (runtime_ops).
* iso_misc <6>:                          Usage and interface (dynmods).
* iso_misc:                              Usage and interface (iso).
* isomodes:                              Modes.
* issue_debug_messages/1 <1>:            Documentation on multifiles (messages).
* issue_debug_messages/1 <2>:            Documentation on exports (messages).
* issue_debug_messages/1:                Usage and interface (messages).
* iterative deepening-based execution <1>: *** PART VII - Ciao Prolog extensions.
* iterative deepening-based execution:   PART VII - Ciao Prolog extensions.
* iterative-deepening:                   Iterative-deepening execution.
* Jan Maluzynski:                        Acknowledgments.
* Java commands:                         Documentation on internals (jtopl).
* Java event handling from Prolog:       Java event handling from Prolog.
* Java exception handling from Prolog:   Java exception handling from Prolog.
* Java interface <1>:                    *** PART VIII - Interfaces to other languages and systems.
* Java interface:                        PART VIII - Interfaces to other languages and systems.
* java_add_listener/3 <1>:               Documentation on exports (javart).
* java_add_listener/3:                   Usage and interface (javart).
* java_connection/0 <1>:                 Documentation on exports (javart).
* java_connection/0:                     Usage and interface (javart).
* java_constructor/1 <1>:                Documentation on exports (javart).
* java_constructor/1:                    Usage and interface (javart).
* java_create_object/2 <1>:              Documentation on exports (javart).
* java_create_object/2:                  Usage and interface (javart).
* java_delete_object/1 <1>:              Documentation on exports (javart).
* java_delete_object/1:                  Usage and interface (javart).
* java_disconnection/0 <1>:              Documentation on exports (javart).
* java_disconnection/0:                  Usage and interface (javart).
* java_event/1 <1>:                      Documentation on exports (javart).
* java_event/1:                          Usage and interface (javart).
* java_fast_read/2 <1>:                  Documentation on exports (javasock).
* java_fast_read/2:                      Usage and interface (javasock).
* java_fast_write/2 <1>:                 Documentation on exports (javasock).
* java_fast_write/2:                     Usage and interface (javasock).
* java_field/1 <1>:                      Documentation on exports (javart).
* java_field/1:                          Usage and interface (javart).
* java_get_value/2 <1>:                  Documentation on exports (javart).
* java_get_value/2:                      Usage and interface (javart).
* java_invoke_method/2 <1>:              Documentation on exports (javart).
* java_invoke_method/2:                  Usage and interface (javart).
* java_method/1 <1>:                     Documentation on exports (javart).
* java_method/1:                         Usage and interface (javart).
* java_object/1 <1>:                     Documentation on exports (javart).
* java_object/1:                         Usage and interface (javart).
* java_remote_connection/1 <1>:          Documentation on exports (javart).
* java_remote_connection/1:              Usage and interface (javart).
* java_remove_listener/3 <1>:            Documentation on exports (javart).
* java_remove_listener/3:                Usage and interface (javart).
* java_set_value/2 <1>:                  Documentation on exports (javart).
* java_set_value/2:                      Usage and interface (javart).
* java_stream/3 <1>:                     Documentation on exports (javasock).
* java_stream/3:                         Usage and interface (javasock).
* javall/javasock <1>:                   Usage and interface (jtopl).
* javall/javasock:                       Usage and interface (javart).
* javart:                                Low-level Prolog to Java socket connection.
* Johan Andersson:                       Acknowledgments (ciao.el).
* Johan Bevemyr:                         Acknowledgments (ciao.el).
* Johan Widen:                           Acknowledgments.
* John Gallagher:                        Acknowledgments.
* jtopl:                                 Low-level Prolog to Java socket connection.
* K.U. Leuven:                           Acknowledgments.
* Kalyan Muthukumar:                     Acknowledgments.
* Kevin Greene:                          Acknowledgments.
* key sequences:                         Functionality and associated key sequences (bindings).
* keyboard:                              Characters and character strings.
* keypair/1:                             Documentation on internals (sort).
* keysort/2 <1>:                         Documentation on exports (sort).
* keysort/2:                             Usage and interface (sort).
* keyword/1:                             Documentation on internals (persdbrt).
* Kim Marriott:                          Acknowledgments.
* L. Byrd:                               Acknowledgments.
* L.M. Pereira:                          Acknowledgments.
* last/2 <1>:                            Documentation on exports (lists).
* last/2:                                Usage and interface (lists).
* leap:                                  Options available during debugging.
* leash/1 <1>:                           Documentation on exports (debugger).
* leash/1 <2>:                           Usage and interface (debugger).
* leash/1:                               Format of debugging messages.
* length/2 <1>:                          Documentation on exports (lists).
* length/2:                              Usage and interface (lists).
* letter_match/2 <1>:                    Documentation on exports (patterns).
* letter_match/2:                        Usage and interface (patterns).
* lgraph/2 <1>:                          Documentation on exports (lgraphs).
* lgraph/2:                              Usage and interface (lgraphs).
* lib library <1>:                       *** PART II - The Ciao basic language (engine).
* lib library:                           PART II - The Ciao basic language (engine).
* libpaths:                              Usage and interface (ciaosh).
* libraries used:                        Printing the declarations and code in a file.
* library('xrefs/mrefs'):                Crossed-references of a program.
* library('xrefs/pxrefs'):               Crossed-references of a program.
* library(iso_byte_char):                Basic input/output.
* library(modes):                        Documentation on exports (assertions_props).
* library(pure):                         The module system.
* library(xrefs):                        Crossed-references of a program.
* library/pillow/doc:                    The PiLLoW Web Programming Library.
* library_directory/1 <1>:               Documentation on multifiles (streams_basic).
* library_directory/1 <2>:               Usage and interface (streams_basic).
* library_directory/1 <3>:               Documentation on multifiles (libpaths).
* library_directory/1 <4>:               Documentation on exports (libpaths).
* library_directory/1 <5>:               Usage and interface (libpaths).
* library_directory/1:                   Paths used by the compiler during compilation.
* librowser:                             The Ciao library browser.
* limitations <1>:                       *** PART XII - Appendices.
* limitations:                           PART XII - Appendices.
* limitations, architecture-specific:    Architecture-specific notes and limitations.
* linda_client/1 <1>:                    Documentation on exports (linda).
* linda_client/1:                        Usage and interface (linda).
* linda_timeout/2 <1>:                   Documentation on exports (linda).
* linda_timeout/2:                       Usage and interface (linda).
* line/1:                                Documentation on internals (strings).
* line_count/2 <1>:                      Documentation on exports (streams_basic).
* line_count/2:                          Usage and interface (streams_basic).
* line_position/2 <1>:                   Documentation on exports (streams_basic).
* line_position/2:                       Usage and interface (streams_basic).
* linear/1 <1>:                          Documentation on exports (native_props).
* linear/1:                              Usage and interface (native_props).
* linker_and_opts/2 <1>:                 Documentation on exports (foreign_compilation).
* linker_and_opts/2:                     Usage and interface (foreign_compilation).
* Linkoping U.:                          Acknowledgments.
* list/1 <1>:                            Documentation on exports (basic_props).
* list/1:                                Usage and interface (basic_props).
* list/2 <1>:                            Documentation on exports (assertions_props).
* list/2 <2>:                            Documentation on exports (basic_props).
* list/2:                                Usage and interface (basic_props).
* list1/2 <1>:                           Documentation on exports (lists).
* list1/2:                               Usage and interface (lists).
* list_breakpt/0 <1>:                    Documentation on exports (debugger).
* list_breakpt/0:                        Usage and interface (debugger).
* list_concat/2 <1>:                     Documentation on exports (lists).
* list_concat/2:                         Usage and interface (lists).
* list_insert/2 <1>:                     Documentation on exports (idlists).
* list_insert/2 <2>:                     Usage and interface (idlists).
* list_insert/2 <3>:                     Documentation on exports (lists).
* list_insert/2:                         Usage and interface (lists).
* list_lookup/3 <1>:                     Documentation on exports (lists).
* list_lookup/3:                         Usage and interface (lists).
* list_lookup/4 <1>:                     Documentation on exports (lists).
* list_lookup/4:                         Usage and interface (lists).
* list_to_list_of_lists/2 <1>:           Documentation on exports (lists).
* list_to_list_of_lists/2:               Usage and interface (lists).
* lists <1>:                             Usage and interface (test_format).
* lists <2>:                             Usage and interface (table_widget4).
* lists <3>:                             Usage and interface (table_widget3).
* lists <4>:                             Usage and interface (table_widget2).
* lists <5>:                             Usage and interface (table_widget1).
* lists <6>:                             Usage and interface (genmultibar).
* lists <7>:                             Usage and interface (gengraph2).
* lists <8>:                             Usage and interface (gengraph1).
* lists <9>:                             Usage and interface (genbar4).
* lists <10>:                            Usage and interface (genbar3).
* lists <11>:                            Usage and interface (genbar2).
* lists <12>:                            Usage and interface (genbar1).
* lists <13>:                            Usage and interface (color_pattern).
* lists <14>:                            Usage and interface (patterns).
* lists <15>:                            Usage and interface (numlists).
* lists <16>:                            Usage and interface (metaterms).
* lists <17>:                            Usage and interface (emacs).
* lists <18>:                            Usage and interface (jtopl).
* lists <19>:                            Usage and interface (javart).
* lists <20>:                            Usage and interface (db_client).
* lists <21>:                            Usage and interface (pl2sql).
* lists <22>:                            Usage and interface (persdbrtsql).
* lists <23>:                            Usage and interface (persdbrt).
* lists <24>:                            Usage and interface (http).
* lists <25>:                            Usage and interface (html).
* lists <26>:                            Usage and interface (tcltk).
* lists <27>:                            Usage and interface (librowser).
* lists <28>:                            Usage and interface (messages).
* lists <29>:                            Usage and interface (filenames).
* lists <30>:                            Usage and interface (native_props).
* lists <31>:                            Documentation on new declarations (assertions).
* lists <32>:                            Usage and interface (classic).
* lists <33>:                            Usage and interface (read).
* lists <34>:                            Usage and interface (aggregates).
* lists:                                 Usage and interface (libpaths).
* load_compilation_module/1:             Documentation on internals (syntax_extensions).
* loading mode:                          Marking modules and files for debugging in the top-level debugger.
* loading programs <1>:                  Loading and compiling programs.
* loading programs <2>:                  Compiling and running programs (Win32).
* loading programs:                      Compiling and running programs (Un*x).
* locating errors:                       Locating errors and checking the syntax of assertions.
* lock_atom/1 <1>:                       Documentation on exports (concurrency).
* lock_atom/1:                           Usage and interface (concurrency).
* log of changes:                        Version control.
* log/1:                                 Documentation on exports (arithmetic).
* LogIn:                                 Entering recursive (conjunctive) shell levels.
* Low level Java to Prolog interface:    Low-level Java to Prolog interface.
* Low-Level Prolog to Java Interface Structure: Low-Level Prolog to Java Interface Structure.
* Low-Level Prolog to Java Interface Structure. Java side: Java side.
* Low-Level Prolog to Java Interface Structure. Prolog side: Prolog side.
* lpdoc <1>:                             Documentation on exports (assertions_props).
* lpdoc <2>:                             Documentation on new declarations (assertions).
* lpdoc <3>:                             The Ciao assertion package.
* lpdoc <4>:                             Customization.
* lpdoc <5>:                             Using Ciao/Prolog mode capabilities in standard shells.
* lpdoc <6>:                             Version control.
* lpdoc <7>:                             Preprocessing programs.
* lpdoc <8>:                             Using Ciao inside GNU emacs.
* lpdoc <9>:                             *** PART I - The program development environment.
* lpdoc <10>:                            PART I - The program development environment.
* lpdoc:                                 About this manual.
* LPdoc:                                 About this manual.
* lpdoc <1>:                             Summary.
* lpdoc:                                 (outside of any node).
* lpdoc command args, setting:           Setting the top-level.
* lpdoc command, setting:                Setting the top-level.
* lpdoc default format, setting:         Generating program documentation.
* lpdoc lib path, setting:               Setting the top-level.
* lpdoc working dir, setting:            Generating program documentation.
* lpmake:                                The Ciao lpmake scripting facility.
* machine_name/1 <1>:                    Documentation on exports (javart).
* machine_name/1:                        Usage and interface (javart).
* mailing list <1>:                      Keeping up to date with the Ciao users mailing list.
* mailing list <2>:                      *** PART XII - Appendices.
* mailing list:                          PART XII - Appendices.
* main module:                           Loading and compiling programs.
* main/0 <1>:                            Loading and compiling programs.
* main/0 <2>:                            Introduction to building executables.
* main/0 <3>:                            Running Ciao scripts (Win32).
* main/0 <4>:                            Generating executables (Win32).
* main/0 <5>:                            Running Ciao scripts (Un*x).
* main/0:                                Generating executables (Un*x).
* main/1 <1>:                            Changing system behaviour and various flags.
* main/1 <2>:                            Loading and compiling programs.
* main/1 <3>:                            How it works.
* main/1 <4>:                            Introduction to building executables.
* main/1 <5>:                            An introduction to the Ciao emacs environment (Win32).
* main/1 <6>:                            Running Ciao scripts (Win32).
* main/1 <7>:                            Generating executables (Win32).
* main/1 <8>:                            An introduction to the Ciao emacs environment (Un*x).
* main/1 <9>:                            Running Ciao scripts (Un*x).
* main/1:                                Generating executables (Un*x).
* major version number:                  Version control.
* make:                                  The Ciao lpmake scripting facility.
* make_actmod/2 <1>:                     Active modules (high-level distributed execution).
* make_actmod/2 <2>:                     Documentation on exports (ciaosh).
* make_actmod/2:                         Usage and interface (ciaosh).
* make_exec/2 <1>:                       Documentation on exports (ciaosh).
* make_exec/2 <2>:                       Usage and interface (ciaosh).
* make_exec/2 <3>:                       Generating executables (Win32).
* make_exec/2:                           Generating executables (Un*x).
* make_persistent/2 <1>:                 Documentation on exports (persdbrt).
* make_persistent/2 <2>:                 Usage and interface (persdbrt).
* make_persistent/2:                     Using file-based persistent predicates.
* make_po/1 <1>:                         Documentation on exports (ciaosh).
* make_po/1:                             Usage and interface (ciaosh).
* make_sql_persistent/3 <1>:             Documentation on exports (persdbrtsql).
* make_sql_persistent/3:                 Usage and interface (persdbrtsql).
* Makefile:                              The stand-alone command-line compiler.
* Makefile.pl:                           The Ciao lpmake scripting facility.
* manual, printing <1>:                  Checking for correct installation on Win32.
* manual, printing <2>:                  Printing manuals (Win32).
* manual, printing <3>:                  Testing your Ciao Win32 installation.
* manual, printing:                      Printing manuals (Un*x).
* manual, tour:                          A tour of the manual.
* manuals, printing <1>:                 Printing manuals (Win32).
* manuals, printing:                     Printing manuals (Un*x).
* Manuel Carro:                          Acknowledgments.
* Manuel Hermenegildo:                   Acknowledgments.
* map/3 <1>:                             Documentation on exports (hiord).
* map/3:                                 Usage and interface (hiord).
* Maria Jose Garcia de la Banda:         Acknowledgments.
* marshalling <1>:                       *** PART VI - Ciao Prolog library miscellanea.
* marshalling:                           PART VI - Ciao Prolog library miscellanea.
* Masanobu Umeda:                        Acknowledgments (ciao.el).
* match_pattern/2 <1>:                   Documentation on exports (patterns).
* match_pattern/2:                       Usage and interface (patterns).
* match_pattern/3 <1>:                   Documentation on exports (patterns).
* match_pattern/3:                       Usage and interface (patterns).
* match_pattern_pred/2 <1>:              Documentation on exports (patterns).
* match_pattern_pred/2:                  Usage and interface (patterns).
* match_string/3 <1>:                    Documentation on exports (db_client).
* match_string/3:                        Usage and interface (db_client).
* Mats Carlsson <1>:                     Acknowledgments (ciao.el).
* Mats Carlsson:                         Acknowledgments.
* Maurice Bruynooghe:                    Acknowledgments.
* max/3:                                 Delaying predicates (when).
* maxdepth/1 <1>:                        Documentation on exports (debugger).
* maxdepth/1:                            Usage and interface (debugger).
* MCC:                                   Acknowledgments.
* Melbourne U.:                          Acknowledgments.
* member/2 <1>:                          Documentation on exports (basic_props).
* member/2:                              Usage and interface (basic_props).
* member_0/2 <1>:                        Documentation on exports (idlists).
* member_0/2:                            Usage and interface (idlists).
* memberchk/2 <1>:                       Documentation on exports (idlists).
* memberchk/2:                           Usage and interface (idlists).
* memory management <1>:                 Documentation on internals (prolog_sys).
* memory management:                     Documentation on exports (prolog_sys).
* memory_option/1:                       Documentation on internals (prolog_sys).
* memory_result/1:                       Documentation on internals (prolog_sys).
* merge/3 <1>:                           Documentation on exports (sets).
* merge/3:                               Usage and interface (sets).
* message/1:                             Documentation on exports (io_aux).
* message/2 <1>:                         Known bugs and planned improvements (io_aux).
* message/2 <2>:                         Documentation on exports (io_aux).
* message/2:                             Usage and interface (io_aux).
* message_lns/4 <1>:                     Documentation on exports (io_aux).
* message_lns/4:                         Usage and interface (io_aux).
* messages <1>:                          Usage and interface (db_client).
* messages <2>:                          Usage and interface (pl2sql).
* messages <3>:                          Usage and interface (persdbrtsql).
* messages:                              Usage and interface (assrt_write).
* meta_predicate/1 <1>:                  Usage and interface (class).
* meta_predicate/1:                      Documentation on internals (modules).
* metaspec/1:                            Documentation on internals (modules).
* metaterms <1>:                         Usage and interface (vndict).
* metaterms <2>:                         Usage and interface (emacs).
* metaterms <3>:                         Usage and interface (persdbrtsql).
* metaterms <4>:                         Usage and interface (when).
* metaterms:                             Usage and interface (native_props).
* method_spec/1 <1>:                     Documentation on exports (objects_rt).
* method_spec/1:                         Usage and interface (objects_rt).
* minor version number:                  Version control.
* mktemp/2 <1>:                          Documentation on exports (system).
* mktemp/2:                              Usage and interface (system).
* mod/2:                                 Documentation on exports (arithmetic).
* mode <1>:                              Documentation on exports (assertions_props).
* mode:                                  Documentation on new declarations (assertions).
* mode spec:                             Modes.
* modedef/1 <1>:                         Documentation on exports (assertions_props).
* modedef/1 <2>:                         Documentation on new declarations (assertions).
* modedef/1 <3>:                         Usage and interface (assertions).
* modedef/1:                             Modes.
* modes <1>:                             Classical Prolog modes.
* modes <2>:                             ISO-Prolog modes.
* modes:                                 Preprocessing programs.
* modif_time/2 <1>:                      Documentation on exports (system).
* modif_time/2:                          Usage and interface (system).
* modif_time0/2 <1>:                     Documentation on exports (system).
* modif_time0/2:                         Usage and interface (system).
* modular interface:                     Intermediate files in the compilation process.
* module qualification:                  The module system.
* module/2 <1>:                          ISO-Prolog package.
* module/2:                              Documentation on internals (modules).
* module/3 <1>:                          Usage and interface (class).
* module/3 <2>:                          Documentation on internals (loading_code).
* module/3 <3>:                          Documentation on internals (modules).
* module/3:                              Marking modules and files for debugging with the embedded debugger.
* modulename/1:                          Documentation on internals (modules).
* modules, active:                       Types of executables generated.
* Monash U.:                             Acknowledgments.
* month/1 <1>:                           Documentation on exports (pillow_types).
* month/1:                               Usage and interface (pillow_types).
* moving changelog entries:              Version control.
* mshare/1 <1>:                          Documentation on exports (native_props).
* mshare/1:                              Usage and interface (native_props).
* multi-evaluated:                       Documentation on new declarations (class).
* multibar_attribute/1:                  Documentation on internals (genmultibar).
* multibarchart/10 <1>:                  Documentation on exports (genmultibar).
* multibarchart/10 <2>:                  Usage and interface (genmultibar).
* multibarchart/10:                      Documentation on exports (chartlib).
* multibarchart/8 <1>:                   Documentation on exports (genmultibar).
* multibarchart/8 <2>:                   Usage and interface (genmultibar).
* multibarchart/8:                       Documentation on exports (chartlib).
* multifile predicate:                   Documentation on internals (builtin_directives).
* multifile/1 <1>:                       Usage and interface (class).
* multifile/1 <2>:                       Documentation on internals (builtin_directives).
* multifile/1 <3>:                       The module system.
* multifile/1 <4>:                       Documentation on exports (ciaosh).
* multifile/1:                           Usage and interface (ciaosh).
* multpredspec/1:                        Documentation on internals (debugger).
* mut_exclusive/1 <1>:                   Documentation on exports (native_props).
* mut_exclusive/1:                       Usage and interface (native_props).
* my_url/1 <1>:                          Documentation on exports (html).
* my_url/1:                              Usage and interface (html).
* n_assrt_body/5:                        Documentation on exports (assertions_props).
* nabody/1 <1>:                          Documentation on exports (assertions_props).
* nabody/1:                              Usage and interface (assertions_props).
* Name:                                  Documentation on exports (foreign_interface).
* name server:                           Active modules (high-level distributed execution).
* name/2 <1>:                            Documentation on exports (html).
* name/2 <2>:                            Documentation on exports (atomic_basic).
* name/2:                                Usage and interface (atomic_basic).
* native/1 <1>:                          Documentation on exports (foreign_interface).
* native/1:                              Usage and interface (foreign_interface).
* native/2 <1>:                          Documentation on exports (foreign_interface).
* native/2:                              Usage and interface (foreign_interface).
* negated comparison goal:               Documentation on internals (pl2sql).
* negated database goal:                 Documentation on internals (pl2sql).
* negated goals:                         Documentation on internals (pl2sql).
* negated_comparison/2:                  Documentation on internals (pl2sql).
* negations:                             Documentation on exports (pl2sql).
* neighbors/3 <1>:                       Documentation on exports (ugraphs).
* neighbors/3:                           Usage and interface (ugraphs).
* netscape:                              Testing your Ciao Un*x installation.
* New Mexico State University:           Acknowledgments.
* new/2 <1>:                             Documentation on exports (objects_rt).
* new/2 <2>:                             Usage and interface (objects_rt).
* new/2 <3>:                             Error reporting at compile time (objects).
* new/2 <4>:                             Documentation on new declarations (objects).
* new/2 <5>:                             Usage and interface (objects).
* new/2:                                 Documentation on exports (class).
* new_atom/1 <1>:                        Documentation on exports (prolog_sys).
* new_atom/1:                            Usage and interface (prolog_sys).
* new_declaration/1 <1>:                 Documentation on internals (syntax_extensions).
* new_declaration/1:                     Basic builtin directives.
* new_declaration/2 <1>:                 Documentation on internals (syntax_extensions).
* new_declaration/2:                     Basic builtin directives.
* new_interp/1 <1>:                      Documentation on exports (bltclass).
* new_interp/1:                          Usage and interface (bltclass).
* nl/0 <1>:                              Documentation on exports (io_basic).
* nl/0:                                  Usage and interface (io_basic).
* nl/1 <1>:                              Documentation on exports (io_basic).
* nl/1:                                  Usage and interface (io_basic).
* nnegint/1 <1>:                         Documentation on exports (basic_props).
* nnegint/1:                             Usage and interface (basic_props).
* no_path_file_name/2 <1>:               Documentation on exports (filenames).
* no_path_file_name/2:                   Usage and interface (filenames).
* nobreakall/0 <1>:                      Documentation on exports (debugger).
* nobreakall/0:                          Usage and interface (debugger).
* nobreakpt/6 <1>:                       Documentation on exports (debugger).
* nobreakpt/6 <2>:                       Usage and interface (debugger).
* nobreakpt/6 <3>:                       Marking modules and files for debugging with the embedded debugger.
* nobreakpt/6:                           The debugging process.
* nocontainsx/2 <1>:                     Documentation on exports (lists).
* nocontainsx/2:                         Usage and interface (lists).
* nodebug <1>:                           Options available during debugging.
* nodebug:                               The debugging process.
* nodebug/0 <1>:                         Documentation on exports (debugger).
* nodebug/0:                             Usage and interface (debugger).
* nodebug_module/1 <1>:                  Documentation on exports (debugger).
* nodebug_module/1 <2>:                  Usage and interface (debugger).
* nodebug_module/1:                      Marking modules and files for debugging in the top-level debugger.
* nofileerrors/0 <1>:                    Documentation on exports (prolog_flags).
* nofileerrors/0:                        Usage and interface (prolog_flags).
* nogc/0 <1>:                            Documentation on exports (prolog_flags).
* nogc/0:                                Usage and interface (prolog_flags).
* non-failure:                           Preprocessing programs.
* nonsingle/1 <1>:                       Documentation on exports (lists).
* nonsingle/1:                           Usage and interface (lists).
* nonvar/1 <1>:                          Documentation on exports (term_typing).
* nonvar/1:                              Usage and interface (term_typing).
* nospy:                                 Options available during debugging.
* nospy/1 <1>:                           Documentation on exports (debugger).
* nospy/1 <2>:                           Usage and interface (debugger).
* nospy/1 <3>:                           Acknowledgements.
* nospy/1 <4>:                           Marking modules and files for debugging with the embedded debugger.
* nospy/1:                               The debugging process.
* nospyall/0 <1>:                        Documentation on exports (debugger).
* nospyall/0:                            Usage and interface (debugger).
* NOT EXISTS-subqueries:                 Documentation on internals (pl2sql).
* not_covered/1 <1>:                     Documentation on exports (native_props).
* not_covered/1:                         Usage and interface (native_props).
* not_empty/3 <1>:                       Documentation on exports (test_format).
* not_empty/3:                           Usage and interface (test_format).
* not_empty/4 <1>:                       Documentation on exports (test_format).
* not_empty/4:                           Usage and interface (test_format).
* not_fails/1 <1>:                       Documentation on exports (native_props).
* not_fails/1:                           Usage and interface (native_props).
* not_further_inst/1:                    Documentation on exports (assertions_props).
* not_further_inst/2 <1>:                Documentation on exports (basic_props).
* not_further_inst/2:                    Usage and interface (basic_props).
* not_mut_exclusive/1 <1>:               Documentation on exports (native_props).
* not_mut_exclusive/1:                   Usage and interface (native_props).
* notation:                              Syntax terminology and notational conventions.
* note/1:                                Documentation on exports (io_aux).
* note_message/1 <1>:                    Documentation on exports (messages).
* note_message/1:                        Usage and interface (messages).
* note_message/2 <1>:                    Documentation on exports (messages).
* note_message/2:                        Usage and interface (messages).
* note_message/3 <1>:                    Documentation on exports (messages).
* note_message/3:                        Usage and interface (messages).
* notrace/0 <1>:                         Documentation on exports (debugger).
* notrace/0:                             Usage and interface (debugger).
* ntemacs:                               Win32 binary installation summary.
* nth/3 <1>:                             Documentation on exports (lists).
* nth/3:                                 Usage and interface (lists).
* null_dict/1 <1>:                       Documentation on exports (vndict).
* null_dict/1:                           Usage and interface (vndict).
* num/1 <1>:                             Documentation on exports (basic_props).
* num/1:                                 Usage and interface (basic_props).
* number/1 <1>:                          Documentation on exports (term_typing).
* number/1:                              Usage and interface (term_typing).
* number_chars/2 <1>:                    Documentation on exports (iso_byte_char).
* number_chars/2:                        Usage and interface (iso_byte_char).
* number_codes/2 <1>:                    Documentation on exports (atomic_basic).
* number_codes/2:                        Usage and interface (atomic_basic).
* number_codes/3 <1>:                    Documentation on exports (atomic_basic).
* number_codes/3:                        Usage and interface (atomic_basic).
* numbervars/3 <1>:                      Documentation on exports (write).
* numbervars/3:                          Usage and interface (write).
* numlist/1 <1>:                         Documentation on exports (numlists).
* numlist/1:                             Usage and interface (numlists).
* object:                                Run time usage of objects.
* object oriented programming <1>:       *** PART VII - Ciao Prolog extensions.
* object oriented programming:           PART VII - Ciao Prolog extensions.
* objects/objects_rt <1>:                Usage and interface (objects).
* objects/objects_rt:                    Usage and interface (class).
* ODBC:                                  Low-level socket interface to SQL/ODBC databases.
* odbc_connect/2 <1>:                    Documentation on exports (db_client).
* odbc_connect/2:                        Usage and interface (db_client).
* odbc_disconnect/1 <1>:                 Documentation on exports (db_client).
* odbc_disconnect/1 <2>:                 Usage and interface (db_client).
* odbc_disconnect/1:                     Documentation on internals (persdbrtsql).
* old_database:                          Usage and interface (classic).
* on-line help:                          Using Ciao inside GNU emacs.
* on_abort/1:                            Documentation on internals (builtin_directives).
* once/1 <1>:                            Documentation on exports (iso_misc).
* once/1:                                Usage and interface (iso_misc).
* op/3 <1>:                              Documentation on exports (operators).
* op/3 <2>:                              Usage and interface (operators).
* op/3:                                  Documentation on internals (syntax_extensions).
* open/3 <1>:                            Documentation on exports (streams_basic).
* open/3:                                Usage and interface (streams_basic).
* open/4 <1>:                            Documentation on exports (iso_incomplete).
* open/4:                                Usage and interface (iso_incomplete).
* open_client/2 <1>:                     Documentation on exports (linda).
* open_client/2:                         Usage and interface (linda).
* open_input/2 <1>:                      Documentation on exports (streams).
* open_input/2:                          Usage and interface (streams).
* open_null_stream/1 <1>:                Documentation on exports (streams).
* open_null_stream/1:                    Usage and interface (streams).
* open_output/2 <1>:                     Documentation on exports (streams).
* open_output/2:                         Usage and interface (streams).
* open_predicate/1 <1>:                  Documentation on exports (data_facts).
* open_predicate/1:                      Usage and interface (data_facts).
* operations file:                       Implementation Issues.
* operator table:                        Documentation on internals (syntax_extensions).
* operator_specifier/1 <1>:              Documentation on exports (basic_props).
* operator_specifier/1:                  Usage and interface (basic_props).
* operators <1>:                         Usage and interface (objects_rt).
* operators <2>:                         Usage and interface (functions).
* operators <3>:                         Usage and interface (argnames).
* operators <4>:                         Usage and interface (runtime_ops).
* operators <5>:                         Usage and interface (dynmods).
* operators <6>:                         Usage and interface (classic).
* operators <7>:                         Usage and interface (write).
* operators <8>:                         Usage and interface (read).
* operators:                             Usage and interface (iso).
* optional_message/2 <1>:                Documentation on exports (messages).
* optional_message/2:                    Usage and interface (messages).
* optional_message/3 <1>:                Documentation on exports (messages).
* optional_message/3:                    Usage and interface (messages).
* ord_delete/3 <1>:                      Documentation on exports (sets).
* ord_delete/3:                          Usage and interface (sets).
* ord_disjoint/2 <1>:                    Documentation on exports (sets).
* ord_disjoint/2:                        Usage and interface (sets).
* ord_intersect/2 <1>:                   Documentation on exports (sets).
* ord_intersect/2:                       Usage and interface (sets).
* ord_intersection/3 <1>:                Documentation on exports (sets).
* ord_intersection/3:                    Usage and interface (sets).
* ord_intersection_diff/4 <1>:           Documentation on exports (sets).
* ord_intersection_diff/4:               Usage and interface (sets).
* ord_member/2 <1>:                      Documentation on exports (sets).
* ord_member/2:                          Usage and interface (sets).
* ord_subset/2 <1>:                      Documentation on exports (sets).
* ord_subset/2:                          Usage and interface (sets).
* ord_subset_diff/3 <1>:                 Documentation on exports (sets).
* ord_subset_diff/3:                     Usage and interface (sets).
* ord_subtract/3 <1>:                    Documentation on exports (sets).
* ord_subtract/3:                        Usage and interface (sets).
* ord_test_member/3 <1>:                 Documentation on exports (sets).
* ord_test_member/3:                     Usage and interface (sets).
* ord_union/3 <1>:                       Documentation on exports (sets).
* ord_union/3:                           Usage and interface (sets).
* ord_union_change/3 <1>:                Documentation on exports (sets).
* ord_union_change/3:                    Usage and interface (sets).
* ord_union_diff/4 <1>:                  Documentation on exports (sets).
* ord_union_diff/4:                      Usage and interface (sets).
* ord_union_symdiff/4 <1>:               Documentation on exports (sets).
* ord_union_symdiff/4:                   Usage and interface (sets).
* out/1 <1>:                             Documentation on exports (linda).
* out/1 <2>:                             Usage and interface (linda).
* out/1 <3>:                             Documentation on new modes (basicmodes).
* out/1:                                 Usage and interface (basicmodes).
* out/2 <1>:                             Documentation on new modes (basicmodes).
* out/2:                                 Usage and interface (basicmodes).
* out_stream/2 <1>:                      Documentation on exports (linda).
* out_stream/2:                          Usage and interface (linda).
* output_html/1 <1>:                     Documentation on multifiles (html).
* output_html/1 <2>:                     Documentation on exports (html).
* output_html/1:                         Usage and interface (html).
* overriden:                             Documentation on new declarations (class).
* P. Lincoln:                            Entering recursive (conjunctive) shell levels.
* package file <1>:                      Documentation on internals (syntax_extensions).
* package file <2>:                      Documentation on internals (loading_code).
* package file:                          Documentation on internals (modules).
* pair/1:                                Documentation on internals (graphs).
* parallel programming <1>:              *** PART VII - Ciao Prolog extensions.
* parallel programming:                  PART VII - Ciao Prolog extensions.
* parallel Prolog:                       Acknowledgments.
* parallelizing compiler:                Acknowledgments.
* parametric property:                   Documentation on internals (meta_props).
* parametric regular type abstractions:  Documentation on internals (meta_props).
* PARFORCE:                              Acknowledgments.
* parse_term/3 <1>:                      Documentation on exports (atom2term).
* parse_term/3:                          Usage and interface (atom2term).
* passertz_fact/1 <1>:                   Documentation on exports (persdbrt).
* passertz_fact/1:                       Usage and interface (persdbrt).
* passwd/1 <1>:                          Documentation on exports (db_client).
* passwd/1 <2>:                          Usage and interface (db_client).
* passwd/1:                              Documentation on exports (persdbrtsql).
* patch number:                          Version control.
* path alias <1>:                        Operating system utilities.
* path alias <2>:                        Documentation on multifiles (streams_basic).
* path alias <3>:                        Documentation on exports (streams_basic).
* path alias <4>:                        Documentation on internals (modules).
* path alias <5>:                        Documentation on exports (libpaths).
* path alias <6>:                        Customizing library paths and path aliases.
* path alias:                            Documentation on exports (ciaosh).
* path aliases:                          Types of executables generated.
* pattern/1 <1>:                         Documentation on exports (color_pattern).
* pattern/1 <2>:                         Usage and interface (color_pattern).
* pattern/1 <3>:                         Documentation on exports (patterns).
* pattern/1:                             Usage and interface (patterns).
* pattern/2 <1>:                         Documentation on exports (color_pattern).
* pattern/2:                             Usage and interface (color_pattern).
* patterns <1>:                          Pattern (regular expression) matching.
* patterns <2>:                          Documentation on exports (librowser).
* patterns:                              Usage and interface (librowser).
* pause/1 <1>:                           Documentation on exports (system).
* pause/1:                               Usage and interface (system).
* Pawel Pietrzak:                        Acknowledgments.
* pcurrent_fact/1 <1>:                   Documentation on exports (persdbrt).
* pcurrent_fact/1:                       Usage and interface (persdbrt).
* Pedro Lopez:                           Acknowledgments.
* peek_byte/1 <1>:                       Documentation on exports (iso_byte_char).
* peek_byte/1:                           Usage and interface (iso_byte_char).
* peek_byte/2 <1>:                       Documentation on exports (iso_byte_char).
* peek_byte/2:                           Usage and interface (iso_byte_char).
* peek_char/1 <1>:                       Documentation on exports (iso_byte_char).
* peek_char/1:                           Usage and interface (iso_byte_char).
* peek_char/2 <1>:                       Documentation on exports (iso_byte_char).
* peek_char/2:                           Usage and interface (iso_byte_char).
* peek_code/1 <1>:                       Documentation on exports (io_basic).
* peek_code/1:                           Usage and interface (io_basic).
* peek_code/2 <1>:                       Documentation on exports (io_basic).
* peek_code/2:                           Usage and interface (io_basic).
* percentbarchart1/7 <1>:                Documentation on exports (genbar1).
* percentbarchart1/7 <2>:                Usage and interface (genbar1).
* percentbarchart1/7:                    Documentation on exports (chartlib).
* percentbarchart2/7 <1>:                Documentation on exports (genbar2).
* percentbarchart2/7 <2>:                Usage and interface (genbar2).
* percentbarchart2/7:                    Documentation on exports (chartlib).
* percentbarchart3/7 <1>:                Documentation on exports (genbar3).
* percentbarchart3/7 <2>:                Usage and interface (genbar3).
* percentbarchart3/7:                    Documentation on exports (chartlib).
* percentbarchart4/7 <1>:                Documentation on exports (genbar4).
* percentbarchart4/7 <2>:                Usage and interface (genbar4).
* percentbarchart4/7:                    Documentation on exports (chartlib).
* perl:                                  Installation of the Ciao/Prolog emacs interface.
* persdb <1>:                            Prolog to SQL translator.
* persdb <2>:                            SQL persistent database interface.
* persdb:                                Persistent predicates.
* persdb_sql:                            Persistent predicates.
* persdb_sql/db_client:                  Usage and interface (persdbrtsql).
* persdb_sql/insert_compiler/pl2sqlinsert: Usage and interface (persdbrtsql).
* persdb_sql/pl2sql:                     Usage and interface (persdbrtsql).
* persdb_sql/sqltypes <1>:               Usage and interface (pl2sql).
* persdb_sql/sqltypes:                   Usage and interface (persdbrtsql).
* persdb_sql/string2term:                Usage and interface (db_client).
* persistence set:                       Implementation Issues.
* persistent:                            Documentation on exports (persdbrt).
* persistent predicate:                  Introduction to persistent predicates.
* Persistent predicate <1>:              *** PART VIII - Interfaces to other languages and systems.
* Persistent predicate:                  PART VIII - Interfaces to other languages and systems.
* persistent predicates <1>:             Prolog to SQL translator.
* persistent predicates:                 SQL persistent database interface.
* persistent/2 <1>:                      Using file-based persistent predicates.
* persistent/2:                          Persistent predicates.
* persistent_dir/2 <1>:                  Documentation on internals (persdbrt).
* persistent_dir/2 <2>:                  Documentation on multifiles (persdbrt).
* persistent_dir/2 <3>:                  Usage and interface (persdbrt).
* persistent_dir/2:                      Using file-based persistent predicates.
* Peter Olin:                            Acknowledgments (ciao.el).
* Peter Stuckey:                         Acknowledgments.
* phrase/2 <1>:                          Documentation on exports (dcg_expansion).
* phrase/2:                              Usage and interface (dcg_expansion).
* phrase/3 <1>:                          Documentation on exports (dcg_expansion).
* phrase/3:                              Usage and interface (dcg_expansion).
* Pierre Deransart:                      Acknowledgments.
* pillow:                                Persistent predicates.
* PiLLoW on-line tutorial:               The PiLLoW Web Programming Library.
* pillow.pl <1>:                         Installing Ciao from the source distribution.
* pillow.pl:                             Installing PiLLoW.
* pillow/html:                           Usage and interface (pillow).
* pillow/http:                           Usage and interface (pillow).
* pillow/http_ll:                        Usage and interface (http).
* pillow/pillow_aux <1>:                 Usage and interface (http).
* pillow/pillow_aux:                     Usage and interface (html).
* pillow/pillow_types <1>:               Usage and interface (http).
* pillow/pillow_types:                   Usage and interface (html).
* pkunzip:                               Win32 binary installation summary.
* pl2sql <1>:                            Documentation on exports (pl2sql).
* pl2sql:                                SQL persistent database interface.
* pl2sqlstring/3 <1>:                    Documentation on exports (pl2sql).
* pl2sqlstring/3 <2>:                    Usage and interface (pl2sql).
* pl2sqlstring/3 <3>:                    Prolog to SQL translator.
* pl2sqlstring/3:                        Documentation on internals (persdbrtsql).
* pl2sqlterm/3 <1>:                      Documentation on exports (pl2sql).
* pl2sqlterm/3 <2>:                      Usage and interface (pl2sql).
* pl2sqlterm/3:                          Prolog to SQL translator.
* platform-dependent:                    Types of executables generated.
* platform-independent:                  Types of executables generated.
* point_to/3 <1>:                        Documentation on exports (ugraphs).
* point_to/3:                            Usage and interface (ugraphs).
* Polymorphism:                          Object oriented programming.
* pop_global/2 <1>:                      Documentation on exports (global).
* pop_global/2:                          Usage and interface (global).
* pop_prolog_flag/1 <1>:                 Documentation on exports (prolog_flags).
* pop_prolog_flag/1:                     Usage and interface (prolog_flags).
* popen/3 <1>:                           Documentation on exports (system).
* popen/3:                               Usage and interface (system).
* popen_mode/1 <1>:                      Documentation on exports (system).
* popen_mode/1:                          Usage and interface (system).
* portray/1 <1>:                         Documentation on multifiles (write).
* portray/1 <2>:                         Documentation on exports (write).
* portray/1:                             Usage and interface (write).
* portray_attribute/1:                   Documentation on exports (write).
* portray_attribute/2 <1>:               Documentation on multifiles (write).
* portray_attribute/2 <2>:               Usage and interface (write).
* portray_attribute/2:                   Usage and interface (attributes).
* portray_clause/1 <1>:                  Documentation on exports (write).
* portray_clause/1:                      Usage and interface (write).
* portray_clause/2 <1>:                  Documentation on exports (write).
* portray_clause/2:                      Usage and interface (write).
* positive database goal:                Documentation on internals (pl2sql).
* possibly_fails/1 <1>:                  Documentation on exports (native_props).
* possibly_fails/1:                      Usage and interface (native_props).
* possibly_nondet/1 <1>:                 Documentation on exports (native_props).
* possibly_nondet/1:                     Usage and interface (native_props).
* powerset/2 <1>:                        Documentation on exports (lists).
* powerset/2:                            Usage and interface (lists).
* pred assertion:                        Documentation on new declarations (assertions).
* pred/1 <1>:                            Documentation on exports (assertions_props).
* pred/1 <2>:                            Documentation on new declarations (assertions).
* pred/1:                                Usage and interface (assertions).
* pred/2 <1>:                            Documentation on new declarations (assertions).
* pred/2:                                Usage and interface (assertions).
* predfunctor/1 <1>:                     Documentation on exports (assertions_props).
* predfunctor/1:                         Usage and interface (assertions_props).
* predicate declarations:                Printing the declarations and code in a file.
* predicate_property/2 <1>:              Documentation on exports (prolog_sys).
* predicate_property/2:                  Usage and interface (prolog_sys).
* predname/1 <1>:                        Documentation on exports (assertions_props).
* predname/1 <2>:                        Documentation on exports (basic_props).
* predname/1:                            Usage and interface (basic_props).
* preprocessing programs:                Preprocessing programs.
* preprocessor <1>:                      *** PART I - The program development environment.
* preprocessor:                          PART I - The program development environment.
* preprocessor command args, setting:    Setting the top-level.
* preprocessor command, setting:         Setting the top-level.
* pretract_fact/1 <1>:                   Documentation on exports (persdbrt).
* pretract_fact/1:                       Usage and interface (persdbrt).
* pretty_print/2 <1>:                    Documentation on exports (pretty_print).
* pretty_print/2:                        Usage and interface (pretty_print).
* pretty_print/3 <1>:                    Documentation on exports (pretty_print).
* pretty_print/3:                        Usage and interface (pretty_print).
* prettyvars/1 <1>:                      Documentation on exports (write).
* prettyvars/1:                          Usage and interface (write).
* print:                                 Options available during debugging.
* print/1 <1>:                           Documentation on exports (write).
* print/1 <2>:                           Usage and interface (write).
* print/1:                               Acknowledgements.
* print/2 <1>:                           Documentation on exports (write).
* print/2:                               Usage and interface (write).
* printable_char/1 <1>:                  Documentation on exports (write).
* printable_char/1:                      Usage and interface (write).
* printdepth:                            Options available during debugging.
* printing assertion information:        Printing the declarations and code in a file.
* printing code-related information:     Printing the declarations and code in a file.
* printing, manual <1>:                  Checking for correct installation on Win32.
* printing, manual <2>:                  Printing manuals (Win32).
* printing, manual <3>:                  Testing your Ciao Win32 installation.
* printing, manual:                      Printing manuals (Un*x).
* printqueries/1 <1>:                    Documentation on exports (pl2sql).
* printqueries/1:                        Usage and interface (pl2sql).
* Procedure Box:                         The interactive debugger.
* process_first_command/1:               Documentation on internals (jtopl).
* process_next_command/2:                Documentation on internals (jtopl).
* program assertions:                    The Ciao assertion package.
* program development environment:       Using Ciao inside GNU emacs.
* program parallelization:               Preprocessing programs.
* program specialization:                Preprocessing programs.
* program transformations <1>:           Preprocessing programs.
* program transformations:               Using Ciao inside GNU emacs.
* programming environment <1>:           *** PART I - The program development environment.
* programming environment:               PART I - The program development environment.
* project files:                         The stand-alone command-line compiler.
* projterm/1 <1>:                        Documentation on exports (pl2sql).
* projterm/1 <2>:                        Usage and interface (pl2sql).
* projterm/1:                            Documentation on exports (persdbrtsql).
* Prolog answers:                        Documentation on internals (jtopl).
* prolog flag <1>:                       Documentation on exports (io_aux).
* prolog flag <2>:                       Changing system behaviour and various flags.
* prolog flag <3>:                       Documentation on exports (streams_basic).
* prolog flag <4>:                       Documentation on internals (builtin_directives).
* prolog flag <5>:                       How it works.
* prolog flag:                           Shell invocation and startup.
* Prolog predicate argument positions:   Documentation on multifiles (pl2sql).
* Prolog predicate names:                Documentation on multifiles (pl2sql).
* Prolog scripts:                        Running Ciao scripts (Un*x).
* Prolog server:                         Documentation on exports (jtopl).
* Prolog shell scripts:                  The script interpreter.
* Prolog to SQL compiler:                Prolog to SQL translator.
* Prolog to SQL translation:             Documentation on internals (persdbrtsql).
* Prolog to SQL translator:              SQL persistent database interface.
* prolog-emacs interface:                Calling emacs from Prolog.
* prolog.el:                             Acknowledgments (ciao.el).
* prolog_flag/3 <1>:                     Documentation on exports (prolog_flags).
* prolog_flag/3:                         Usage and interface (prolog_flags).
* prolog_goal/1 <1>:                     Documentation on exports (javart).
* prolog_goal/1:                         Usage and interface (javart).
* prolog_parse/2:                        Documentation on internals (jtopl).
* prolog_query/1:                        Documentation on internals (jtopl).
* prolog_server/0 <1>:                   Documentation on exports (jtopl).
* prolog_server/0:                       Usage and interface (jtopl).
* prolog_sys <1>:                        Usage and interface (objects_rt).
* prolog_sys <2>:                        Usage and interface (conc_aggregates).
* prolog_sys:                            Usage and interface (debugger).
* PrologName:                            Documentation on exports (foreign_interface).
* prompt:                                Usage and interface (davinci).
* prompt/2 <1>:                          Documentation on exports (prolog_flags).
* prompt/2:                              Usage and interface (prolog_flags).
* prop assertion:                        Documentation on new declarations (assertions).
* prop/1 <1>:                            Documentation on new declarations (assertions).
* prop/1:                                Usage and interface (assertions).
* prop/2 <1>:                            Documentation on exports (meta_props).
* prop/2 <2>:                            Usage and interface (meta_props).
* prop/2 <3>:                            Documentation on new declarations (assertions).
* prop/2:                                Usage and interface (assertions).
* prop_abs/1:                            Documentation on internals (meta_props).
* properties of computations:            Defining properties.
* properties of execution states:        Defining properties.
* properties, basic:                     Basic data types and properties.
* properties, native:                    Properties which are native to analyzers.
* property:                              Documentation on new declarations (assertions).
* property abstraction:                  Documentation on internals (meta_props).
* property compatibility:                Documentation on exports (basic_props).
* property declarations:                 Printing the declarations and code in a file.
* property_conjunction/1 <1>:            Documentation on exports (assertions_props).
* property_conjunction/1:                Usage and interface (assertions_props).
* property_starterm/1 <1>:               Documentation on exports (assertions_props).
* property_starterm/1:                   Usage and interface (assertions_props).
* propfunctor/1 <1>:                     Documentation on exports (assertions_props).
* propfunctor/1:                         Usage and interface (assertions_props).
* protected:                             Documentation on new declarations (class).
* proves/2:                              Documentation on multifiles (rtchecks).
* providing information to the compiler <1>: Documentation on exports (assertions).
* providing information to the compiler: Documentation on new declarations (assertions).
* prune_dict/3 <1>:                      Documentation on exports (vndict).
* prune_dict/3:                          Usage and interface (vndict).
* public:                                Documentation on new declarations (class).
* public domain <1>:                     Summary.
* public domain:                         (outside of any node).
* public interface:                      Documentation on new declarations (class).
* public/1 <1>:                          Class and Interface error reporting at compile time.
* public/1 <2>:                          Documentation on new declarations (class).
* public/1:                              Usage and interface (class).
* pure <1>:                              *** PART II - The Ciao basic language (engine).
* pure:                                  PART II - The Ciao basic language (engine).
* pure Prolog <1>:                       Pure Prolog package.
* pure Prolog <2>:                       *** PART VII - Ciao Prolog extensions.
* pure Prolog:                           PART VII - Ciao Prolog extensions.
* push_global/2 <1>:                     Documentation on exports (global).
* push_global/2:                         Usage and interface (global).
* push_prolog_flag/2 <1>:                Documentation on exports (prolog_flags).
* push_prolog_flag/2:                    Usage and interface (prolog_flags).
* put_byte/1 <1>:                        Documentation on exports (iso_byte_char).
* put_byte/1:                            Usage and interface (iso_byte_char).
* put_byte/2 <1>:                        Documentation on exports (iso_byte_char).
* put_byte/2:                            Usage and interface (iso_byte_char).
* put_char/1 <1>:                        Documentation on exports (iso_byte_char).
* put_char/1:                            Usage and interface (iso_byte_char).
* put_char/2 <1>:                        Documentation on exports (iso_byte_char).
* put_char/2:                            Usage and interface (iso_byte_char).
* put_code/1 <1>:                        Documentation on exports (io_basic).
* put_code/1:                            Usage and interface (io_basic).
* put_code/2 <1>:                        Documentation on exports (io_basic).
* put_code/2:                            Usage and interface (io_basic).
* q_delete/3 <1>:                        Documentation on exports (queues).
* q_delete/3:                            Usage and interface (queues).
* q_empty/1 <1>:                         Documentation on exports (queues).
* q_empty/1:                             Usage and interface (queues).
* q_insert/3 <1>:                        Documentation on exports (queues).
* q_insert/3:                            Usage and interface (queues).
* q_member/2 <1>:                        Documentation on exports (queues).
* q_member/2:                            Usage and interface (queues).
* qualified attributes:                  Documentation on internals (pl2sql).
* query:                                 Shell interaction.
* query_generation/3:                    Documentation on internals (pl2sql).
* querybody/1 <1>:                       Documentation on internals (pl2sql).
* querybody/1 <2>:                       Documentation on exports (pl2sql).
* querybody/1 <3>:                       Usage and interface (pl2sql).
* querybody/1:                           Documentation on exports (persdbrtsql).
* quoted string:                         Documentation on exports (arithmetic).
* random/1 <1>:                          Documentation on exports (random).
* random/1:                              Usage and interface (random).
* random/3 <1>:                          Documentation on exports (random).
* random/3:                              Usage and interface (random).
* random/random <1>:                     Usage and interface (genmultibar).
* random/random <2>:                     Usage and interface (gengraph2).
* random/random <3>:                     Usage and interface (gengraph1).
* random/random <4>:                     Usage and interface (genbar4).
* random/random <5>:                     Usage and interface (genbar3).
* random/random <6>:                     Usage and interface (genbar2).
* random/random <7>:                     Usage and interface (genbar1).
* random/random:                         Usage and interface (color_pattern).
* random_color/1 <1>:                    Documentation on exports (color_pattern).
* random_color/1:                        Usage and interface (color_pattern).
* random_darkcolor/1 <1>:                Documentation on exports (color_pattern).
* random_darkcolor/1:                    Usage and interface (color_pattern).
* random_lightcolor/1 <1>:               Documentation on exports (color_pattern).
* random_lightcolor/1:                   Usage and interface (color_pattern).
* random_pattern/1 <1>:                  Documentation on exports (color_pattern).
* random_pattern/1:                      Usage and interface (color_pattern).
* range variable:                        Documentation on internals (pl2sql).
* rd/1 <1>:                              Documentation on exports (linda).
* rd/1:                                  Usage and interface (linda).
* rd/2 <1>:                              Documentation on exports (linda).
* rd/2:                                  Usage and interface (linda).
* rd_findall/3 <1>:                      Documentation on exports (linda).
* rd_findall/3:                          Usage and interface (linda).
* rd_noblock/1 <1>:                      Documentation on exports (linda).
* rd_noblock/1:                          Usage and interface (linda).
* read <1>:                              Usage and interface (bltclass).
* read <2>:                              Usage and interface (linda).
* read <3>:                              Usage and interface (javasock).
* read <4>:                              Usage and interface (jtopl).
* read <5>:                              Usage and interface (javart).
* read <6>:                              Usage and interface (pl2sql).
* read <7>:                              Usage and interface (persdbrt).
* read <8>:                              Usage and interface (davinci).
* read <9>:                              Usage and interface (objects_rt).
* read <10>:                             Usage and interface (functions).
* read <11>:                             Usage and interface (argnames).
* read <12>:                             Usage and interface (librowser).
* read <13>:                             Usage and interface (file_utils).
* read <14>:                             Usage and interface (runtime_ops).
* read <15>:                             Usage and interface (dynmods).
* read <16>:                             Usage and interface (iso).
* read:                                  Usage and interface (debugger).
* read/1 <1>:                            Documentation on exports (read).
* read/1 <2>:                            Usage and interface (read).
* read/1:                                Documentation on exports (io_aux).
* read/2 <1>:                            Documentation on exports (sockets).
* read/2 <2>:                            Documentation on exports (read).
* read/2:                                Usage and interface (read).
* read_command/1:                        Documentation on internals (jtopl).
* read_term/2 <1>:                       Documentation on exports (write).
* read_term/2 <2>:                       Documentation on exports (read).
* read_term/2:                           Usage and interface (read).
* read_term/3 <1>:                       Documentation on exports (write).
* read_term/3 <2>:                       Documentation on exports (read).
* read_term/3 <3>:                       Usage and interface (read).
* read_term/3:                           Documentation on exports (io_basic).
* read_top_level/3 <1>:                  Documentation on exports (read).
* read_top_level/3:                      Usage and interface (read).
* recorda/3 <1>:                         Documentation on exports (old_database).
* recorda/3:                             Usage and interface (old_database).
* recorded/3 <1>:                        Documentation on exports (old_database).
* recorded/3:                            Usage and interface (old_database).
* records <1>:                           *** PART VII - Ciao Prolog extensions.
* records:                               PART VII - Ciao Prolog extensions.
* recordz/3 <1>:                         Documentation on exports (old_database).
* recordz/3:                             Usage and interface (old_database).
* recursive level <1>:                   Entering recursive (conjunctive) shell levels.
* recursive level:                       Shell interaction.
* redefined:                             Documentation on exports (class).
* redefining/1:                          Documentation on internals (builtin_directives).
* reexport/1:                            Documentation on internals (modules).
* reexport/2:                            Documentation on internals (modules).
* reference/1:                           Documentation on internals (data_facts).
* references, to Ciao:                   Referring to Ciao.
* referring to Ciao:                     Referring to Ciao.
* regedit:                               Uninstallation under Windows.
* regtype assertion:                     Documentation on new declarations (regtypes).
* regtype/1 <1>:                         Documentation on new declarations (regtypes).
* regtype/1 <2>:                         Usage and interface (regtypes).
* regtype/1 <3>:                         Documentation on exports (basic_props).
* regtype/1:                             Usage and interface (basic_props).
* regtype/2 <1>:                         Documentation on exports (meta_props).
* regtype/2 <2>:                         Usage and interface (meta_props).
* regtype/2 <3>:                         Documentation on new declarations (regtypes).
* regtype/2:                             Usage and interface (regtypes).
* regular expresions:                    Documentation on exports (librowser).
* regular expressions:                   Pattern (regular expression) matching.
* regular type:                          Documentation on new declarations (regtypes).
* regular type definitions:              Declaring regular types.
* regular types:                         Declaring regular types.
* relation name:                         Documentation on internals (pl2sql).
* relation/3 <1>:                        Documentation on multifiles (pl2sql).
* relation/3 <2>:                        Documentation on exports (pl2sql).
* relation/3 <3>:                        Usage and interface (pl2sql).
* relation/3:                            Prolog to SQL translator.
* relational databases:                  SQL persistent database interface.
* rem/2:                                 Documentation on exports (arithmetic).
* rename/2 <1>:                          Documentation on exports (vndict).
* rename/2:                              Usage and interface (vndict).
* repeat/0 <1>:                          Documentation on exports (basiccontrol).
* repeat/0:                              Usage and interface (basiccontrol).
* reporting bugs <1>:                    Reporting bugs.
* reporting bugs <2>:                    *** PART XII - Appendices.
* reporting bugs:                        PART XII - Appendices.
* retract/1 <1>:                         Documentation on exports (dynamic).
* retract/1:                             Usage and interface (dynamic).
* retract_fact/1 <1>:                    Documentation on exports (persdbrtsql).
* retract_fact/1 <2>:                    SQL persistent database interface.
* retract_fact/1 <3>:                    Documentation on exports (persdbrt).
* retract_fact/1 <4>:                    Introduction to persistent predicates.
* retract_fact/1 <5>:                    Documentation on exports (data_facts).
* retract_fact/1:                        Usage and interface (data_facts).
* retract_fact_nb/1 <1>:                 Documentation on exports (data_facts).
* retract_fact_nb/1:                     Usage and interface (data_facts).
* retractall/1 <1>:                      Documentation on exports (dynamic).
* retractall/1:                          Usage and interface (dynamic).
* retractall_fact/1 <1>:                 Documentation on exports (persdbrtsql).
* retractall_fact/1 <2>:                 SQL persistent database interface.
* retractall_fact/1 <3>:                 Documentation on exports (data_facts).
* retractall_fact/1:                     Usage and interface (data_facts).
* retry:                                 Options available during debugging.
* returns/2 <1>:                         Documentation on exports (foreign_interface).
* returns/2:                             Usage and interface (foreign_interface).
* reverse/2 <1>:                         Documentation on exports (lists).
* reverse/2:                             Usage and interface (lists).
* reverse/3 <1>:                         Documentation on exports (lists).
* reverse/3:                             Usage and interface (lists).
* Roger Nasr <1>:                        Entering recursive (conjunctive) shell levels.
* Roger Nasr:                            Acknowledgments.
* round/1:                               Documentation on exports (arithmetic).
* row/1:                                 Documentation on internals (table_widget1).
* rtchecks/rtchecks_sys:                 Usage and interface (rtchecks).
* run-time checks <1>:                   Run-time checking of assertions.
* run-time checks:                       Documentation on new declarations (assertions).
* run-time tests:                        Preprocessing programs.
* running programs <1>:                  Running Ciao scripts (Win32).
* running programs <2>:                  Compiling and running programs (Win32).
* running programs <3>:                  Running Ciao scripts (Un*x).
* running programs:                      Compiling and running programs (Un*x).
* s_assrt_body/1 <1>:                    Documentation on exports (assertions_props).
* s_assrt_body/1:                        Usage and interface (assertions_props).
* Saumya Debray:                         Acknowledgments.
* scattergraph1_b1/13:                   Documentation on exports (gengraph1).
* scattergraph_b1/12 <1>:                Documentation on exports (gengraph1).
* scattergraph_b1/12 <2>:                Usage and interface (gengraph1).
* scattergraph_b1/12:                    Documentation on exports (chartlib).
* scattergraph_b1/8 <1>:                 Documentation on exports (gengraph1).
* scattergraph_b1/8 <2>:                 Usage and interface (gengraph1).
* scattergraph_b1/8:                     Documentation on exports (chartlib).
* scattergraph_b2/12 <1>:                Documentation on exports (gengraph2).
* scattergraph_b2/12 <2>:                Usage and interface (gengraph2).
* scattergraph_b2/12:                    Documentation on exports (chartlib).
* scattergraph_b2/8 <1>:                 Documentation on exports (gengraph2).
* scattergraph_b2/8 <2>:                 Usage and interface (gengraph2).
* scattergraph_b2/8:                     Documentation on exports (chartlib).
* scattergraph_w1/12 <1>:                Documentation on exports (gengraph1).
* scattergraph_w1/12 <2>:                Usage and interface (gengraph1).
* scattergraph_w1/12:                    Documentation on exports (chartlib).
* scattergraph_w1/8 <1>:                 Documentation on exports (gengraph2).
* scattergraph_w1/8 <2>:                 Documentation on exports (gengraph1).
* scattergraph_w1/8 <3>:                 Usage and interface (gengraph1).
* scattergraph_w1/8:                     Documentation on exports (chartlib).
* scattergraph_w2/12 <1>:                Documentation on exports (gengraph2).
* scattergraph_w2/12 <2>:                Usage and interface (gengraph2).
* scattergraph_w2/12:                    Documentation on exports (chartlib).
* scattergraph_w2/13:                    Documentation on exports (gengraph2).
* scattergraph_w2/8 <1>:                 Documentation on exports (gengraph2).
* scattergraph_w2/8 <2>:                 Usage and interface (gengraph2).
* scattergraph_w2/8:                     Documentation on exports (chartlib).
* scripts <1>:                           Running Ciao scripts (Win32).
* scripts <2>:                           Running Ciao scripts (Un*x).
* scripts:                               Testing your Ciao Un*x installation.
* second_prompt/2 <1>:                   Documentation on exports (read).
* second_prompt/2:                       Usage and interface (read).
* see/1 <1>:                             Documentation on exports (dec10_io).
* see/1:                                 Usage and interface (dec10_io).
* seeing/1 <1>:                          Documentation on exports (dec10_io).
* seeing/1:                              Usage and interface (dec10_io).
* seen/0 <1>:                            Documentation on exports (dec10_io).
* seen/0:                                Usage and interface (dec10_io).
* Seif Haridi:                           Acknowledgments.
* select/3 <1>:                          Documentation on exports (lists).
* select/3:                              Usage and interface (lists).
* select_socket/5 <1>:                   Documentation on exports (sockets).
* select_socket/5:                       Usage and interface (sockets).
* self/1 <1>:                            Documentation on exports (class).
* self/1:                                Usage and interface (class).
* semantic analisys:                     Documentation on exports (objects_rt).
* semaphore:                             Documentation on exports (concurrency).
* sequence/2 <1>:                        Documentation on exports (basic_props).
* sequence/2:                            Usage and interface (basic_props).
* sequence_or_list/2 <1>:                Documentation on exports (basic_props).
* sequence_or_list/2:                    Usage and interface (basic_props).
* set at a time:                         Low-level socket interface to SQL/ODBC databases.
* set_cookie/2 <1>:                      Documentation on exports (html).
* set_cookie/2:                          Usage and interface (html).
* set_debug_mode/1 <1>:                  Marking modules and files for debugging in the top-level debugger.
* set_debug_mode/1 <2>:                  Documentation on exports (ciaosh).
* set_debug_mode/1:                      Usage and interface (ciaosh).
* set_fact/1 <1>:                        Documentation on exports (data_facts).
* set_fact/1:                            Usage and interface (data_facts).
* set_global/2 <1>:                      Documentation on exports (global).
* set_global/2:                          Usage and interface (global).
* set_input/1 <1>:                       Documentation on exports (streams_basic).
* set_input/1:                           Usage and interface (streams_basic).
* set_nodebug_mode/1 <1>:                Marking modules and files for debugging in the top-level debugger.
* set_nodebug_mode/1 <2>:                Documentation on exports (ciaosh).
* set_nodebug_mode/1:                    Usage and interface (ciaosh).
* set_output/1 <1>:                      Documentation on exports (streams_basic).
* set_output/1:                          Usage and interface (streams_basic).
* set_prolog_flag/1:                     Normal Prolog module system interaction.
* set_prolog_flag/2 <1>:                 Documentation on exports (prolog_flags).
* set_prolog_flag/2:                     Usage and interface (prolog_flags).
* setarg/3 <1>:                          Documentation on exports (odd).
* setarg/3:                              Usage and interface (odd).
* setcounter/2 <1>:                      Documentation on exports (counters).
* setcounter/2:                          Usage and interface (counters).
* setof/3 <1>:                           Documentation on exports (pl2sql).
* setof/3 <2>:                           Known bugs and planned improvements (conc_aggregates).
* setof/3 <3>:                           Documentation on exports (aggregates).
* setof/3:                               Usage and interface (aggregates).
* setproduct/3 <1>:                      Documentation on exports (sets).
* setproduct/3:                          Usage and interface (sets).
* sets <1>:                              Usage and interface (vndict).
* sets <2>:                              Usage and interface (lgraphs).
* sets <3>:                              Usage and interface (wgraphs).
* sets <4>:                              Usage and interface (ugraphs).
* sets:                                  Usage and interface (when).
* sh <1>:                                Installation of the Ciao/Prolog emacs interface.
* sh:                                    Un*x user setup.
* sh-compatible shell:                   Un*x user setup.
* sharing sets:                          Documentation on exports (native_props).
* shell:                                 Starting/exiting the top-level shell (Win32).
* shell scripts:                         The stand-alone command-line compiler.
* shell/0 <1>:                           Documentation on exports (system).
* shell/0:                               Usage and interface (system).
* shell/1 <1>:                           Documentation on exports (system).
* shell/1:                               Usage and interface (system).
* shell/2 <1>:                           Documentation on exports (system).
* shell/2:                               Usage and interface (system).
* shell_s/0:                             Documentation on internals (jtopl).
* shortcut, windows:                     Win32 binary installation summary.
* SICS <1>:                              Acknowledgments (ciao.el).
* SICS:                                  Acknowledgments.
* SICStus:                               Coexistence with other Prolog interfaces.
* SICStus Prolog:                        Acknowledgments.
* sideff_hard/1 <1>:                     Documentation on exports (native_props).
* sideff_hard/1:                         Usage and interface (native_props).
* sideff_pure/1 <1>:                     Documentation on exports (native_props).
* sideff_pure/1:                         Usage and interface (native_props).
* sideff_soft/1 <1>:                     Documentation on exports (native_props).
* sideff_soft/1:                         Usage and interface (native_props).
* sign/1:                                Documentation on exports (arithmetic).
* simple_client.pl:                      Active modules (high-level distributed execution).
* simple_message/1 <1>:                  Documentation on exports (messages).
* simple_message/1:                      Usage and interface (messages).
* simple_message/2 <1>:                  Documentation on exports (messages).
* simple_message/2:                      Usage and interface (messages).
* sin/1:                                 Documentation on exports (arithmetic).
* size/1 <1>:                            Documentation on exports (gengraph1).
* size/1:                                Usage and interface (gengraph1).
* size_lb/2 <1>:                         Documentation on exports (native_props).
* size_lb/2:                             Usage and interface (native_props).
* size_of/3 <1>:                         Documentation on exports (foreign_interface).
* size_of/3:                             Usage and interface (foreign_interface).
* size_ub/2 <1>:                         Documentation on exports (native_props).
* size_ub/2:                             Usage and interface (native_props).
* sizes of terms:                        Preprocessing programs.
* skip:                                  Options available during debugging.
* skip_code/1 <1>:                       Documentation on exports (io_basic).
* skip_code/1:                           Usage and interface (io_basic).
* skip_code/2 <1>:                       Documentation on exports (io_basic).
* skip_code/2:                           Usage and interface (io_basic).
* smooth/1 <1>:                          Documentation on exports (gengraph1).
* smooth/1:                              Usage and interface (gengraph1).
* Socket implementation:                 Low-level Prolog to Java socket connection.
* Socket interface <1>:                  *** PART VIII - Interfaces to other languages and systems.
* Socket interface:                      PART VIII - Interfaces to other languages and systems.
* socket_accept/2 <1>:                   Documentation on exports (sockets).
* socket_accept/2:                       Usage and interface (sockets).
* socket_connection/2 <1>:               Documentation on exports (javasock).
* socket_connection/2:                   Usage and interface (javasock).
* socket_disconnection/0 <1>:            Documentation on exports (javasock).
* socket_disconnection/0:                Usage and interface (javasock).
* socket_recv/2 <1>:                     Documentation on exports (sockets).
* socket_recv/2:                         Usage and interface (sockets).
* socket_recv_code/3 <1>:                Documentation on exports (sockets).
* socket_recv_code/3:                    Usage and interface (sockets).
* socket_send/2 <1>:                     Documentation on exports (sockets).
* socket_send/2:                         Usage and interface (sockets).
* socket_type/1 <1>:                     Documentation on exports (sockets).
* socket_type/1:                         Usage and interface (sockets).
* socketname/1 <1>:                      Documentation on exports (db_client).
* socketname/1 <2>:                      Usage and interface (db_client).
* socketname/1:                          Documentation on exports (persdbrtsql).
* sockets/sockets <1>:                   Usage and interface (bltclass).
* sockets/sockets <2>:                   Usage and interface (linda).
* sockets/sockets <3>:                   Usage and interface (javasock).
* sockets/sockets:                       Usage and interface (db_client).
* sockets/sockets_c:                     Usage and interface (sockets).
* soft side-effects:                     Documentation on exports (native_props).
* solve/1:                               Documentation on internals (jtopl).
* solve_on_thread/1:                     Documentation on internals (jtopl).
* sort <1>:                              Usage and interface (vndict).
* sort <2>:                              Usage and interface (sets).
* sort <3>:                              Usage and interface (lgraphs).
* sort <4>:                              Usage and interface (wgraphs).
* sort <5>:                              Usage and interface (ugraphs).
* sort <6>:                              Usage and interface (graphs).
* sort <7>:                              Usage and interface (metaterms).
* sort <8>:                              Usage and interface (when).
* sort <9>:                              Usage and interface (native_props).
* sort <10>:                             Usage and interface (classic).
* sort <11>:                             Usage and interface (write).
* sort <12>:                             Usage and interface (aggregates).
* sort:                                  Usage and interface (debugger).
* sort/2 <1>:                            Documentation on exports (sort).
* sort/2:                                Usage and interface (sort).
* source-level debugger <1>:             Conventions for writing Ciao programs under Emacs.
* source-level debugger:                 The interactive debugger.
* source-level debugging <1>:            Debugging programs.
* source-level debugging <2>:            Using Ciao inside GNU emacs.
* source-level debugging <3>:            The procedure box control flow model.
* source-level debugging <4>:            The debugging process.
* source-level debugging:                Marking modules and files for debugging in the top-level debugger.
* sourcename/1 <1>:                      Documentation on exports (streams_basic).
* sourcename/1 <2>:                      Usage and interface (streams_basic).
* sourcename/1:                          Documentation on internals (ciaosh).
* sourcenames/1:                         Documentation on internals (ciaosh).
* specifications <1>:                    The Ciao assertion package.
* specifications:                        Preprocessing programs.
* spy:                                   Options available during debugging.
* spy-points <1>:                        Debugging programs.
* spy-points <2>:                        Marking modules and files for debugging with the embedded debugger.
* spy-points:                            The interactive debugger.
* spy/1 <1>:                             Documentation on exports (debugger).
* spy/1 <2>:                             Usage and interface (debugger).
* spy/1 <3>:                             Acknowledgements.
* spy/1 <4>:                             Marking modules and files for debugging with the embedded debugger.
* spy/1:                                 The debugging process.
* SQL <1>:                               Prolog to SQL translator.
* SQL:                                   SQL persistent database interface.
* SQL attributes:                        Documentation on multifiles (pl2sql).
* SQL Databases:                         Low-level socket interface to SQL/ODBC databases.
* SQL queries:                           Low-level socket interface to SQL/ODBC databases.
* SQL query <1>:                         Documentation on exports (pl2sql).
* SQL query <2>:                         Documentation on internals (persdbrtsql).
* SQL query:                             Documentation on exports (persdbrtsql).
* SQL server:                            Documentation on exports (pl2sql).
* SQL table names:                       Documentation on multifiles (pl2sql).
* SQL tables <1>:                        Documentation on multifiles (pl2sql).
* SQL tables:                            Prolog to SQL translator.
* SQL-like database interface <1>:       *** PART VIII - Interfaces to other languages and systems.
* SQL-like database interface:           PART VIII - Interfaces to other languages and systems.
* sql_get_tables/2 <1>:                  Documentation on exports (persdbrtsql).
* sql_get_tables/2:                      Usage and interface (persdbrtsql).
* sql_persistent/3:                      Documentation on exports (persdbrtsql).
* sql_persistent_location/2 <1>:         Documentation on multifiles (persdbrtsql).
* sql_persistent_location/2:             Usage and interface (persdbrtsql).
* sql_query/3 <1>:                       Documentation on internals (persdbrtsql).
* sql_query/3 <2>:                       Documentation on exports (persdbrtsql).
* sql_query/3:                           Usage and interface (persdbrtsql).
* sql_query_one_tuple/3:                 Documentation on internals (persdbrtsql).
* sql_table_types/3 <1>:                 Documentation on exports (persdbrtsql).
* sql_table_types/3:                     Usage and interface (persdbrtsql).
* sqlstring/1 <1>:                       Documentation on exports (pl2sql).
* sqlstring/1:                           Usage and interface (pl2sql).
* sqlterm2string/2 <1>:                  Documentation on exports (pl2sql).
* sqlterm2string/2:                      Usage and interface (pl2sql).
* sqltype/1 <1>:                         Documentation on multifiles (pl2sql).
* sqltype/1 <2>:                         Documentation on exports (pl2sql).
* sqltype/1:                             Documentation on exports (persdbrtsql).
* sqltypes <1>:                          Documentation on exports (pl2sql).
* sqltypes:                              Documentation on exports (persdbrtsql).
* sqrt/1:                                Documentation on exports (arithmetic).
* srandom/1 <1>:                         Documentation on exports (random).
* srandom/1:                             Usage and interface (random).
* standalone compiler:                   Testing your Ciao Un*x installation.
* standalone utilities <1>:              *** PART X - Miscellaneous standalone utilities.
* standalone utilities:                  PART X - Miscellaneous standalone utilities.
* standard total ordering:               Comparing terms.
* static checks:                         Using Ciao inside GNU emacs.
* static debugging:                      Preprocessing programs.
* statistics/0 <1>:                      Documentation on exports (prolog_sys).
* statistics/0:                          Usage and interface (prolog_sys).
* statistics/2 <1>:                      Documentation on exports (prolog_sys).
* statistics/2:                          Usage and interface (prolog_sys).
* status bar:                            Checking the installation.
* status, this manual:                   About this manual.
* steps_lb/2 <1>:                        Documentation on exports (native_props).
* steps_lb/2:                            Usage and interface (native_props).
* steps_ub/2 <1>:                        Documentation on exports (native_props).
* steps_ub/2:                            Usage and interface (native_props).
* stmthandle/1:                          Documentation on internals (db_client).
* stream/1 <1>:                          Documentation on exports (streams_basic).
* stream/1:                              Usage and interface (streams_basic).
* stream_code/2 <1>:                     Documentation on exports (streams_basic).
* stream_code/2:                         Usage and interface (streams_basic).
* stream_property/2 <1>:                 Documentation on exports (iso_incomplete).
* stream_property/2:                     Usage and interface (iso_incomplete).
* stream_to_string/2 <1>:                Documentation on exports (file_utils).
* stream_to_string/2:                    Usage and interface (file_utils).
* streams <1>:                           Usage and interface (persdbrt).
* streams <2>:                           Usage and interface (librowser).
* streams <3>:                           Usage and interface (file_utils).
* streams:                               Usage and interface (dec10_io).
* string/1 <1>:                          Documentation on exports (basic_props).
* string/1:                              Usage and interface (basic_props).
* string/3 <1>:                          Documentation on exports (strings).
* string/3:                              Usage and interface (strings).
* string2term/2 <1>:                     Documentation on exports (atom2term).
* string2term/2:                         Usage and interface (atom2term).
* stringcommand/1 <1>:                   Documentation on exports (assertions_props).
* stringcommand/1:                       Documentation on new declarations (assertions).
* strings <1>:                           Usage and interface (bltclass).
* strings <2>:                           Usage and interface (db_client).
* strings <3>:                           Usage and interface (http).
* strings <4>:                           Usage and interface (html).
* strings <5>:                           Usage and interface (tcltk).
* strings:                               Usage and interface (classic).
* struct/1 <1>:                          Documentation on exports (basic_props).
* struct/1:                              Usage and interface (basic_props).
* style sheets <1>:                      Checking for correct installation on Win32.
* style sheets <2>:                      Testing your Ciao Win32 installation.
* style sheets:                          Testing your Ciao Un*x installation.
* sub-shell:                             Using Ciao inside GNU emacs.
* sub_atom/4 <1>:                        Documentation on exports (atomic_basic).
* sub_atom/4:                            Usage and interface (atomic_basic).
* sub_atom/5 <1>:                        Documentation on exports (iso_misc).
* sub_atom/5:                            Usage and interface (iso_misc).
* sublist/2 <1>:                         Documentation on exports (lists).
* sublist/2:                             Usage and interface (lists).
* subordlist/2 <1>:                      Documentation on exports (lists).
* subordlist/2:                          Usage and interface (lists).
* subterm:                               Options available during debugging.
* subtract/3 <1>:                        Documentation on exports (idlists).
* subtract/3:                            Usage and interface (idlists).
* success assertion:                     Documentation on new declarations (assertions).
* success/1 <1>:                         Documentation on new declarations (assertions).
* success/1:                             Usage and interface (assertions).
* success/2 <1>:                         Documentation on new declarations (assertions).
* success/2:                             Usage and interface (assertions).
* sum_list/2 <1>:                        Documentation on exports (numlists).
* sum_list/2:                            Usage and interface (numlists).
* sum_list/3 <1>:                        Documentation on exports (numlists).
* sum_list/3:                            Usage and interface (numlists).
* sum_list_of_lists/2 <1>:               Documentation on exports (numlists).
* sum_list_of_lists/2:                   Usage and interface (numlists).
* sum_list_of_lists/3 <1>:               Documentation on exports (numlists).
* sum_list_of_lists/3:                   Usage and interface (numlists).
* super class:                           Documentation on new declarations (class).
* Swedish Institute of Computer Science: Acknowledgments.
* symbol/1 <1>:                          Documentation on exports (gengraph1).
* symbol/1:                              Usage and interface (gengraph1).
* symbol_option/1:                       Documentation on internals (prolog_sys).
* symbol_result/1:                       Documentation on internals (prolog_sys).
* syntax coloring:                       Conventions for writing Ciao programs under Emacs.
* Syntax highlighting:                   Using Ciao inside GNU emacs.
* syntax of regular types:               Declaring regular types.
* syntax/1:                              Usage and interface (persdbrt).
* system <1>:                            Usage and interface (bltclass).
* system <2>:                            Usage and interface (emacs).
* system <3>:                            Usage and interface (jtopl).
* system <4>:                            Usage and interface (javart).
* system <5>:                            Usage and interface (pl2sql).
* system <6>:                            Usage and interface (persdbrt).
* system <7>:                            Usage and interface (html).
* system <8>:                            Usage and interface (davinci).
* system <9>:                            Usage and interface (foreign_compilation).
* system <10>:                           Usage and interface (objects_rt).
* system <11>:                           Usage and interface (librowser).
* system <12>:                           Usage and interface (ctrlcclean).
* system <13>:                           Usage and interface (libpaths).
* system <14>:                           Compiling and running programs (Win32).
* system:                                Compiling and running programs (Un*x).
* system libraries:                      Documentation on exports (librowser).
* system/1 <1>:                          Documentation on exports (system).
* system/1:                              Usage and interface (system).
* system/2 <1>:                          Documentation on exports (system).
* system/2:                              Usage and interface (system).
* system_lib/1 <1>:                      Documentation on exports (librowser).
* system_lib/1:                          Usage and interface (librowser).
* tab/1 <1>:                             Documentation on exports (io_basic).
* tab/1:                                 Usage and interface (io_basic).
* tab/2 <1>:                             Documentation on exports (io_basic).
* tab/2:                                 Usage and interface (io_basic).
* table/1 <1>:                           Documentation on exports (table_widget1).
* table/1:                               Usage and interface (table_widget1).
* table_widget1:                         Documentation on exports (chartlib).
* table_widget2:                         Documentation on exports (chartlib).
* table_widget3:                         Documentation on exports (chartlib).
* table_widget4:                         Documentation on exports (chartlib).
* tablewidget1/4 <1>:                    Documentation on exports (table_widget1).
* tablewidget1/4 <2>:                    Usage and interface (table_widget1).
* tablewidget1/4:                        Documentation on exports (chartlib).
* tablewidget1/5 <1>:                    Documentation on exports (table_widget1).
* tablewidget1/5 <2>:                    Usage and interface (table_widget1).
* tablewidget1/5:                        Documentation on exports (chartlib).
* tablewidget2/4 <1>:                    Documentation on exports (table_widget2).
* tablewidget2/4 <2>:                    Usage and interface (table_widget2).
* tablewidget2/4:                        Documentation on exports (chartlib).
* tablewidget2/5 <1>:                    Documentation on exports (table_widget2).
* tablewidget2/5 <2>:                    Usage and interface (table_widget2).
* tablewidget2/5:                        Documentation on exports (chartlib).
* tablewidget3/4 <1>:                    Documentation on exports (table_widget3).
* tablewidget3/4 <2>:                    Usage and interface (table_widget3).
* tablewidget3/4:                        Documentation on exports (chartlib).
* tablewidget3/5 <1>:                    Documentation on exports (table_widget3).
* tablewidget3/5 <2>:                    Usage and interface (table_widget3).
* tablewidget3/5:                        Documentation on exports (chartlib).
* tablewidget4/4 <1>:                    Documentation on exports (table_widget4).
* tablewidget4/4 <2>:                    Usage and interface (table_widget4).
* tablewidget4/4:                        Documentation on exports (chartlib).
* tablewidget4/5 <1>:                    Documentation on exports (table_widget4).
* tablewidget4/5 <2>:                    Usage and interface (table_widget4).
* tablewidget4/5:                        Documentation on exports (chartlib).
* tag_attrib/1:                          Documentation on exports (pillow_types).
* Tcl/tk interface <1>:                  *** PART VIII - Interfaces to other languages and systems.
* Tcl/tk interface:                      PART VIII - Interfaces to other languages and systems.
* tcl_delete/1 <1>:                      Documentation on exports (tcltk).
* tcl_delete/1:                          Usage and interface (tcltk).
* tcl_eval/3 <1>:                        Documentation on exports (tcltk).
* tcl_eval/3:                            Usage and interface (tcltk).
* tcl_event/3 <1>:                       Documentation on exports (tcltk).
* tcl_event/3:                           Usage and interface (tcltk).
* tcl_new/1 <1>:                         Documentation on exports (tcltk).
* tcl_new/1:                             Usage and interface (tcltk).
* tclCommand/1 <1>:                      Documentation on exports (tcltk).
* tclCommand/1:                          Usage and interface (tcltk).
* tclInterpreter/1 <1>:                  Documentation on exports (tcltk).
* tclInterpreter/1:                      Usage and interface (tcltk).
* tcltk:                                 The Tcl/Tk interface.
* tcltk/tcltk_low_level:                 Usage and interface (tcltk).
* tcltk_raw_code/2 <1>:                  Documentation on exports (bltclass).
* tcltk_raw_code/2:                      Usage and interface (bltclass).
* tcsh <1>:                              Installation of the Ciao/Prolog emacs interface.
* tcsh:                                  Un*x user setup.
* Technical University of Madrid:        Acknowledgments.
* tell/1 <1>:                            Documentation on exports (dec10_io).
* tell/1:                                Usage and interface (dec10_io).
* telling/1 <1>:                         Documentation on exports (dec10_io).
* telling/1:                             Usage and interface (dec10_io).
* term/1 <1>:                            Documentation on exports (basic_props).
* term/1:                                Usage and interface (basic_props).
* terms <1>:                             Usage and interface (bltclass).
* terms <2>:                             Usage and interface (emacs).
* terms <3>:                             Usage and interface (persdbrtsql).
* terms:                                 Usage and interface (dcg_expansion).
* this_module/1 <1>:                     Documentation on exports (system_info).
* this_module/1:                         Usage and interface (system_info).
* throw/1 <1>:                           Documentation on exports (exceptions).
* throw/1:                               Usage and interface (exceptions).
* time stamp:                            Version control.
* time/1 <1>:                            Documentation on exports (system).
* time/1:                                Usage and interface (system).
* time_option/1:                         Documentation on internals (prolog_sys).
* time_result/1:                         Documentation on internals (prolog_sys).
* title/1 <1>:                           Documentation on exports (genbar1).
* title/1:                               Usage and interface (genbar1).
* tk_event_loop/1 <1>:                   Documentation on exports (tcltk).
* tk_event_loop/1:                       Usage and interface (tcltk).
* tk_loop/1 <1>:                         Documentation on exports (tcltk).
* tk_loop/1:                             Usage and interface (tcltk).
* tk_new/2 <1>:                          Documentation on exports (tcltk).
* tk_new/2:                              Usage and interface (tcltk).
* tk_new/4 <1>:                          Documentation on exports (tcltk).
* tk_new/4:                              Usage and interface (tcltk).
* tk_next_event/2 <1>:                   Documentation on exports (tcltk).
* tk_next_event/2:                       Usage and interface (tcltk).
* tokenize:                              Usage and interface (read).
* told/0 <1>:                            Documentation on exports (dec10_io).
* told/0:                                Usage and interface (dec10_io).
* top-level:                             The interactive debugger.
* top-level shell, starting, unix:       Starting/exiting the top-level shell (Un*x).
* top-level shell, starting, windows:    Starting/exiting the top-level shell (Win32).
* topd/0 <1>:                            Documentation on exports (davinci).
* topd/0:                                Usage and interface (davinci).
* toplev:                                Usage and interface (ciaosh).
* toplevel:                              Documentation on exports (system_info).
* toplevel command args, setting:        Setting the top-level.
* toplevel command, setting:             Setting the top-level.
* tour, of the manual:                   A tour of the manual.
* trace:                                 The debugging process.
* trace/0 <1>:                           Documentation on exports (debugger).
* trace/0 <2>:                           Usage and interface (debugger).
* trace/0:                               The debugging process.
* trace/1:                               Marking modules and files for debugging with the embedded debugger.
* tracing the source code:               Using Ciao inside GNU emacs.
* transactional update:                  Introduction to persistent predicates.
* transient state:                       Implementation Issues.
* translate_arithmetic_function/5:       Documentation on internals (pl2sql).
* translate_comparison/5:                Documentation on internals (pl2sql).
* translate_conjunction/5:               Documentation on internals (pl2sql).
* translate_goal/5:                      Documentation on internals (pl2sql).
* translate_projection/3:                Documentation on exports (pl2sql).
* translation_predname/1:                Documentation on internals (syntax_extensions).
* transpose/2 <1>:                       Documentation on exports (ugraphs).
* transpose/2:                           Usage and interface (ugraphs).
* triple/1:                              Documentation on internals (graphs).
* troubleshooting:                       Installing Ciao from a Win32 binary distribution.
* true assertion:                        Documentation on exports (assertions).
* true/0 <1>:                            Documentation on exports (basiccontrol).
* true/0 <2>:                            Usage and interface (basiccontrol).
* true/0:                                The module system.
* true/1 <1>:                            Documentation on exports (assertions).
* true/1:                                Usage and interface (assertions).
* truncate/1:                            Documentation on exports (arithmetic).
* trust assertion:                       Documentation on exports (assertions).
* trust/1 <1>:                           Documentation on exports (assertions).
* trust/1:                               Usage and interface (assertions).
* ttydisplay/1 <1>:                      Documentation on exports (ttyout).
* ttydisplay/1:                          Usage and interface (ttyout).
* ttydisplay_string/1 <1>:               Documentation on exports (ttyout).
* ttydisplay_string/1:                   Usage and interface (ttyout).
* ttydisplayq/1 <1>:                     Documentation on exports (ttyout).
* ttydisplayq/1:                         Usage and interface (ttyout).
* ttyflush/0 <1>:                        Documentation on exports (ttyout).
* ttyflush/0:                            Usage and interface (ttyout).
* ttyget/1 <1>:                          Documentation on exports (ttyout).
* ttyget/1:                              Usage and interface (ttyout).
* ttyget1/1 <1>:                         Documentation on exports (ttyout).
* ttyget1/1:                             Usage and interface (ttyout).
* ttynl/0 <1>:                           Documentation on exports (ttyout).
* ttynl/0:                               Usage and interface (ttyout).
* ttyout <1>:                            Usage and interface (classic).
* ttyout:                                Usage and interface (debugger).
* ttyput/1 <1>:                          Documentation on exports (ttyout).
* ttyput/1:                              Usage and interface (ttyout).
* ttyskip/1 <1>:                         Documentation on exports (ttyout).
* ttyskip/1:                             Usage and interface (ttyout).
* ttyskipeol/0 <1>:                      Documentation on exports (ttyout).
* ttyskipeol/0:                          Usage and interface (ttyout).
* ttytab/1 <1>:                          Documentation on exports (ttyout).
* ttytab/1:                              Usage and interface (ttyout).
* tuple at a time:                       Low-level socket interface to SQL/ODBC databases.
* tuple/1 <1>:                           Documentation on exports (db_client).
* tuple/1 <2>:                           Usage and interface (db_client).
* tuple/1:                               Documentation on internals (persdbrtsql).
* tuples:                                Documentation on internals (persdbrtsql).
* type <1>:                              *** PART V - Annotated Prolog library (assertions).
* type:                                  PART V - Annotated Prolog library (assertions).
* type declarations:                     Printing the declarations and code in a file.
* type of version control:               Version control.
* type/2 <1>:                            Documentation on exports (term_typing).
* type/2:                                Usage and interface (term_typing).
* types:                                 Preprocessing programs.
* U. of Arizona:                         Acknowledgments.
* ugraph/1 <1>:                          Documentation on exports (ugraphs).
* ugraph/1:                              Usage and interface (ugraphs).
* ugraph2term/2 <1>:                     Documentation on exports (davinci).
* ugraph2term/2:                         Usage and interface (davinci).
* ugraphs:                               Labeled graph-processing utilities.
* umask/2 <1>:                           Documentation on exports (system).
* umask/2:                               Usage and interface (system).
* undo/1 <1>:                            Documentation on exports (odd).
* undo/1:                                Usage and interface (odd).
* undo_force_lazy/1 <1>:                 Documentation on exports (ciaosh).
* undo_force_lazy/1:                     Usage and interface (ciaosh).
* unify:                                 Options available during debugging.
* unify_with_occurs_check/2 <1>:         Documentation on exports (iso_misc).
* unify_with_occurs_check/2:             Usage and interface (iso_misc).
* UNION-operator:                        Documentation on internals (pl2sql).
* union/3 <1>:                           Documentation on exports (lists).
* union/3:                               Usage and interface (lists).
* union_idlists/3 <1>:                   Documentation on exports (idlists).
* union_idlists/3:                       Usage and interface (idlists).
* Unix/Linux machine:                    Low-level socket interface to SQL/ODBC databases.
* unload/1 <1>:                          Documentation on exports (ciaosh).
* unload/1:                              Usage and interface (ciaosh).
* unlock_atom/1 <1>:                     Documentation on exports (concurrency).
* unlock_atom/1:                         Usage and interface (concurrency).
* unmarshalling <1>:                     *** PART VI - Ciao Prolog library miscellanea.
* unmarshalling:                         PART VI - Ciao Prolog library miscellanea.
* unzip:                                 Win32 binary installation summary.
* update/0 <1>:                          Documentation on exports (librowser).
* update/0:                              Usage and interface (librowser).
* update_attribute/2 <1>:                Documentation on exports (attributes).
* update_attribute/2:                    Usage and interface (attributes).
* update_files/2 <1>:                    Documentation on exports (persdbrt).
* update_files/2 <2>:                    Usage and interface (persdbrt).
* update_files/2 <3>:                    Using persistent predicates from the top level.
* update_files/2:                        Implementation Issues.
* updated state:                         Implementation Issues.
* Updates to persistent predicates:      Introduction to persistent predicates.
* UPM:                                   Acknowledgments.
* url_info/2 <1>:                        Documentation on exports (html).
* url_info/2:                            Usage and interface (html).
* url_info_relative/3 <1>:               Documentation on exports (html).
* url_info_relative/3:                   Usage and interface (html).
* url_query/2 <1>:                       Documentation on exports (html).
* url_query/2:                           Usage and interface (html).
* url_term/1 <1>:                        Documentation on exports (pillow_types).
* url_term/1:                            Usage and interface (pillow_types).
* usage:                                 Documentation on new declarations (assertions).
* usage relationship:                    Documentation on new declarations (objects).
* use_active_module:                     Active modules (high-level distributed execution).
* use_active_module/2 <1>:               Documentation on new declarations (actmods).
* use_active_module/2:                   Usage and interface (actmods).
* use_class/1 <1>:                       Documentation on exports (objects_rt).
* use_class/1 <2>:                       Usage and interface (objects_rt).
* use_class/1 <3>:                       Run time usage of objects.
* use_class/1 <4>:                       Error reporting at compile time (objects).
* use_class/1 <5>:                       Documentation on new declarations (objects).
* use_class/1 <6>:                       Usage and interface (objects).
* use_class/1:                           Documentation on new declarations (class).
* use_module:                            Active modules (high-level distributed execution).
* use_module/1 <1>:                      Known bugs and planned improvements (objects_rt).
* use_module/1 <2>:                      Documentation on exports (objects_rt).
* use_module/1 <3>:                      Documentation on new declarations (objects).
* use_module/1 <4>:                      Usage and interface (expansion_tools).
* use_module/1 <5>:                      Usage and interface (librowser).
* use_module/1 <6>:                      Documentation on exports (dynmods).
* use_module/1 <7>:                      Usage and interface (dynmods).
* use_module/1 <8>:                      Documentation on exports (streams_basic).
* use_module/1 <9>:                      Documentation on internals (modules).
* use_module/1 <10>:                     Documentation on exports (ciaosh).
* use_module/1 <11>:                     Usage and interface (ciaosh).
* use_module/1 <12>:                     Shell invocation and startup.
* use_module/1 <13>:                     Types of executables generated.
* use_module/1:                          Paths used by the compiler during compilation.
* use_module/2 <1>:                      Documentation on internals (modules).
* use_module/2 <2>:                      Documentation on exports (ciaosh).
* use_module/2:                          Usage and interface (ciaosh).
* use_package/1 <1>:                     Usage and interface (persdbrtsql).
* use_package/1 <2>:                     ISO-Prolog package.
* use_package/1 <3>:                     Documentation on internals (loading_code).
* use_package/1 <4>:                     Documentation on exports (ciaosh).
* use_package/1:                         Usage and interface (ciaosh).
* user module <1>:                       The module system.
* user module:                           Shell interaction.
* user modules, debugging:               Marking modules and files for debugging in the top-level debugger.
* user setup:                            Un*x user setup.
* user/1 <1>:                            Documentation on exports (db_client).
* user/1 <2>:                            Usage and interface (db_client).
* user/1:                                Documentation on exports (persdbrtsql).
* users mailing list:                    Keeping up to date with the Ciao users mailing list.
* using alternate engines or libraries:  Environment variables used by Ciao executables.
* valid_attributes/2 <1>:                Documentation on exports (test_format).
* valid_attributes/2:                    Usage and interface (test_format).
* valid_format/4 <1>:                    Documentation on exports (test_format).
* valid_format/4:                        Usage and interface (test_format).
* valid_table/2 <1>:                     Documentation on exports (test_format).
* valid_table/2:                         Usage and interface (test_format).
* valid_vectors/4 <1>:                   Documentation on exports (test_format).
* valid_vectors/4:                       Usage and interface (test_format).
* value_dict/1 <1>:                      Documentation on exports (pillow_types).
* value_dict/1:                          Usage and interface (pillow_types).
* var/1 <1>:                             Documentation on exports (assertions_props).
* var/1 <2>:                             Documentation on exports (term_typing).
* var/1:                                 Usage and interface (term_typing).
* variable instantiation:                Preprocessing programs.
* variable names:                        Some attention points.
* variables occurring in several goals:  Documentation on internals (pl2sql).
* variant/2 <1>:                         Documentation on exports (metaterms).
* variant/2:                             Usage and interface (metaterms).
* varname/1 <1>:                         Documentation on exports (vndict).
* varname/1:                             Usage and interface (vndict).
* varnamedict/1 <1>:                     Documentation on exports (vndict).
* varnamedict/1:                         Usage and interface (vndict).
* varnamesl/1 <1>:                       Documentation on exports (vndict).
* varnamesl/1:                           Usage and interface (vndict).
* varnamesl2dict/2 <1>:                  Documentation on exports (vndict).
* varnamesl2dict/2:                      Usage and interface (vndict).
* vars_names_dict/3 <1>:                 Documentation on exports (vndict).
* vars_names_dict/3:                     Usage and interface (vndict).
* varsbag/3 <1>:                         Documentation on exports (metaterms).
* varsbag/3:                             Usage and interface (metaterms).
* varset/2 <1>:                          Documentation on exports (metaterms).
* varset/2:                              Usage and interface (metaterms).
* vector/1 <1>:                          Documentation on exports (gengraph1).
* vector/1:                              Usage and interface (gengraph1).
* vectors_format/4 <1>:                  Documentation on exports (test_format).
* vectors_format/4:                      Usage and interface (test_format).
* verify_attribute/2 <1>:                Documentation on multifiles (when).
* verify_attribute/2 <2>:                Usage and interface (when).
* verify_attribute/2 <3>:                Documentation on multifiles (freeze).
* verify_attribute/2 <4>:                Usage and interface (freeze).
* verify_attribute/2 <5>:                Documentation on multifiles (attributes).
* verify_attribute/2:                    Usage and interface (attributes).
* Veroniek Dumortier:                    Acknowledgments.
* version control <1>:                   Version control.
* version control:                       Using Ciao inside GNU emacs.
* version maintenance mode for packages: Version control.
* version number:                        Version control.
* version numbering:                     Version control.
* vertices/2 <1>:                        Documentation on exports (ugraphs).
* vertices/2:                            Usage and interface (ugraphs).
* vertices_edges_to_lgraph/3 <1>:        Documentation on exports (lgraphs).
* vertices_edges_to_lgraph/3:            Usage and interface (lgraphs).
* vertices_edges_to_ugraph/3 <1>:        Documentation on exports (ugraphs).
* vertices_edges_to_ugraph/3:            Usage and interface (ugraphs).
* vertices_edges_to_wgraph/3 <1>:        Documentation on exports (wgraphs).
* vertices_edges_to_wgraph/3:            Usage and interface (wgraphs).
* views:                                 SQL persistent database interface.
* virtual:                               Documentation on new declarations (class).
* virtual/1 <1>:                         Documentation on new declarations (class).
* virtual/1:                             Usage and interface (class).
* virtual_method_spec/1 <1>:             Documentation on exports (objects_rt).
* virtual_method_spec/1:                 Usage and interface (objects_rt).
* vndict:                                Usage and interface (pretty_print).
* wakeup_exp/1 <1>:                      Documentation on exports (when).
* wakeup_exp/1:                          Usage and interface (when).
* WAM:                                   Acknowledgments.
* warning/1:                             Documentation on exports (io_aux).
* warning_message/1 <1>:                 Documentation on exports (messages).
* warning_message/1:                     Usage and interface (messages).
* warning_message/2 <1>:                 Documentation on exports (messages).
* warning_message/2:                     Usage and interface (messages).
* warning_message/3 <1>:                 Documentation on exports (messages).
* warning_message/3:                     Usage and interface (messages).
* Web interface <1>:                     *** PART VIII - Interfaces to other languages and systems.
* Web interface:                         PART VIII - Interfaces to other languages and systems.
* WebDB:                                 Persistent predicates.
* weekday/1 <1>:                         Documentation on exports (pillow_types).
* weekday/1:                             Usage and interface (pillow_types).
* wellformed_body/3 <1>:                 Documentation on exports (dynamic).
* wellformed_body/3:                     Usage and interface (dynamic).
* when/2 <1>:                            Documentation on exports (when).
* when/2 <2>:                            Usage and interface (when).
* when/2:                                Delaying predicates (when).
* WHERE-clause:                          Documentation on internals (pl2sql).
* WHERE-clauses:                         Documentation on internals (pl2sql).
* where/1 <1>:                           Documentation on exports (librowser).
* where/1:                               Usage and interface (librowser).
* whitespace/2 <1>:                      Documentation on exports (strings).
* whitespace/2:                          Usage and interface (strings).
* whitespace0/2 <1>:                     Documentation on exports (strings).
* whitespace0/2:                         Usage and interface (strings).
* why the name Ciao:                     About the name of the System.
* Win32:                                 Running executables from the command line.
* Win95/NT machine:                      Low-level socket interface to SQL/ODBC databases.
* windows shortcut:                      Win32 binary installation summary.
* WinZip:                                Win32 binary installation summary.
* Wlodek Drabent:                        Acknowledgments.
* word-help.el:                          Getting on-line help.
* working_directory/2 <1>:               Documentation on exports (system).
* working_directory/2:                   Usage and interface (system).
* write <1>:                             Usage and interface (bltclass).
* write <2>:                             Usage and interface (metaterms).
* write <3>:                             Usage and interface (jtopl).
* write <4>:                             Usage and interface (javart).
* write <5>:                             Usage and interface (db_client).
* write <6>:                             Usage and interface (pl2sql).
* write <7>:                             Usage and interface (tcltk).
* write <8>:                             Usage and interface (davinci).
* write <9>:                             Usage and interface (objects_rt).
* write <10>:                            Usage and interface (functions).
* write <11>:                            Usage and interface (argnames).
* write <12>:                            Usage and interface (pretty_print).
* write <13>:                            Usage and interface (runtime_ops).
* write <14>:                            Usage and interface (dynmods).
* write <15>:                            Usage and interface (format).
* write <16>:                            Usage and interface (iso).
* write <17>:                            Documentation on exports (io_aux).
* write <18>:                            Usage and interface (debugger).
* write:                                 Options available during debugging.
* write/1 <1>:                           Documentation on multifiles (write).
* write/1 <2>:                           Documentation on exports (write).
* write/1 <3>:                           Usage and interface (write).
* write/1 <4>:                           Documentation on exports (io_aux).
* write/1:                               Acknowledgements.
* write/2 <1>:                           Documentation on exports (sockets).
* write/2 <2>:                           Documentation on exports (write).
* write/2:                               Usage and interface (write).
* write_answer/1:                        Documentation on internals (jtopl).
* write_assertion/6 <1>:                 Documentation on exports (assrt_write).
* write_assertion/6:                     Usage and interface (assrt_write).
* write_assertion_as_comment/6 <1>:      Documentation on exports (assrt_write).
* write_assertion_as_comment/6:          Usage and interface (assrt_write).
* write_canonical/1 <1>:                 Documentation on exports (write).
* write_canonical/1:                     Usage and interface (write).
* write_canonical/2 <1>:                 Documentation on exports (write).
* write_canonical/2:                     Usage and interface (write).
* write_list1/1 <1>:                     Documentation on exports (write).
* write_list1/1:                         Usage and interface (write).
* write_option/1 <1>:                    Documentation on exports (write).
* write_option/1:                        Usage and interface (write).
* write_string/1 <1>:                    Documentation on exports (strings).
* write_string/1:                        Usage and interface (strings).
* write_string/2 <1>:                    Documentation on exports (strings).
* write_string/2:                        Usage and interface (strings).
* write_term/2 <1>:                      Documentation on exports (write).
* write_term/2:                          Usage and interface (write).
* write_term/3 <1>:                      Documentation on exports (write).
* write_term/3:                          Usage and interface (write).
* writeq/1 <1>:                          Documentation on exports (write).
* writeq/1 <2>:                          Usage and interface (write).
* writeq/1:                              Documentation on exports (io_aux).
* writeq/2 <1>:                          Documentation on exports (write).
* writeq/2:                              Usage and interface (write).
* writing programs:                      Commands which help in typing in programs.
* WWW browser:                           Testing your Ciao Un*x installation.
* WWW, interfacing with:                 The PiLLoW Web Programming Library.
* xbarelement1:                          genbar1 (library).
* xbarelement1/1 <1>:                    Documentation on internals (genbar1).
* xbarelement1/1:                        genbar1 (library).
* xbarelement2/1 <1>:                    Documentation on exports (genbar2).
* xbarelement2/1 <2>:                    Usage and interface (genbar2).
* xbarelement2/1:                        genbar2 (library).
* xbarelement3/1:                        Documentation on internals (genbar3).
* xbarelement4/1:                        Documentation on internals (genbar4).
* xelement/1:                            Documentation on internals (genmultibar).
* XML <1>:                               HTML/XML/CGI programming.
* XML:                                   The PiLLoW Web Programming Library.
* xml2terms/2 <1>:                       Documentation on exports (html).
* xml2terms/2:                           Usage and interface (html).
* yelement/1 <1>:                        Documentation on exports (genbar1).
* yelement/1:                            Usage and interface (genbar1).
* |/2:                                   Documentation on internals (basiccontrol).
* ~/.cshrc:                              Un*x user setup.
* ~/.emacs <1>:                          Win32 binary installation summary.
* ~/.emacs:                              Un*x user setup.
* ~/.profile:                            Un*x user setup.
* ~/1:                                   Usage and interface (functions).



Tag Table:
Node: Top6581
Node: Summary12390
Node: Introduction15768
Node: About this manual16211
Node: About the Ciao Prolog development system18581
Node: ISO-Prolog compliance versus extensibility21992
Node: About the name of the System24595
Node: Referring to Ciao27147
Node: Syntax terminology and notational conventions28133
Node: Predicates and their components28899
Node: Characters and character strings30071
Node: Predicate specs30936
Node: Modes31609
Node: Properties and types32627
Node: Declarations33613
Node: Operators34952
Node: A tour of the manual35852
Node: PART I - The program development environment36804
Node: PART II - The Ciao basic language (engine)38657
Node: PART III - ISO-Prolog library (iso)39403
Node: PART IV - Classic Prolog library (classic)40579
Node: PART V - Annotated Prolog library (assertions)41316
Node: PART VI - Ciao Prolog library miscellanea42097
Node: PART VII - Ciao Prolog extensions42920
Node: PART VIII - Interfaces to other languages and systems43851
Node: PART IX - Abstract data types44652
Node: PART X - Miscellaneous standalone utilities45078
Node: PART XI - Contributed libraries45480
Node: PART XII - Appendices45902
Node: Acknowledgments46289
Node: Version/Change Log (ciao)50139
Node: Getting started on Un*x-like machines57182
Node: Testing your Ciao Un*x installation58392
Node: Un*x user setup60684
Node: Using Ciao from a Un*x command shell62345
Node: Starting/exiting the top-level shell (Un*x)62871
Node: Getting help (Un*x)63589
Node: Compiling and running programs (Un*x)64109
Node: Generating executables (Un*x)65888
Node: Running Ciao scripts (Un*x)67208
Node: The Ciao initialization file (Un*x)68332
Node: Printing manuals (Un*x)69049
Node: An introduction to the Ciao emacs environment (Un*x)69736
Node: Keeping up to date (Un*x)73134
Node: Getting started on Windows machines73553
Node: Testing your Ciao Win32 installation74865
Node: Using Ciao from the Windows explorer and command shell77308
Node: Starting/exiting the top-level shell (Win32)77915
Node: Getting help (Win32)78521
Node: Compiling and running programs (Win32)79064
Node: Generating executables (Win32)80866
Node: Running Ciao scripts (Win32)82039
Node: The Ciao initialization file (Win32)83178
Node: Printing manuals (Win32)83907
Node: An introduction to the Ciao emacs environment (Win32)84495
Node: Keeping up to date (Win32)87913
Node: *** PART I - The program development environment88334
Node: The stand-alone command-line compiler90184
Node: Introduction to building executables91421
Node: Paths used by the compiler during compilation94792
Node: Running executables from the command line95547
Node: Types of executables generated98698
Ref: Types of executables generated-Footnote-1104846
Ref: Types of executables generated-Footnote-2105212
Node: Environment variables used by Ciao executables105818
Node: Intermediate files in the compilation process107307
Node: Usage (ciaoc)108359
Node: The interactive top-level shell110507
Node: Shell invocation and startup111619
Node: Shell interaction112741
Node: Entering recursive (conjunctive) shell levels115234
Node: Usage and interface (ciaosh)116791
Node: Documentation on exports (ciaosh)117912
Node: Documentation on internals (ciaosh)125653
Node: The interactive debugger126258
Node: Marking modules and files for debugging in the top-level debugger128949
Node: The debugging process132910
Node: Marking modules and files for debugging with the embedded debugger134399
Node: The procedure box control flow model136419
Node: Format of debugging messages141913
Node: Options available during debugging145388
Node: Calling predicates that are not exported by a module154197
Node: Acknowledgements154946
Node: Predicates controlling the interactive debugger155819
Node: Usage and interface (debugger)156628
Node: Documentation on exports (debugger)157517
Node: Documentation on internals (debugger)165290
Node: Known bugs and planned improvements (debugger)166255
Node: The script interpreter166727
Node: How it works168350
Node: Command line arguments in scripts170794
Node: Customizing library paths and path aliases171461
Node: Usage and interface (libpaths)172296
Node: Documentation on exports (libpaths)172880
Node: Documentation on multifiles (libpaths)173850
Node: Using Ciao inside GNU emacs174415
Node: Conventions for writing Ciao programs under Emacs177834
Node: Checking the installation178946
Node: Functionality and associated key sequences (bindings)179870
Node: Syntax coloring and syntax based editors180859
Node: Getting on-line help181542
Node: Loading and compiling programs183083
Node: Locating errors and checking the syntax of assertions187285
Node: Commands which help in typing in programs188235
Node: Debugging programs188933
Node: Preprocessing programs193135
Node: Version control196287
Node: Generating program documentation205544
Node: Setting the top-level207711
Node: Traditional Prolog Mode Commands210035
Node: Other commands210965
Node: Getting the Ciao/Prolog mode version211367
Node: Commands available in toplevel and preprocessor buffers211654
Node: Using Ciao/Prolog mode capabilities in standard shells212377
Node: Coexistence with other Prolog interfaces213506
Node: Customization214651
Node: Ciao variables215437
Node: CiaoPP variables217068
Node: LPdoc variables217504
Node: Installation of the Ciao/Prolog emacs interface218157
Node: Emacs version compatibility221804
Node: Acknowledgments (ciao.el)222183
Node: *** PART II - The Ciao basic language (engine)222724
Node: The module system223422
Node: Usage and interface (modules)226294
Node: Documentation on internals (modules)226634
Node: Directives for using code in other files234920
Node: Usage and interface (loading_code)235386
Node: Documentation on internals (loading_code)235788
Node: Control constructs/predicates238113
Node: Usage and interface (basiccontrol)238777
Node: Documentation on exports (basiccontrol)239421
Node: Documentation on internals (basiccontrol)243358
Node: Basic builtin directives244153
Node: Usage and interface (builtin_directives)245460
Node: Documentation on internals (builtin_directives)245854
Node: Basic data types and properties249673
Node: Usage and interface (basic_props)250428
Node: Documentation on exports (basic_props)251272
Node: Extra-logical properties for typing260726
Node: Usage and interface (term_typing)261374
Node: Documentation on exports (term_typing)261925
Node: Basic term manipulation266807
Node: Usage and interface (term_basic)267177
Node: Documentation on exports (term_basic)267685
Node: Comparing terms271218
Node: Usage and interface (term_compare)272601
Node: Documentation on exports (term_compare)273105
Node: Basic predicates handling names of constants279456
Node: Usage and interface (atomic_basic)280065
Node: Documentation on exports (atomic_basic)280657
Node: Arithmetic290233
Node: Usage and interface (arithmetic)291227
Node: Documentation on exports (arithmetic)291729
Node: Basic file/stream handling299030
Node: Usage and interface (streams_basic)299548
Node: Documentation on exports (streams_basic)300471
Node: Documentation on multifiles (streams_basic)316162
Node: Basic input/output317511
Node: Usage and interface (io_basic)318302
Node: Documentation on exports (io_basic)319009
Node: Exception handling329437
Node: Usage and interface (exceptions)329848
Node: Documentation on exports (exceptions)330307
Node: Changing system behaviour and various flags333988
Node: Usage and interface (prolog_flags)337195
Node: Documentation on exports (prolog_flags)337908
Node: Documentation on multifiles (prolog_flags)344121
Node: Fast/concurrent update of facts346138
Node: Usage and interface (data_facts)347750
Node: Documentation on exports (data_facts)348473
Node: Documentation on internals (data_facts)352977
Node: Extending the syntax353353
Node: Usage and interface (syntax_extensions)353904
Node: Documentation on internals (syntax_extensions)354286
Node: Message printing primitives362448
Node: Usage and interface (io_aux)362982
Node: Documentation on exports (io_aux)363436
Node: Known bugs and planned improvements (io_aux)367974
Node: Attributed variables368301
Node: Usage and interface (attributes)368883
Node: Documentation on exports (attributes)370770
Node: Documentation on multifiles (attributes)373987
Node: Gathering some basic internal info375548
Node: Usage and interface (system_info)376133
Node: Documentation on exports (system_info)376660
Node: Documentation on internals (system_info)381854
Node: *** PART III - ISO-Prolog library (iso)382397
Node: ISO-Prolog package383529
Node: Usage and interface (iso)383970
Node: All solutions predicates384416
Node: Usage and interface (aggregates)385289
Node: Documentation on exports (aggregates)385839
Node: Dynamic predicates389276
Node: Usage and interface (dynamic)390429
Node: Documentation on exports (dynamic)391068
Node: Documentation on multifiles (dynamic)396180
Node: Term input396602
Node: Usage and interface (read)396911
Node: Documentation on exports (read)397424
Node: Term output398650
Node: Usage and interface (write)399591
Node: Documentation on exports (write)400433
Node: Documentation on multifiles (write)409860
Node: Defining operators411467
Node: Usage and interface (operators)412687
Node: Documentation on exports (operators)413132
Node: iso_byte_char (library)414456
Node: Usage and interface (iso_byte_char)414716
Node: Documentation on exports (iso_byte_char)415342
Node: iso_misc (library)416931
Node: Usage and interface (iso_misc)417210
Node: Documentation on exports (iso_misc)417722
Node: iso_incomplete (library)418433
Node: Usage and interface (iso_incomplete)418726
Node: Documentation on exports (iso_incomplete)419150
Node: *** PART IV - Classic Prolog library (classic)419653
Node: Classic Prolog package420343
Node: Usage and interface (classic)420901
Node: Definite clause grammars421438
Node: Usage and interface (dcg)426491
Node: Definite clause grammars (expansion)426760
Node: Usage and interface (dcg_expansion)427094
Node: Documentation on exports (dcg_expansion)427649
Node: List processing428819
Node: Usage and interface (lists)429229
Node: Documentation on exports (lists)430165
Node: Sorting lists437767
Node: Usage and interface (sort)438110
Node: Documentation on exports (sort)438443
Node: Documentation on internals (sort)439763
Node: Dictionaries440115
Node: Usage and interface (dict)440487
Node: Documentation on exports (dict)440881
Node: String processing441518
Node: Usage and interface (strings)441989
Node: Documentation on exports (strings)442451
Node: Documentation on internals (strings)444547
Node: Formatted output444913
Node: Usage and interface (format)446357
Node: Documentation on exports (format)446875
Node: DEC-10 Prolog file IO454230
Node: Usage and interface (dec10_io)454640
Node: Documentation on exports (dec10_io)455163
Node: ttyout (library)455981
Node: Usage and interface (ttyout)456241
Node: Documentation on exports (ttyout)456746
Node: dynmods (library)457934
Node: Usage and interface (dynmods)458174
Node: Documentation on exports (dynmods)458742
Node: Quintus-like internal database459096
Node: Usage and interface (old_database)460285
Node: Documentation on exports (old_database)460726
Node: runtime_ops (library)462495
Node: Usage and interface (runtime_ops)462746
Node: *** PART V - Annotated Prolog library (assertions)463238
Node: The Ciao assertion package463970
Node: More info465735
Node: Some attention points466566
Node: Usage and interface (assertions)467748
Node: Documentation on new declarations (assertions)469169
Node: Documentation on exports (assertions)480995
Node: Types and properties related to assertions485372
Node: Usage and interface (assertions_props)485966
Node: Documentation on exports (assertions_props)486867
Node: Declaring regular types501107
Node: Defining properties502538
Node: Usage and interface (regtypes)510213
Node: Documentation on new declarations (regtypes)510812
Node: Properties which are native to analyzers514238
Node: Usage and interface (native_props)514944
Node: Documentation on exports (native_props)515940
Node: Meta-properties521974
Node: Usage and interface (meta_props)523013
Node: Documentation on exports (meta_props)523569
Node: Documentation on multifiles (meta_props)524696
Node: Documentation on internals (meta_props)525318
Node: Known bugs and planned improvements (meta_props)526582
Node: ISO-Prolog modes527011
Node: Usage and interface (isomodes)527569
Node: Documentation on new modes (isomodes)528137
Node: Classical Prolog modes530232
Node: Usage and interface (basicmodes)530969
Node: Documentation on new modes (basicmodes)531593
Node: Run-time checking of assertions535668
Node: Usage and interface (rtchecks)536447
Node: Documentation on multifiles (rtchecks)536929
Node: Known bugs and planned improvements (rtchecks)537708
Node: *** PART VI - Ciao Prolog library miscellanea538179
Node: Structured stream handling538967
Node: Usage and interface (streams)539309
Node: Documentation on exports (streams)539760
Node: Operating system utilities540437
Node: Usage and interface (system)541234
Node: Documentation on exports (system)542188
Node: Prolog system internal predicates552749
Node: Usage and interface (prolog_sys)553468
Node: Documentation on exports (prolog_sys)554000
Node: Documentation on internals (prolog_sys)560308
Node: Known bugs and planned improvements (prolog_sys)562966
Node: Atom to Term Conversion563489
Node: Usage and interface (atom2term)563918
Node: Documentation on exports (atom2term)564321
Node: ctrlcclean (library)565152
Node: Usage and interface (ctrlcclean)565436
Node: Documentation on exports (ctrlcclean)565930
Node: errhandle (library)566485
Node: Usage and interface (errhandle)566775
Node: Documentation on exports (errhandle)567159
Node: Fast Reading and Writing of Terms567618
Node: Usage and interface (fastrw)568220
Node: Documentation on exports (fastrw)568721
Node: File name manipulation569546
Node: Usage and interface (filenames)570055
Node: Documentation on exports (filenames)570580
Node: file_utils (library)574310
Node: Usage and interface (file_utils)574668
Node: Documentation on exports (file_utils)575202
Node: terms (library)577918
Node: Usage and interface (terms)578267
Node: Documentation on exports (terms)578627
Node: Printing status and error messages579175
Node: Usage and interface (messages)579774
Node: Documentation on exports (messages)580741
Node: Documentation on multifiles (messages)591580
Node: Known bugs and planned improvements (messages)592404
Node: A simple pretty-printer for Ciao programs592759
Node: Usage and interface (pretty_print)593339
Node: Documentation on exports (pretty_print)593876
Node: Documentation on internals (pretty_print)595069
Node: Pretty-printing assertions596861
Node: Usage and interface (assrt_write)597409
Node: Documentation on exports (assrt_write)597996
Node: The Ciao library browser599712
Node: Usage and interface (librowser)600880
Node: Documentation on exports (librowser)602254
Node: Documentation on internals (librowser)606592
Node: Code translation utilities607096
Node: Usage and interface (expansion_tools)608042
Node: Documentation on exports (expansion_tools)608789
Node: Documentation on internals (expansion_tools)613755
Node: Known bugs and planned improvements (expansion_tools)614545
Node: Low-level concurrency/multithreading primitives614891
Node: Usage and interface (concurrency)616898
Node: Documentation on exports (concurrency)617600
Node: Known bugs and planned improvements (concurrency)625810
Node: conc_aggregates (library)626659
Node: Usage and interface (conc_aggregates)627605
Node: Documentation on exports (conc_aggregates)628097
Node: Known bugs and planned improvements (conc_aggregates)628738
Node: The socket interface629120
Node: Usage and interface (sockets)629825
Node: Documentation on exports (sockets)630531
Node: *** PART VII - Ciao Prolog extensions635908
Node: Pure Prolog package636772
Node: Usage and interface (pure)638680
Node: argnames (library)638944
Node: Usage and interface (argnames)639155
Node: Independent and-parallel execution639722
Node: Usage and interface (andprolog)640526
Node: Documentation on exports (andprolog)641119
Node: Known bugs and planned improvements (andprolog)643316
Node: functions (library)644082
Node: Usage and interface (functions)644306
Node: Some Higher-Order Predicates644878
Node: Usage and interface (hiord)645562
Node: Documentation on exports (hiord)645927
Node: global (library)646815
Node: Usage and interface (global)647089
Node: Documentation on exports (global)647506
Node: Miscellaneous predicates648160
Node: Usage and interface (odd)648667
Node: Documentation on exports (odd)649016
Node: Delaying predicates (freeze)650645
Node: Usage and interface (freeze)651280
Node: Documentation on exports (freeze)651736
Node: Documentation on multifiles (freeze)652772
Node: Delaying predicates (when)653262
Node: Usage and interface (when)655011
Node: Documentation on exports (when)655599
Node: Documentation on multifiles (when)657313
Node: Known bugs and planned improvements (when)657844
Node: Active modules (high-level distributed execution)658180
Ref: Active modules (high-level distributed execution)-Footnote-1664007
Node: Usage and interface (actmods)664262
Node: Documentation on new declarations (actmods)664717
Node: Breadth-first execution665517
Node: Usage and interface (bf)666978
Node: Known bugs and planned improvements (bf)667363
Node: Iterative-deepening execution667626
Node: Usage and interface (id)671378
Node: Constraint programming over rationals671652
Node: Usage and interface (clpq)672357
Node: Other information (clpq)672690
Node: Some CLP(Q) examples672911
Node: Constraint programming over reals674390
Node: Usage and interface (clpr)674969
Node: Other information (clpr)675294
Node: Some CLP(R) examples675511
Node: Object oriented programming676134
Node: Early examples677326
Node: Recommendations on when to use objects683712
Node: Limitations on object usage685324
Node: Declaring classes and interfaces685751
Node: Usage and interface (class)686928
Node: Documentation on new declarations (class)688940
Node: Documentation on exports (class)697401
Node: Other information (class)702317
Node: Class and Interface error reporting at compile time703331
Node: Class and Interface error reporting at run time713799
Node: Normal Prolog module system interaction714274
Node: Known bugs and planned improvements (class)715537
Node: Compile-time usage of objects715858
Node: Usage and interface (objects)716463
Node: Documentation on new declarations (objects)717331
Node: Other information (objects)720994
Node: Error reporting at compile time (objects)722227
Node: Error reporting at run time (objects)728156
Node: Run time usage of objects729124
Node: Usage and interface (objects_rt)730401
Node: Documentation on exports (objects_rt)731459
Node: Known bugs and planned improvements (objects_rt)741965
Node: *** PART VIII - Interfaces to other languages and systems742635
Node: foreign_interface (library)743413
Node: Usage and interface (foreign_interface)743879
Node: Documentation on exports (foreign_interface)744525
Node: Utilities for on-demand compilation of foreign files746746
Node: Usage and interface (foreign_compilation)747799
Node: Documentation on exports (foreign_compilation)748392
Node: davinci (library)749922
Node: Usage and interface (davinci)750941
Node: Documentation on exports (davinci)751641
Node: The Tcl/Tk interface752768
Node: Usage and interface (tcltk)753407
Node: Documentation on exports (tcltk)754094
Node: The PiLLoW Web Programming Library760905
Node: Installing PiLLoW762056
Node: Usage and interface (pillow)762941
Node: HTML/XML/CGI programming763405
Node: Usage and interface (html)764138
Node: Documentation on exports (html)765090
Node: Documentation on multifiles (html)772992
Node: Other information (html)773546
Node: HTTP conectivity773931
Node: Usage and interface (http)774390
Node: Documentation on exports (http)774889
Node: PiLLoW types775976
Node: Usage and interface (pillow_types)776348
Node: Documentation on exports (pillow_types)776983
Node: Persistent predicate database793616
Node: Introduction to persistent predicates794516
Node: Persistent predicates796622
Node: Using file-based persistent predicates799798
Node: Implementation Issues801971
Node: Using persistent predicates from the top level803869
Node: Usage and interface (persdbrt)804983
Node: Documentation on exports (persdbrt)806341
Node: Documentation on multifiles (persdbrt)810081
Node: Documentation on internals (persdbrt)811427
Node: Known bugs and planned improvements (persdbrt)812215
Node: Using the persdb library813082
Node: An example of persistent predicates (static version)813782
Node: An example of persistent predicates (dynamic version)814753
Node: A simple application / a persistent queue815659
Node: SQL persistent database interface816941
Node: Implementation of the Database Interface818908
Node: Example(s)821549
Node: Usage and interface (persdbrtsql)825410
Node: Documentation on exports (persdbrtsql)826976
Node: Documentation on multifiles (persdbrtsql)836131
Node: Documentation on internals (persdbrtsql)837566
Node: Known bugs and planned improvements (persdbrtsql)840910
Node: Prolog to SQL translator841555
Node: Usage and interface (pl2sql)844212
Node: Documentation on exports (pl2sql)844979
Node: Documentation on multifiles (pl2sql)851352
Node: Documentation on internals (pl2sql)853842
Node: Known bugs and planned improvements (pl2sql)860718
Node: Low-level socket interface to SQL/ODBC databases861114
Ref: Low-level socket interface to SQL/ODBC databases-Footnote-1868607
Node: Usage and interface (db_client)869052
Node: Documentation on exports (db_client)870042
Node: Documentation on internals (db_client)878503
Node: Known bugs and planned improvements (db_client)879278
Node: Low-level Prolog to Java interface879657
Node: Low-Level Prolog to Java Interface Structure880480
Node: Prolog side881915
Node: Java side883316
Node: Java event handling from Prolog885776
Node: Java exception handling from Prolog887981
Node: Usage and interface (javart)889047
Node: Documentation on exports (javart)890044
Node: Low-level Java to Prolog interface899302
Node: Usage and interface (jtopl)901257
Node: Documentation on exports (jtopl)901856
Node: Documentation on internals (jtopl)902526
Node: Low-level Prolog to Java socket connection912502
Node: Usage and interface (javasock)913340
Node: Documentation on exports (javasock)913979
Node: Calling emacs from Prolog916776
Node: Usage and interface (emacs)918827
Node: Documentation on exports (emacs)919428
Node: linda (library)920601
Node: Usage and interface (linda)921136
Node: Documentation on exports (linda)921807
Node: *** PART IX - Abstract data types923344
Node: counters (library)923695
Node: Usage and interface (counters)923973
Node: Documentation on exports (counters)924361
Node: Identity lists924840
Node: Usage and interface (idlists)925241
Node: Documentation on exports (idlists)925700
Node: Term manipulation927481
Node: Usage and interface (metaterms)927756
Node: Documentation on exports (metaterms)928273
Node: Lists of numbers929202
Node: Usage and interface (numlists)929498
Node: Documentation on exports (numlists)930084
Node: Pattern (regular expression) matching932655
Node: Usage and interface (patterns)933161
Node: Documentation on exports (patterns)933804
Node: Graphs936888
Node: Usage and interface (graphs)937300
Node: Documentation on exports (graphs)937887
Node: Documentation on internals (graphs)940978
Node: Unweighted graph-processing utilities941371
Node: Usage and interface (ugraphs)942567
Node: Documentation on exports (ugraphs)943253
Node: wgraphs (library)945295
Node: Usage and interface (wgraphs)945657
Node: Documentation on exports (wgraphs)946112
Node: Labeled graph-processing utilities946416
Node: Usage and interface (lgraphs)946818
Node: Documentation on exports (lgraphs)947358
Node: queues (library)947808
Node: Usage and interface (queues)948078
Node: Documentation on exports (queues)948459
Node: Random numbers949011
Node: Usage and interface (random)949442
Node: Documentation on exports (random)949801
Node: sets (library)950646
Node: Usage and interface (sets)951049
Node: Documentation on exports (sets)951818
Node: Variable name dictionaries955650
Node: Usage and interface (vndict)956076
Node: Documentation on exports (vndict)956821
Node: *** PART X - Miscellaneous standalone utilities960545
Node: A Program to Help Cleaning your Directories961098
Node: Usage (cleandirs)961685
Node: Known bugs and planned improvements (cleandirs)963192
Node: Printing the declarations and code in a file963562
Node: Usage (fileinfo)964567
Node: More detailed explanation of options (fileinfo)965326
Node: Printing the contents of a bytecode file966675
Node: Usage (viewpo)967279
Node: Crossed-references of a program967577
Node: Gathering the dependent files for a file969993
Node: Usage (get_deps)970933
Node: Finding differences between two Prolog files971352
Node: Usage (pldiff)972009
Node: Known bugs and planned improvements (pldiff)972473
Node: The Ciao lpmake scripting facility972913
Node: Find out which architecture we are running on975224
Node: Usage (ciao_get_arch)976003
Node: More details976254
Node: *** PART XI - Contributed libraries976436
Node: Programming MYCIN rules976849
Node: Usage and interface (mycin)978011
Node: Documentation on new declarations (mycin)978487
Node: Known bugs and planned improvements (mycin)979523
Node: A Chart Library980020
Node: Bar charts981472
Ref: Bar charts-Footnote-1986821
Node: Line graphs986963
Node: Scatter graphs989971
Node: Tables992989
Node: Overview of widgets994561
Node: Usage and interface (chartlib)998093
Node: Documentation on exports (chartlib)998787
Node: Low level Interface between Prolog and blt1004206
Node: Usage and interface (bltclass)1004867
Node: Documentation on exports (bltclass)1005529
Node: chartlib_errhandle (library)1006651
Node: Usage and interface (chartlib_errhandle)1007290
Node: Documentation on exports (chartlib_errhandle)1007901
Node: Documentation on internals (chartlib_errhandle)1008850
Node: Color and Pattern Library1009596
Node: Usage and interface (color_pattern)1009977
Node: Documentation on exports (color_pattern)1010648
Node: genbar1 (library)1015060
Node: Usage and interface (genbar1)1016782
Node: Documentation on exports (genbar1)1017500
Node: Documentation on internals (genbar1)1023590
Node: genbar2 (library)1025458
Node: Usage and interface (genbar2)1027149
Node: Documentation on exports (genbar2)1027831
Node: genbar3 (library)1031640
Node: Usage and interface (genbar3)1032705
Node: Documentation on exports (genbar3)1033329
Node: Documentation on internals (genbar3)1035269
Node: genbar4 (library)1036843
Node: Usage and interface (genbar4)1037925
Node: Documentation on exports (genbar4)1038550
Node: Documentation on internals (genbar4)1040837
Node: gengraph1 (library)1042062
Ref: gengraph1 (library)-Footnote-11044772
Node: Usage and interface (gengraph1)1044877
Node: Documentation on exports (gengraph1)1045738
Node: gengraph2 (library)1054786
Ref: gengraph2 (library)-Footnote-11056984
Node: Usage and interface (gengraph2)1057081
Node: Documentation on exports (gengraph2)1057827
Node: genmultibar (library)1063941
Node: Usage and interface (genmultibar)1066749
Node: Documentation on exports (genmultibar)1067388
Node: Documentation on internals (genmultibar)1069584
Node: table_widget1 (library)1071511
Node: Usage and interface (table_widget1)1072087
Node: Documentation on exports (table_widget1)1072745
Node: Documentation on internals (table_widget1)1074639
Node: table_widget2 (library)1075719
Node: Usage and interface (table_widget2)1076315
Node: Documentation on exports (table_widget2)1076948
Node: table_widget3 (library)1078495
Node: Usage and interface (table_widget3)1079125
Node: Documentation on exports (table_widget3)1079758
Node: table_widget4 (library)1080883
Node: Usage and interface (table_widget4)1081488
Node: Documentation on exports (table_widget4)1082121
Node: test_format (library)1083952
Node: Usage and interface (test_format)1084822
Node: Documentation on exports (test_format)1085471
Node: *** PART XII - Appendices1087722
Node: Installing Ciao from the source distribution1088140
Node: Installing Ciao from a Win32 binary distribution1089265
Node: Win32 binary installation summary1090626
Node: Checking for correct installation on Win321095804
Node: Compiling the miscellaneous utilities under Windows1099365
Node: Server installation under Windows1100015
Node: Uninstallation under Windows1100988
Node: Beyond installation1101953
Node: Architecture-specific notes and limitations1102405
Node: Keeping up to date with the Ciao users mailing list1103799
Node: Downloading new versions1104833
Node: Reporting bugs1105283
Node: References1106269
Node: Library/Module Definition Index1122413
Node: Predicate/Method Definition Index1131718
Node: Property Definition Index1190017
Node: Regular Type Definition Index1196263
Node: Declaration Definition Index1208726
Node: Concept Definition Index1213840
Node: Global Index1241657

End Tag Table
