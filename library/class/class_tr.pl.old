%%------------------------------------------------------------------------
%%
%% O'CIAO: Object Oriented Programming in CIAO/Prolog
%%
%% SOURCE-TO-SOURCE EXPANSION FOR CLASS DECLARATION
%%
%% AUTHOR : Angel Fernandez Pineda
%% DATE   : Febrary 1999
%%
%%------------------------------------------------------------------------

:- module(class_tr,[class_sentence_trans/2,class_clause_trans/2,classdebug/1]).

%%------------------------------------------------------------------------

:- use_module(library('compiler/c_itf')).
:- use_module(library(lists),[append/3]).
:- use_module(library(filenames),[no_path_file_name/2]).
:- use_module(library(aggregates),[findall/3]).

%%------------------------------------------------------------------------

:- data debug/0.               % Show expanded clauses.

:- data module/1.              % Current module/class name.
:- data base/1.                % Current module/class base name.
:- data super/1.               % Name of super class.
:- data super_source/1.        % Source file for super class.

:- data initial_state/1.       % FACT must be present at instance creation.

:- data is_inheritable/2.      % F/A may be inherited.
:- data is_public/2.           % F/A was declared as public.

:- data is_multifile/2.        % F/A is multifile.
:- data is_state/2.            % F/A is data or dynamic.
:- data is_method/2.           % F/A is a class method.
:- data is_virtual/2.          % F/A is a virtual method.
:- data is_concurrent/2.       % F/A is a concurrent method or attribute.
:- data is_metapredicate/1.    % Spec is a meta_predicate specification.

:- data to_export/2.           % F/A should be exported for code optimization.

:- dynamic check/1.            % Tell the compiler to perform
                               % additional checks.

%%------------------------------------------------------------------------

:- include(library('class/class_tr_aux')). % for "second pass" expansion.

%%------------------------------------------------------------------------

% debug.

classdebug(on) :-
	asserta_fact(debug).

classdebug(off) :- 
	retract_fact(debug).

%%------------------------------------------------------------------------
%%
%% INITIALIZATION
%%
%%------------------------------------------------------------------------

class_sentence_trans(start_of_file(Base),_) :-
	defines_module(Base,Module),
	set_fact(module(Module)),
	set_fact(base(Base)),
	retractall_fact(super(_)),
	retractall_fact(super_source(_)),
	retractall_fact(is_inheritable(_,_)),
	retractall_fact(is_public(_,_)),
	retractall_fact(is_method(_,_)),
	retractall_fact(is_virtual(_,_)),
	retractall_fact(is_metapredicate(_)),
	retractall_fact(is_state(_,_)),
	retractall_fact(is_multifile(_,_)),
	retractall_fact(is_concurrent(_,_)),
	retractall_fact(initial_state(_)),
	retractall_fact(to_export(_,_)),
	message(note,[Module,' class declaration in progress']),
	retractall(check(_)),
	add_module_check(check),
	!,
	fail.

%%------------------------------------------------------------------------
%%
%% END OF FILE ADD-ON
%%
%% Notice: all called goals are assumed not to fail.
%%------------------------------------------------------------------------

class_sentence_trans(end_of_file,FinalClauses) :-
	module(_),
	!,
	generate_fixed_clauses(FixedClauses),
	generate_initial_state_clauses(InitialStateClauses),
	generate_class_template(TemplateClauses),
	generate_interface_info(InterfaceClauses),
	generate_metapredicate_decls(MetaPredDecls),
	generate_calling_optimization(OptimizationClauses),
	generate_redefinition_clauses(RedefClauses),
	findall((:- method(F/A)),is_method(F,A),MethodDecls),
	findall((:- attribute(F/A)),is_state(F,A),AttrDecls),
	%
	append(FixedClauses,InitialStateClauses,Aux1),
	append(Aux1,TemplateClauses,Aux2),
	append(Aux2,InterfaceClauses,Aux3),
	append(Aux3,OptimizationClauses,Aux4),
	append(Aux4,MethodDecls,Aux5),
	append(Aux5,AttrDecls,Aux6),
	append(Aux6,MetaPredDecls,Aux7),
	append(Aux7,RedefClauses,Aux8),
	append(Aux8,[end_of_file],FinalClauses),
	( debug ->
	  (
	      nl,display('End of expansion clauses: '),nl,
	      inform_user(FinalClauses),nl
	  ) ; true
	),
	true.

%%------------------------------------------------------------------------
%%
%% DECLARATIONS
%%
%%------------------------------------------------------------------------

%%------------------------------------------------------------------------
%% NORMALIZE MULTIPLE-SPEC DECLARATIONS
%%------------------------------------------------------------------------

class_sentence_trans((:- IsDecl),Exp) :-
	functor(IsDecl,Decl,1),
	( Decl = public ;
	  Decl = inheritable ;
	  Decl = data ;
	  Decl = dynamic ;
	  Decl = meta_predicate ;
	  Decl = multifile ;
	  Decl = concurrent ;
	  Decl = discontiguous ;
	  Decl = virtual
	),
	arg(1,IsDecl,Arg),
	functor(Arg,',',2),
	!,
	sequence_to_list(Arg,List),
	functor(NewDecl,Decl,1),
	arg(1,NewDecl,List),
	class_sentence_trans((:- NewDecl),Exp).

class_sentence_trans((:- public([])),[]) :-
	!.

class_sentence_trans((:- public([Spec|Nsp])),Exp) :-
	!,
	class_sentence_trans((:- public(Spec)),OneDeclExp),
	class_sentence_trans((:- public(Nsp)),NExp),
	append(OneDeclExp,NExp,Exp).

class_sentence_trans((:- inheritable([])),[]) :-
	!.

class_sentence_trans((:- inheritable([Spec|Nsp])),Exp) :-
	!,
	class_sentence_trans((:- inheritable(Spec)),OneDeclExp),
	class_sentence_trans((:- inheritable(Nsp)),NExp),
	append(OneDeclExp,NExp,Exp).

class_sentence_trans((:- virtual([])),[]) :-
	!.

class_sentence_trans((:- virtual([Spec|Nsp])),Exp) :-
	!,
	class_sentence_trans((:- virtual(Spec)),OneDeclExp),
	class_sentence_trans((:- virtual(Nsp)),NExp),
	append(OneDeclExp,NExp,Exp).

class_sentence_trans((:- data([])),[]) :-
	!.

class_sentence_trans((:- data([Spec|Nsp])),Exp) :-
	!,
	class_sentence_trans((:- data(Spec)),OneDeclExp),
	class_sentence_trans((:- data(Nsp)),NExp),
	append(OneDeclExp,NExp,Exp).

class_sentence_trans((:- dynamic([])),[]) :-
	!.

class_sentence_trans((:- dynamic([Spec|Nsp])),Exp) :-
	!,
	class_sentence_trans((:- public(Spec)),OneDeclExp),
	class_sentence_trans((:- public(Nsp)),NExp),
	append(OneDeclExp,NExp,Exp).

class_sentence_trans((:- concurrent([])),[]) :-
	!.

class_sentence_trans((:- concurrent([Spec|Nsp])),Exp) :-
	!,
	class_sentence_trans((:- concurrent(Spec)),OneDeclExp),
	class_sentence_trans((:- concurrent(Nsp)),NExp),
	append(OneDeclExp,NExp,Exp).

class_sentence_trans((:- multifile([])),[]) :-
	!.

class_sentence_trans((:- multifile([Spec|Nsp])),Exp) :-
	!,
	class_sentence_trans((:- concurrent(Spec)),OneDeclExp),
	class_sentence_trans((:- concurrent(Nsp)),NExp),
	append(OneDeclExp,NExp,Exp).

class_sentence_trans((:- meta_predicate([])),[]) :-
	!.

class_sentence_trans((:- meta_predicate([Spec|Nsp])),Exp) :-
	!,
	class_sentence_trans((:- concurrent(Spec)),OneDeclExp),
	class_sentence_trans((:- concurrent(Nsp)),NExp),
	append(OneDeclExp,NExp,Exp).

class_sentence_trans((:- discontiguous([])),[]) :-
	!.

class_sentence_trans((:- discontiguous([Spec|Nsp])),Exp) :-
	!,
	class_sentence_trans((:- discontiguous(Spec)),OneDeclExp),
	class_sentence_trans((:- discontiguous(Nsp)),NExp),
	append(OneDeclExp,NExp,Exp).

%%------------------------------------------------------------------------
%% AVOID RESERVED DECLARATIONS
%%------------------------------------------------------------------------

class_sentence_trans((:- super(_)),[]) :-
	!,
	true.

class_sentence_trans((:- method(_)),[]) :-
	!,
	true.

class_sentence_trans((:- attribute(_)),[]) :-
	!,
	true.

%%------------------------------------------------------------------------
%% INHERITANCE DECLARATION
%%------------------------------------------------------------------------

class_sentence_trans((:- inherit_class(_)),[]) :-
	super(_),
	!,
	message(error,'multiple inheritance not allowed').

class_sentence_trans((:- inherit_class(SuperSource)),
	[
	    (:- use_module(SuperSource)),
	    (:- multifile 'class$super'/2),
	    (:- super(Super)),
	    ('class$super'(Module,Super))
	]) :-
	module(Module),
	base(Base),
	class_from_base(SuperSource,Super),
	set_fact(super(Super)),
	set_fact(super_source(SuperSource)),
	assertz((
	   check(Base) :- 
	      superbase(SuperBase),
	      \+ c_itf:includes(SuperBase,library(class)),
	      message(error,
	        ['inherited ',Super,' must be a class']),
	      set_fact(c_itf:module_error)
	)),
	assertz((
	   check(Base) :- 
	      superbase(SuperBase),
	      c_itf:decl(SuperBase,inheritance_line(Base,InhLine)),
	      member(Module,InhLine),
	      message(error,
	       ['circular inheritance: ',Super,' is not a valid super-class']),
	      set_fact(c_itf:module_error)
	)),
	!.

class_sentence_trans((:- inherit_class(_)),[]) :-
	message(error,'invalid inheritance declaration'),
	!.

%%------------------------------------------------------------------------
%% KEEP TRACKING OF METAPREDICATE DECLARATIONS
%%------------------------------------------------------------------------
	
class_sentence_trans((:- meta_predicate(Spec)),[]) :-
	Spec =.. [_|SpecArgs],
	functor(Spec,F,A),
	\+ is_multifile(F,A),
	has_addmodule(SpecArgs),
	!,
	message(error,[
		'sorry, addmodule meta-arg is not allowed at ',
		F,'/',A]).

class_sentence_trans((:- meta_predicate(Spec)),[]) :-
	functor(Spec,F,A),
	\+ is_multifile(F,A),
	assertz_fact(is_metapredicate(Spec)),
	!,
	true.

%%------------------------------------------------------------------------
%% KEEP TRACKING OF DATA DECLARATIONS
%%------------------------------------------------------------------------

% 1st case: normalize attribute declarations 

class_sentence_trans((:- dynamic(F/A)),Exp) :-
	!,
	class_sentence_trans((:- data(F/A)),Exp).

% 2nd case: invalid spec.

class_sentence_trans((:- data(F/A)),[]) :-
	( (\+ atom(F)) ; (\+ integer(A)) ),
	!,
	message(error,
	['invalid attribute declaration for ',F,'/',A]).

% 3rd case: already declared as method.

class_sentence_trans((:- data(F/A)),[]) :-
	is_method(F,A),
	!,
	message(error,['pretended attribute ',F,'/',A,
	 ' was assumed to be a method']),
	true.

% 4nd case: already declared.

class_sentence_trans((:- data(F/A)),[]) :-
	is_state(F,A),
	!,
	true.

% 5rd case: multifile declaration already found.

class_sentence_trans((:- data(F/A)),[]) :-
	is_multifile(F,A),
	!,
	fail.

% 6th case: predicate is reserved.

class_sentence_trans((:- data(destructor/0)),[]) :-
	!,
	message(error,
	 ['destructor/0 is not allowed to be an attribute']).

class_sentence_trans((:- data(Module/A)),[]) :-
	module(Module),
	!,
	message(error,
	 [Module,'/',A,' is not allowed to be an attribute']).

% 7th case: valid attribute declaration.

class_sentence_trans((:- data(F/A)),[]) :-
	asserta_fact(is_state(F,A)),
	!,
	fail.

%%------------------------------------------------------------------------
%% KEEP TRACKING OF MULTIFILE DECLARATIONS
%%------------------------------------------------------------------------

% 0 case : F/A is a reserved predicate.

class_sentence_trans((:- multifile(destructor/0)),[]) :-
	!,
	message(error,
	 ['invalid multifile: destructor/0 is a reserved predicate']).

class_sentence_trans((:- multifile(Module/A)),[]) :-
	module(Module),
	!,
	message(error,
	 ['invalid multifile: ',Module,'/',A,' is a reserved predicate']).

% 1st case : F/A was declared dynamic before multifile

class_sentence_trans((:- multifile(F/A)),[]) :-
	is_state(F,A),
	!,
	retract_fact(is_state(F,A)),
	asserta_fact(is_multifile(F,A)),
	fail.

% 2nd case : F/A was declared method before multifile

class_sentence_trans((:- multifile(F/A)),[]) :-
	is_method(F,A),
	!,
	message(error,
	 ['multifile declaration of ',F,'/',A,
          ' ignored: it was assumed to be a method']),
	true.

% 3rd case : valid multifile declaration.

class_sentence_trans((:- multifile(F/A)),[]) :-
	atom(F),
	integer(A),
	!,
	asserta_fact(is_multifile(F,A)),
	base(Base),
	assertz((
	       check(Base) :- 
		  superbase(SuperBase),
	          c_itf:decl(SuperBase,inheritable(F/A)),
		  message(warning,
	           ['multifile ',F,'/',A,' hides inherited predicate'])
	)),
	fail.

% 4th case : invalid multifile declaration.

class_sentence_trans((:- multifile(S)),[]) :-
	!,
	message(error,
	 ['invalid multifile declaration: ',multifile(S)]).

%%------------------------------------------------------------------------
%% KEEP TRACKING OF DISCONTIGUOUS DECLARATIONS
%%------------------------------------------------------------------------

class_sentence_trans((:- discontiguous(F/A)),[]) :-
	is_state(F,A),
	!.

class_sentence_trans((:- discontiguous(F/A)),[]) :-
	is_multifile(F,A),
	!,
	fail.

class_sentence_trans((:- discontiguous(F/A)),[(:- discontiguous(NF/NA))]) :-
	is_method(F,A),
	!,
	atom_concat('obj$',F,NF),
	NA is A+1.

class_sentence_trans((:- discontiguous(F/A)),
	[(:- discontiguous(F/NA)),(:- discontiguous(NF/A))] ) :-
	!,
	atom_concat('obj$',F,NF),
	NA is A+1.

%%------------------------------------------------------------------------
%% KEEP TRACKING OF CONCURRENT DECLARATIONS
%%------------------------------------------------------------------------

class_sentence_trans((:- concurrent(F/A)),[]) :-
	is_multifile(F,A),
	!,
	fail.

class_sentence_trans((:- concurrent(F/A)),[(:- concurrent(NF/NA))]) :-
	is_method(F,A),
	!,
	atom_concat('obj$',F,NF),
	NA is A+1.

class_sentence_trans((:- concurrent(F/A)),[(:- concurrent(F/NA))]) :-
	!,
	NA is A+1,
	( is_concurrent(F,A) -> true ; asserta_fact(is_concurrent(F,A)) ).

%%------------------------------------------------------------------------
%% PUBLIC PREDICATE DECLARATION
%%------------------------------------------------------------------------

class_sentence_trans((:- export(X)),Exp) :-
	!,
	class_sentence_trans((:- public(X)),Exp).

class_sentence_trans((:- public(F/A)),[]) :-
	atom(F),
	integer(A),
	!,
	( is_public(F,A) -> true ; asserta_fact(is_public(F,A)) ),
	true.

class_sentence_trans((:- public(S)),[]) :-
	!,
	message(error,
	 ['invalid public declaration: ',public(S)]).

%%------------------------------------------------------------------------
%% INHERITABLE PREDICATE DECLARATION
%%------------------------------------------------------------------------

class_sentence_trans((:- inheritable(F/A)),[]) :-
	atom(F),
	integer(A),
	!,
	( is_inheritable(F,A) -> true ; asserta_fact(is_inheritable(F,A)) ),
	true.

class_sentence_trans((:- inheritable(X)),[]) :-
	!,
	message(error,['invalid inheritable declaration: ',
	 inheritable(X)]).

%%------------------------------------------------------------------------
%% VIRTUAL PREDICATE DECLARATION
%%------------------------------------------------------------------------

class_sentence_trans((:- virtual(destructor/0)),[]) :-
	!,
	message(error,
	 ['destructor/0 is not allowed to be virtual']).

class_sentence_trans((:- virtual(Module/A)),[]) :-
	module(Module),
	!,
	message(error,
	 [Module,'/',A,' is not allowed to be virtual']).

class_sentence_trans((:- virtual(F/A)),[]) :-
	atom(F),
	integer(A),
	!,
	( is_virtual(F,A) -> true ; asserta_fact(is_virtual(F,A)) ),
	true.

class_sentence_trans((:- virtual(X)),[]) :-
	!,
	message(error,['invalid virtual declaration: ',
	 virtual(X)]).

%%------------------------------------------------------------------------

class_sentence_trans((:-_),_) :-
	!,
	fail.

%%------------------------------------------------------------------------
%%
%% DECLARE INITIAL STATE
%%
%%------------------------------------------------------------------------

class_sentence_trans((Head :- _),[]) :-
	functor(Head,F,A),
	is_state(F,A),
	!,
	message(error,['clause of ',F,'/',A,' ignored : ',
	  'only facts are allowed as initial state']).

class_sentence_trans((Head),[]) :-
	functor(Head,F,A),
	is_state(F,A),
	\+ is_multifile(F,A),
	!,
	module(Class),
	attribute_head(Class,Head,NewHead),
	assertz_fact(initial_state(NewHead)),
	fail.

%%------------------------------------------------------------------------
%%
%% CONSTRUCTOR DECLS
%%
%%------------------------------------------------------------------------

class_sentence_trans((Head :- _),_) :-
	module(Module),
	functor(Head,Module,Arity),
	( is_inheritable(Module,Arity) -> true ;
	  asserta_fact(is_inheritable(Module,Arity))
	),
	fail.

class_sentence_trans((Head),_) :-
	module(Module),
	functor(Head,Module,Arity),
	( is_inheritable(Module,Arity) -> true ;
	  asserta_fact(is_inheritable(Module,Arity))
	),
	fail.

%%------------------------------------------------------------------------
%%
%% METHOD CLAUSE RECOGNITION
%%
%% METHOD BODY WILL BE EXPANDED AT SECOND PASS
%%------------------------------------------------------------------------

class_sentence_trans((Head :- Body),[(NewHead :- Body)]) :-
	functor(Head,F,A),
	\+ is_state(F,A),
	\+ is_multifile(F,A),
	!,
	method_head(Head,NewHead,_),
	( is_method(F,A) -> true ; asserta_fact(is_method(F,A)) ),
	true.

class_sentence_trans((Head),[(NewHead)]) :-
	functor(Head,F,A),
	\+ functor(Head,':-',_),
	\+ is_state(F,A),
	\+ is_multifile(F,A),
	!,
	method_head(Head,NewHead,_),
	( is_method(F,A) -> true ; asserta_fact(is_method(F,A)) ),
	true.

%%------------------------------------------------------------------------
%%
%% METHOD BODY EXPANSION
%% (ALSO CALLED "SECOND PASS EXPANSION").
%%
%% method_expansion/4 is defined in class_tr_aux.pl
%%------------------------------------------------------------------------

class_clause_trans(clause(0,0),clause(0,0)) :-
	!,
	super(_),
	itf_second_pass.

class_clause_trans(clause(Head,Body),clause(Head,NewBody)) :-
	functor(Head,F,LastArgNumber),
	\+ is_multifile(F,LastArgNumber),
	LastArgNumber > 0,
	arg(LastArgNumber,Head,LastArg),
	var(LastArg),
	!,
	method_expansion(Body,LastArg,NewBody),
	( debug ->
	  (
	      inform_user(['-- expanded body of ',Head,':']),nl,
	      inform_user([NewBody]),nl,nl
	  ) ; true
	),
	true.

%%------------------------------------------------------------------------
%%
%% GENERATE FIXED END-OF-EXPANSION CLAUSES
%%
%%------------------------------------------------------------------------

generate_fixed_clauses(FixedClauses) :-
	module(Module),
	FixedClauses =
	[
	    (:- discontiguous('class$template'/4)),
	    (:- discontiguous('class$public'/3)),
	    (:- discontiguous('class$inheritable'/3)),
	    (:- multifile     '$class$'/1),
	    (:- multifile     'class$inheritable'/3),
	    (:- multifile     'class$public'/3),
	    (:- multifile     'class$virtual'/3),
	    (:- multifile     'class$initial_state'/2),
	    (:- multifile     'class$method'/4),
	    (:- multifile     'class$attribute'/5),
	    ('$class$'(Module))
	],
	true.

%%------------------------------------------------------------------------
%%
%% GENERATE STATE INITIALIZATION CLAUSES
%%
%%------------------------------------------------------------------------

generate_initial_state_clauses(InitialStateClauses) :-
	module(Module),
	findall(
	  'class$initial_state'(Module,Fact),
	  initial_state(Fact),
	  InitialStateClauses
	),
	true.

%%------------------------------------------------------------------------
%%
%% GENERATE CLASS TEMPLATE CLAUSES
%%
%%------------------------------------------------------------------------

generate_class_template(Clauses) :-
	module(Module),
	findall(
	  'class$method'(Module,F/A,MethodHead,CodeHead),
	  (
	      is_method(F,A),
	      functor(MethodHead,F,A),
	      method_head(MethodHead,CodeHead,_)
	  ),
	  MethodClauses
	),
	findall(
	  'class$attribute'(Module,F,A,RealF,Props),
	  (
	      is_state(F,A),
	      atom_concat(Module,'::',Aux),
	      atom_concat(Aux,F,RealF),
	      ( is_concurrent(F,A) -> 
		Props = [concurrent] 
	      ;
		Props = []
	      )
	  ),
	  StateClauses
	),
	append(StateClauses,MethodClauses,Clauses).

%%------------------------------------------------------------------------
%%
%% GENERATE META PREDICATE SPECIFICATION DECLS.
%%
%%------------------------------------------------------------------------

generate_metapredicate_decls(Decls) :-
	findall(
		   meta(F,A,Spec),
		   (is_metapredicate(Spec),
		    functor(Spec,F,A)
		   ),
		   PreviousMetaDecls
	),
	metapredicate_decl(PreviousMetaDecls,Decls).

metapredicate_decl([],[]).

metapredicate_decl([meta(F,A,Spec)|Nm],[(:- meta_predicate(NewSpec))|N] ) :-
	is_method(F,A),
	!,
	method_head(Spec,NewSpec,'?'),
	metapredicate_decl(Nm,N).

metapredicate_decl([meta(F,A,_)|Nm],N) :-
	is_state(F,A),
	!,
	message(warning,
	 ['meta-predicate specification of ',F,'/',A,
	  ' ignored since this is an attribute']),
	metapredicate_decl(Nm,N).

metapredicate_decl([meta(_,_,Spec)|Nm],[(:- meta_predicate(Spec))|N]) :-
	metapredicate_decl(Nm,N).
	
%%------------------------------------------------------------------------
%%
%% GENERATE CLASS INTERFACE INFO
%%
%%------------------------------------------------------------------------

generate_interface_info(Interface) :-
	findall(v(F,A),is_virtual(F,A),VirtualList),
	findall(e(F,A),is_public(F,A),ExportList),
	findall(i(F,A),(is_inheritable(F,A) ; is_public(F,A)),
               InheritableList),
	public_info(ExportList,Public),
	inheritable_info(InheritableList,Inheritable),
	virtual_info(VirtualList,Virtual),
	append(Public,Inheritable,Aux),
	append(Aux,Virtual,Interface),
	true.

%%------------------------------------------------------------------------
%% GENERATE PUBLIC INTERFACE INFORMATION
%%------------------------------------------------------------------------

public_info([],[]).

% 1st case: public predicate is a multifile: not allowed.

public_info([e(F,A)|Ne],Nc) :-
	is_multifile(F,A),
	!,
	retract_fact(is_public(F,A)),
	message(error,['multifile ',F,'/',A,' is not allowed to be ',
	 'public.']),
	public_info(Ne,Nc).

% 2nd case: exported predicate is data or dynamic.

public_info([e(F,A)|Ne],
	[
	  ('class$public'(Module,F,A)), 
	  (:- public(F/A))
	| Nc]) :-
	is_state(F,A),
	!,
	module(Module),
	asserta_fact(to_export(F,A)),
	public_info(Ne,Nc).

% 3rd case: exported predicate is a method.

public_info([e(destructor,0)|_],_) :-
	message(warning,['class destructor is public !!!']),
	fail.

public_info([e(F,A)|Ne],
	[
	  ('class$public'(Module,F,A)), 
	  (:- public(F/A))
	| Nc]) :-
	is_method(F,A),
	!,
	module(Module),
	asserta_fact(to_export(F,A)),
	public_info(Ne,Nc).

% 4th case: exported predicate was not defined in current source,
%           so it must be defined at super class.

public_info([e(F,A)|Ne],
	[
	  ('class$public'(Module,F,A)), 
	  (:- public(F/A))
	| Nc ] ):-
	super(_),
	!,
	module(Module),
	base(Base),
	asserta_fact(to_export(F,A)),
	assertz((  
	       check(Base) :- 
		  superbase(SuperBase),
	          \+ c_itf:decl(SuperBase,inheritable(F/A)),
		  message(error,['public predicate ',F,'/',A,
		    ' is not defined nor inherited in this class']),
		  set_fact(module_error)
	)),
	public_info(Ne,Nc).

% 5th case: exported predicate was not defined in current source,
%           but there is no inheritance declaration.

public_info([e(F,A)|Ne],Nc) :-
	!,
	retract_fact(is_public(F,A)),
	message(error,['public predicate ',F,'/',A,
	 ' is not defined nor inherited in this class']),
	public_info(Ne,Nc).

%%------------------------------------------------------------------------
%% GENERATE INHERITABLE INTERFACE INFORMATION
%%------------------------------------------------------------------------

inheritable_info([],[]).

% 1st case: inheritable predicate is a multifile: not allowed.

inheritable_info([i(F,A)|Ne],Nc) :-
	is_multifile(F,A),
	!,
	message(error,['multifile ',F,'/',A,' is not allowed to be ',
	 'inheritable.']),
	inheritable_info(Ne,Nc).

% 2nd case: inheritable predicate is data or dynamic.

inheritable_info([i(F,A)|Ne],
	[(:- inheritable(F/A)),
	 ('class$inheritable'(Module,F,A))|Nc]) :-
	is_state(F,A),
	!,
	module(Module),
	(to_export(F,A) -> true ; asserta_fact(to_export(F,A))),
	inheritable_info(Ne,Nc).

% 3rd case: inheritable predicate is a method.

inheritable_info([i(destructor,0)|_],_) :-
	message(warning,['class destructor is inheritable !!!']),
	fail.

inheritable_info([i(F,A)|Ne],
	[(:- inheritable(F/A)),
	 ('class$inheritable'(Module,F,A))|Nc]) :-
	is_method(F,A),
	!,
	module(Module),
	(to_export(F,A) -> true ; asserta_fact(to_export(F,A))),
	inheritable_info(Ne,Nc).

% 4th case: inheritable predicate was not defined in current source,
%           so it must be defined at super class.

inheritable_info([i(F,A)|Ne],
	[
	  (:- inheritable(F/A)),
	  'class$inheritable'(Module,F,A)
	| Nc ] ):-
	super(_),
	\+ to_export(F,A),
	!,
	module(Module),
	base(Base),
	asserta_fact(to_export(F,A)),
	assertz((  
	       check(Base) :- 
		  superbase(SuperBase),
	          \+ c_itf:decl(SuperBase,inheritable(F/A)),
		  message(error,['inheritable predicate ',F,'/',A,
		    ' is not defined nor inherited in this class']),
		  set_fact(module_error)
	)),
	inheritable_info(Ne,Nc).

inheritable_info([i(F,A)|Ne],
	[
	    (:- inheritable(F/A)),('class$inheritable'(Module,F,A))
	|Nc]):-
	super(_),
	to_export(F,A),
	module(Module),
	!,
	inheritable_info(Ne,Nc).

inheritable_info([i(F,A)|Ne],Nc) :-
	!,
	message(error,['inheritable predicate ',F,'/',A,
	 ' is not defined nor inherited in this class']),
	inheritable_info(Ne,Nc).

%%------------------------------------------------------------------------
%% GENERATE VIRTUAL INTERFACE INFORMATION
%%------------------------------------------------------------------------

virtual_info([],[]).

% 1st case: virtual predicate is a multifile: not allowed.

virtual_info([v(F,A)|Ne],Nc) :-
	is_multifile(F,A),
	!,
	retract_fact(is_virtual(F,A)),
	message(error,['multifile ',F,'/',A,' is not allowed to be ',
	 'virtual.']),
	virtual_info(Ne,Nc).

% 2nd case: exported predicate is data or dynamic.

virtual_info([v(F,A)|Ne],Nc) :-
	is_state(F,A),
	!,
	retract_fact(is_virtual(F,A)),
	message(error,['attribute ',F,'/',A,' is not allowed to be ',
	 'virtual.']),
	virtual_info(Ne,Nc).

% 3rd case: exported predicate is a method.

virtual_info([v(F,A)|Ne],
	[
	  ('class$virtual'(Module,F,A)), 
	  (:- virtual(F/A))
	| Nc]) :-
	is_method(F,A),
	!,
	module(Module),
	virtual_info(Ne,Nc).

% 4th case: exported predicate was not defined in current source.

virtual_info([v(F,A)|Ne],Nc) :-
	!,
	retract_fact(is_virtual(F,A)),
	message(error,['virtual ',F,'/',A,
	 ' must be a method defined at this class']),
	virtual_info(Ne,Nc).

%%------------------------------------------------------------------------
%%
%% GENERATE CLAUSES TO ENABLE OPTIMIZED METHOD CALLING
%%
%%------------------------------------------------------------------------

generate_calling_optimization(Clauses) :-
	module(Module),
	findall(
		   (:- export(NewF/NewA)),
		   (to_export(F,A),
		    atom_concat('obj$',F,NewF),
		    NewA is A+1
		   ),
		   Aux1
	),
	findall(
		   (NewClause),
		   (is_state(F,A),
		    functor(State,F,A),
		    attribute_head(Module,State,Fact),
		    method_head(State,NewHead,Obj),
		    NewClause = (NewHead :- class_rt:current_attr(Fact,Obj))
		   ),
		   Aux2
	),
	append(Aux1,Aux2,Clauses).


%%------------------------------------------------------------------------
%%
%% GENERATE CLAUSES TO AVOID SOME MODULE SYSTEM WARNING
%%
%%------------------------------------------------------------------------

generate_redefinition_clauses([]) :-
	\+ super(_),
	!,
	true.

generate_redefinition_clauses(Clauses) :-
	superbase(SuperBase),
	findall(
		   (:- redefining(NF/NA)),
		   (
		       c_itf:decl(SuperBase,inheritable(F/A)),
		       (is_method(F,A) ; is_state(F,A) ; is_public(F,A) ;
			is_inheritable(F,A)),
			NA is A+1,
			atom_concat('obj$',F,NF)
		   ),
		   Clauses
	).
%%------------------------------------------------------------------------
%%
%% COMPLETE ITF INFORMATION ONCE GENERATED
%%
%% This predicate is executed at "second pass expansion" when
%% itf information has been solved.
%%------------------------------------------------------------------------

itf_second_pass :-
	base(Base),
	superbase(SuperBase),
	findall(
	   d(inherited_attribute(F/A,Class)),
	   (
	       c_itf:decl(Base,inheritable(F/A)),
	       \+ c_itf:decl(Base,attribute(F/A)),
	       \+ c_itf:decl(Base,method(F/A)),
	       inherited_attr_from(SuperBase,F/A,Class),
	       asserta_fact(c_itf:decl(Base,inherited_attribute(F/A,Class)))
	   ),
	   NewDecls
	),
	compute_inheritance_line(SuperBase,InhLine),
	asserta_fact(c_itf:decl(Base,inheritance_line(InhLine))),
	append(NewDecls,[d(inheritance_line(InhLine))],Add_on),
	!,
	current_prolog_flag(fileerrors,OldFE),
	set_prolog_flag(fileerrors,off),
	( add_to_itf(Base,Add_on) ; true ),
	set_prolog_flag(fileerrors,OldFE).

%%------------------------------------------------------------------------

compute_inheritance_line(SuperBase,[Super|InhLine]) :-
	c_itf:decl(SuperBase,inheritance_line(InhLine)),
	super(Super),
	!.

compute_inheritance_line(_,[Super]) :-
	super(Super),
	!.

%%------------------------------------------------------------------------

inherited_attr_from(SuperBase,F/A,Class) :-
	c_itf:decl(SuperBase,inherited_attribute(F/A,Class)),
	!.

inherited_attr_from(SuperBase,F/A,Class) :-
	c_itf:decl(SuperBase,attribute(F/A)),
	!,
	super(Class).

%%------------------------------------------------------------------------

add_to_itf(Base,Decls) :-
	atom_concat(Base,'.itf',ItfFile),
	open(ItfFile,read,FileIn),
	read_itf(FileIn,OldItf),
	close(FileIn),
	merge_itf(OldItf,Decls,NewItf),
	current_output(CO),
	open(ItfFile,write,FileOut),
	set_output(FileOut),
	write_itf(NewItf),
	set_output(CO),
	close(FileOut),
	!.

add_to_itf(_,_) :-
	!,
	message(error,['could not generate .itf class info']).

%%------------------------------------------------------------------------

merge_itf([],_,[]).

merge_itf([d(D)|Nd],Decl,Merge) :-
	!,
	append(Decl,[d(D)|Nd],Merge).

merge_itf([I|Nd],Decl,[I|Merge]) :-
	!,
	merge_itf(Nd,Decl,Merge).

%%------------------------------------------------------------------------

read_itf(FileIn,[I|Ni]) :-
	read(FileIn,I),
	I \== end_of_file,
	!,
	read_itf(FileIn,Ni).

read_itf(_,[]) :- 
	!.

%%------------------------------------------------------------------------

write_itf([]) :-
	!.

write_itf([I|Ni]) :-
	display_term(I),
	!,
	write_itf(Ni).

%%------------------------------------------------------------------------
%%
%% OTHER AUXILIARY PREDICATES
%%
%%------------------------------------------------------------------------

%%------------------------------------------------------------------------
%% FIND ADDMODULE DECLARATION AT METAPREDICATE
%%------------------------------------------------------------------------

has_addmodule([]) :- 
	!,
	fail.

has_addmodule([addmodule|_]) :- 
	!,
	true.

has_addmodule([_|N]) :-
	has_addmodule(N).

%%------------------------------------------------------------------------
%% Convert Class source file to Class name and vice-versa
%%------------------------------------------------------------------------

class_from_base(Base,Class) :-
	functor(Base,_,1),
	arg(1,Base,Path),
	atom_codes(Path,PathCodes),
	no_path_file_name(PathCodes,FileNameCodes),
	atom_codes(Class,FileNameCodes),
	!.

class_from_base(Base,Class) :-
	atom(Base),
	module_from_base(Base,Class).

superbase(Base) :-
	super_source(S),
	base_name(S,Base),
	!.

%%------------------------------------------------------------------------
%% Convert sequence to list
%%------------------------------------------------------------------------

sequence_to_list(Sequence,List) :-
	functor(Sequence,',',2),
	!,
	arg(1,Sequence,Sq1),
	arg(2,Sequence,Sq2),
	sequence_to_list(Sq1,L1),
	sequence_to_list(Sq2,L2),
	append(L1,L2,List).

sequence_to_list(SomeThing,[SomeThing]).

%%------------------------------------------------------------------------
%% Conver a method head to its implementation head
%%------------------------------------------------------------------------

method_head(Method,Code,Obj) :-
	var(Code),
	Method =.. [F|Args],
	append(Args,[Obj],NewArgs),
	atom_concat('obj$',F,NewF),
	Code   =.. [NewF|NewArgs].

%%------------------------------------------------------------------------
%% Conver an attribute head to its implementation head
%%------------------------------------------------------------------------

attribute_head(Class,Attr,Code) :-
	Attr =.. [F|Args],
	atom_concat(Class,'::',Aux),
	atom_concat(Aux,F,NewF),
	Code   =.. [NewF|Args].

%%------------------------------------------------------------------------

member(X,[X|_]) :-
	!.

member(X,[_|R]) :-
	member(X,R).

%%------------------------------------------------------------------------
