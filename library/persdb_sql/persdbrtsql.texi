

@node SQL Persistent Database Interface, next,  previous,  up
@comment node-name, next,  previous,  up
@chapter SQL Persistent Database Interface
@liindex persdbrtsql
@c -------------------------------------------------
@c WARNING: Do not edit this file (persdbrtsql.texi)
@c It has been generated automatically from file:  
@c /home/clip/Systems/ciao/library/persdb_sql/persdbrtsql.pl
@c -------------------------------------------------

@strong{Author(s):} I. Caballero, D. Cabeza, J.M. G@'omez, and M. Hermenegildo, @code{clip@@dia.fi.upm.es}, @code{http://www.clip.dia.fi.upm.es/}, The CLIP Group, Facultad de Inform@'atica, Universidad Polit@'ecnica de Madrid.

@strong{Version:} 0.9#37 (1999/4/6, 14:26:43 MEST)

@strong{Version of last change:} 0.9#35 (1999/4/6, 13:52:16 MEST)

The purpose of this library is to implement an instance of the generic concept of 
@glindex persistent predicates
persistent predicates, where external 
@glindex relational databases
relational databases are used for storage (see the documentation of the 
@glindex persdb
@code{persdb} library and [BibRef: radioweb-D3.1.M1-A1,radioweb-ta] for details). To this end, this library exports SQL persistent versions of the 
@glindex assertz_fact/1
@code{assertz_fact/1}, 
@glindex retract_fact/1
@code{retract_fact/1} and 
@glindex retractall_fact/1
@code{retractall_fact/1} builtin predicates. Persistent predicates also allow 
@glindex concurrent updates
concurrent updates from several programs, since each update is atomic. 

The notion of persistence provides a very natural and transparent way to access database relations from a Prolog program. Stub definitions are provided for such predicates which access the database when the predicate is called (using the 
@glindex db_client
@code{db_client} library). A 
@glindex Prolog to SQL translator
Prolog to SQL translator is used to generate the required 
@glindex SQL
SQL code dynamically (see library 
@glindex pl2sql
@code{pl2sql}). 

This library also provides facilities for reflecting more complex 
@glindex views
views of the database relations as Prolog predicates. Such views can be constructed as conjunctions, disjunctions, projections, etc. of database relations. Also, 
@glindex SQL
SQL-like 
@glindex aggregation operations
aggregation operations are supported. 



@node Implementation of the Database Interface, next,  previous,  up
@comment node-name, next,  previous,  up
@section Implementation of the Database Interface 

The architecture of the low-level implementation of the database interface was defined with two goals in mind: 


@itemize @bullet{} 
@item to simplify the communication between the Prolog system and the relational database engines as much as possible, and 


@item to give as much flexibility as possible to the overall system. This includes simultaneous access to several databases, allowing both the databases and clients to reside on the same physical machine or different machines, and allowing the clients to reside in Win95/NT or Unix machines. 
@end itemize  
 
In order to allow the flexibility mentioned above, a client-sever architecture was chosen. The following figure depicts the overall architecture of the system: 

@image{persdbrtsqlarchitecture,400pt,250pt} 

At the server side, a ``database mediator server'' connects on one side to the databases using the ODBC interface (this interface is available for the databases of the RadioWeb project, as well as for the majority of the databases running in the Win95/NT operating systems) and on the other it is connected to the network by TCP/IP using a fixed socket number / service (currently fixed to socket number 2020). 

The mediator server must run on the Windows (NT/95) operating system, on the machine where the databases are also running. The (Prolog) clients which connect to it can be run locally at the server machine. In addition, remote clients running on different machines can also connect to the mediator server by connecting to its socket number (service). Such clients can run on either Unix or Windows systems. 

After the connection is established a client can send commands to the mediator server which will pass them to the corresponding database server, and then the data will traverse in the opposite direction. These messages include logging on and off from the database, sending SQL queries, and receiving the responses. 

The low level implementation of the current library is accomplished by providing several abstraction levels over the socket interface library of the Prolog engine. These layers of abstraction implement the persistent predicate view, build the appropriate commands for the database using a translator of Prolog goals to SQL commands, issue such commands using the mediator send/receive procedures, parse the responses, and present such responses to the Prolog engine via backtracking. 



@node Example(s), next,  previous,  up
@comment node-name, next,  previous,  up
@section Example(s) 


@smallexample 
:- use_package(persdb_sql).
:- use_module(library(format)).

%% ------------------------------------------------- %%
%% First sample database : 'SQL Anywhere 5.0 Sample' %%
%% ------------------------------------------------- %%

%% Declare STATICALLY product/4 a persistent predicate, storage in 'sampledb'
:- sql_persistent(product( integer,    integer, string, string ),
                  product( quantity,   id,      name,   size   ),
                  sampledb).

sql_persistent_location(sampledb, db('SQL Anywhere 5.0 Sample', 'dba', 'sql','r2d5.dia.fi.upm.es':2020)).

sql_persistent_location(literature_db, db('Literature', 'dba', 'sql','r2d5.dia.fi.upm.es':2021)).

data sql_persistent_location/2.
main0:-
        sql_get_tables(literature_db,AccessTablesList),
        AccessTablesList=[T1,T2,T3],
        sql_table_types(literature_db, T1, AttL),
        sql_table_types(literature_db, T2, AttL2),
        sql_table_types(literature_db, T3, AttL3),
        format("SampleAccess tables list is ~w~n",AccessTablesList),
        format("SampleAccess table atts. is ~w~n",AttL),
        format("SampleAccess table atts. is ~w~n",AttL2),
        format("SampleAccess table atts. is ~w~n",AttL3).

main1 :-
%% Prints the contents of the relation 'product/4' by backtracking over it:
         format("Printing table:\n",[]),
         product(Quantity, Id, Name, Size), 
         format("Tuple: ~w \t ~w \t ~w \t ~w \n",[Quantity, Id, Name, Size]),
         fail.
main1 :-
         format("Done.\n",[]).


main2 :- %% Issues a complex query inside a db_findall:
         dbfindall(sampledb,
                   foo(Quantity, Id, Name, Size, Bar),
                   ( product(Quantity, Id, Name, Size),
                     I^N^S^(Bar is avg(Q,product(Q, I, N, S)))
                   ),
                   Results),
         format("Results = ~w~n",[Results]).

main3 :- %% Using db_call
         dbcall(sampledb,
                ( product(Quantity, Id, Name, Size),
                  product(Quantity, Id1, _Name1, _Size1),
                  Id1>Id ) ),
         format("Tuple: ~w \t ~w \t ~w \t ~w \n",[Quantity, Id, Name, Size]).


%% --------------------------------------------------------------------- %%
%% Second sample database : 'LitAccess'                                  %%
%% --------------------------------------------------------------------- %%


sql_persistent_location(lit_db,
     db('litAccess','dba','sql','r2d5.dia.fi.upm.es':2020)).

%% Declare DYNAMICALLY lit_authors/3 a persistent predicate, 
%% storage in 'literature_db' 
main4:- %% Declares dynamically a persistent predicate
        make_sql_persistent(lit_authors(string,string,integer),
               dba_authors(firstName,lastName,id), 
               literature_db).

main5:- %% Prints an element of lit_authors
        lit_authors(FirstName,LastName,Id),
        format("Tuple: ~w \t ~w \t ~w \n",[FirstName, LastName, Id]).

main6:- %% Issues a complex query inside a db_findall 
        dbfindall(literature_db,
                  pred(First,Last,Id),
                  ( lit_authors(First,Last,Id), Id<100 ),
                  Results),
        format("Results = ~w~n.",[Results]).

main7:- %% asserting several persistent facts
        dbassertz_fact(lit_authors('Pedro','Calderon de la Barca',2)),
        dbassertz_fact(lit_authors('Pedro','Calderon de la Barca',7)).

main8:- %% checking if a persistent fact is a current fact
        dbcurrent_fact(lit_authors(_X,_Y,_Z)).


%% --------------------------------------------------------------------- %%
%% Third sample database : 'Literature'                                  %%
%% --------------------------------------------------------------------- %%

sql_persistent_location(literature_db,
        db('Literature','dba','sql','r2d5.dia.fi.upm.es':2020)).

%% Declare DYNAMICALLY authors/3 a persistent predicate,
%% storage in 'literature_db' 
main9:-
        make_sql_persistent(authors(string,string,integer),
               authors(firstName,lastName,id), %% 'id' is the primary key
               literature_db).

main10:- %% retracting a set of persistent facts
        dbretractall_fact(authors('Pedro',_X,_Y)).

main11:- %% assert a persistent fact
         dbassertz_fact(authors('Pedro','Calderon de la Barca',17)).

%% retract a persistent fact
%%         dbretract_fact(authors('Pedro','Calderon de la Barca',17)).






@end smallexample  




@node Usage and interface (persdbrtsql), next,  previous,  up
@comment node-name, next,  previous,  up
@section Usage and interface (@code{persdbrtsql})
@cartouche
@itemize @bullet{}

@item @strong{Library usage:}

Typically, this library is used including the 'persdb_sql' package into the package list of the module, or using the 
@glindex use_package/1
@code{use_package/1} declaration: 
@table @asis 
@item In a module: 
@smallexample 
	:- module(bar, [main/1], [persdb_sql]).
@end smallexample  
or 
@smallexample 
        :- module(bar, [main/1]).
        :- include(library(persdb_sql)).
@end smallexample  
@item In a @emph{user} file: 
@smallexample 
	:- use_package([persdb_sql]).
@end smallexample  
or 
@smallexample 
        :- include(library(persdb_sql)).
@end smallexample  
@end table  
This loads the run-time and compile-time versions of the library (@code{persdbtr_sql.pl} and @code{persdbrt_sql.pl}) and includes some needed declarations.

@item @strong{Exports:}
@itemize @minus


@item @emph{Declarations:}

@code{sql_persistent/3}.

@glindex sql_persistent/3

@item @emph{Predicates:}

@code{init_sql_persdb/0}, 
@glindex init_sql_persdb/0
@code{dbname/1}, 
@glindex dbname/1
@code{user/1}, 
@glindex user/1
@code{passwd/1}, 
@glindex passwd/1
@code{socketname/1}, 
@glindex socketname/1
@code{dbassertz_fact/1}, 
@glindex dbassertz_fact/1
@code{dbretract_fact/1}, 
@glindex dbretract_fact/1
@code{dbcurrent_fact/1}, 
@glindex dbcurrent_fact/1
@code{dbretractall_fact/1}, 
@glindex dbretractall_fact/1
@code{make_sql_persistent/3}, 
@glindex make_sql_persistent/3
@code{dbfindall/4}, 
@glindex dbfindall/4
@code{projterm/1}, 
@glindex projterm/1
@code{querybody/1}, 
@glindex querybody/1
@code{dbcall/2}, 
@glindex dbcall/2
@code{sql_get_tables/2}, 
@glindex sql_get_tables/2
@code{sql_table_types/3}.

@glindex sql_table_types/3

@item @emph{Multifiles:}

@code{sql_persistent_location/2}.

@glindex sql_persistent_location/2

@end itemize


@item @strong{Other modules used:}
@itemize @minus


@item @emph{System library modules:}

@code{aggregates}, 
@glindex aggregates
@code{basicprops}, 
@glindex basicprops
@code{dynamic}, 
@glindex dynamic
@code{lists}, 
@glindex lists
@code{messages}, 
@glindex messages
@code{metaterms}, 
@glindex metaterms
@code{persdb_sql/insert_compiler/pl2sqlinsert}, 
@glindex persdb_sql/insert_compiler/pl2sqlinsert
@code{persdb_sql/pl2sql}.

@glindex persdb_sql/pl2sql

@end itemize

@end itemize
@end cartouche


@node Documentation on new declarations (persdbrtsql), next,  previous,  up
@comment node-name, next,  previous,  up
@section Documentation on new declarations (@code{persdbrtsql})
@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{sql_persistent/3 (decl)}}}
@temp
@end iftex
@deffn DECLARATION sql_persistent/3:
@deindex sql_persistent/3 
@glindex sql_persistent/3 






@strong{Usage:} :- @code{sql_persistent(PrologPredTypes,TableAttributes,Keyword)}.
@itemize @minus
@item @emph{Description:} Declares the predicate corresponding to the main functor of @code{PrologPredTypes} as SQL persistent. @code{Keyword} is the 
@glindex name of a location
name of a location where the 
@glindex persistent storage
persistent storage for the predicate is kept, which in this case must be an external relational database. The description of this database is given through the 
@glindex sql_persistent_location
@code{sql_persistent_location} predicate, which must contain a fact in which the first argument unifies with @code{Keyword}. @code{TableAttributes} provides the 
@glindex table name
table name and 
@glindex attributes
attributes in the database corresponding respectively to the predicate name and arguments of the (virtual) Prolog predicate. 

@strong{Example:} 


@smallexample 
:- sql_persistent(product( integer,    integer, string, string ),
              product( quantity,   id,      name,   size   ),
              radiowebdb).

sql_persistent_location(radiowebdb, 
   db('SQL Anywhere 5.0 Sample', user, pass, 'r2d5.dia.fi.upm.es':2020)).
@end smallexample  
 
@item @emph{Should hold upon exit:}


@code{PrologPredTypes} is a structure describing a Prolog predicate name with its types.
@iftex
@hfill
@end iftex
 (@code{persdbrt_sql:prologPredTypes/1})

@code{TableAttributes} is a structure describing a table name and some attributes.
@iftex
@hfill
@end iftex
 (@code{persdbrt_sql:tableAttributes/1})

@code{Keyword} is the name of a persistent storage location.
@iftex
@hfill
@end iftex
 (@code{persdbrt_sql:persLocId/1})
@end itemize
@end deffn
@sp 1



@node Documentation on exports (persdbrtsql), next,  previous,  up
@comment node-name, next,  previous,  up
@section Documentation on exports (@code{persdbrtsql})
@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{init_sql_persdb/0 (pred)}}}
@temp
@end iftex
@deffn PREDICATE init_sql_persdb/0:
@pdindex init_sql_persdb/0 
@glindex init_sql_persdb/0 






@strong{Usage:} 
@itemize @minus
@item @emph{Description:} Internal predicate, used to transform predicates statically declared as persistent (see 
@glindex sql_persistent/3
@code{sql_persistent/3}) into real persistent predicates.  
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{sql_persistent/3 (decl)}}}
@temp
@end iftex
@deffn DECLARATION sql_persistent/3:
@deindex sql_persistent/3 
@glindex sql_persistent/3 






@strong{Usage:} :- @code{sql_persistent(PrologPredTypes,TableAttributes,Keyword)}.
@itemize @minus
@item @emph{Description:} Declares the predicate corresponding to the main functor of @code{PrologPredTypes} as SQL persistent. @code{Keyword} is the 
@glindex name of a location
name of a location where the 
@glindex persistent storage
persistent storage for the predicate is kept, which in this case must be an external relational database. The description of this database is given through the 
@glindex sql_persistent_location
@code{sql_persistent_location} predicate, which must contain a fact in which the first argument unifies with @code{Keyword}. @code{TableAttributes} provides the 
@glindex table name
table name and 
@glindex attributes
attributes in the database corresponding respectively to the predicate name and arguments of the (virtual) Prolog predicate. 

@strong{Example:} 


@smallexample 
:- sql_persistent(product( integer,    integer, string, string ),
              product( quantity,   id,      name,   size   ),
              radiowebdb).

sql_persistent_location(radiowebdb, 
   db('SQL Anywhere 5.0 Sample', user, pass, 'r2d5.dia.fi.upm.es':2020)).
@end smallexample  
 
@item @emph{Should hold upon exit:}


@code{PrologPredTypes} is a structure describing a Prolog predicate name with its types.
@iftex
@hfill
@end iftex
 (@code{persdbrt_sql:prologPredTypes/1})

@code{TableAttributes} is a structure describing a table name and some attributes.
@iftex
@hfill
@end iftex
 (@code{persdbrt_sql:tableAttributes/1})

@code{Keyword} is the name of a persistent storage location.
@iftex
@hfill
@end iftex
 (@code{persdbrt_sql:persLocId/1})
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{dbname/1 (pred)}}}
@temp
@end iftex
@deffn PREDICATE dbname/1:
@pdindex dbname/1 
@glindex dbname/1 



No further documentation available for this predicate.

@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{user/1 (pred)}}}
@temp
@end iftex
@deffn PREDICATE user/1:
@pdindex user/1 
@glindex user/1 



No further documentation available for this predicate.

@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{passwd/1 (pred)}}}
@temp
@end iftex
@deffn PREDICATE passwd/1:
@pdindex passwd/1 
@glindex passwd/1 



No further documentation available for this predicate.

@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{socketname/1 (pred)}}}
@temp
@end iftex
@deffn PREDICATE socketname/1:
@pdindex socketname/1 
@glindex socketname/1 



No further documentation available for this predicate.

@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{dbassertz_fact/1 (pred)}}}
@temp
@end iftex
@deffn PREDICATE dbassertz_fact/1:
@pdindex dbassertz_fact/1 
@glindex dbassertz_fact/1 






@strong{Usage:} @code{dbassertz_fact(+Fact)}
@itemize @minus
@item @emph{Description:} Persistent extension of 
@glindex assertz_fact/1
@code{assertz_fact/1}: the current instance of @code{Fact} is interpreted as a fact (i.e., a relation tuple) and is added to the end of the definition of the corresponding predicate. If any integrity constraint violation is done (database stored predicates), an error will be displayed. The predicate concerned must be statically (
@glindex sql_persistent/3
@code{sql_persistent/3}) or dinamically (
@glindex make_sql_persistent/3
@code{make_sql_persistent/3}) declared. Any uninstantiated variables in the @code{Fact} will be replaced by new, private variables. @strong{Note:} @emph{assertion of facts with uninstantiated variables not implemented at this time.} 
@item @emph{Call and exit should be @emph{compatible} with:}


@code{+Fact} is a fact (a term whose main functor is not @code{':-'/2}).
@iftex
@hfill
@end iftex
 (@code{persdbrt_sql:fact/1})
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{dbretract_fact/1 (pred)}}}
@temp
@end iftex
@deffn PREDICATE dbretract_fact/1:
@pdindex dbretract_fact/1 
@glindex dbretract_fact/1 






@strong{Usage:} @code{dbretract_fact(+Fact)}
@itemize @minus
@item @emph{Description:} Persistent extension of 
@glindex retract_fact/1
@code{retract_fact/1}: deletes on backtracking all the facts which unify with @code{Fact}. The predicate concerned must be statically (
@glindex sql_persistent/3
@code{sql_persistent/3}) or dinamically (
@glindex make_sql_persistent/3
@code{make_sql_persistent/3}) declared. 
@item @emph{Call and exit should be @emph{compatible} with:}


@code{+Fact} is a fact (a term whose main functor is not @code{':-'/2}).
@iftex
@hfill
@end iftex
 (@code{persdbrt_sql:fact/1})
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{dbcurrent_fact/1 (pred)}}}
@temp
@end iftex
@deffn PREDICATE dbcurrent_fact/1:
@pdindex dbcurrent_fact/1 
@glindex dbcurrent_fact/1 






@strong{Usage:} @code{dbcurrent_fact(+Fact)}
@itemize @minus
@item @emph{Description:} Persistent extension of 
@glindex current_fact/1
@code{current_fact/1}: the fact @code{Fact} exists in the current database. The predicate concerned must be declared 
@glindex sql_persistent/3
@code{sql_persistent/3}. Provides on backtracking all the facts (tuples) which unify with @code{Fact}. 
@item @emph{Call and exit should be @emph{compatible} with:}


@code{+Fact} is a fact (a term whose main functor is not @code{':-'/2}).
@iftex
@hfill
@end iftex
 (@code{persdbrt_sql:fact/1})
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{dbretractall_fact/1 (pred)}}}
@temp
@end iftex
@deffn PREDICATE dbretractall_fact/1:
@pdindex dbretractall_fact/1 
@glindex dbretractall_fact/1 






@strong{Usage:} @code{dbretractall_fact(+Fact)}
@itemize @minus
@item @emph{Description:} Persistent extension of 
@glindex retractall_fact/1
@code{retractall_fact/1}: when called deletes all the facts which unify with @code{Fact}. The predicate concerned must be statically (
@glindex sql_persistent/3
@code{sql_persistent/3}) or dinamically (
@glindex make_sql_persistent/3
@code{make_sql_persistent/3}) declared. 
@item @emph{Call and exit should be @emph{compatible} with:}


@code{+Fact} is a fact (a term whose main functor is not @code{':-'/2}).
@iftex
@hfill
@end iftex
 (@code{persdbrt_sql:fact/1})
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{make_sql_persistent/3 (pred)}}}
@temp
@end iftex
@deffn PREDICATE make_sql_persistent/3:
@pdindex make_sql_persistent/3 
@glindex make_sql_persistent/3 






@strong{Usage:} @code{make_sql_persistent(PrologPredTypes,TableAttributes,Keyword)}
@itemize @minus
@item @emph{Description:} Dynamic version of the 
@glindex sql_persistent/3
@code{sql_persistent/3} declaration. 
@item @emph{Should hold upon exit:}


@code{PrologPredTypes} is a structure describing a Prolog predicate name with its types.
@iftex
@hfill
@end iftex
 (@code{persdbrt_sql:prologPredTypes/1})

@code{TableAttributes} is a structure describing a table name and some attributes.
@iftex
@hfill
@end iftex
 (@code{persdbrt_sql:tableAttributes/1})

@code{Keyword} is the name of a persistent storage location.
@iftex
@hfill
@end iftex
 (@code{persdbrt_sql:persLocId/1})
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{dbfindall/4 (pred)}}}
@temp
@end iftex
@deffn PREDICATE dbfindall/4:
@pdindex dbfindall/4 
@glindex dbfindall/4 






@strong{Usage:} @code{dbfindall(+DBId,+Pattern,+ComplexGoal,-(Results))}
@itemize @minus
@item @emph{Description:} Similar to 
@glindex findall/3
@code{findall/3}, but @code{Goal} is executed in database @code{DBId}. Certain restrictions and extensions apply to both @code{Pattern} and @code{ComplexGoal} stemming from the Prolog to SQL translation involved (see the corresponding type definitions for details). 
@item @emph{Call and exit should be @emph{compatible} with:}


@code{+Pattern} is a database projection term.
@iftex
@hfill
@end iftex
 (@code{pl2sql:projterm/1})

@code{+ComplexGoal} is a database query goal.
@iftex
@hfill
@end iftex
 (@code{pl2sql:querybody/1})

@code{-(Results)} is a list.
@iftex
@hfill
@end iftex
 (@code{basic_props:list/1})
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{projterm/1 (regtype)}}}
@temp
@end iftex
@deffn REGTYPE projterm/1:
@teindex projterm/1 
@glindex projterm/1 






@strong{Usage:} @code{projterm(DBProjTerm)}
@itemize @minus
@item @emph{Description:} @code{DBProjTerm} is a database projection term. 
@item @emph{Should hold globally:}


Defines a regular type.
@iftex
@hfill
@end iftex
 (@code{basic_props:regtype/1})
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{querybody/1 (regtype)}}}
@temp
@end iftex
@deffn REGTYPE querybody/1:
@teindex querybody/1 
@glindex querybody/1 






@strong{Usage:} @code{querybody(DBGoal)}
@itemize @minus
@item @emph{Description:} @code{DBGoal} is a database query goal. 
@item @emph{Should hold globally:}


Defines a regular type.
@iftex
@hfill
@end iftex
 (@code{basic_props:regtype/1})
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{dbcall/2 (pred)}}}
@temp
@end iftex
@deffn PREDICATE dbcall/2:
@pdindex dbcall/2 
@glindex dbcall/2 






@strong{Usage:} @code{dbcall(+DBId,+ComplexGoal)}
@itemize @minus
@item @emph{Description:} Internal predicate, used by the transformed versions of the persistent predicates. Not meant to be called directly by users. It is exported by the library so that it can be used by the transformed versions of the persistent predicates in the modules in which they reside. Sends @code{ComplexGoal} to database @code{DBId} for evaluation. @code{ComplexGoal} must be a call to a persistent predicate which resides in database @code{DBId}. 
@item @emph{Call and exit should be @emph{compatible} with:}


@code{+ComplexGoal} is a database query goal.
@iftex
@hfill
@end iftex
 (@code{pl2sql:querybody/1})
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{sql_get_tables/2 (pred)}}}
@temp
@end iftex
@deffn PREDICATE sql_get_tables/2:
@pdindex sql_get_tables/2 
@glindex sql_get_tables/2 






@strong{Usage 1:} @code{sql_get_tables(+Location,-(Tables))}
@itemize @minus
@item @emph{Description:} @code{Tables} contains the tables available in @code{Location}. 
@item @emph{Call and exit should be @emph{compatible} with:}


@code{persdbrt_sql:persLocation(+Location)}
@iftex
@hfill
@end iftex
 (@code{persdbrt_sql:persLocation/1})

@code{-(Tables)} is a list of @code{atm}s.
@iftex
@hfill
@end iftex
 (@code{basic_props:list/2})
@end itemize

@strong{Usage 2:} @code{sql_get_tables(+DbConnection,-(Tables))}
@itemize @minus
@item @emph{Description:} @code{Tables} contains the tables available in @code{DbConnection}. 
@item @emph{Call and exit should be @emph{compatible} with:}


@code{-(Tables)} is a list of @code{atm}s.
@iftex
@hfill
@end iftex
 (@code{basic_props:list/2})
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{sql_table_types/3 (pred)}}}
@temp
@end iftex
@deffn PREDICATE sql_table_types/3:
@pdindex sql_table_types/3 
@glindex sql_table_types/3 






@strong{Usage 1:} @code{sql_table_types(+Location,+Table,-(AttrTypes))}
@itemize @minus
@item @emph{Description:} @code{AttrTypes} are the attributes and types of @code{Table} in @code{Location}. 
@item @emph{Call and exit should be @emph{compatible} with:}


@code{persdbrt_sql:persLocation(+Location)}
@iftex
@hfill
@end iftex
 (@code{persdbrt_sql:persLocation/1})

@code{+Table} is an atom.
@iftex
@hfill
@end iftex
 (@code{basic_props:atm/1})

@code{-(AttrTypes)} is a list.
@iftex
@hfill
@end iftex
 (@code{basic_props:list/1})
@end itemize

@strong{Usage 2:} @code{sql_table_types(+DbConnection,+Table,-(AttrTypes))}
@itemize @minus
@item @emph{Description:} @code{AttrTypes} are the attributes and types of @code{Table} in @code{DbConnection}. 
@item @emph{Call and exit should be @emph{compatible} with:}


@code{+Table} is an atom.
@iftex
@hfill
@end iftex
 (@code{basic_props:atm/1})

@code{-(AttrTypes)} is a list.
@iftex
@hfill
@end iftex
 (@code{basic_props:list/1})
@end itemize
@end deffn
@sp 1



@node Documentation on multifiles (persdbrtsql), next,  previous,  up
@comment node-name, next,  previous,  up
@section Documentation on multifiles (@code{persdbrtsql})
@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{sql_persistent_location/2 (pred)}}}
@temp
@end iftex
@deffn PREDICATE sql_persistent_location/2:
@pdindex sql_persistent_location/2 
@glindex sql_persistent_location/2 



Relates names of locations (the @code{Keyword}s) with descriptions of such locations (@code{Location}s).


The predicate is @emph{multifile} and of type @emph{data}.


@strong{Usage 1:} @code{sql_persistent_location(Keyword,Location)}
@itemize @minus
@item @emph{Description:} @code{Keyword} is an identifier for the persistent data location @code{Location}. 
@item @emph{Call and exit should be @emph{compatible} with:}


@code{Keyword} is the name of a persistent storage location.
@iftex
@hfill
@end iftex
 (@code{persdbrt_sql:persLocId/1})

@code{persdbrt_sql:persLocation(Location)}
@iftex
@hfill
@end iftex
 (@code{persdbrt_sql:persLocation/1})
@end itemize

@strong{Usage 2:} @code{sql_persistent_location(Keyword,DBLocation)}
@itemize @minus
@item @emph{Description:} In this usage, @code{DBLocation} is a @emph{relational database}, in which case the predicate is stored as tuples in the database. 
@item @emph{Should hold upon exit:}


@code{Keyword} is the name of a persistent storage location.
@iftex
@hfill
@end iftex
 (@code{persdbrt_sql:persLocId/1})

@code{DBLocation} is a structure describing a database.
@iftex
@hfill
@end iftex
 (@code{persdbrt_sql:database_desc/1})
@end itemize
@end deffn
@sp 1



@node Documentation on internals (persdbrtsql), next,  previous,  up
@comment node-name, next,  previous,  up
@section Documentation on internals (@code{persdbrtsql})
@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{db_query/4 (pred)}}}
@temp
@end iftex
@deffn PREDICATE db_query/4:
@pdindex db_query/4 
@glindex db_query/4 






@strong{Usage:} @code{db_query(+DBId,+ProjTerm,+Goal,ResultTerm)}
@itemize @minus
@item @emph{Description:} @code{ResultTerm} contains all the 
@glindex tuples
tuples which are the response from database @code{DBId} to the Prolog query @code{Goal}, projected onto @code{ProjTerm}. Uses 
@glindex pl2sqlstring/3
@code{pl2sqlstring/3} for the 
@glindex Prolog to SQL translation
Prolog to SQL translation and 
@glindex sql_query/3
@code{sql_query/3} for posing the actual query. 
@item @emph{Call and exit should be @emph{compatible} with:}


@code{+ProjTerm} is a database projection term.
@iftex
@hfill
@end iftex
 (@code{pl2sql:projterm/1})

@code{+Goal} is a database query goal.
@iftex
@hfill
@end iftex
 (@code{pl2sql:querybody/1})
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{sql_query/3 (pred)}}}
@temp
@end iftex
@deffn PREDICATE sql_query/3:
@pdindex sql_query/3 
@glindex sql_query/3 






@strong{Usage:} @code{sql_query(+DBId,+SQLString,AnswerTableTerm)}
@itemize @minus
@item @emph{Description:} @code{ResultTerm} is the response from database @code{DBId} to the 
@glindex SQL query
SQL query in @code{SQLString} to database @code{DBId}. @code{AnswerTableTerm} can express a set of tuples, an error answer or a 'ok' response (see 
@glindex answertableterm/1
@code{answertableterm/1} for details). At the moment, 
@glindex sql_query/3
@code{sql_query/3} log in and out for each query. This should be changed to log in only the first time and log out on exit and/or via a timer in the standard way. 
@item @emph{Call and exit should be @emph{compatible} with:}


@code{+SQLString} is a string containing SQL code.
@iftex
@hfill
@end iftex
 (@code{pl2sql:sqlstring/1})
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{db_query_one_tuple/4 (pred)}}}
@temp
@end iftex
@deffn PREDICATE db_query_one_tuple/4:
@pdindex db_query_one_tuple/4 
@glindex db_query_one_tuple/4 






@strong{Usage:} @code{db_query_one_tuple(+DBId,+ProjTerm,+Goal,ResultTerm)}
@itemize @minus
@item @emph{Description:} @code{ResultTerm} is one of the 
@glindex tuples
tuples which are the response from database @code{DBId} to the Prolog query @code{Goal}, projected onto @code{ProjTerm}. Uses 
@glindex pl2sqlstring/3
@code{pl2sqlstring/3} for the 
@glindex Prolog to SQL translation
Prolog to SQL translation and 
@glindex sql_query_one_tuple/3
@code{sql_query_one_tuple/3} for posing the actual query. After last tuple has been reached, a null tuple is unified with ResultTerm, and the connection to the database finishes. 
@item @emph{Call and exit should be @emph{compatible} with:}


@code{+ProjTerm} is a database projection term.
@iftex
@hfill
@end iftex
 (@code{pl2sql:projterm/1})

@code{+Goal} is a database query goal.
@iftex
@hfill
@end iftex
 (@code{pl2sql:querybody/1})
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{sql_query_one_tuple/3 (pred)}}}
@temp
@end iftex
@deffn PREDICATE sql_query_one_tuple/3:
@pdindex sql_query_one_tuple/3 
@glindex sql_query_one_tuple/3 






@strong{Usage:} @code{sql_query_one_tuple(+DBId,+SQLString,ResultTuple)}
@itemize @minus
@item @emph{Description:} @code{ResultTuple} contains an element from the set of tuples which represents the response in @code{DBId} to the 
@glindex SQL query
SQL query @code{SQLString}. If the connection is kept, succesive calls return consecutive tuples, until the last tuple is reached. Then a null tuple is unified with @code{ResultTuple} and the connection is finished (calls to 
@glindex db_logoff/1
@code{db_logoff/1} and 
@glindex odbc_disconnect/1
@code{odbc_disconnect/1}). 
@item @emph{Call and exit should be @emph{compatible} with:}


@code{+SQLString} is a string containing SQL code.
@iftex
@hfill
@end iftex
 (@code{pl2sql:sqlstring/1})
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{dbconnection/1 (pred)}}}
@temp
@end iftex
@deffn PREDICATE dbconnection/1:
@pdindex dbconnection/1 
@glindex dbconnection/1 



No further documentation available for this predicate.

@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{tuple/1 (pred)}}}
@temp
@end iftex
@deffn PREDICATE tuple/1:
@pdindex tuple/1 
@glindex tuple/1 



No further documentation available for this predicate.

@end deffn
@sp 1



@node Known bugs and planned improvements (persdbrtsql), next,  previous,  up
@comment node-name, next,  previous,  up
@section Known bugs and planned improvements (@code{persdbrtsql})

@itemize @bullet{}

@item
At least in the shell, reloading a file after changing the definition of a persistent predicate does not eliminate the old definition...

@item
Functionality missing: some questions need to be debugged.

@item
Warning: still using kludgey string2term and still using some non-uniquified temp files.

@item
Needs to be unified with the file-based library.
@end itemize


@node Version/Change Log (persdbrtsql), next,  previous,  up
@comment node-name, next,  previous,  up
@section Version/Change Log (@code{persdbrtsql})

@table @strong

@item Version 0.9#35 (1999/4/6, 13:52:16 MEST)
Changed from type to regtype. (Manuel Hermenegildo)

@item Version 0.9#10 (1999/3/18, 19:23:42 MET)
Added sql_get_tables/2, sql_table_types/3 (Ignacio Caballero Blanco)

@item Version 0.8#7 (1998/11/18, 14:7:13 MET)
updated to changes in predicate names imported from messages (Ignacio Caballero Blanco)

@item Version 0.7#18 (1998/10/7, 13:40:33 MEST)
persdb_sql updated with make_sql_persistent/3 and predicates revised (Jose Manuel Gomez Perez)

@item Version 0.7#16 (1998/10/1, 10:29:11 MET DST)
Name/Arity compatibility with the file based persistent predicates completed (Jose Manuel Gomez Perez)

@item Version 0.6#15 (1998/8/4, 14:12:46 MET DST)
retractz_fact/1, retractall_fact/1, current_fact/1, added (Ignacio Caballero Blanco)

@item Version 0.6#8 (1998/7/30, 16:52:1 MET DST)
assertz_fact/1 added (Ignacio Caballero Blanco)

@item Version 0.5#48 (1998/7/10, 13:47:35 MET DST)
Documented type declarations (Manuel Hermenegildo)

@item Version 0.5#45 (1998/7/8, 12:0:47 MET DST)
Added db_findall/4 and db_call/2. (Manuel Hermenegildo)

@item Version 0.5#22 (1998/6/24, 9:26:7 MET DST)
Incorporated into ciao library directory. For now, in a separate directory: needs to be integrated with previous persdb dir. (Manuel Hermenegildo)
@end table
