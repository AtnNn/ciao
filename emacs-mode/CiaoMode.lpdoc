@comment{** Do not edit--generated automatically **}

The Ciao/Prolog @concept{emacs interface} (or @em{mode} @cindex{emacs mode}
in @apl{emacs} terms) provides a rich, integrated user interface to
the Ciao @index{program development environment} components, including
the @apl{ciaosh} interactive top level and the @apl{ciaopp}
preprocessor. While most features of the Ciao development environment
are available from the command line of the preprocessor and the
top-level shell, using Ciao inside @apl{emacs} is highly
recommended. The facilities that this mode provides include:

@begin{itemize}

@item @index{Syntax highlighting} and syntax coloring,
@cindex{coloring, syntax} @index{auto-indentation}, @index{auto-fill},
etc. of code. This includes the assertions used by the preprocessor
and the documentation strings used by the Ciao auto-documenter,
@apl{lpdoc}.

@item Providing automatic access to @concept{on-line help} for all
predicates by accessing the Ciao system manuals in @apl{info} format.

@item Starting and communicating with @apl{ciaopp}, the
@index{Ciao preprocessor}, running in its own
@concept{sub-shell}. This allows easily performing certain kinds of
@index{static checks} (useful for finding errors in programs before
running them), program analysis tasks, and @index{program
transformations} on source programs.

@item Starting and communicating with the @index{Ciao top-level},
running in its own @concept{sub-shell}. This facilitates loading
programs, checking the @em{syntax} of programs (and of
@index{assertions} within programs), marking and unmarking modules
for interactive debugging, making stand-alone executables, compiling
modules to dynamically linkable Prolog objects, compiling modules to
active objects, etc.

@item Syntax highlighting and coloring of the error and warning
messages produced by the top level, preprocessor, or any other tool
using the same message format (such as the @apl{lpdoc}
auto-documenter), and @em{locating automatically the points in the
source files where such errors occur}.

@item Performing automatic @index{version control} and keeping a
@index{change log} of individual files or whole applications. This is
done by automatically including change log entries in source files,
which can then be processed by the @apl{lpdoc} auto-documenter.

@end{itemize}

This chapter explains how to use the Ciao/Prolog @apl{emacs} interface and
how to set up your @apl{emacs} environment for correct operation.  The
Ciao @apl{emacs} interface can also be used to work with other Prolog
or CLP systems.

@section{Installation of the Ciao/Prolog emacs interface}

It may be possible that a complete pre-installation of the Ciao/Prolog
@apl{emacs} interface was already completed during Ciao
installation. To check this, open a file with a @tt{.pl} ending. You
should see that @apl{emacs} enters Ciao/Prolog mode: the mode is identified
in the @concept{status bar} below the @concept{buffer} and, if the
@concept{emacs menu bar} is enabled, you should see the Ciao/Prolog
menu. You should be able from the menu-bar, for example, to go to the
Ciao manuals in the info or load the @tt{.pl} file that you just
opened into a ciao top level.

If opening a file ending with @tt{.pl} puts emacs in another mode
(such as @apl{perl} mode, which is the --arguably incorrect-- default
setting in some @apl{emacs} distributions), then you can set things so
that the Ciao/Prolog mode is loaded by default in your system. This can be
done by including in your @file{.emacs} file a line such as:

@tt{(load <CIAOLIBDIR>/DOTemacs)}

@noindent This loads the above mentioned file from the Ciao library,
which contains the following lines (except that the paths are changed
during installation to appropriate values for your system):

@begin{verbatim}
@includeverbatim{DOTemacs.skel}
@end{verbatim}

If you would like to configure things in a different way, you can also
copy the contents of this file to your @file{.emacs} file and make the
appropriate changes.  For example, if you do not want @tt{.pl} files
to be put automatically in Ciao/Prolog mode, then comment out (or
remove) the line:

@tt{(setq auto-mode-alist} ... @tt{)}

@noindent You will then need to switch manually to Ciao/Prolog mode by
typing @tt{M-x ciao-mode} after opening a Prolog file.

If you are able to open the Ciao/Prolog menu but the Ciao manuals are not
found or the @apl{ciao} command (the top-level) is not found when
loading @tt{.pl} files, the probable cause is that you do not have the
Ciao paths in the @tt{INFOPATH} and @tt{MANPATH} @index{environment
variables} (whether these variables are set automatically or not for
users depends on how the Ciao system was installed).  You can add
these paths easily by including the line:

@tt{source <CIAOLIBDIR>/DOTcshrc}

@noindent in your @tt{.login} or @tt{.cshrc} files if you are using
@apl{csh} (or @apl{tcsh}, etc.), or, alternatively, the line:

@tt{. <CIAOLIBDIR>/DOTprofile}

@noindent in your @tt{.login} or @tt{.profile} files if you are using
@apl{sh} (or @apl{bash}, etc.). See the Ciao installation instructions
(@ref{Installing Ciao}) for details.

@section{Functionality and associated key sequences (bindings)}

The following is a summary of the capabilities of the Ciao/Prolog emacs
interface and the (default) @index{key sequences} used to access those
capabilities.  Most of these functions are accessible also from the
menu bar.

@subsection{Getting on-line help}

The following commands are useful for getting on-line help. This
is done by accessing the @apl{info} version of the Ciao manuals or the
@apl{emacs} built-in help strings. Note also that the @apl{info}
standard @tt{search} command (generally bound to @key{s}) can be used
inside @apl{info} buffers to search for a given string.
@begin{description}

@item{@key{^C} @key{TAB} } Find help for the symbol (e.g., predicate, directive, declaration,
type, etc.) that is currently under the cursor. Opens a (hopefully)
relevant part of the Ciao manuals in @apl{info} mode. Requires that
the Ciao manuals in @apl{info} format be installed and that they
accessible to emacs (i.e., they should appear somewhere in the info
directory when typing @tt{M-x info}). It also requires
@file{word-help.el}, which is provided with Ciao.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{/} } Find a completion for the symbol (e.g., predicate, directive,
declaration, type, etc.) that is currently under the cursor. Uses for
completion the contents of the indices of the Ciao manuals. Same
requirements as for finding help for the symbol.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{^M} } Go to the part of the info directory containing the Ciao manuals.
@end{description} @p 
@begin{description}

@item{@key{^H} @key{m} } Show a short description of the Ciao/Prolog emacs mode, including all key
bindings.
@end{description} @p 
@subsection{Loading and compiling programs}

These commands allow @index{loading programs}, @index{creating
executables}, etc. by issuing the appropriate commands to a Ciao/Prolog top
level shell, running in its own buffer as a subprocess. See @ref{The
interactive top-level shell} for details. The following commands implement
the communication with the Ciao/Prolog top level:
@begin{description}

@item{@key{^C} @key{t} } Ensure that an inferior Ciao/Prolog top-level process is
running. Normally, it is not necessary to use this function since
execution of any of the other functions related to the top level
ensures that a top level is started (starting one if required). This
function is useful when one would like to start a top level in order
to type a command directly by hand into it.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{l} } Load the current buffer (and any auxiliary files it may use) into
the top level. The type of compilation performed (@index{compiling}
or @index{consulting}) is selected automatically depending 
on whether the buffer has been marked for debugging
or not -- see below. 
@end{description} @p 
@begin{description}

@item{@key{^C} @key{x} } Make an executable from the code in the current buffer. The buffer
must contain a @pred{main/0} or @pred{main/1} predicate. Note that
compiler options can be set to determine whether the libraries and
auxiliary files used by the executable will be statically linked,
dynamically linked, auto-loaded, etc.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{o} } Make a Prolog object (.po) file from the code in the current buffer.
This is very useful during debugging or program development, when only
one or a few files of a large application are modified. If the
application executable is dynamically linked, i.e., the component .po
files are loaded dynamically during startup of the application, then
this command can be used to recompile only the file or files which have
changed, and the correct version will be loaded dynamically the next
time the application is started. However, note that this only works if
the inter-module interfaces have not changed.  A safer, but possibly
slower way is to generate the executable again, letting the Ciao
compiler, which is inherently incremental, determine what needs to be
recompiled.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{a} } Make an active module executable from the code in the current
buffer. An active module is a remote procedure call server (see the
@lib{activemod} library documentation for details).
@end{description} @p 
@subsection{Locating errors and checking the syntax of assertions}

These commands allow several syntactic checks of assertions, and
locating quickly the point in the source code corresponding to errors
flagged by the compiler or preprocessor: @cindex{locating errors}
@begin{description}

@item{@key{^C} @key{`} } Go to location in source file containing next error reported by the 
   last Ciao/Prolog subprocess (preprocessor or toplevel) which was run.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{E} } Check the syntax of the code and
assertions in the current buffer, as well as imports and exports.  Note that
full (semantic) assertion checking must be done with the preprocessor.
@end{description} @p 
@subsection{Commands which help in typing in programs}

The following commands are intended to help in the process of
writing programs: @cindex{writing programs}
@begin{description}

@item{@key{^C} @key{I} @key{S} } Insert a (Unix) header at the top of the current buffer so that the
ciao script interpreter will be called on this file if @em{run} from
the command line. It also makes the file 'executable' (e.g.,
'@tt{chmod +x <file>}' in Unix). See @ref{The script interpreter} for
details.
@end{description} @p 
@subsection{Debugging programs}

These commands allow marking modules for @index{debugging} by issuing the
appropiate commands to a Ciao/Prolog top level shell, running in its own
buffer as a subprocess. There are two differents type of debugging:
tradicional prolog debugging and source debugging. In order to use
breakpoints the source debugging must be on. The following commands
implement the comunication with the Ciao/Prolog top level:
@begin{description}

@item{@key{^C} @key{m} } Mark the current buffer for debugging. Note that if the buffer has
already been loaded while it was unmarked for debugging (and has therefore
been loaded in ``compile'' mode) it has to be loaded again.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{u} } Unmarks the current buffer for debugging. Note that if the buffer has
already been loaded while it was marked for debugging (and has therefore
been loaded in ``consult'' mode) it has to be loaded again.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{S} @key{y} } Turn on source debugging, i.e., line tracing (experimental).
@end{description} @p 
@begin{description}

@item{@key{^C} @key{S} @key{n} } Turn off source debugging (line tracing).
@end{description} @p 
@begin{description}

@item{@key{^C} @key{S} @key{b} } Breakpoint on actual predicate.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{S} @key{v} } Remove breakpoint on actual predicate.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{S} @key{d} } Redisplay breakpoints in all Ciao buffers.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{r} } Load the current region (between the cursor and a previous mark)
into the top level for debugging. Since loading a 
region of a file is typically done for debugging and/or testing purposes,
this command always loads the region in debugging mode (consult).
@end{description} @p 
@begin{description}

@item{@key{^C} @key{p} } Load the predicate around the cursor into the top level. Since loading a 
single predicate is typically done for debugging and/or testing purposes,
this command always loads the predicate in debugging mode (consult).
@end{description} @p 
@subsection{Preprocessing programs}

These commands allow @index{preprocessing programs} with
@apl{ciaopp}, the @index{Ciao preprocessor}.

@include{../ciaopp/doc/readmes/README.lpdoc}

See the preprocessor manual for details. The following commands
implement the communication with the Ciao preprocessor:


@begin{description}

@item{@key{^C} @key{M} } Preprocess the buffer, selecting options. Instructs
the preprocessor to load the current buffer and start an interactive dialog
in which the different options available in the preprocessor can 
be set. 
@end{description} @p 
@begin{description}

@item{@key{^C} @key{P} } Preprocess the buffer, using the previously selected options. If no
options were set previously, then the preprocessor defaults are
used.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{^V} } Show last output file produced by Ciao preprocessor. The
preprocessor works by producing a file which is a transformed and/or
adorned (with assertions) version of the input file. This is often used
after running the preprocessor in order to see such results.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{V} } Preprocess the buffer, selecting options. Instructs
the preprocessor to load the current buffer and start an interactive dialog
in which the different options available in the preprocessor can 
be set. 
@end{description} @p 
@begin{description}

@item{@key{^C} @key{^R} } Ensure that an inferior Ciao preprocessor process is running
@end{description} @p 
@subsection{Version control}

The following commands can be used to carry out a simple form of
@concept{version control} by keeping a @concept{log of changes} on a
file or a group of related files. This log is kept in a format that is
understood by @apl{lpdoc}, the Ciao documenter @cite{lpdoc-tr}. As a
result, if these version comments are present, then @apl{lpdoc} will
be able to automatically assign up to date version numbers to the
manuals that it generates. This way it is always possible to identify
to which version of the software a manual corresponds. Also,
@apl{lpdoc} can create automatically sections describing the changes
made since previous versions, which are extracted from the comments in
the changelog entries.

The main effect of these commands is automatically associate the
following information to a set of changes performed in the file and/or
in a set of related files:

@begin{itemize}

@item a @index{version number} (such as, e.g., @tt{1.2}, where @tt{1}
is the @concept{major version number} and @tt{2} is the @concept{minor
version number}),

@item a @concept{patch number} (such as, e.g., the @tt{4} in
@tt{1.2#4}), 

@item a @concept{time stamp} (such as, e.g.,
@tt{1998/12/14,17:20*28+MET}),

@item the author of the change, @cindex{change, author} and

@item a comment explaining the change. @cindex{change, comment}
@end{itemize}

The @concept{version numbering} used can be local to a single file or
common to a number of related files. A simple version numbering policy
is implemented: when a relevant change is made, the user typically
inserts a @concept{changelog entry} for it, using the appropriate
command (or selecting the corresponding option when prompted while
saving a file). This will cause the @em{patch number} for the file (or
for the whole system that the file is part of) to be incremented
automatically and the corresponding machine-readable comment to be
inserted in the file. Major and minor version numbers can also be
changed, but this is always invoked by hand (see below).

The changelog entry is written in the form of a @decl{comment/2}
declaration.  As mentioned before, the advantage of using this kind of
changelog entries is that these declarations can be processed by the
@apl{lpdoc} automatic documenter (see the @apl{lpdoc} reference
manual @cite{lpdoc-tr} or the @lib{assertions} library documentation
for more details on these declarations). 

Whether the user is asked or not to introduce such changelog entries,
and how the patch and version numbers should be increased is
controlled by the presence in the file of a @pred{comment/2}
declaration of the type:

@tt{:- comment(version_maintenance,<type>).}

@noindent (note that this requires including the @lib{assertions}
library in the source file).  These declarations themselves are also
typically introduced automatically when using this mode (see below).

The version maintenance mode can also be set alternatively by
inserting a comment such as:

@begin{verbatim}
%% Local Variables: 
%% mode: Ciao/Prolog
%% update-version-comments: ""off""
%% End:
@end{verbatim}

The lines above instruct emacs to put the buffer visiting the file in
@concept{emacs Ciao/Prolog mode} and to turn version maintenance off.
Setting the version maintenance mode in this way has the disadvantage
that @apl{lpdoc}, the auto-documenter, and other related tools will
not be aware of the type of version maintenance being performed (the
lines above are comments for Prolog). However, this can be useful in
fact for setting the @index{version maintenance mode for packages} and
other files meant for inclusion in other files, since that way the
settings will not affect the file in which the package is included.

The following commands implement the version control support:

@begin{description}

@item{@key{^X} @key{^S} } This is the standard @apl{emacs} command that saves a buffer by
writing the contents into the associated @tt{.pl} file.  However, in
Ciao/Prolog mode this command can be set to ask the user before saving
whether to introduce a change log entry documenting the changes performed.

If the buffer does not already contain a comment specifying the
@concept{type of version control} to be performed, and before saving
the buffer, the Ciao/Prolog mode prompts the user to choose among the
following options:

   @begin{description} 

   @item{@key{q}} Turn off prompting for the introduction of change log
entries for now. @apl{emacs} will not ask again while the buffer is
loaded, but it will ask again next time you load the buffer.

   @item{@key{n}} Turn off version control for this file. A version
control comment such as:

@tt{:- comment(version_maintenance,off).}

@noindent is added to the buffer and the file is saved. @apl{emacs}
will not perform any version control on this file until the line above
is removed or modified (i.e., from now on C-x C-s simply
saves the buffer).

   @item{@key{y}} Turn version control on for this file. 

   @end{description}

   If @key{y} is selected, then the system prompts again regarding how
and where the version and patch number information is to be
maintained. The following options are available:

   @begin{description}

   @item{@tt{on}} All version control information will be contained
within this file. When saving a buffer (C-x C-s) emacs
will ask if a change log entry should be added to the file before
saving. If a comment is entered by the user, a new patch number is
assigned to it and the comment is added to the file. This patch number
will be the one that follows the most recent change log entry already
in the file. This is obviously useful when maintaining version numbers
individually for each file.

   @item{@tt{<directory_name>}} Global version control will be
performed coherently on several files. When saving a buffer
(C-x C-s) emacs will ask if a change log entry should be
added to the file before saving. If a comment is given, the global
patch number (which will be kept in the file:
@tt{<directory_name>/GlobalPatch}) is atomically incremented and the
change log entry is added to the current file, associated to that patch
number. Also, a small entry is added to a file
@tt{<directory_name>/GlobalChangeLog} which points to the current
file. This allows inspecting all changes sequentially by visiting all
the files where the changes were made (see
C-c `). This is obviously useful when
maintaining a single thread of version and patch numbers for a set of
files.

   @item{@tt{off}} Turns off version control: C-x C-s then simply
   saves the file as usual. 

   @end{description}

@bf{Some useful tips:} 

@begin{itemize}

@item If a change log entry is in fact introduced, the cursor is left
at the point in the file where the comment was inserted and the mark
is left at the original file point. This allows inspecting (and
possibly modifying) the change log entry, and then returning to the
original point in the file by simply typing
C-x C-x.

@item @cindex{moving change log entries} The first change log entry is
entered by default at the end of the buffer. Later, the change log
entries can be moved anywhere else in the file. New change log entries
are always inserted just above the first change log entry which appears
in the file.

@item The comments in change log entries can be edited at any time. 

@item If a change log entry is moved to another file, and version
numbers are shared by several files through a directory, the
corresponding file pointer in the
@tt{<directory_name>/GlobalChangeLog} file needs to be changed also,
for the entry to be locatable later using
C-c C-n.

@end{itemize}


@end{description} @p 
@begin{description}

@item{@key{^C} @key{^S} } Same as C-x C-s except that it forces prompting for
inclusion of a changelog entry even if the buffer is unmodified.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{n} } Force a move to a new major/minor version number (the user will be
prompted for the new numbers). Only applicable if using
directory-based version maintenance. Note that otherwise it suffices
with introducing a change log entry in the file and changing its
version number by hand.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{^N} } When a unique version numbering is being maintained across several
files, this command allows inspecting all changes sequentially by
visiting all the files in which the changes were made:

    @begin{itemize}

    @item If in a source file, find the next changelog entry in the
source file, open in another window the corresponding
@file{GlobalChangeLog} file, and position the cursor at the
corresponding entry. This allows browsing the previous and following
changes made, which may perhaps reside in other files in the system.

   @item If in a @file{GlobalChangeLog} file, look for the next entry
in the file, and open in another window the source file in which the
corresponding comment resides, positioning the corresponding comment
at the top of the screen. This allows going through a section of the
@file{GlobalChangeLog} file checking all the corresponding comments in
the different files in which they occur.

    @end{itemize}


@end{description} @p 
@subsection{Setting the top-level, preprocessor, and documenter executables}

These commands allow @index{changing the executables used} when
starting a Prolog top-level, the preprocessor, or the
auto-documenter. They also allow changing the arguments that these
executables take, and changing the path where the libraries reside. In
the case of the top-level and preprocessor, this should be done only
by users which understand the implications, but it is very useful if
several versions of Ciao/Prolog are available in the system:
@begin{description}

@item{@key{^C} @key{S} @key{C} } Change the Ciao/Prolog executable used to run the Prolog-like top
level. It is set by default to @tt{ciao} or, to the environment
variable @tt{CIAO} if it is defined. @cindex{toplevel command, setting}
@end{description} @p 
@begin{description}

@item{@key{^C} @key{S} @key{^C} } Change the arguments passed to the Ciao/Prolog executable. They are
set by default to none or, to the environment variable @tt{CIAOARGS} if it
is defined. @cindex{toplevel command args, setting}
@end{description} @p 
@begin{description}

@item{@key{^C} @key{S} @key{P} } Change the executable used to run the Ciao Preprocessor
toplevel. It is set by default to @tt{ciaopp} or, to the environment 
variable @tt{CIAOPP} if it is defined. @cindex{preprocessor command, setting}
@end{description} @p 
@begin{description}

@item{@key{^C} @key{S} @key{^P} } Change the arguments parssed to the Ciao preprocessor executable. They are
set by default to none or, to the environment variable @tt{CIAOPPARGS} if it
is defined. @cindex{preprocessor command args, setting}
@end{description} @p 
@begin{description}

@item{@key{^C} @key{S} @key{L} } Change the location of the Ciao/Prolog library paths (changes the
   environment variable CIAOLIB).
@end{description} @p 
@begin{description}

@item{@key{^C} @key{S} @key{D} } Change the executable used to run the LPdoc auto-documenter. It is
set by default to @tt{lpdoc} or, to the environment  
variable @tt{LPDOC} if it is defined. @cindex{lpdoc command, setting}
@cindex{auto-documenter command, setting}
@end{description} @p 
@begin{description}

@item{@key{^C} @key{S} @key{^D} } Change the arguments parssed to the LPdoc auto-documenter. They are
set by default to none or, to the environment variable @tt{LPDOCARGS} if it
is defined. @cindex{lpdoc command args, setting}
@cindex{auto-documenter command args, setting}
@end{description} @p 
@begin{description}

@item{@key{^C} @key{S} @key{^L} } Change the path in which the LPdoc library is installed. It is
set by default to @tt{/home/clip/lib} or, to the environment  
variable @tt{LPDOCLIB} if it is defined. @cindex{lpdoc lib path, setting}
@cindex{auto-documenter lib path, setting}
@end{description} @p 
@subsection{Traditional Prolog Mode Commands}

These commands provide some bindings and facilities for loading
programs, which are present in emacs Prolog modes of other Prolog
systems (e.g., SICStus). This is useful mainly if the Ciao/Prolog emacs mode
is used with such Prolog systems.  Note that the behavior of these
commands in Ciao is slightly different from that of SICStus.
@begin{description}

@item{@key{^C} @key{K} } Compile the entire buffer.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{k} } Compile a given region.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{^K} } Compile the predicate around point.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{C} } Consult the entire buffer.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{c} } Consult a given region.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{^C} } Consult the predicate around point.
@end{description} @p 
@subsection{Other commands}

Some other commands which are active in the Ciao/Prolog mode:
@begin{description}

@item{@key{TAB} } Indent current line as Ciao/Prolog code.
With argument, indent any additional lines of the same clause
rigidly along with this one.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{^L} } Recenter the most recently used Ciao/Prolog inferior process buffer
(top-level or preprocessor).
@end{description} @p 
@subsection{Generating program documentation:}

These commands provide some bindings and facilities for generating
the documentation corresponding to the current buffer.  This is
specially useful while modifying the documentation for a file, in order
to check the output that will be produced.
@begin{description}

@item{@key{^C} @key{D} @key{S} } Visit the @tt{SETTINGS} file (which controls all auto-documenter options).
@end{description} @p 
@begin{description}

@item{@key{^C} @key{D} @key{F} } Change the default output format used the LPdoc auto-documenter. It is
set by default to @tt{dvi} or, to the environment  
variable @tt{LPDOCFORMAT} if it is defined. @cindex{lpdoc default
format, setting} 
@cindex{auto-documenter default format, setting}
@end{description} @p 
@begin{description}

@item{@key{^C} @key{D} @key{G} } Generate the documentation according to SETTINGS in the default format.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{D} @key{B} } Generate the documentation for the current buffer in the default
format. Basically, it sets MAIN in SETTINGS to the current buffer and
then generates the documentation.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{D} @key{V} } Start a viewer on the documentation for the current buffer in the
   default format.
@end{description} @p 
@begin{description}

@item{@key{^C} @key{D} @key{W} } Change the root working dir used by the LPdoc auto-documenter. It is
set by default to a new dir under @tt{/tmp} or, to the environment  
variable @tt{LPDOCWDIR} if it is defined. @cindex{lpdoc working dir, setting}
@cindex{auto-documenter working dir, setting}
@end{description} @p 
@subsection{Getting the Ciao/Prolog mode version}

@cindex{Ciao/Prolog mode version}
@begin{description}

@item{@key{^C} @key{v} } Report the version of the emacs Ciao/Prolog mode.
@end{description} @p 


@section{Commands available in toplevel and preprocessor buffers}

The interactive top level and the preprocessor both are typically run
in an iteractive buffer, in which it is possible to communicate with
them in the same way as is they had been started from a standard
shell. In addition, the commands and key bindings available in buffers
containing source code are also available in these interactive
buffers, when applicable.

@section{Using Ciao/Prolog mode capabilities in standard shells} 

The capabilities (commands, coloring, ...) which are active in the
Ciao/Prolog ``inferior'' mode (the mode of the buffers in which the top level
and the preprocessor run) can also be made available in any standard
command line shell which is being run within emacs. This can be
enabled by going to the buffer in which the shell is running and
typing ``@key{M-x} @tt{ciao-inferior-mode}''.  This is very useful for
example when running the stand-alone compiler, the @apl{lpdoc}
auto-documenter, or even certain user applications (those that use the
standard error message library) in an emacs sub-shell. Turning the
Ciao/Prolog inferior mode on on that sub-shell will highlight and color the
error messages (type @key{^L}), and automatically find and visit the
locations in the files in which the errors are reported.

@section{Coexistence with other Prolog interfaces} 

As mentioned previously, the Ciao/Prolog @apl{emacs} interface can also be
used to work with other Prolog or CLP systems. Also, the Ciao/Prolog
@apl{emacs} interface (@em{mode}) can coexist with other
Prolog-related @apl{emacs} interfaces (@em{modes}) @cindex{emacs mode,
loading several} (such as, e.g., the @apl{SICStus} Prolog
interface). Only one of the interfaces can be active at a time for a
given buffer (i.e., for each given file opened inside @apl{emacs}). In
order the change a buffer to a given interface, move the cursor to
that buffer and type @tt{M-x ...-mode} (e.g., for the Ciao/Prolog mode,
@tt{M-x ciao-mode}).

If several Prolog-related @apl{emacs} interfaces are loaded, then
typically the @em{last} one to be loaded takes precedence, in the
sense that this will be the interface in which @apl{emacs} will be set
when opening files which have a @tt{.pl} ending (this depends a bit on
how things are set up in your @tt{.emacs} file).

@section{Version information} This documentation corresponds to Ciao/Prolog
emacs mode version @bf{5.70}. This mode is currently being developed within @apl{GNU emacs}
version 20.2. It should also work with all other 20.XX and later 19.XX
versions.

@section{Acknowledgments (ciao.el)}

This code is derived from the 1993 version of the emacs interface for
@concept{&-Prolog}, itself derived from the original @file{prolog.el}
by @index{Masanobu Umeda} with changes by @index{Johan Andersson},
@index{Peter Olin}, @index{Mats Carlsson}, and @index{Johan Bevemyr}
of @index{SICS}, Sweden. Other changes also by Daniel Cabeza.