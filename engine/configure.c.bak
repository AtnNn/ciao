/* Copyright (C) 1996,1997,1998, UPM-CLIP */

/* First, if we are a BSD system, a line is printed:
 *      #define ENG_BSD 1
 * Then, we test for endian-ness and print a line
 *      #define BIGENDIAN <bool>
 * Then, we test whether the top 4 bits matter in memory accesses.
 * We also test what part of the address space that malloc() places
 * its objects in: if the top 4 bits matter, then a line
 *	#define MallocBase <base>
 * is printed, <base> being the top 4 bits for malloc() pointers.
 * CIAO assumes that those 4 bits are always the same.
 * (MCL) A line is the printed to store the minimum amount of memory which 
 * should be allocated to make the previous true:
 *      #define MIN_MEM_ALLOC <minimum>
 * Then, two lines
 *      #define ENG_FLT_SIGNIF <int>
 *      #define ENG_FLT_ROUND <float>
 * denoting respectively #significant digits in a float and a number to
 * be used for rounding purposes when floats are printed.
 * Then, a line is printed telling whether the system is being built with
 * native code support.
 */

#if defined(__STDC__)
#define VOLATILE volatile
#define PROTO(argl) argl
#else
#define VOLATILE
#define PROTO(ignore) ()
#endif

#include <stdio.h>
#include <unistd.h>
#include <setjmp.h>
#include <signal.h>

#include "compat.h"
#include "termdefs.h"                          /* because of TAGGED (MCL) */
#include "own_malloc_defs.h"

#if defined(__svr4__)                                          /* Solaris */
# include <unistd.h>                                            /* sbrk () */
# if !defined(MALLOC_DEBUG)
#  include <stdlib.h>                                           /* malloc() */
# endif
#else                                                            /* SunOS */
# include <sys/types.h>
# if !defined(MALLOC_DEBUG)
#  include <malloc.h>
# endif
#endif

#if defined(MALLOC_DEBUG)
#include "dmalloc.h"
#endif

#define LOTS 16384
#define MIN_MEM_BLOCK_CHARS 16384

#define TAG_MASK 0xf0000000
#define ALIGN sizeof(TAGGED)                        /* Minimum block size */
#define ROUND_CHARS(Chars) Chars%ALIGN == 0 ? Chars/ALIGN : Chars/ALIGN + 1
#define MIN_MEM_BLOCK (ROUND_CHARS(MIN_MEM_BLOCK_CHARS))


int turn_point(TAGGED *base);

jmp_buf buf;

void handler(rc)
     int rc;
{
  longjmp(buf,rc);
}


int main(argc, argv)
     int argc;
     char **argv;
{
  register int i, j;
  TAGGED mbase = 1;
  int lots;

  SIGNAL(SIGSEGV, handler);
  SIGNAL(SIGBUS, handler);

  if
#if defined(multimax) || defined(AIX)
    (1)
#else
#if defined(hpux) || defined(m88k) || defined(_SEQUENT_) || defined(__svr4__)
    (0)
#else
    (!access("/usr/include/sys/time.h",0) &&
     !access("/usr/include/sys/resource.h",0))
#endif
#endif
      
      printf("#define ENG_BSD 1\n");
      printf("#define BIGENDIAN %d\n", ((unsigned short *)(&mbase))[1]);


  if ((lots = turn_point(&mbase))) {
    int tagged_lots = ROUND_CHARS(lots);  /* Use tagged words from now on */
    printf("#define MallocBase 0x%lx\n", mbase);
    printf("#define MIN_MEM_ALLOC %d\n", 
           tagged_lots > MIN_MEM_BLOCK ? tagged_lots : MIN_MEM_BLOCK);
  } else {
    printf("#define MallocBase 0x0\n");
    printf("#define MIN_MEM_ALLOC %d\n", MIN_MEM_BLOCK);
  }


  /*           
#if defined(sun)
  mbase = 0x0;
#else
  if ((lots = turn_point()) < LOTS) 
    lots = LOTS;
  ptr = malloc(lots*TAG_W_SIZE);
  mbase = (unsigned long)ptr & 0xf0000000;
  for (j=lots-1; j; --j)
    ((unsigned long *)ptr)[j] = 0x12345678;
  if (setjmp(buf))
#endif
    {
      printf("#define MallocBase 0x%lx\n", mbase);
      printf("#define MIN_MEM_ALLOC 0x%lx\n", lots);
      goto out;
    }
  for (i=0; i<16; i++)
    {
      ptr += 0x10000000;
      for (j=lots-1; j; --j)
	{

	  if (((unsigned long *)ptr)[j] != 0x12345678)
	    longjmp(buf,1);

	  ((unsigned long *)ptr)[j] = 0x12345678;
	}
    }
    */
  /* out:*/
  {
    double f = 1.0;
    
    for (i=1; f+1.0>1.0; i++)
      f/=2.0;
    i = (i*0.3010299956639812)+1; /* #significant digits */
    f = 0.5e-9;			/* rounding factor if above=18 */
    for (j=18; j>i; j--)
      f*=10.0;
    printf("#define ENG_FLT_SIGNIF %d\n#define ENG_FLT_ROUND %.16g\n",
	   i, f);
  }
  
  printf("/*kernel=def*/\n");

  exit(0);
}

 /* Some systems (namely, LINUX) allocate memory in different parts of the
    memory depending on how much we ask.  The result is that blocks can be
    scattered so that the "unmutable four top bits" assumption is broken
    (i.e., the mapped memory can't be fit into the pointer part of a tagged
    word) and MallocBase is not useful at all.  We try to find out
    dynamically if this ever happens, and at which point.  This will serve
    to calculate the minimum amount of memory to be requested at a time from
    the system, and a (hopefully) correct MallocBase.  
    
    If we, anyway, choose to build a system without snooping for a good
    MallocBase, just use the first pointer the system returns.

    (MCL) 
  */


int turn_point(base)
  TAGGED *base;
{

  int *this_pointer;
  int size = 1;

#if defined(USE_OWN_MALLOC)
  while(1)
    if ((this_pointer = (int *)malloc(size*ALIGN))) {
      if ((TAGGED)this_pointer & TAG_MASK){
        *base = (TAGGED)this_pointer & TAG_MASK;
        free(this_pointer);
        break;
      } else {
        size *= 2;
        free(this_pointer);
      }
    }
    else {
      size = 0;
      break;
    }
#else
  this_pointer = (int *)malloc(size*ALIGN);
  *base =  (TAGGED)this_pointer & TAG_MASK;
  free(this_pointer);
#endif

  return (size * ALIGN);
}
